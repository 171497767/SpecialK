; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\steam\client.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?SteamInternal_CreateInterface_Original@@3P6APAXPBD@ZA ; SteamInternal_CreateInterface_Original
PUBLIC	_SteamClient_Original
_BSS	SEGMENT
?SteamInternal_CreateInterface_Original@@3P6APAXPBD@ZA DD 01H DUP (?) ; SteamInternal_CreateInterface_Original
_SteamClient_Original DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
$SG164509 DB	'SteamClient_Detour', 00H
	ORG $+1
$SG164510 DB	'[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 'h', 00H
	DB	's', 00H, ' ', 00H, '(', 00H, ')', 00H, 00H, 00H
	ORG $+6
$SG164530 DB	'[', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'W', 00H, 'r', 00H, 'a', 00H, 'p', 00H, ']', 00H, ' ', 00H, 'S'
	DB	00H, 't', 00H, 'e', 00H, 'a', 00H, 'm', 00H, 'I', 00H, 'n', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H, 'l', 00H, '_'
	DB	00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'a'
	DB	00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 'h', 00H
	DB	's', 00H, ')', 00H, 00H, 00H
$SG164533 DB	'SteamClient017', 00H
	ORG $+1
$SG164539 DB	'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	'p', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, '(', 00H
	DB	'%', 00H, 's', 00H, ')', 00H, '!', 00H, 00H, 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0ISteamClient@@QAE@XZ				; ISteamClient::ISteamClient
PUBLIC	?_Hash_seq@std@@YAIPBEI@Z			; std::_Hash_seq
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0logic_error@std@@QAE@PBD@Z			; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0out_of_range@std@@QAE@PBD@Z			; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	?_Reverse_byte@details@Concurrency@@YAEE@Z	; Concurrency::details::_Reverse_byte
PUBLIC	?_Get_msb@details@Concurrency@@YAEI@Z		; Concurrency::details::_Get_msb
PUBLIC	??0?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >
PUBLIC	??0?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >
PUBLIC	??0?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@QAE@ABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@@Z ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>
PUBLIC	??0?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QAE@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@@Z ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >
PUBLIC	??R?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QBEIABQAVISteamClient@@@Z ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::operator()
PUBLIC	??R?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QBE_NABQAVISteamClient@@0@Z ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::operator()
PUBLIC	??R?$_Bitwise_hash@PAVISteamClient@@@std@@QBEIABQAVISteamClient@@@Z ; std::_Bitwise_hash<ISteamClient *>::operator()
PUBLIC	??R?$equal_to@PAVISteamClient@@@std@@QBE_NABQAVISteamClient@@0@Z ; std::equal_to<ISteamClient *>::operator()
PUBLIC	??0?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@I@Z ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@I@Z ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::allocate
PUBLIC	??0?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
PUBLIC	??1?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
PUBLIC	?_Buynode@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@I@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Buynode
PUBLIC	?_Nextnode@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAAAPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAU4523@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Nextnode
PUBLIC	?_Myval@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Myval
PUBLIC	??0?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
PUBLIC	??1?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
PUBLIC	?clear@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXXZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::clear
PUBLIC	?end@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::end
PUBLIC	?end@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::end
PUBLIC	?_Begin@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Begin
PUBLIC	?_End@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_End
PUBLIC	?_End@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_End
PUBLIC	?_Get_key@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAIABV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_key
PUBLIC	?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_iterator
PUBLIC	?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_iterator
PUBLIC	?_Erase@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Erase
PUBLIC	?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAU4523@00@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert
PUBLIC	?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@5@0PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAJ@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert
PUBLIC	?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert_dummy
PUBLIC	?_Check_range@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@AAEXXZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Check_range
PUBLIC	??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
PUBLIC	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
PUBLIC	?_Segment_index_of@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_index_of
PUBLIC	?_Segment_base@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_base
PUBLIC	?_Segment_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_size
PUBLIC	?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::end
PUBLIC	?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::end
PUBLIC	?find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::find
PUBLIC	?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::count
PUBLIC	?unsafe_max_bucket_count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIXZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::unsafe_max_bucket_count
PUBLIC	?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::rehash
PUBLIC	?_Init@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXXZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Init
PUBLIC	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
PUBLIC	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
PUBLIC	?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Initialize_bucket
PUBLIC	?_Adjust_table_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Adjust_table_size
PUBLIC	?_Get_parent@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Get_parent
PUBLIC	?_Get_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@I@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Get_bucket
PUBLIC	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Set_bucket
PUBLIC	?_Is_initialized@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE_NI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Is_initialized
PUBLIC	?_Reverse@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Reverse
PUBLIC	?_Split_order_regular_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Split_order_regular_key
PUBLIC	?_Split_order_dummy_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Split_order_dummy_key
PUBLIC	??0?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
PUBLIC	?deallocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocate
PUBLIC	??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
PUBLIC	??A?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAEAAPAVIWrapSteamClient@@ABQAVISteamClient@@@Z ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::operator[]
PUBLIC	??1?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@XZ ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
PUBLIC	??0IWrapSteamClient@@QAE@PAVISteamClient@@@Z	; IWrapSteamClient::IWrapSteamClient
PUBLIC	?CreateSteamPipe@IWrapSteamClient@@UAEHXZ	; IWrapSteamClient::CreateSteamPipe
PUBLIC	?BReleaseSteamPipe@IWrapSteamClient@@UAE_NH@Z	; IWrapSteamClient::BReleaseSteamPipe
PUBLIC	?ConnectToGlobalUser@IWrapSteamClient@@UAEHH@Z	; IWrapSteamClient::ConnectToGlobalUser
PUBLIC	?CreateLocalUser@IWrapSteamClient@@UAEHPAHW4EAccountType@@@Z ; IWrapSteamClient::CreateLocalUser
PUBLIC	?ReleaseUser@IWrapSteamClient@@UAEXHH@Z		; IWrapSteamClient::ReleaseUser
PUBLIC	?GetISteamUser@IWrapSteamClient@@UAEPAVISteamUser@@HHPBD@Z ; IWrapSteamClient::GetISteamUser
PUBLIC	?GetISteamGameServer@IWrapSteamClient@@UAEPAVISteamGameServer@@HHPBD@Z ; IWrapSteamClient::GetISteamGameServer
PUBLIC	?SetLocalIPBinding@IWrapSteamClient@@UAEXIG@Z	; IWrapSteamClient::SetLocalIPBinding
PUBLIC	?GetISteamFriends@IWrapSteamClient@@UAEPAVISteamFriends@@HHPBD@Z ; IWrapSteamClient::GetISteamFriends
PUBLIC	?GetISteamUtils@IWrapSteamClient@@UAEPAVISteamUtils@@HPBD@Z ; IWrapSteamClient::GetISteamUtils
PUBLIC	?GetISteamMatchmaking@IWrapSteamClient@@UAEPAVISteamMatchmaking@@HHPBD@Z ; IWrapSteamClient::GetISteamMatchmaking
PUBLIC	?GetISteamMatchmakingServers@IWrapSteamClient@@UAEPAVISteamMatchmakingServers@@HHPBD@Z ; IWrapSteamClient::GetISteamMatchmakingServers
PUBLIC	?GetISteamGenericInterface@IWrapSteamClient@@UAEPAXHHPBD@Z ; IWrapSteamClient::GetISteamGenericInterface
PUBLIC	?GetISteamUserStats@IWrapSteamClient@@UAEPAVISteamUserStats@@HHPBD@Z ; IWrapSteamClient::GetISteamUserStats
PUBLIC	?GetISteamGameServerStats@IWrapSteamClient@@UAEPAVISteamGameServerStats@@HHPBD@Z ; IWrapSteamClient::GetISteamGameServerStats
PUBLIC	?GetISteamApps@IWrapSteamClient@@UAEPAVISteamApps@@HHPBD@Z ; IWrapSteamClient::GetISteamApps
PUBLIC	?GetISteamNetworking@IWrapSteamClient@@UAEPAVISteamNetworking@@HHPBD@Z ; IWrapSteamClient::GetISteamNetworking
PUBLIC	?GetISteamRemoteStorage@IWrapSteamClient@@UAEPAVISteamRemoteStorage@@HHPBD@Z ; IWrapSteamClient::GetISteamRemoteStorage
PUBLIC	?GetISteamScreenshots@IWrapSteamClient@@UAEPAVISteamScreenshots@@HHPBD@Z ; IWrapSteamClient::GetISteamScreenshots
PUBLIC	?RunFrame@IWrapSteamClient@@UAEXXZ		; IWrapSteamClient::RunFrame
PUBLIC	?GetIPCCallCount@IWrapSteamClient@@UAEIXZ	; IWrapSteamClient::GetIPCCallCount
PUBLIC	?SetWarningMessageHook@IWrapSteamClient@@UAEXP6AXHPBD@Z@Z ; IWrapSteamClient::SetWarningMessageHook
PUBLIC	?BShutdownIfAllPipesClosed@IWrapSteamClient@@UAE_NXZ ; IWrapSteamClient::BShutdownIfAllPipesClosed
PUBLIC	?GetISteamHTTP@IWrapSteamClient@@UAEPAVISteamHTTP@@HHPBD@Z ; IWrapSteamClient::GetISteamHTTP
PUBLIC	?GetISteamUnifiedMessages@IWrapSteamClient@@UAEPAVISteamUnifiedMessages@@HHPBD@Z ; IWrapSteamClient::GetISteamUnifiedMessages
PUBLIC	?GetISteamController@IWrapSteamClient@@UAEPAVISteamController@@HHPBD@Z ; IWrapSteamClient::GetISteamController
PUBLIC	?GetISteamUGC@IWrapSteamClient@@UAEPAVISteamUGC@@HHPBD@Z ; IWrapSteamClient::GetISteamUGC
PUBLIC	?GetISteamAppList@IWrapSteamClient@@UAEPAVISteamAppList@@HHPBD@Z ; IWrapSteamClient::GetISteamAppList
PUBLIC	?GetISteamMusic@IWrapSteamClient@@UAEPAVISteamMusic@@HHPBD@Z ; IWrapSteamClient::GetISteamMusic
PUBLIC	?GetISteamMusicRemote@IWrapSteamClient@@UAEPAVISteamMusicRemote@@HHPBD@Z ; IWrapSteamClient::GetISteamMusicRemote
PUBLIC	?GetISteamHTMLSurface@IWrapSteamClient@@UAEPAVISteamHTMLSurface@@HHPBD@Z ; IWrapSteamClient::GetISteamHTMLSurface
PUBLIC	?Set_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z ; IWrapSteamClient::Set_SteamAPI_CPostAPIResultInProcess
PUBLIC	?Remove_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z ; IWrapSteamClient::Remove_SteamAPI_CPostAPIResultInProcess
PUBLIC	?Set_SteamAPI_CCheckCallbackRegisteredInProcess@IWrapSteamClient@@UAEXP6AIH@Z@Z ; IWrapSteamClient::Set_SteamAPI_CCheckCallbackRegisteredInProcess
PUBLIC	?GetISteamInventory@IWrapSteamClient@@UAEPAVISteamInventory@@HHPBD@Z ; IWrapSteamClient::GetISteamInventory
PUBLIC	?GetISteamVideo@IWrapSteamClient@@UAEPAVISteamVideo@@HHPBD@Z ; IWrapSteamClient::GetISteamVideo
PUBLIC	?SteamClient_Detour@@YAPAVISteamClient@@XZ	; SteamClient_Detour
PUBLIC	?SteamInternal_CreateInterface_Detour@@YAPAXPBD@Z ; SteamInternal_CreateInterface_Detour
PUBLIC	??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@XZ ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>
PUBLIC	??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>
PUBLIC	?_Mynode@?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QBEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@XZ ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
PUBLIC	??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
PUBLIC	??D?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBEABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@XZ ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*
PUBLIC	??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
PUBLIC	??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
PUBLIC	??8?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator==
PUBLIC	??9?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator!=
PUBLIC	??0?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@@Z ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
PUBLIC	??D?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@XZ ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*
PUBLIC	??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAEAAV012@XZ ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
PUBLIC	??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE?AV012@H@Z ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
PUBLIC	??$_Key_function@QAVISteamClient@@PAVIWrapSteamClient@@@?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamClient@@ABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Key_function<ISteamClient * const,IWrapSteamClient *>
PUBLIC	??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
PUBLIC	??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
PUBLIC	??D?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBEAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@XZ ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*
PUBLIC	??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
PUBLIC	??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
PUBLIC	??$destroy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::destroy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
PUBLIC	??0?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@@Z ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
PUBLIC	??D?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@XZ ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*
PUBLIC	??$make_pair@ABQAVISteamClient@@PAVIWrapSteamClient@@@std@@YA?AU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@0@ABQAVISteamClient@@$$QAPAVIWrapSteamClient@@@Z ; std::make_pair<ISteamClient * const &,IWrapSteamClient *>
PUBLIC	??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Insert<std::pair<ISteamClient *,IWrapSteamClient *> >
PUBLIC	?_Init@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXI@Z ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Init
PUBLIC	?_Get_order_key@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBEIXZ ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Get_order_key
PUBLIC	?_Atomic_set_next@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU1234@PAU1234@0@Z ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Atomic_set_next
PUBLIC	?_Is_dummy@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE_NXZ ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Is_dummy
PUBLIC	??$?0U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@1@@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > ><std::pair<ISteamClient * const,IWrapSteamClient *> >
PUBLIC	??$destroy@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@Z ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::destroy<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>
PUBLIC	??$?0AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAE@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > ><std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > &>
PUBLIC	??$_Uninitialized_default_fill_n@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >
PUBLIC	??$?0U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@1@@Z ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node><std::pair<ISteamClient * const,IWrapSteamClient *> >
PUBLIC	??$forward@ABQAVISteamClient@@@std@@YAABQAVISteamClient@@ABQAV1@@Z ; std::forward<ISteamClient * const &>
PUBLIC	??$forward@PAVIWrapSteamClient@@@std@@YA$$QAPAVIWrapSteamClient@@AAPAV1@@Z ; std::forward<IWrapSteamClient *>
PUBLIC	??$?0ABQAVISteamClient@@PAVIWrapSteamClient@@X$0A@@?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@QAE@ABQAVISteamClient@@$$QAPAVIWrapSteamClient@@@Z ; std::pair<ISteamClient *,IWrapSteamClient *>::pair<ISteamClient *,IWrapSteamClient *><ISteamClient * const &,IWrapSteamClient *,void,0>
PUBLIC	??$_Key_function@PAVISteamClient@@PAVIWrapSteamClient@@@?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamClient@@ABU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Key_function<ISteamClient *,IWrapSteamClient *>
PUBLIC	??$forward@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@YA$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@0@AAU10@@Z ; std::forward<std::pair<ISteamClient *,IWrapSteamClient *> >
PUBLIC	??$_Buynode@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@I$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Buynode<std::pair<ISteamClient *,IWrapSteamClient *> >
PUBLIC	??$?0V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_NX$0A@@?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@QAE@$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@$$QA_N@Z ; std::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool>::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool><Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool,void,0>
PUBLIC	??$forward@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@YAAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@0@AAV10@@Z ; std::forward<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > &>
PUBLIC	??$_Unfancy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@@Z ; std::_Unfancy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
PUBLIC	??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >
PUBLIC	??$addressof@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@YAPAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@0@AAU10@@Z ; std::addressof<std::pair<ISteamClient * const,IWrapSteamClient *> >
PUBLIC	??$construct@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@2@@?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAEXPAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@1@@Z ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::construct<std::pair<ISteamClient * const,IWrapSteamClient *>,std::pair<ISteamClient *,IWrapSteamClient *> >
PUBLIC	??$forward@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@@std@@YA$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@AAV123@@Z ; std::forward<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *>
PUBLIC	??$?0PAVISteamClient@@PAVIWrapSteamClient@@X$0A@@?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@QAE@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@1@@Z ; std::pair<ISteamClient * const,IWrapSteamClient *>::pair<ISteamClient * const,IWrapSteamClient *><ISteamClient *,IWrapSteamClient *,void,0>
PUBLIC	??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator_traits@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z ; std::allocator_traits<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
PUBLIC	??$_Destroy_range1@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *>
PUBLIC	??$forward@PAVISteamClient@@@std@@YA$$QAPAVISteamClient@@AAPAV1@@Z ; std::forward<ISteamClient *>
PUBLIC	??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
PUBLIC	??_7ISteamClient@@6B@				; ISteamClient::`vftable'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
PUBLIC	??_7IWrapSteamClient@@6B@			; IWrapSteamClient::`vftable'
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BK@KDCGEAPC@invalid?5number?5of?5buckets?$AA@ ; `string'
PUBLIC	??_R4ISteamClient@@6B@				; ISteamClient::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVISteamClient@@@8			; ISteamClient `RTTI Type Descriptor'
PUBLIC	??_R3ISteamClient@@8				; ISteamClient::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ISteamClient@@8				; ISteamClient::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ISteamClient@@8			; ISteamClient::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IWrapSteamClient@@6B@			; IWrapSteamClient::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIWrapSteamClient@@@8			; IWrapSteamClient `RTTI Type Descriptor'
PUBLIC	??_R3IWrapSteamClient@@8			; IWrapSteamClient::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IWrapSteamClient@@8			; IWrapSteamClient::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IWrapSteamClient@@8		; IWrapSteamClient::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__lstrcmpA@8:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z:PROC ; SK_SteamWrapper_WrappedClient_GetISteamUser
EXTRN	?SK_SteamWrapper_WrappedClient_GetISteamController@@YAPAVISteamController@@PAVISteamClient@@HHPBD@Z:PROC ; SK_SteamWrapper_WrappedClient_GetISteamController
EXTRN	?SK_SteamWrapper_WrappedClient_GetISteamUtils@@YAPAVISteamUtils@@PAVISteamClient@@HPBD@Z:PROC ; SK_SteamWrapper_WrappedClient_GetISteamUtils
EXTRN	?SK_SteamWrapper_WrappedClient_GetISteamRemoteStorage@@YAPAVISteamRemoteStorage@@PAVISteamClient@@HHPBD@Z:PROC ; SK_SteamWrapper_WrappedClient_GetISteamRemoteStorage
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	?steam_log@@3UiSK_Logger@@A:BYTE		; steam_log
EXTRN	__imp_?_Byte_reverse_table@details@Concurrency@@3QBEB:BYTE
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A DB 09cH DUP (?) ; SK_SteamWrapper_remap_client
_BSS	ENDS
CRT$XCU	SEGMENT
?SK_SteamWrapper_remap_client$initializer$@@3P6AXXZA DD FLAT:??__ESK_SteamWrapper_remap_client@@YAXXZ ; SK_SteamWrapper_remap_client$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@IWrapSteamClient@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IWrapSteamClient@@8 DD FLAT:??_R0?AVIWrapSteamClient@@@8 ; IWrapSteamClient::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IWrapSteamClient@@8
rdata$r	ENDS
;	COMDAT ??_R2IWrapSteamClient@@8
rdata$r	SEGMENT
??_R2IWrapSteamClient@@8 DD FLAT:??_R1A@?0A@EA@IWrapSteamClient@@8 ; IWrapSteamClient::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ISteamClient@@8
rdata$r	ENDS
;	COMDAT ??_R3IWrapSteamClient@@8
rdata$r	SEGMENT
??_R3IWrapSteamClient@@8 DD 00H				; IWrapSteamClient::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IWrapSteamClient@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIWrapSteamClient@@@8
data$r	SEGMENT
??_R0?AVIWrapSteamClient@@@8 DD FLAT:??_7type_info@@6B@	; IWrapSteamClient `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIWrapSteamClient@@', 00H
data$r	ENDS
;	COMDAT ??_R4IWrapSteamClient@@6B@
rdata$r	SEGMENT
??_R4IWrapSteamClient@@6B@ DD 00H			; IWrapSteamClient::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIWrapSteamClient@@@8
	DD	FLAT:??_R3IWrapSteamClient@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ISteamClient@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ISteamClient@@8 DD FLAT:??_R0?AVISteamClient@@@8 ; ISteamClient::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ISteamClient@@8
rdata$r	ENDS
;	COMDAT ??_R2ISteamClient@@8
rdata$r	SEGMENT
??_R2ISteamClient@@8 DD FLAT:??_R1A@?0A@EA@ISteamClient@@8 ; ISteamClient::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ISteamClient@@8
rdata$r	SEGMENT
??_R3ISteamClient@@8 DD 00H				; ISteamClient::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ISteamClient@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVISteamClient@@@8
data$r	SEGMENT
??_R0?AVISteamClient@@@8 DD FLAT:??_7type_info@@6B@	; ISteamClient `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVISteamClient@@', 00H
data$r	ENDS
;	COMDAT ??_R4ISteamClient@@6B@
rdata$r	SEGMENT
??_R4ISteamClient@@6B@ DD 00H				; ISteamClient::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVISteamClient@@@8
	DD	FLAT:??_R3ISteamClient@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BK@KDCGEAPC@invalid?5number?5of?5buckets?$AA@
CONST	SEGMENT
??_C@_0BK@KDCGEAPC@invalid?5number?5of?5buckets?$AA@ DB 'invalid number o'
	DB	'f buckets', 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
data$r	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
data$r	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ?first@?P@??SteamInternal_CreateInterface_Detour@@YAPAXPBD@Z@4_NA
_DATA	SEGMENT
?first@?P@??SteamInternal_CreateInterface_Detour@@YAPAXPBD@Z@4_NA DB 01H ; `SteamInternal_CreateInterface_Detour'::`15'::first
_DATA	ENDS
;	COMDAT ?first@?2??SteamClient_Detour@@YAPAVISteamClient@@XZ@4_NA
_DATA	SEGMENT
?first@?2??SteamClient_Detour@@YAPAVISteamClient@@XZ@4_NA DB 01H ; `SteamClient_Detour'::`3'::first
_DATA	ENDS
;	COMDAT ??_7IWrapSteamClient@@6B@
CONST	SEGMENT
??_7IWrapSteamClient@@6B@ DD FLAT:??_R4IWrapSteamClient@@6B@ ; IWrapSteamClient::`vftable'
	DD	FLAT:?CreateSteamPipe@IWrapSteamClient@@UAEHXZ
	DD	FLAT:?BReleaseSteamPipe@IWrapSteamClient@@UAE_NH@Z
	DD	FLAT:?ConnectToGlobalUser@IWrapSteamClient@@UAEHH@Z
	DD	FLAT:?CreateLocalUser@IWrapSteamClient@@UAEHPAHW4EAccountType@@@Z
	DD	FLAT:?ReleaseUser@IWrapSteamClient@@UAEXHH@Z
	DD	FLAT:?GetISteamUser@IWrapSteamClient@@UAEPAVISteamUser@@HHPBD@Z
	DD	FLAT:?GetISteamGameServer@IWrapSteamClient@@UAEPAVISteamGameServer@@HHPBD@Z
	DD	FLAT:?SetLocalIPBinding@IWrapSteamClient@@UAEXIG@Z
	DD	FLAT:?GetISteamFriends@IWrapSteamClient@@UAEPAVISteamFriends@@HHPBD@Z
	DD	FLAT:?GetISteamUtils@IWrapSteamClient@@UAEPAVISteamUtils@@HPBD@Z
	DD	FLAT:?GetISteamMatchmaking@IWrapSteamClient@@UAEPAVISteamMatchmaking@@HHPBD@Z
	DD	FLAT:?GetISteamMatchmakingServers@IWrapSteamClient@@UAEPAVISteamMatchmakingServers@@HHPBD@Z
	DD	FLAT:?GetISteamGenericInterface@IWrapSteamClient@@UAEPAXHHPBD@Z
	DD	FLAT:?GetISteamUserStats@IWrapSteamClient@@UAEPAVISteamUserStats@@HHPBD@Z
	DD	FLAT:?GetISteamGameServerStats@IWrapSteamClient@@UAEPAVISteamGameServerStats@@HHPBD@Z
	DD	FLAT:?GetISteamApps@IWrapSteamClient@@UAEPAVISteamApps@@HHPBD@Z
	DD	FLAT:?GetISteamNetworking@IWrapSteamClient@@UAEPAVISteamNetworking@@HHPBD@Z
	DD	FLAT:?GetISteamRemoteStorage@IWrapSteamClient@@UAEPAVISteamRemoteStorage@@HHPBD@Z
	DD	FLAT:?GetISteamScreenshots@IWrapSteamClient@@UAEPAVISteamScreenshots@@HHPBD@Z
	DD	FLAT:?RunFrame@IWrapSteamClient@@UAEXXZ
	DD	FLAT:?GetIPCCallCount@IWrapSteamClient@@UAEIXZ
	DD	FLAT:?SetWarningMessageHook@IWrapSteamClient@@UAEXP6AXHPBD@Z@Z
	DD	FLAT:?BShutdownIfAllPipesClosed@IWrapSteamClient@@UAE_NXZ
	DD	FLAT:?GetISteamHTTP@IWrapSteamClient@@UAEPAVISteamHTTP@@HHPBD@Z
	DD	FLAT:?GetISteamUnifiedMessages@IWrapSteamClient@@UAEPAVISteamUnifiedMessages@@HHPBD@Z
	DD	FLAT:?GetISteamController@IWrapSteamClient@@UAEPAVISteamController@@HHPBD@Z
	DD	FLAT:?GetISteamUGC@IWrapSteamClient@@UAEPAVISteamUGC@@HHPBD@Z
	DD	FLAT:?GetISteamAppList@IWrapSteamClient@@UAEPAVISteamAppList@@HHPBD@Z
	DD	FLAT:?GetISteamMusic@IWrapSteamClient@@UAEPAVISteamMusic@@HHPBD@Z
	DD	FLAT:?GetISteamMusicRemote@IWrapSteamClient@@UAEPAVISteamMusicRemote@@HHPBD@Z
	DD	FLAT:?GetISteamHTMLSurface@IWrapSteamClient@@UAEPAVISteamHTMLSurface@@HHPBD@Z
	DD	FLAT:?Set_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z
	DD	FLAT:?Remove_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z
	DD	FLAT:?Set_SteamAPI_CCheckCallbackRegisteredInProcess@IWrapSteamClient@@UAEXP6AIH@Z@Z
	DD	FLAT:?GetISteamInventory@IWrapSteamClient@@UAEPAVISteamInventory@@HHPBD@Z
	DD	FLAT:?GetISteamVideo@IWrapSteamClient@@UAEPAVISteamVideo@@HHPBD@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7ISteamClient@@6B@
CONST	SEGMENT
??_7ISteamClient@@6B@ DD FLAT:??_R4ISteamClient@@6B@	; ISteamClient::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__ESK_SteamWrapper_remap_client@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__ESK_SteamWrapper_remap_client@@YAXXZ$1
__ehfuncinfo$??__ESK_SteamWrapper_remap_client@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__ESK_SteamWrapper_remap_client@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z$0
__ehfuncinfo$??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z$0
__ehfuncinfo$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 38   : 		: _Ptr()

	mov	DWORD PTR [eax], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 841  : 		}

	pop	ebp
	ret	4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@PAVISteamClient@@@std@@YA$$QAPAVISteamClient@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVISteamClient@@@std@@YA$$QAPAVISteamClient@@AAPAV1@@Z PROC ; std::forward<ISteamClient *>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@PAVISteamClient@@@std@@YA$$QAPAVISteamClient@@AAPAV1@@Z ENDP ; std::forward<ISteamClient *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator_traits@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator_traits@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN5@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 38   : 		: _Ptr()

	mov	DWORD PTR [eax], 0
$LN5@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 960  : 		}

	pop	ebp
	ret	0
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator_traits@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0PAVISteamClient@@PAVIWrapSteamClient@@X$0A@@?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@QAE@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0PAVISteamClient@@PAVIWrapSteamClient@@X$0A@@?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@QAE@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@1@@Z PROC ; std::pair<ISteamClient * const,IWrapSteamClient *>::pair<ISteamClient * const,IWrapSteamClient *><ISteamClient *,IWrapSteamClient *,void,0>, COMDAT
; _this$ = ecx

; 217  : 		{	// construct from moved compatible pair

	npad	2
	push	ebp
	mov	ebp, esp

; 215  : 		: first(_STD forward<_Other1>(_Right.first)),

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 216  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 218  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAVISteamClient@@PAVIWrapSteamClient@@X$0A@@?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@QAE@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@1@@Z ENDP ; std::pair<ISteamClient * const,IWrapSteamClient *>::pair<ISteamClient * const,IWrapSteamClient *><ISteamClient *,IWrapSteamClient *,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 38   : 		: _Ptr()

	mov	DWORD PTR [eax], 0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1098 : 		}

	pop	ebp
	ret	4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@@std@@YA$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@AAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@@std@@YA$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@AAV123@@Z PROC ; std::forward<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@@std@@YA$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@AAV123@@Z ENDP ; std::forward<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@2@@?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAEXPAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@2@@?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAEXPAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@1@@Z PROC ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::construct<std::pair<ISteamClient * const,IWrapSteamClient *>,std::pair<ISteamClient *,IWrapSteamClient *> >, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 215  : 		: first(_STD forward<_Other1>(_Right.first)),

	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 216  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 841  : 		}

	pop	ebp
	ret	8
??$construct@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@2@@?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAEXPAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@1@@Z ENDP ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::construct<std::pair<ISteamClient * const,IWrapSteamClient *>,std::pair<ISteamClient *,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@YAPAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@YAPAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@0@AAU10@@Z PROC ; std::addressof<std::pair<ISteamClient * const,IWrapSteamClient *> >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@YAPAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<ISteamClient * const,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >, COMDAT

; 228  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Uninitiali
	npad	1
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN19@Uninitiali
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 38   : 		: _Ptr()

	mov	DWORD PTR [eax], 0
$LN19@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 233  : 		{
; 234  : 		_Al.construct(_Unfancy(_First));
; 235  : 		}
; 236  : 
; 237  : 	_CATCH_ALL
; 238  : 	_Destroy_range(_Next, _First, _Al);
; 239  : 	_RERAISE;
; 240  : 	_CATCH_END
; 241  : 
; 242  : 	return (_First);
; 243  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@@Z PROC ; std::_Unfancy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@@Z ENDP ; std::_Unfancy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@YAAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@YAAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@YAAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_NX$0A@@?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@QAE@$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_NX$0A@@?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@QAE@$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@$$QA_N@Z PROC ; std::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool>::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool><Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_NX$0A@@?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@QAE@$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@$$QA_N@Z ENDP ; std::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool>::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool><Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??$_Buynode@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@I$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z
_TEXT	SEGMENT
__Order_key$ = 8					; size = 4
__Value$ = 12						; size = 4
??$_Buynode@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@I$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Buynode<std::pair<ISteamClient *,IWrapSteamClient *> >, COMDAT
; _this$ = ecx

; 323  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edx, edx
	jne	SHORT $LN17@Buynode
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN51@Buynode:
$LN17@Buynode:
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 358  :         return ((reference)(*_Pnode)._M_element);

	lea	esi, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN31@Buynode
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 215  : 		: first(_STD forward<_Other1>(_Right.first)),

	mov	ecx, DWORD PTR __Value$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 216  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
$LN31@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	eax, DWORD PTR __Order_key$[ebp]
	mov	DWORD PTR [edx+12], eax

; 324  :         _Nodeptr _Pnode = this->_M_node_allocator.allocate(1);
; 325  : 
; 326  :         try
; 327  :         {
; 328  :             this->_M_value_allocator.construct(std::addressof(_Myval(_Pnode)), std::forward<_ValTy>(_Value));
; 329  :             _Pnode->_Init(_Order_key);
; 330  :         }
; 331  :         catch(...)
; 332  :         {
; 333  :             this->_M_node_allocator.deallocate(_Pnode, 1);
; 334  :             throw;
; 335  :         }
; 336  : 
; 337  :         return (_Pnode);

	mov	eax, edx

; 216  :             _M_next = NULL;

	mov	DWORD PTR [edx], 0
	pop	esi

; 338  :     }

	pop	ebp
	ret	8
$LN50@Buynode:
??$_Buynode@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@I$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Buynode<std::pair<ISteamClient *,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@YA$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@YA$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@0@AAU10@@Z PROC ; std::forward<std::pair<ISteamClient *,IWrapSteamClient *> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@YA$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@0@AAU10@@Z ENDP ; std::forward<std::pair<ISteamClient *,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??$_Key_function@PAVISteamClient@@PAVIWrapSteamClient@@@?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamClient@@ABU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
??$_Key_function@PAVISteamClient@@PAVIWrapSteamClient@@@?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamClient@@ABU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z PROC ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Key_function<ISteamClient *,IWrapSteamClient *>, COMDAT

; 84   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 85   :         return (_Value.first);

	mov	eax, DWORD PTR __Value$[ebp]

; 86   :     }

	pop	ebp
	ret	0
??$_Key_function@PAVISteamClient@@PAVIWrapSteamClient@@@?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamClient@@ABU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z ENDP ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Key_function<ISteamClient *,IWrapSteamClient *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0ABQAVISteamClient@@PAVIWrapSteamClient@@X$0A@@?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@QAE@ABQAVISteamClient@@$$QAPAVIWrapSteamClient@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABQAVISteamClient@@PAVIWrapSteamClient@@X$0A@@?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@QAE@ABQAVISteamClient@@$$QAPAVIWrapSteamClient@@@Z PROC ; std::pair<ISteamClient *,IWrapSteamClient *>::pair<ISteamClient *,IWrapSteamClient *><ISteamClient * const &,IWrapSteamClient *,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0ABQAVISteamClient@@PAVIWrapSteamClient@@X$0A@@?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@QAE@ABQAVISteamClient@@$$QAPAVIWrapSteamClient@@@Z ENDP ; std::pair<ISteamClient *,IWrapSteamClient *>::pair<ISteamClient *,IWrapSteamClient *><ISteamClient * const &,IWrapSteamClient *,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@PAVIWrapSteamClient@@@std@@YA$$QAPAVIWrapSteamClient@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVIWrapSteamClient@@@std@@YA$$QAPAVIWrapSteamClient@@AAPAV1@@Z PROC ; std::forward<IWrapSteamClient *>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@PAVIWrapSteamClient@@@std@@YA$$QAPAVIWrapSteamClient@@AAPAV1@@Z ENDP ; std::forward<IWrapSteamClient *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABQAVISteamClient@@@std@@YAABQAVISteamClient@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVISteamClient@@@std@@YAABQAVISteamClient@@ABQAV1@@Z PROC ; std::forward<ISteamClient * const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABQAVISteamClient@@@std@@YAABQAVISteamClient@@ABQAV1@@Z ENDP ; std::forward<ISteamClient * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@1@@Z PROC ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node><std::pair<ISteamClient * const,IWrapSteamClient *> >, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@1@@Z ENDP ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node><std::pair<ISteamClient * const,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >, COMDAT

; 260  : 	{	// value-initialize _Count objects to raw _First, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 261  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >
	add	esp, 16					; 00000010H

; 263  : 		_Conjunction_t<
; 264  : 			is_pointer<_FwdIt>,
; 265  : 			is_scalar<_Ty>,
; 266  : 			negation<is_volatile<_Ty>>,
; 267  : 			negation<is_member_pointer<_Ty>>,
; 268  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>()));
; 269  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAE@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAE@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > ><std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAE@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > ><std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@Z PROC ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::destroy<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@Z ENDP ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::destroy<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@1@@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > ><std::pair<ISteamClient * const,IWrapSteamClient *> >, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@1@@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > ><std::pair<ISteamClient * const,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Is_dummy@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE_NXZ
_TEXT	SEGMENT
?_Is_dummy@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE_NXZ PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Is_dummy, COMDAT
; _this$ = ecx

; 247  :             return (_M_order_key & 0x1) == 0;

	mov	eax, DWORD PTR [ecx+12]
	not	eax
	and	eax, 1

; 248  :         }

	ret	0
?_Is_dummy@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE_NXZ ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Is_dummy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Atomic_set_next@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU1234@PAU1234@0@Z
_TEXT	SEGMENT
__New_node$ = 8						; size = 4
__Current_node$ = 12					; size = 4
?_Atomic_set_next@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU1234@PAU1234@0@Z PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Atomic_set_next, COMDAT
; _this$ = ecx

; 227  :         {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  :             // Try to change the next pointer on the current element to a new element, only if it still points to the cached next
; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, DWORD PTR __New_node$[ebp]
	mov	eax, DWORD PTR __Current_node$[ebp]
	lock	 cmpxchg DWORD PTR [ecx], edx

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, DWORD PTR __Current_node$[ebp]
	cmove	eax, DWORD PTR __New_node$[ebp]

; 232  :             {
; 233  :                 // Operation succeeded, return the new node
; 234  :                 return _New_node;
; 235  :             }
; 236  :             else
; 237  :             {
; 238  :                 // Operation failed, return the "interfering" node
; 239  :                 return _Exchange_node;
; 240  :             }
; 241  :         }

	pop	ebp
	ret	8
?_Atomic_set_next@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU1234@PAU1234@0@Z ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Atomic_set_next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Get_order_key@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBEIXZ
_TEXT	SEGMENT
?_Get_order_key@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBEIXZ PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Get_order_key, COMDAT
; _this$ = ecx

; 222  :             return _M_order_key;

	mov	eax, DWORD PTR [ecx+12]

; 223  :         }

	ret	0
?_Get_order_key@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBEIXZ ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Get_order_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Init@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXI@Z
_TEXT	SEGMENT
__Order_key$ = 8					; size = 4
?_Init@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXI@Z PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Init, COMDAT
; _this$ = ecx

; 214  :         {

	npad	2
	push	ebp
	mov	ebp, esp

; 215  :             _M_order_key = _Order_key;

	mov	eax, DWORD PTR __Order_key$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 216  :             _M_next = NULL;

	mov	DWORD PTR [ecx], 0

; 217  :         }

	pop	ebp
	ret	4
?_Init@_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXI@Z ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z
_TEXT	SEGMENT
__Result$1 = -24					; size = 8
tv811 = -20						; size = 4
_this$1$ = -16						; size = 4
__Reversed_order_key$2 = -12				; size = 4
tv813 = -8						; size = 4
__Index$3 = -8						; size = 4
__Index$4 = -8						; size = 4
__Val$5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Value$ = 12						; size = 4
??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Insert<std::pair<ISteamClient *,IWrapSteamClient *> >, COMDAT
; _this$ = ecx

; 862  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	esi, DWORD PTR __Value$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 862  :     {

	mov	ebx, ecx

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$4[ebp], 0
	push	edi

; 862  :     {

	mov	DWORD PTR _this$1$[ebp], ebx

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	edi, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [esi]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [esi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+2]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+3]
	imul	ecx, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 864  :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	ecx, eax

; 347  : 		_Val *= _FNV_prime;

	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 864  :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	lea	ecx, DWORD PTR [ebx+148]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 347  : 		_Val *= _FNV_prime;

	mov	DWORD PTR __Val$5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 864  :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	div	DWORD PTR [ecx]
	mov	esi, edx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, esi
	or	eax, 1
	mov	DWORD PTR tv811[ebp], eax

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$4[ebp], eax

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	eax, DWORD PTR [ebx+ecx*4+4]
	test	eax, eax
	je	SHORT $LN232@Insert

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	edx, edi

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	eax, esi

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	edx, cl

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	ecx, DWORD PTR [ebx+ecx*4+4]

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	and	edx, -2					; fffffffeH

; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	eax, edx
	cmp	DWORD PTR [ecx+eax*4], 0
	setne	al

; 865  : 
; 866  :         // If bucket is empty, initialize it first
; 867  :         if (!_Is_initialized(_Bucket))

	test	al, al
	jne	SHORT $LN5@Insert
$LN232@Insert:

; 868  :         {
; 869  :             _Initialize_bucket(_Bucket);

	push	esi
	mov	ecx, ebx
	call	?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Initialize_bucket
$LN5@Insert:

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	ecx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	edx, DWORD PTR __Val$5[ebp]
	movzx	eax, dl

; 870  :         }
; 871  : 
; 872  :         long _New_count;
; 873  :         _Order_key = _Split_order_regular_key(_Order_key);
; 874  :         _Full_iterator _Iterator = _Get_bucket(_Bucket);
; 875  :         _Full_iterator _Last = _M_split_ordered_list._End();
; 876  :         _Full_iterator _Where = _Iterator;
; 877  :         _Nodeptr _New_node = _M_split_ordered_list._Buynode(_Order_key, std::forward<_ValTy>(_Value));

	push	DWORD PTR __Value$[ebp]

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$3[ebp], 0

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$2[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, dh

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$2[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$5[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$2[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$5[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$2[ebp], al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, DWORD PTR tv811[ebp]

; 1296 :         return _Reverse(_Order_key) | 0x1;

	mov	ebx, DWORD PTR __Reversed_order_key$2[ebp]

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 1296 :         return _Reverse(_Order_key) | 0x1;

	or	ebx, edi

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$3[ebp], eax

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, edi
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1240 :         return _M_buckets[_Segment][_Bucket];

	sub	esi, eax
	mov	eax, DWORD PTR _this$1$[ebp]

; 870  :         }
; 871  : 
; 872  :         long _New_count;
; 873  :         _Order_key = _Split_order_regular_key(_Order_key);
; 874  :         _Full_iterator _Iterator = _Get_bucket(_Bucket);
; 875  :         _Full_iterator _Last = _M_split_ordered_list._End();
; 876  :         _Full_iterator _Where = _Iterator;
; 877  :         _Nodeptr _New_node = _M_split_ordered_list._Buynode(_Order_key, std::forward<_ValTy>(_Value));

	push	ebx

; 1240 :         return _M_buckets[_Segment][_Bucket];

	mov	edi, DWORD PTR [eax+ecx*4+4]

; 870  :         }
; 871  : 
; 872  :         long _New_count;
; 873  :         _Order_key = _Split_order_regular_key(_Order_key);
; 874  :         _Full_iterator _Iterator = _Get_bucket(_Bucket);
; 875  :         _Full_iterator _Last = _M_split_ordered_list._End();
; 876  :         _Full_iterator _Where = _Iterator;
; 877  :         _Nodeptr _New_node = _M_split_ordered_list._Buynode(_Order_key, std::forward<_ValTy>(_Value));

	lea	ecx, DWORD PTR [eax+132]

; 1240 :         return _M_buckets[_Segment][_Bucket];

	mov	edi, DWORD PTR [edi+esi*4]

; 870  :         }
; 871  : 
; 872  :         long _New_count;
; 873  :         _Order_key = _Split_order_regular_key(_Order_key);
; 874  :         _Full_iterator _Iterator = _Get_bucket(_Bucket);
; 875  :         _Full_iterator _Last = _M_split_ordered_list._End();
; 876  :         _Full_iterator _Where = _Iterator;
; 877  :         _Nodeptr _New_node = _M_split_ordered_list._Buynode(_Order_key, std::forward<_ValTy>(_Value));

	call	??$_Buynode@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@I$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Buynode<std::pair<ISteamClient *,IWrapSteamClient *> >
	mov	ecx, eax
$LN236@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [edi]
	npad	4
$LL2@Insert:

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 886  :             if (_Where == _Last || _Mylist::_Get_key(_Where) > _Order_key)

	je	SHORT $LN8@Insert
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, ebx
	ja	SHORT $LN8@Insert

; 909  :             else if (!this->_M_allow_multimapping && _Mylist::_Get_key(_Where) == _Order_key &&

	jne	SHORT $LN11@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 909  :             else if (!this->_M_allow_multimapping && _Mylist::_Get_key(_Where) == _Order_key &&

	je	SHORT $LN212@Insert
$LN11@Insert:

; 910  :                 this->_M_comparator(this->_Key_function(*_Where), this->_Key_function(_New_node->_M_element)) == 0)
; 911  :             {
; 912  :                 // If the insert failed (element already there), then delete the new one
; 913  :                 _M_split_ordered_list._Erase(_New_node);
; 914  : 
; 915  :                 // Element already in the list, return it
; 916  :                 return std::pair<iterator, bool>(_M_split_ordered_list._Get_iterator(_Where), false);
; 917  :             }
; 918  : 
; 919  :             // Move the iterator forward
; 920  :             _Iterator = _Where;

	mov	edi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 922  :         }

	jmp	SHORT $LL2@Insert
$LN8@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 610  :         _New_node->_M_next = _Current_node;

	mov	DWORD PTR [ecx], esi

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, ecx
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [edi], edx

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, esi
	je	SHORT $LN235@Insert

; 619  :         if (_Inserted_node == _List_node)

	cmp	eax, ecx
	je	SHORT $LN235@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR __Result$1[ebp], 0

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR __Result$1[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 906  :                     continue;

	jmp	SHORT $LN236@Insert
$LN212@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi
	pop	esi

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 923  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN235@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 623  :             *_New_count = _InterlockedIncrement(&_M_element_count);

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, 1
	lock	 xadd	 DWORD PTR [edx+140], eax
	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 894  :                     _Adjust_table_size(_New_count, _M_number_of_buckets);

	mov	esi, DWORD PTR [edx+148]
	lea	edi, DWORD PTR [edx+148]
	movd	xmm0, eax

; 1221 :         if (((float) _Total_elements / (float) _Current_size) > _M_maximum_bucket_size)

	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR __Result$1[ebp+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1221 :         if (((float) _Total_elements / (float) _Current_size) > _M_maximum_bucket_size)

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, esi
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm1, xmm0
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	comiss	xmm1, DWORD PTR [edx+152]
	jbe	SHORT $LN138@Insert

; 1222 :         {
; 1223 :              // Double the size of the hash only if size has not changed inbetween loads
; 1224 :             _InterlockedCompareExchangeSizeT(&_M_number_of_buckets, 2 * _Current_size, _Current_size);

	lea	edx, DWORD PTR [esi+esi]
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [edi], edx
$LN138@Insert:

; 895  :                     return _Result;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Result$1[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 923  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Insert<std::pair<ISteamClient *,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$make_pair@ABQAVISteamClient@@PAVIWrapSteamClient@@@std@@YA?AU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@0@ABQAVISteamClient@@$$QAPAVIWrapSteamClient@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@ABQAVISteamClient@@PAVIWrapSteamClient@@@std@@YA?AU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@0@ABQAVISteamClient@@$$QAPAVIWrapSteamClient@@@Z PROC ; std::make_pair<ISteamClient * const &,IWrapSteamClient *>, COMDAT

; 341  : 	{	// return pair composed from arguments

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR __Val2$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx

; 342  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 343  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 344  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),
; 345  : 		_STD forward<_Ty2>(_Val2)));
; 346  : 	}

	pop	ebp
	ret	0
??$make_pair@ABQAVISteamClient@@PAVIWrapSteamClient@@@std@@YA?AU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@0@ABQAVISteamClient@@$$QAPAVIWrapSteamClient@@@Z ENDP ; std::make_pair<ISteamClient * const &,IWrapSteamClient *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??D?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@XZ
_TEXT	SEGMENT
??D?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@XZ PROC ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*, COMDAT
; _this$ = ecx

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 148  :         return ((reference)**(_Mybase *)this);
; 149  :     }

	ret	0
??D?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@XZ ENDP ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@@Z PROC ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >, COMDAT
; _this$ = ecx

; 130  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 131  :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@@Z ENDP ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::destroy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@1@@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::destroy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++, COMDAT
; _this$ = ecx

; 313  : 		{	// postincrement

	npad	2
	push	ebp
	mov	ebp, esp

; 314  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 315  : 		++*this;
; 316  : 		return (_Tmp);
; 317  : 		}

	pop	ebp
	ret	8
??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 308  : 		++(*(_Mybase *)this);
; 309  : 		return (*this);

	mov	eax, ecx

; 310  : 		}

	ret	0
??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??D?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBEAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@XZ
_TEXT	SEGMENT
??D?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBEAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@XZ PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 299  : 		}

	ret	0
??D?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBEAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@XZ ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 281  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 275  : 		{	// construct with null node
; 276  : 		}

	mov	eax, ecx
	ret	0
??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??$_Key_function@QAVISteamClient@@PAVIWrapSteamClient@@@?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamClient@@ABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
??$_Key_function@QAVISteamClient@@PAVIWrapSteamClient@@@?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamClient@@ABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z PROC ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Key_function<ISteamClient * const,IWrapSteamClient *>, COMDAT

; 84   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 85   :         return (_Value.first);

	mov	eax, DWORD PTR __Value$[ebp]

; 86   :     }

	pop	ebp
	ret	0
??$_Key_function@QAVISteamClient@@PAVIWrapSteamClient@@@?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamClient@@ABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@Z ENDP ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Key_function<ISteamClient * const,IWrapSteamClient *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE?AV012@H@Z PROC ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++, COMDAT
; _this$ = ecx

; 86   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 87   :         _Myiter _Tmp = *this;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, ecx
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	npad	1
$LL10@operator:

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	ecx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 80   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	ecx, ecx
	je	SHORT $LN36@operator
	mov	al, BYTE PTR [ecx+12]
	not	al
	test	al, 1
	jne	SHORT $LL10@operator

; 88   :         do
; 89   :         {
; 90   :             ++*this;
; 91   :         }
; 92   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	ecx, ecx
	je	SHORT $LN36@operator
	mov	cl, BYTE PTR [ecx+12]
	not	cl
	test	cl, 1
	jne	SHORT $LL10@operator
$LN36@operator:

; 93   : 
; 94   :         return (_Tmp);

	mov	eax, esi
	pop	esi

; 95   :     }

	pop	ebp
	ret	8
??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE?AV012@H@Z ENDP ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAEAAV012@XZ PROC ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++, COMDAT
; _this$ = ecx

; 75   :     {

	npad	2
$LL4@operator:

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 80   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	eax, eax
	je	SHORT $LN20@operator
	mov	al, BYTE PTR [eax+12]
	not	al
	test	al, 1
	jne	SHORT $LL4@operator
$LN20@operator:

; 81   : 
; 82   :         return (*this);

	mov	eax, ecx

; 83   :     }

	ret	0
??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAEAAV012@XZ ENDP ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??D?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@XZ
_TEXT	SEGMENT
??D?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@XZ PROC ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*, COMDAT
; _this$ = ecx

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 66   :         return ((reference)**(_Mybase *)this);
; 67   :     }

	ret	0
??D?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@XZ ENDP ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@@Z PROC ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >, COMDAT
; _this$ = ecx

; 48   :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 49   :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@12@@Z ENDP ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??9?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator!=, COMDAT
; _this$ = ecx

; 237  : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 238  : 		return (!(*this == _Right));
; 239  : 		}

	pop	ebp
	ret	4
??9?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??8?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator==, COMDAT
; _this$ = ecx

; 222  : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 223  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 224  : 		if (this->_Getcont() != _Right._Getcont())
; 225  : 			{	// report error
; 226  : 			_DEBUG_ERROR("forward_list iterators incompatible");
; 227  : 			}
; 228  : 
; 229  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 230  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 231  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 232  : 
; 233  : 		return (this->_Ptr == _Right._Ptr);
; 234  : 		}

	pop	ebp
	ret	4
??8?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++, COMDAT
; _this$ = ecx

; 215  : 		{	// postincrement

	npad	2
	push	ebp
	mov	ebp, esp

; 216  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 217  : 		++*this;
; 218  : 		return (_Tmp);
; 219  : 		}

	pop	ebp
	ret	8
??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 211  : 		return (*this);

	mov	eax, ecx

; 212  : 		}

	ret	0
??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??D?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBEABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@XZ
_TEXT	SEGMENT
??D?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBEABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@XZ PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 195  : 		}

	ret	0
??D?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QBEABU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@1@XZ ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >, COMDAT
; _this$ = ecx

; 161  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 162  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 157  : 		}

	mov	eax, ecx
	ret	0
??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ?_Mynode@?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QBEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@XZ
_TEXT	SEGMENT
?_Mynode@?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QBEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@XZ PROC ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 83   : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 84   : 		}

	ret	0
?_Mynode@?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QBEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@XZ ENDP ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z PROC ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@45@@Z ENDP ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@XZ PROC ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@XZ ENDP ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -24						; size = 8
$T3 = -16						; size = 8
$T4 = -16						; size = 8
$T5 = -16						; size = 8
__Where$6 = -12						; size = 4
__Where$7 = -12						; size = 4
__Where$8 = -12						; size = 4
$T9 = -12						; size = 4
$T10 = -8						; size = 8
_pClient$11 = -4					; size = 4
_ver$ = 8						; size = 4
?SteamInternal_CreateInterface_Detour@@YAPAXPBD@Z PROC	; SteamInternal_CreateInterface_Detour

; 238  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 239  :   dll_log.Log (L"[SteamWrap] SteamInternal_CreateInterface (%hs)", ver);

	mov	esi, DWORD PTR _ver$[ebp]
	push	edi
	push	esi
	push	OFFSET $SG164530
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 240  : 
; 241  :   if (! lstrcmpA (ver, STEAMCLIENT_INTERFACE_VERSION))

	push	OFFSET $SG164533
	push	esi
	call	DWORD PTR __imp__lstrcmpA@8
	test	eax, eax
	jne	$LN2@SteamInter

; 242  :   {
; 243  :     ISteamClient* pClient =
; 244  :       static_cast <ISteamClient *> ( SteamInternal_CreateInterface_Original (ver) );

	push	esi
	call	DWORD PTR ?SteamInternal_CreateInterface_Original@@3P6APAXPBD@ZA ; SteamInternal_CreateInterface_Original
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _pClient$11[ebp], edi

; 245  : 
; 246  :     if (pClient != nullptr)

	test	edi, edi
	je	$LN7@SteamInter

; 247  :     {
; 248  :       if (SK_SteamWrapper_remap_client.count (pClient))

	lea	eax, DWORD PTR _pClient$11[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	push	eax
	call	?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::count
	test	eax, eax
	je	SHORT $LN5@SteamInter
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	lea	eax, DWORD PTR _pClient$11[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	push	eax
	lea	eax, DWORD PTR __Where$8[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$8[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN13@SteamInter

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
$LN156@SteamInter:
	push	eax
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T5[ebp+4], 0
	mov	DWORD PTR $T5[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	call	??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Insert<std::pair<ISteamClient *,IWrapSteamClient *> >
	mov	eax, DWORD PTR [eax]
$LN13@SteamInter:
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 249  :          return SK_SteamWrapper_remap_client [pClient];

	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi

; 270  :     SteamInternal_CreateInterface_Original (ver);
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SteamInter:

; 253  :         SK_SteamWrapper_remap_client [pClient] =

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T9[ebp], esi
	test	esi, esi
	je	SHORT $LN9@SteamInter

; 63   :                      pRealClient (pSteamClient) {

	mov	DWORD PTR [esi], OFFSET ??_7IWrapSteamClient@@6B@
	mov	DWORD PTR [esi+4], edi

; 253  :         SK_SteamWrapper_remap_client [pClient] =

	jmp	SHORT $LN10@SteamInter
$LN9@SteamInter:
	xor	esi, esi
$LN10@SteamInter:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	lea	eax, DWORD PTR _pClient$11[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	push	eax
	lea	eax, DWORD PTR __Where$7[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$7[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN64@SteamInter
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T4[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	lea	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR $T4[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Insert<std::pair<ISteamClient *,IWrapSteamClient *> >
	mov	eax, DWORD PTR [eax]
$LN64@SteamInter:
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 253  :         SK_SteamWrapper_remap_client [pClient] =

	mov	DWORD PTR [eax+8], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	lea	eax, DWORD PTR _pClient$11[ebp]
	push	eax
	lea	eax, DWORD PTR __Where$6[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$6[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN13@SteamInter

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 256  :         return SK_SteamWrapper_remap_client [pClient];

	jmp	$LN156@SteamInter
$LN2@SteamInter:

; 257  :       }
; 258  :     }
; 259  :   }
; 260  : 
; 261  :   else
; 262  :   {
; 263  :     SK_RunOnce (

	cmp	BYTE PTR ?first@?P@??SteamInternal_CreateInterface_Detour@@YAPAXPBD@Z@4_NA, 0
	je	SHORT $LN7@SteamInter
	push	esi
	push	OFFSET $SG164539
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	BYTE PTR ?first@?P@??SteamInternal_CreateInterface_Detour@@YAPAXPBD@Z@4_NA, 0
$LN7@SteamInter:

; 264  :       steam_log.Log ( L"Game requested unexpected interface version (%s)!",
; 265  :                         ver )
; 266  :     );
; 267  :   }
; 268  : 
; 269  :   return

	push	esi
	call	DWORD PTR ?SteamInternal_CreateInterface_Original@@3P6APAXPBD@ZA ; SteamInternal_CreateInterface_Original
	add	esp, 4
	pop	edi
	pop	esi

; 270  :     SteamInternal_CreateInterface_Original (ver);
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SteamInternal_CreateInterface_Detour@@YAPAXPBD@Z ENDP	; SteamInternal_CreateInterface_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -24						; size = 8
$T3 = -16						; size = 8
$T4 = -16						; size = 8
$T5 = -16						; size = 8
__Where$6 = -12						; size = 4
__Where$7 = -12						; size = 4
__Where$8 = -12						; size = 4
$T9 = -12						; size = 4
$T10 = -8						; size = 8
_pClient$ = -4						; size = 4
?SteamClient_Detour@@YAPAVISteamClient@@XZ PROC		; SteamClient_Detour

; 202  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 203  :   SK_RunOnce (

	cmp	BYTE PTR ?first@?2??SteamClient_Detour@@YAPAVISteamClient@@XZ@4_NA, 0
	je	SHORT $LN2@SteamClien
	push	OFFSET $SG164509
	push	OFFSET $SG164510
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	BYTE PTR ?first@?2??SteamClient_Detour@@YAPAVISteamClient@@XZ@4_NA, 0
$LN2@SteamClien:

; 204  :     steam_log.Log ( L"[!] %hs ()",
; 205  :                       __FUNCTION__ )
; 206  :   );
; 207  : 
; 208  :   ISteamClient* pClient =
; 209  :     static_cast <ISteamClient *> ( SteamClient_Original () );

	push	edi
	call	DWORD PTR _SteamClient_Original
	mov	edi, eax
	mov	DWORD PTR _pClient$[ebp], edi

; 210  : 
; 211  :   if (pClient != nullptr)

	test	edi, edi
	je	$LN5@SteamClien

; 212  :   {
; 213  :     if (SK_SteamWrapper_remap_client.count (pClient))

	lea	eax, DWORD PTR _pClient$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	push	eax
	call	?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::count
	test	eax, eax
	je	SHORT $LN4@SteamClien
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	lea	eax, DWORD PTR _pClient$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	push	eax
	lea	eax, DWORD PTR __Where$8[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$8[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN11@SteamClien

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
$LN154@SteamClien:
	push	eax
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T5[ebp+4], 0
	mov	DWORD PTR $T5[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	call	??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Insert<std::pair<ISteamClient *,IWrapSteamClient *> >
	mov	eax, DWORD PTR [eax]
$LN11@SteamClien:
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 214  :        return SK_SteamWrapper_remap_client [pClient];

	mov	eax, DWORD PTR [eax+8]
	pop	edi

; 226  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@SteamClien:
	push	esi

; 218  :       SK_SteamWrapper_remap_client [pClient] =

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T9[ebp], esi
	test	esi, esi
	je	SHORT $LN7@SteamClien

; 63   :                      pRealClient (pSteamClient) {

	mov	DWORD PTR [esi], OFFSET ??_7IWrapSteamClient@@6B@
	mov	DWORD PTR [esi+4], edi

; 218  :       SK_SteamWrapper_remap_client [pClient] =

	jmp	SHORT $LN8@SteamClien
$LN7@SteamClien:
	xor	esi, esi
$LN8@SteamClien:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	lea	eax, DWORD PTR _pClient$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	push	eax
	lea	eax, DWORD PTR __Where$7[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$7[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN62@SteamClien
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T4[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	lea	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR $T4[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Insert<std::pair<ISteamClient *,IWrapSteamClient *> >
	mov	eax, DWORD PTR [eax]
$LN62@SteamClien:
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 218  :       SK_SteamWrapper_remap_client [pClient] =

	mov	DWORD PTR [eax+8], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	lea	eax, DWORD PTR _pClient$[ebp]
	push	eax
	lea	eax, DWORD PTR __Where$6[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$6[ebp]
	pop	esi
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN11@SteamClien

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 221  :       return SK_SteamWrapper_remap_client [pClient];

	jmp	$LN154@SteamClien
$LN5@SteamClien:

; 222  :     }
; 223  :   }
; 224  : 
; 225  :   return nullptr;

	xor	eax, eax
	pop	edi

; 226  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SteamClient_Detour@@YAPAVISteamClient@@XZ ENDP		; SteamClient_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamVideo@IWrapSteamClient@@UAEPAVISteamVideo@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamVideo@IWrapSteamClient@@UAEPAVISteamVideo@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamVideo, COMDAT
; _this$ = ecx

; 185  :   virtual ISteamVideo              *GetISteamVideo               (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 186  :     return pRealClient->GetISteamVideo              (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+140]
?GetISteamVideo@IWrapSteamClient@@UAEPAVISteamVideo@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamVideo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamInventory@IWrapSteamClient@@UAEPAVISteamInventory@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamInventory@IWrapSteamClient@@UAEPAVISteamInventory@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamInventory, COMDAT
; _this$ = ecx

; 183  :   virtual ISteamInventory          *GetISteamInventory           (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 184  :     return pRealClient->GetISteamInventory          (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+136]
?GetISteamInventory@IWrapSteamClient@@UAEPAVISteamInventory@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamInventory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?Set_SteamAPI_CCheckCallbackRegisteredInProcess@IWrapSteamClient@@UAEXP6AIH@Z@Z
_TEXT	SEGMENT
_func$ = 8						; size = 4
?Set_SteamAPI_CCheckCallbackRegisteredInProcess@IWrapSteamClient@@UAEXP6AIH@Z@Z PROC ; IWrapSteamClient::Set_SteamAPI_CCheckCallbackRegisteredInProcess, COMDAT
; _this$ = ecx

; 180  :   virtual void                      Set_SteamAPI_CCheckCallbackRegisteredInProcess (SteamAPI_CheckCallbackRegistered_t func) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 181  :     return pRealClient->Set_SteamAPI_CCheckCallbackRegisteredInProcess (func); }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+132]
?Set_SteamAPI_CCheckCallbackRegisteredInProcess@IWrapSteamClient@@UAEXP6AIH@Z@Z ENDP ; IWrapSteamClient::Set_SteamAPI_CCheckCallbackRegisteredInProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?Remove_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z
_TEXT	SEGMENT
_func$ = 8						; size = 4
?Remove_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z PROC ; IWrapSteamClient::Remove_SteamAPI_CPostAPIResultInProcess, COMDAT
; _this$ = ecx

; 178  :   virtual void                      Remove_SteamAPI_CPostAPIResultInProcess        (SteamAPI_PostAPIResultInProcess_t  func) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 179  :     return pRealClient->Remove_SteamAPI_CPostAPIResultInProcess        (func);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+128]
?Remove_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z ENDP ; IWrapSteamClient::Remove_SteamAPI_CPostAPIResultInProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?Set_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z
_TEXT	SEGMENT
_func$ = 8						; size = 4
?Set_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z PROC ; IWrapSteamClient::Set_SteamAPI_CPostAPIResultInProcess, COMDAT
; _this$ = ecx

; 176  :   virtual void                      Set_SteamAPI_CPostAPIResultInProcess           (SteamAPI_PostAPIResultInProcess_t  func) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 177  :     return pRealClient->Set_SteamAPI_CPostAPIResultInProcess           (func);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+124]
?Set_SteamAPI_CPostAPIResultInProcess@IWrapSteamClient@@UAEXP6AX_KPAXIH@Z@Z ENDP ; IWrapSteamClient::Set_SteamAPI_CPostAPIResultInProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamHTMLSurface@IWrapSteamClient@@UAEPAVISteamHTMLSurface@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamHTMLSurface@IWrapSteamClient@@UAEPAVISteamHTMLSurface@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamHTMLSurface, COMDAT
; _this$ = ecx

; 173  :   virtual ISteamHTMLSurface        *GetISteamHTMLSurface         (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 174  :     return pRealClient->GetISteamHTMLSurface        (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+120]
?GetISteamHTMLSurface@IWrapSteamClient@@UAEPAVISteamHTMLSurface@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamHTMLSurface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamMusicRemote@IWrapSteamClient@@UAEPAVISteamMusicRemote@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamMusicRemote@IWrapSteamClient@@UAEPAVISteamMusicRemote@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamMusicRemote, COMDAT
; _this$ = ecx

; 171  :   virtual ISteamMusicRemote        *GetISteamMusicRemote         (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 172  :     return pRealClient->GetISteamMusicRemote        (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+116]
?GetISteamMusicRemote@IWrapSteamClient@@UAEPAVISteamMusicRemote@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamMusicRemote
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamMusic@IWrapSteamClient@@UAEPAVISteamMusic@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamMusic@IWrapSteamClient@@UAEPAVISteamMusic@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamMusic, COMDAT
; _this$ = ecx

; 169  :   virtual ISteamMusic              *GetISteamMusic               (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 170  :     return pRealClient->GetISteamMusic              (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+112]
?GetISteamMusic@IWrapSteamClient@@UAEPAVISteamMusic@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamMusic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamAppList@IWrapSteamClient@@UAEPAVISteamAppList@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamAppList@IWrapSteamClient@@UAEPAVISteamAppList@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamAppList, COMDAT
; _this$ = ecx

; 167  :   virtual ISteamAppList            *GetISteamAppList             (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 168  :     return pRealClient->GetISteamAppList            (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+108]
?GetISteamAppList@IWrapSteamClient@@UAEPAVISteamAppList@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamAppList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamUGC@IWrapSteamClient@@UAEPAVISteamUGC@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamUGC@IWrapSteamClient@@UAEPAVISteamUGC@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamUGC, COMDAT
; _this$ = ecx

; 165  :   virtual ISteamUGC                *GetISteamUGC                 (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 166  :     return pRealClient->GetISteamUGC                (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+104]
?GetISteamUGC@IWrapSteamClient@@UAEPAVISteamUGC@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamUGC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamController@IWrapSteamClient@@UAEPAVISteamController@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamController@IWrapSteamClient@@UAEPAVISteamController@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamController, COMDAT
; _this$ = ecx

; 152  :   virtual ISteamController         *GetISteamController          (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 153  : #if 0
; 154  :     return pRealClient->GetISteamController (hSteamUser, hSteamPipe, pchVersion);
; 155  : #else
; 156  :     return SK_SteamWrapper_WrappedClient_GetISteamController (pRealClient, hSteamUser, hSteamPipe, pchVersion);

	push	DWORD PTR _pchVersion$[ebp]
	push	DWORD PTR _hSteamPipe$[ebp]
	push	DWORD PTR _hSteamUser$[ebp]
	push	DWORD PTR [ecx+4]
	call	?SK_SteamWrapper_WrappedClient_GetISteamController@@YAPAVISteamController@@PAVISteamClient@@HHPBD@Z ; SK_SteamWrapper_WrappedClient_GetISteamController
	add	esp, 16					; 00000010H

; 157  : #endif
; 158  :                                                                                                                                                  }

	pop	ebp
	ret	12					; 0000000cH
?GetISteamController@IWrapSteamClient@@UAEPAVISteamController@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamController
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamUnifiedMessages@IWrapSteamClient@@UAEPAVISteamUnifiedMessages@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamUnifiedMessages@IWrapSteamClient@@UAEPAVISteamUnifiedMessages@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamUnifiedMessages, COMDAT
; _this$ = ecx

; 146  :   virtual ISteamUnifiedMessages    *GetISteamUnifiedMessages     (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 147  :     return pRealClient->GetISteamUnifiedMessages    (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+96]
?GetISteamUnifiedMessages@IWrapSteamClient@@UAEPAVISteamUnifiedMessages@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamUnifiedMessages
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamHTTP@IWrapSteamClient@@UAEPAVISteamHTTP@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamHTTP@IWrapSteamClient@@UAEPAVISteamHTTP@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamHTTP, COMDAT
; _this$ = ecx

; 144  :   virtual ISteamHTTP               *GetISteamHTTP                (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 145  :     return pRealClient->GetISteamHTTP               (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+92]
?GetISteamHTTP@IWrapSteamClient@@UAEPAVISteamHTTP@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamHTTP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?BShutdownIfAllPipesClosed@IWrapSteamClient@@UAE_NXZ
_TEXT	SEGMENT
?BShutdownIfAllPipesClosed@IWrapSteamClient@@UAE_NXZ PROC ; IWrapSteamClient::BShutdownIfAllPipesClosed, COMDAT
; _this$ = ecx

; 143  :   virtual bool                      BShutdownIfAllPipesClosed    (void)                                                override { return false;  }

	xor	al, al
	ret	0
?BShutdownIfAllPipesClosed@IWrapSteamClient@@UAE_NXZ ENDP ; IWrapSteamClient::BShutdownIfAllPipesClosed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?SetWarningMessageHook@IWrapSteamClient@@UAEXP6AXHPBD@Z@Z
_TEXT	SEGMENT
_pFunction$ = 8						; size = 4
?SetWarningMessageHook@IWrapSteamClient@@UAEXP6AXHPBD@Z@Z PROC ; IWrapSteamClient::SetWarningMessageHook, COMDAT
; _this$ = ecx

; 141  :   virtual void                      SetWarningMessageHook        (SteamAPIWarningMessageHook_t pFunction)                               override {

	npad	2
	push	ebp
	mov	ebp, esp

; 142  :     return pRealClient->SetWarningMessageHook       (pFunction);                                                                                 }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+84]
?SetWarningMessageHook@IWrapSteamClient@@UAEXP6AXHPBD@Z@Z ENDP ; IWrapSteamClient::SetWarningMessageHook
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetIPCCallCount@IWrapSteamClient@@UAEIXZ
_TEXT	SEGMENT
?GetIPCCallCount@IWrapSteamClient@@UAEIXZ PROC		; IWrapSteamClient::GetIPCCallCount, COMDAT
; _this$ = ecx

; 140  :     return pRealClient->GetIPCCallCount             ();                                                                                          }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+80]
?GetIPCCallCount@IWrapSteamClient@@UAEIXZ ENDP		; IWrapSteamClient::GetIPCCallCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?RunFrame@IWrapSteamClient@@UAEXXZ
_TEXT	SEGMENT
?RunFrame@IWrapSteamClient@@UAEXXZ PROC			; IWrapSteamClient::RunFrame, COMDAT
; _this$ = ecx

; 138  :     return pRealClient->RunFrame                    ();                                                                                          }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+76]
?RunFrame@IWrapSteamClient@@UAEXXZ ENDP			; IWrapSteamClient::RunFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamScreenshots@IWrapSteamClient@@UAEPAVISteamScreenshots@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamScreenshots@IWrapSteamClient@@UAEPAVISteamScreenshots@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamScreenshots, COMDAT
; _this$ = ecx

; 135  :   virtual ISteamScreenshots        *GetISteamScreenshots         (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 136  :     return pRealClient->GetISteamScreenshots        (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+72]
?GetISteamScreenshots@IWrapSteamClient@@UAEPAVISteamScreenshots@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamScreenshots
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamRemoteStorage@IWrapSteamClient@@UAEPAVISteamRemoteStorage@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamRemoteStorage@IWrapSteamClient@@UAEPAVISteamRemoteStorage@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamRemoteStorage, COMDAT
; _this$ = ecx

; 123  :   virtual ISteamRemoteStorage      *GetISteamRemoteStorage       (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 124  : #if 1
; 125  :     return SK_SteamWrapper_WrappedClient_GetISteamRemoteStorage ( pRealClient,

	push	DWORD PTR _pchVersion$[ebp]
	push	DWORD PTR _hSteamPipe$[ebp]
	push	DWORD PTR _hSteamuser$[ebp]
	push	DWORD PTR [ecx+4]
	call	?SK_SteamWrapper_WrappedClient_GetISteamRemoteStorage@@YAPAVISteamRemoteStorage@@PAVISteamClient@@HHPBD@Z ; SK_SteamWrapper_WrappedClient_GetISteamRemoteStorage
	add	esp, 16					; 00000010H

; 126  :                                                                     hSteamuser,
; 127  :                                                                       hSteamPipe,
; 128  :                                                                         pchVersion );
; 129  : #else
; 130  :     return pRealClient->GetISteamRemoteStorage ( hSteamuser,
; 131  :                                                    hSteamPipe,
; 132  :                                                      pchVersion );
; 133  : #endif
; 134  : }

	pop	ebp
	ret	12					; 0000000cH
?GetISteamRemoteStorage@IWrapSteamClient@@UAEPAVISteamRemoteStorage@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamRemoteStorage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamNetworking@IWrapSteamClient@@UAEPAVISteamNetworking@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamNetworking@IWrapSteamClient@@UAEPAVISteamNetworking@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamNetworking, COMDAT
; _this$ = ecx

; 121  :   virtual ISteamNetworking         *GetISteamNetworking          (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 122  :     return pRealClient->GetISteamNetworking         (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+64]
?GetISteamNetworking@IWrapSteamClient@@UAEPAVISteamNetworking@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamNetworking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamApps@IWrapSteamClient@@UAEPAVISteamApps@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamApps@IWrapSteamClient@@UAEPAVISteamApps@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamApps, COMDAT
; _this$ = ecx

; 119  :   virtual ISteamApps               *GetISteamApps                (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 120  :     return pRealClient->GetISteamApps               (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+60]
?GetISteamApps@IWrapSteamClient@@UAEPAVISteamApps@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamApps
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamGameServerStats@IWrapSteamClient@@UAEPAVISteamGameServerStats@@HHPBD@Z
_TEXT	SEGMENT
_hSteamuser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamGameServerStats@IWrapSteamClient@@UAEPAVISteamGameServerStats@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamGameServerStats, COMDAT
; _this$ = ecx

; 117  :   virtual ISteamGameServerStats    *GetISteamGameServerStats     (HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 118  :     return pRealClient->GetISteamGameServerStats    (hSteamuser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+56]
?GetISteamGameServerStats@IWrapSteamClient@@UAEPAVISteamGameServerStats@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamGameServerStats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamUserStats@IWrapSteamClient@@UAEPAVISteamUserStats@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamUserStats@IWrapSteamClient@@UAEPAVISteamUserStats@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamUserStats, COMDAT
; _this$ = ecx

; 115  :   virtual ISteamUserStats          *GetISteamUserStats           (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 116  :     return pRealClient->GetISteamUserStats          (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+52]
?GetISteamUserStats@IWrapSteamClient@@UAEPAVISteamUserStats@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamUserStats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamGenericInterface@IWrapSteamClient@@UAEPAXHHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamGenericInterface@IWrapSteamClient@@UAEPAXHHPBD@Z PROC ; IWrapSteamClient::GetISteamGenericInterface, COMDAT
; _this$ = ecx

; 113  :   virtual void                     *GetISteamGenericInterface    (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 114  :     return pRealClient->GetISteamGenericInterface   (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+48]
?GetISteamGenericInterface@IWrapSteamClient@@UAEPAXHHPBD@Z ENDP ; IWrapSteamClient::GetISteamGenericInterface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamMatchmakingServers@IWrapSteamClient@@UAEPAVISteamMatchmakingServers@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamMatchmakingServers@IWrapSteamClient@@UAEPAVISteamMatchmakingServers@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamMatchmakingServers, COMDAT
; _this$ = ecx

; 111  :   virtual ISteamMatchmakingServers *GetISteamMatchmakingServers  (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 112  :     return pRealClient->GetISteamMatchmakingServers (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+44]
?GetISteamMatchmakingServers@IWrapSteamClient@@UAEPAVISteamMatchmakingServers@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamMatchmakingServers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamMatchmaking@IWrapSteamClient@@UAEPAVISteamMatchmaking@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamMatchmaking@IWrapSteamClient@@UAEPAVISteamMatchmaking@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamMatchmaking, COMDAT
; _this$ = ecx

; 109  :   virtual ISteamMatchmaking        *GetISteamMatchmaking         (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 110  :     return pRealClient->GetISteamMatchmaking        (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+40]
?GetISteamMatchmaking@IWrapSteamClient@@UAEPAVISteamMatchmaking@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamMatchmaking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamUtils@IWrapSteamClient@@UAEPAVISteamUtils@@HPBD@Z
_TEXT	SEGMENT
_hSteamPipe$ = 8					; size = 4
_pchVersion$ = 12					; size = 4
?GetISteamUtils@IWrapSteamClient@@UAEPAVISteamUtils@@HPBD@Z PROC ; IWrapSteamClient::GetISteamUtils, COMDAT
; _this$ = ecx

; 99   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 100  : #if 1
; 101  :     return SK_SteamWrapper_WrappedClient_GetISteamUtils ( pRealClient,

	push	DWORD PTR _pchVersion$[ebp]
	push	DWORD PTR _hSteamPipe$[ebp]
	push	DWORD PTR [ecx+4]
	call	?SK_SteamWrapper_WrappedClient_GetISteamUtils@@YAPAVISteamUtils@@PAVISteamClient@@HPBD@Z ; SK_SteamWrapper_WrappedClient_GetISteamUtils
	add	esp, 12					; 0000000cH

; 102  :                                                             hSteamPipe,
; 103  :                                                               pchVersion );                                                                      
; 104  : #else
; 105  :     return pRealClient->GetISteamUtils ( hSteamPipe,
; 106  :                                            pchVersion );
; 107  : #endif
; 108  : }

	pop	ebp
	ret	8
?GetISteamUtils@IWrapSteamClient@@UAEPAVISteamUtils@@HPBD@Z ENDP ; IWrapSteamClient::GetISteamUtils
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamFriends@IWrapSteamClient@@UAEPAVISteamFriends@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamFriends@IWrapSteamClient@@UAEPAVISteamFriends@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamFriends, COMDAT
; _this$ = ecx

; 96   :   virtual ISteamFriends            *GetISteamFriends             (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :     return pRealClient->GetISteamFriends            (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+32]
?GetISteamFriends@IWrapSteamClient@@UAEPAVISteamFriends@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamFriends
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?SetLocalIPBinding@IWrapSteamClient@@UAEXIG@Z
_TEXT	SEGMENT
_unIP$ = 8						; size = 4
_usPort$ = 12						; size = 2
?SetLocalIPBinding@IWrapSteamClient@@UAEXIG@Z PROC	; IWrapSteamClient::SetLocalIPBinding, COMDAT
; _this$ = ecx

; 94   :   virtual void                      SetLocalIPBinding            (uint32 unIP, uint16 usPort)                                           override {

	npad	2
	push	ebp
	mov	ebp, esp

; 95   :     return pRealClient->SetLocalIPBinding           (unIP, usPort);                                                                              }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+28]
?SetLocalIPBinding@IWrapSteamClient@@UAEXIG@Z ENDP	; IWrapSteamClient::SetLocalIPBinding
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamGameServer@IWrapSteamClient@@UAEPAVISteamGameServer@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamGameServer@IWrapSteamClient@@UAEPAVISteamGameServer@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamGameServer, COMDAT
; _this$ = ecx

; 92   :   virtual ISteamGameServer         *GetISteamGameServer          (HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) override {

	npad	2
	push	ebp
	mov	ebp, esp

; 93   :     return pRealClient->GetISteamGameServer         (hSteamUser, hSteamPipe, pchVersion);                                                        }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+24]
?GetISteamGameServer@IWrapSteamClient@@UAEPAVISteamGameServer@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamGameServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?GetISteamUser@IWrapSteamClient@@UAEPAVISteamUser@@HHPBD@Z
_TEXT	SEGMENT
_hSteamUser$ = 8					; size = 4
_hSteamPipe$ = 12					; size = 4
_pchVersion$ = 16					; size = 4
?GetISteamUser@IWrapSteamClient@@UAEPAVISteamUser@@HHPBD@Z PROC ; IWrapSteamClient::GetISteamUser, COMDAT
; _this$ = ecx

; 77   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 78   : #if 1
; 79   :     return SK_SteamWrapper_WrappedClient_GetISteamUser ( pRealClient,

	push	DWORD PTR _pchVersion$[ebp]
	push	DWORD PTR _hSteamPipe$[ebp]
	push	DWORD PTR _hSteamUser$[ebp]
	push	DWORD PTR [ecx+4]
	call	?SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ; SK_SteamWrapper_WrappedClient_GetISteamUser
	add	esp, 16					; 00000010H

; 80   :                                                            hSteamUser,
; 81   :                                                              hSteamPipe,
; 82   :                                                                pchVersion );
; 83   : #else
; 84   :     return pRealClient->GetISteamUser ( hSteamUser,
; 85   :                                           hSteamPipe,
; 86   :                                             pchVersion );
; 87   : #endif
; 88   :   }

	pop	ebp
	ret	12					; 0000000cH
?GetISteamUser@IWrapSteamClient@@UAEPAVISteamUser@@HHPBD@Z ENDP ; IWrapSteamClient::GetISteamUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?ReleaseUser@IWrapSteamClient@@UAEXHH@Z
_TEXT	SEGMENT
_hSteamPipe$ = 8					; size = 4
_hUser$ = 12						; size = 4
?ReleaseUser@IWrapSteamClient@@UAEXHH@Z PROC		; IWrapSteamClient::ReleaseUser, COMDAT
; _this$ = ecx

; 70   :   virtual void       ReleaseUser         (HSteamPipe   hSteamPipe, HSteamUser hUser)          override { return pRealClient->ReleaseUser         (hSteamPipe,  hUser);        }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+16]
?ReleaseUser@IWrapSteamClient@@UAEXHH@Z ENDP		; IWrapSteamClient::ReleaseUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?CreateLocalUser@IWrapSteamClient@@UAEHPAHW4EAccountType@@@Z
_TEXT	SEGMENT
_phSteamPipe$ = 8					; size = 4
_eAccountType$ = 12					; size = 4
?CreateLocalUser@IWrapSteamClient@@UAEHPAHW4EAccountType@@@Z PROC ; IWrapSteamClient::CreateLocalUser, COMDAT
; _this$ = ecx

; 69   :   virtual HSteamUser CreateLocalUser     (HSteamPipe *phSteamPipe, EAccountType eAccountType) override { return pRealClient->CreateLocalUser     (phSteamPipe, eAccountType); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+12]
?CreateLocalUser@IWrapSteamClient@@UAEHPAHW4EAccountType@@@Z ENDP ; IWrapSteamClient::CreateLocalUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?ConnectToGlobalUser@IWrapSteamClient@@UAEHH@Z
_TEXT	SEGMENT
_hSteamPipe$ = 8					; size = 4
?ConnectToGlobalUser@IWrapSteamClient@@UAEHH@Z PROC	; IWrapSteamClient::ConnectToGlobalUser, COMDAT
; _this$ = ecx

; 68   :   virtual HSteamUser ConnectToGlobalUser (HSteamPipe   hSteamPipe)                            override { return pRealClient->ConnectToGlobalUser (hSteamPipe);                }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+8]
?ConnectToGlobalUser@IWrapSteamClient@@UAEHH@Z ENDP	; IWrapSteamClient::ConnectToGlobalUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?BReleaseSteamPipe@IWrapSteamClient@@UAE_NH@Z
_TEXT	SEGMENT
_hSteamPipe$ = 8					; size = 4
?BReleaseSteamPipe@IWrapSteamClient@@UAE_NH@Z PROC	; IWrapSteamClient::BReleaseSteamPipe, COMDAT
; _this$ = ecx

; 67   :   virtual bool       BReleaseSteamPipe   (HSteamPipe   hSteamPipe)                            override { return pRealClient->BReleaseSteamPipe   (hSteamPipe);                }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	pop	ebp
	jmp	eax
?BReleaseSteamPipe@IWrapSteamClient@@UAE_NH@Z ENDP	; IWrapSteamClient::BReleaseSteamPipe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?CreateSteamPipe@IWrapSteamClient@@UAEHXZ
_TEXT	SEGMENT
?CreateSteamPipe@IWrapSteamClient@@UAEHXZ PROC		; IWrapSteamClient::CreateSteamPipe, COMDAT
; _this$ = ecx

; 66   :   virtual HSteamPipe CreateSteamPipe     (void)                                               override { return pRealClient->CreateSteamPipe     (          );                }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax]
?CreateSteamPipe@IWrapSteamClient@@UAEHXZ ENDP		; IWrapSteamClient::CreateSteamPipe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ??0IWrapSteamClient@@QAE@PAVISteamClient@@@Z
_TEXT	SEGMENT
_pSteamClient$ = 8					; size = 4
??0IWrapSteamClient@@QAE@PAVISteamClient@@@Z PROC	; IWrapSteamClient::IWrapSteamClient, COMDAT
; _this$ = ecx

; 63   :                      pRealClient (pSteamClient) {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pSteamClient$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 64   :   };

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7IWrapSteamClient@@6B@
	pop	ebp
	ret	4
??0IWrapSteamClient@@QAE@PAVISteamClient@@@Z ENDP	; IWrapSteamClient::IWrapSteamClient
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FSK_SteamWrapper_remap_client@@YAXXZ
text$yd	SEGMENT
??__FSK_SteamWrapper_remap_client@@YAXXZ PROC		; `dynamic atexit destructor for 'SK_SteamWrapper_remap_client'', COMDAT
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	jmp	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
??__FSK_SteamWrapper_remap_client@@YAXXZ ENDP		; `dynamic atexit destructor for 'SK_SteamWrapper_remap_client''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ??__ESK_SteamWrapper_remap_client@@YAXXZ
text$di	SEGMENT
__Index$2 = -20						; size = 4
$T3 = -18						; size = 2
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??__ESK_SteamWrapper_remap_client@@YAXXZ PROC		; `dynamic initializer for 'SK_SteamWrapper_remap_client'', COMDAT

; 29   :        concurrency::concurrent_unordered_map <ISteamClient*,        IWrapSteamClient*>        SK_SteamWrapper_remap_client;

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 252  :         : _Mybase(_Number_of_buckets, _Key_compare(_Hasher, _Key_equality), _Allocator)

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 29   :        concurrency::concurrent_unordered_map <ISteamClient*,        IWrapSteamClient*>        SK_SteamWrapper_remap_client;

	push	-1
	push	__ehhandler$??__ESK_SteamWrapper_remap_client@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 252  :         : _Mybase(_Number_of_buckets, _Key_compare(_Hasher, _Key_equality), _Allocator)

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 29   :        concurrency::concurrent_unordered_map <ISteamClient*,        IWrapSteamClient*>        SK_SteamWrapper_remap_client;

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 252  :         : _Mybase(_Number_of_buckets, _Key_compare(_Hasher, _Key_equality), _Allocator)

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	push	8
	call	??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 846  :         if (_Current_buckets > _Buckets)

	cmp	DWORD PTR ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A+148, 8
	ja	SHORT $LN11@dynamic

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, 15					; 0000000fH
	mov	DWORD PTR __Index$2[ebp], 0
	bsr	eax, eax
	mov	DWORD PTR __Index$2[ebp], eax

; 855  :         _M_number_of_buckets = ((size_type) 1) << _Get_msb(_Buckets*2-1);

	mov	eax, 1
	mov	cl, BYTE PTR __Index$2[ebp]
	shl	eax, cl
	mov	DWORD PTR ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A+148, eax
$LN11@dynamic:
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp

; 29   :        concurrency::concurrent_unordered_map <ISteamClient*,        IWrapSteamClient*>        SK_SteamWrapper_remap_client;

	push	OFFSET ??__FSK_SteamWrapper_remap_client@@YAXXZ ; `dynamic atexit destructor for 'SK_SteamWrapper_remap_client''
	call	_atexit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__ESK_SteamWrapper_remap_client@@YAXXZ$1:
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_client@@3V?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_client
	jmp	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
__ehhandler$??__ESK_SteamWrapper_remap_client@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__ESK_SteamWrapper_remap_client@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__ESK_SteamWrapper_remap_client@@YAXXZ ENDP		; `dynamic initializer for 'SK_SteamWrapper_remap_client''
; Function compile flags: /Ogtp
;	COMDAT ??1?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@XZ
_TEXT	SEGMENT
??1?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@XZ PROC ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >, COMDAT
; _this$ = ecx
	jmp	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
??1?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@XZ ENDP ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??A?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAEAAPAVIWrapSteamClient@@ABQAVISteamClient@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
__Where$ = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAEAAPAVIWrapSteamClient@@ABQAVISteamClient@@@Z PROC ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::operator[], COMDAT
; _this$ = ecx

; 713  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	mov	edi, DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 713  :     {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN47@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	push	eax
	call	??$_Insert@U?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamClient@@PAVIWrapSteamClient@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Insert<std::pair<ISteamClient *,IWrapSteamClient *> >
	mov	eax, DWORD PTR [eax]
$LN47@operator:

; 719  :         }
; 720  : 
; 721  :         return ((*_Where).second);

	pop	edi
	add	eax, 8
	pop	esi

; 722  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAEAAPAVIWrapSteamClient@@ABQAVISteamClient@@@Z ENDP ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Number_of_buckets$ = 8				; size = 4
__Hasher$ = 12						; size = 4
__Key_equality$ = 16					; size = 4
__Allocator$ = 20					; size = 4
$T2 = 22						; size = 2
??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z PROC ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >, COMDAT
; _this$ = ecx

; 253  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	edi
	mov	edi, ecx
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _this$[ebp], edi
	push	DWORD PTR __Allocator$[ebp]
	push	eax
	push	DWORD PTR __Number_of_buckets$[ebp]
	call	??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >

; 254  :         this->rehash(_Number_of_buckets);

	push	DWORD PTR __Number_of_buckets$[ebp]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::rehash

; 255  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
__ehhandler$??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$concurrent_unordered_map@PAVISteamClient@@PAVIWrapSteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamClient@@@std@@ABU?$equal_to@PAVISteamClient@@@3@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@3@@Z ENDP ; Concurrency::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::concurrent_unordered_map<ISteamClient *,IWrapSteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Split_order_dummy_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z
_TEXT	SEGMENT
__Reversed_order_key$1 = -8				; size = 4
__Order_key$ = 8					; size = 4
?_Split_order_dummy_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Split_order_dummy_key, COMDAT
; _this$ = ecx

; 1301 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	edx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	ecx, DWORD PTR __Order_key$[ebp]
	movzx	eax, cl

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, ch

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], al

; 1302 :         return _Reverse(_Order_key) & ~(0x1);

	mov	eax, DWORD PTR __Reversed_order_key$1[ebp]
	and	eax, -2					; fffffffeH

; 1303 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Split_order_dummy_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Split_order_dummy_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Split_order_regular_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z
_TEXT	SEGMENT
__Reversed_order_key$1 = -8				; size = 4
__Order_key$ = 8					; size = 4
?_Split_order_regular_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Split_order_regular_key, COMDAT
; _this$ = ecx

; 1295 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	edx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	ecx, DWORD PTR __Order_key$[ebp]
	movzx	eax, cl

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, ch

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], al

; 1296 :         return _Reverse(_Order_key) | 0x1;

	mov	eax, DWORD PTR __Reversed_order_key$1[ebp]
	or	eax, 1

; 1297 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Split_order_regular_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Split_order_regular_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Reverse@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z
_TEXT	SEGMENT
__Reversed_order_key$ = -8				; size = 4
__Order_key$ = 8					; size = 4
?_Reverse@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Reverse, COMDAT
; _this$ = ecx

; 1278 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	edx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	ecx, DWORD PTR __Order_key$[ebp]
	movzx	eax, cl

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, ch

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+2]

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+3]

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$[ebp], al

; 1288 :         }
; 1289 : 
; 1290 :         return _Reversed_order_key;

	mov	eax, DWORD PTR __Reversed_order_key$[ebp]

; 1291 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Reverse@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Reverse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Is_initialized@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE_NI@Z
_TEXT	SEGMENT
__Index$1 = -4						; size = 4
__Bucket$ = 8						; size = 4
?_Is_initialized@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE_NI@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Is_initialized, COMDAT
; _this$ = ecx

; 1263 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	edx, DWORD PTR __Bucket$[ebp]
	mov	eax, edx
	or	eax, 1

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$1[ebp], 0

; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	push	esi

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	esi, al
	push	edi

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$1[ebp], eax

; 1264 :         size_type _Segment = _Segment_index_of(_Bucket);
; 1265 :         _Bucket -= _Segment_base(_Segment);
; 1266 : 
; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	edi, DWORD PTR [ecx+esi*4+4]
	test	edi, edi
	jne	SHORT $LN2@Is_initial

; 1268 :         {
; 1269 :             return false;

	pop	edi
	xor	al, al
	pop	esi

; 1274 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@Is_initial:

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	ecx, esi
	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1270 :         }
; 1271 : 
; 1272 :         _Full_iterator _Iterator = _M_buckets[_Segment][_Bucket];
; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	edx, eax
	cmp	DWORD PTR [edi+edx*4], 0
	pop	edi
	setne	al
	pop	esi

; 1274 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Is_initialized@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE_NI@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Is_initialized
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z
_TEXT	SEGMENT
__New_segment$1$ = -8					; size = 4
_this$1$ = -8						; size = 4
__Index$1 = -4						; size = 4
__Bucket$ = 8						; size = 4
__Wrapped_allocator$2 = 11				; size = 1
$T3 = 12						; size = 1
__Dummy_head$ = 12					; size = 4
?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Set_bucket, COMDAT
; _this$ = ecx

; 1244 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	esi, DWORD PTR __Bucket$[ebp]

; 1244 :     {

	mov	ebx, ecx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, esi

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$1[ebp], 0

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	or	eax, 1

; 1244 :     {

	mov	DWORD PTR _this$1$[ebp], ebx

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	edx, 1

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	edx, cl

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$1[ebp], eax

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, edx
	push	edi
	and	eax, -2					; fffffffeH

; 1245 :         size_type _Segment = _Segment_index_of(_Bucket);
; 1246 :         _Bucket -= _Segment_base(_Segment);
; 1247 : 
; 1248 :         if (_M_buckets[_Segment] == NULL)

	lea	edi, DWORD PTR [ecx+1]
	lea	edi, DWORD PTR [ebx+edi*4]
	sub	esi, eax
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN20@Set_bucket

; 198  :         return _K ? size_type(1)<<_K : 2;

	test	ecx, ecx
	mov	ebx, 2

; 1251 :             _Full_iterator * _New_segment = _M_allocator.allocate(_Seg_size);

	mov	ecx, DWORD PTR _this$1$[ebp]

; 198  :         return _K ? size_type(1)<<_K : 2;

	cmovne	ebx, edx

; 1251 :             _Full_iterator * _New_segment = _M_allocator.allocate(_Seg_size);

	add	ecx, 144				; 00000090H
	push	ebx
	call	?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@2@I@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > >::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T3[ebp]
	lea	ecx, DWORD PTR __Wrapped_allocator$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1251 :             _Full_iterator * _New_segment = _M_allocator.allocate(_Seg_size);

	mov	DWORD PTR __New_segment$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
	push	ebx
	push	eax
	call	??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > > > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1254 :             if (_InterlockedCompareExchangePointer((void * volatile *) &_M_buckets[_Segment], _New_segment, NULL) != NULL)

	mov	edx, DWORD PTR __New_segment$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1254 :             if (_InterlockedCompareExchangePointer((void * volatile *) &_M_buckets[_Segment], _New_segment, NULL) != NULL)

	mov	ecx, edx
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edi], ecx
	test	eax, eax
	je	SHORT $LN20@Set_bucket
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	ebx
	push	edx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN20@Set_bucket:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1259 :         _M_buckets[_Segment][_Bucket] = _Dummy_head;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR __Dummy_head$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+esi*4], eax
	pop	esi
	pop	ebx

; 1260 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Set_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Get_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@I@Z
_TEXT	SEGMENT
__Index$1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Get_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@I@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Get_bucket, COMDAT
; _this$ = ecx

; 1237 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	edx, DWORD PTR __Bucket$[ebp]
	mov	eax, edx
	or	eax, 1

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$1[ebp], 0

; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	push	esi

; 1237 :     {

	mov	esi, ecx

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$1[ebp], eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1238 :         size_type _Segment = _Segment_index_of(_Bucket);
; 1239 :         _Bucket -= _Segment_base(_Segment);
; 1240 :         return _M_buckets[_Segment][_Bucket];

	sub	edx, eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
	pop	esi
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1241 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Get_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@I@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Get_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Get_parent@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z
_TEXT	SEGMENT
__Index$1 = -4						; size = 4
__Bucket$ = 8						; size = 4
?_Get_parent@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Get_parent, COMDAT
; _this$ = ecx

; 1229 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, DWORD PTR __Bucket$[ebp]
	bsr	ecx, eax
	mov	DWORD PTR __Index$1[ebp], 0
	mov	DWORD PTR __Index$1[ebp], ecx

; 1230 :         // Unsets bucket's most significant turned-on bit
; 1231 :         unsigned char _Msb = _Get_msb(_Bucket);
; 1232 :         return _Bucket & ~(1 << _Msb);

	movzx	ecx, cl
	btr	eax, ecx

; 1233 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Get_parent@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Get_parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Adjust_table_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXII@Z
_TEXT	SEGMENT
__Total_elements$ = 8					; size = 4
__Current_size$ = 12					; size = 4
?_Adjust_table_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Adjust_table_size, COMDAT
; _this$ = ecx

; 1219 :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 1220 :         // Grow the table by a factor of 2 if possible and needed
; 1221 :         if (((float) _Total_elements / (float) _Current_size) > _M_maximum_bucket_size)

	mov	eax, DWORD PTR __Total_elements$[ebp]
	push	esi
	mov	esi, DWORD PTR __Current_size$[ebp]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, esi
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm1, xmm0
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	comiss	xmm1, DWORD PTR [ecx+152]
	jbe	SHORT $LN2@Adjust_tab

; 1222 :         {
; 1223 :              // Double the size of the hash only if size has not changed inbetween loads
; 1224 :             _InterlockedCompareExchangeSizeT(&_M_number_of_buckets, 2 * _Current_size, _Current_size);

	lea	edx, DWORD PTR [esi+esi]
	add	ecx, 148				; 00000094H
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [ecx], edx
$LN2@Adjust_tab:
	pop	esi

; 1225 :         }
; 1226 :     }

	pop	ebp
	ret	8
?_Adjust_table_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Adjust_table_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z
_TEXT	SEGMENT
__Reversed_order_key$1 = -12				; size = 4
tv569 = -8						; size = 4
tv570 = -4						; size = 4
__Index$2 = -4						; size = 4
__Index$3 = -4						; size = 4
__Index$4 = -4						; size = 4
__Dummy_node$ = 8					; size = 4
__Bucket$ = 8						; size = 4
?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Initialize_bucket, COMDAT
; _this$ = ecx

; 1195 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1196 :         // Bucket 0 has no parent. Initialize it and return.
; 1197 :         if (_Bucket == 0)

	mov	ebx, DWORD PTR __Bucket$[ebp]
	push	esi
	mov	esi, ecx
	test	ebx, ebx
	jne	SHORT $LN2@Initialize

; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	push	128					; 00000080H
	lea	eax, DWORD PTR [esi+4]
	push	ebx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 941  : 
; 942  :         // Insert the first element in the split-ordered list
; 943  :         _Full_iterator _Dummy_node = _M_split_ordered_list._Begin();
; 944  :         _Set_bucket(0, _Dummy_node);

	mov	ecx, esi
	push	DWORD PTR [esi+132]
	push	ebx
	call	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Set_bucket
	pop	esi
	pop	ebx

; 1216 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@Initialize:

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, ebx
	mov	DWORD PTR __Index$4[ebp], 0
	mov	DWORD PTR __Index$4[ebp], eax

; 1198 :         {
; 1199 :             _Init();
; 1200 :             return;
; 1201 :         }
; 1202 : 
; 1203 :         size_type _Parent_bucket = _Get_parent(_Bucket);

	movzx	eax, al
	push	edi

; 1232 :         return _Bucket & ~(1 << _Msb);

	mov	edi, ebx

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$3[ebp], 0

; 1232 :         return _Bucket & ~(1 << _Msb);

	btr	edi, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, edi
	or	eax, 1
	mov	DWORD PTR tv569[ebp], eax

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$3[ebp], eax

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	eax, DWORD PTR [esi+ecx*4+4]
	test	eax, eax
	je	SHORT $LN57@Initialize

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	edx, 1

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	eax, edi

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	edx, cl

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	ecx, DWORD PTR [esi+ecx*4+4]

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	and	edx, -2					; fffffffeH

; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	eax, edx
	cmp	DWORD PTR [ecx+eax*4], 0
	setne	al

; 1204 : 
; 1205 :         // All _Parent_bucket buckets have to be initialized before this bucket is
; 1206 :         if (!_Is_initialized(_Parent_bucket))

	test	al, al
	jne	SHORT $LN3@Initialize
$LN57@Initialize:

; 1207 :         {
; 1208 :             _Initialize_bucket(_Parent_bucket);

	push	edi
	mov	ecx, esi
	call	?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Initialize_bucket
$LN3@Initialize:

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, DWORD PTR tv569[ebp]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	edx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	mov	DWORD PTR __Index$2[ebp], 0

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$2[ebp], eax

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1240 :         return _M_buckets[_Segment][_Bucket];

	sub	edi, eax
	mov	eax, DWORD PTR [esi+ecx*4+4]

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, bl

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	ecx, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], cl

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, bh

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	ecx, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], cl

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, BYTE PTR __Bucket$[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	ecx, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], cl

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, BYTE PTR __Bucket$[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	ecx, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], cl

; 1302 :         return _Reverse(_Order_key) & ~(0x1);

	mov	ecx, DWORD PTR __Reversed_order_key$1[ebp]
	and	ecx, -2					; fffffffeH

; 1209 :         }
; 1210 : 
; 1211 :         _Full_iterator _Parent = _Get_bucket(_Parent_bucket);
; 1212 : 
; 1213 :         // Create a dummy first node in this bucket
; 1214 :         _Full_iterator _Dummy_node = _M_split_ordered_list._Insert_dummy(_Parent, _Split_order_dummy_key(_Bucket));

	push	ecx
	push	DWORD PTR [eax+edi*4]
	lea	eax, DWORD PTR __Dummy_node$[ebp]
	push	eax
	lea	ecx, DWORD PTR [esi+132]
	call	?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert_dummy

; 1215 :         _Set_bucket(_Bucket, _Dummy_node);

	push	DWORD PTR __Dummy_node$[ebp]
	mov	ecx, esi
	push	ebx
	call	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Set_bucket
	pop	edi
	pop	esi
	pop	ebx

; 1216 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Initialize_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
__Reversed_order_key$1 = -12				; size = 4
__Index$2 = -8						; size = 4
__Index$3 = -8						; size = 4
__Index$4 = -8						; size = 4
__Val$5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find, COMDAT
; _this$ = ecx

; 1037 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	ebx, DWORD PTR __Keyval$[ebp]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1037 :     {

	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ebx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [ebx+1]
	push	edi

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	edx, eax
	movzx	eax, BYTE PTR [ebx+2]

; 347  : 		_Val *= _FNV_prime;

	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [ebx+3]
	imul	ecx, edx, 16777619
	mov	ebx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1039 :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	ecx, eax

; 347  : 		_Val *= _FNV_prime;

	imul	eax, ecx, 16777619
	mov	DWORD PTR __Val$5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1039 :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	div	DWORD PTR [esi+148]
	npad	11
$LL2@Find:

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, edx

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$4[ebp], 0

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	or	eax, 1

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$4[ebp], eax

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	edi, DWORD PTR [esi+ecx*4+4]
	test	edi, edi
	je	SHORT $LN156@Find

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	esi, ebx

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	eax, edx

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	esi, cl
	and	esi, -2					; fffffffeH

; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	eax, esi
	cmp	DWORD PTR [edi+eax*4], 0
	setne	al

; 1040 : 
; 1041 :         // If _Bucket has not been initialized, keep searching up for a parent bucket
; 1042 :         // that has been initialized.  Worst case is the entire map will be read.
; 1043 :         while (!_Is_initialized(_Bucket))

	test	al, al
	jne	SHORT $LN3@Find
	mov	esi, DWORD PTR _this$1$[ebp]
$LN156@Find:

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, edx
	mov	DWORD PTR __Index$3[ebp], 0
	mov	DWORD PTR __Index$3[ebp], eax

; 1044 :         {
; 1045 :             _Bucket = _Get_parent(_Bucket);

	movzx	eax, al

; 1232 :         return _Bucket & ~(1 << _Msb);

	btr	edx, eax

; 1046 :         }

	jmp	SHORT $LL2@Find
$LN3@Find:

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	ecx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	ebx, DWORD PTR __Val$5[ebp]
	movzx	eax, bl

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$2[ebp], 0
	pop	edi

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, bh

; 1051 :         for (_Full_const_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	mov	ebx, DWORD PTR __Keyval$[ebp]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$5[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$5[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], al

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, edx

; 1296 :         return _Reverse(_Order_key) | 0x1;

	mov	esi, DWORD PTR __Reversed_order_key$1[ebp]

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	or	eax, 1

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 1296 :         return _Reverse(_Order_key) | 0x1;

	or	esi, 1

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$2[ebp], eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1051 :         for (_Full_const_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	sub	edx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	mov	eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1051 :         for (_Full_const_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	je	SHORT $LN5@Find
$LL6@Find:

; 1052 :         {
; 1053 :             if (_Mylist::_Get_key(_Iterator) > _Order_key)

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, esi
	ja	SHORT $LN5@Find

; 1054 :             {
; 1055 :                 // If the order key is smaller than the current order key, the element
; 1056 :                 // is not in the hash.
; 1057 :                 return end();
; 1058 :             }
; 1059 :             else if (_Mylist::_Get_key(_Iterator) == _Order_key)

	jne	SHORT $LN4@Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1064 :                 if (!this->_M_comparator(this->_Key_function(*_Iterator), _Keyval))

	je	SHORT $LN134@Find
$LN4@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1051 :         for (_Full_const_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	jne	SHORT $LL6@Find
$LN5@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1072 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN134@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1066 :                     return _M_split_ordered_list._Get_iterator(_Iterator);

	mov	eax, ecx

; 1072 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z
_TEXT	SEGMENT
tv686 = -12						; size = 4
__Reversed_order_key$1 = -8				; size = 4
tv688 = -4						; size = 4
__Index$2 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Index$3 = 12						; size = 4
__Val$4 = 12						; size = 4
__Keyval$ = 12						; size = 4
?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find, COMDAT
; _this$ = ecx

; 999  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	esi, DWORD PTR __Keyval$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 999  :     {

	mov	ebx, ecx
	push	edi

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [esi]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [esi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+2]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+3]
	imul	ecx, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1001 :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	ecx, eax

; 347  : 		_Val *= _FNV_prime;

	imul	eax, ecx, 16777619
	mov	DWORD PTR __Val$4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1001 :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	div	DWORD PTR [ebx+148]
	mov	edi, edx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, edi
	or	eax, 1
	mov	DWORD PTR tv686[ebp], eax

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$2[ebp], eax

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	eax, DWORD PTR [ebx+ecx*4+4]
	test	eax, eax
	je	SHORT $LN160@Find

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	edx, 1

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	eax, edi

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	edx, cl

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	ecx, DWORD PTR [ebx+ecx*4+4]

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	and	edx, -2					; fffffffeH

; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	eax, edx
	cmp	DWORD PTR [ecx+eax*4], 0
	setne	al

; 1002 : 
; 1003 :         // If _Bucket is empty, initialize it first
; 1004 :         if (!_Is_initialized(_Bucket))

	test	al, al
	jne	SHORT $LN5@Find
$LN160@Find:

; 1005 :         {
; 1006 :             _Initialize_bucket(_Bucket);

	push	edi
	mov	ecx, ebx
	call	?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Initialize_bucket
$LN5@Find:

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	edx, DWORD PTR __Val$4[ebp]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	ecx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, dl

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, dh

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$4[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$4[ebp+3]

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$3[ebp], 0

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, DWORD PTR tv686[ebp]
	bsr	eax, eax

; 1296 :         return _Reverse(_Order_key) | 0x1;

	mov	edx, DWORD PTR __Reversed_order_key$1[ebp]

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$3[ebp], eax

; 1296 :         return _Reverse(_Order_key) | 0x1;

	or	edx, 1

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1240 :         return _M_buckets[_Segment][_Bucket];

	sub	edi, eax
	mov	eax, DWORD PTR [ebx+ecx*4+4]
	mov	eax, DWORD PTR [eax+edi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1012 :         for (_Full_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	je	SHORT $LN3@Find
$LL4@Find:

; 1013 :         {
; 1014 :             if (_Mylist::_Get_key(_Iterator) > _Order_key)

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	ja	SHORT $LN3@Find

; 1015 :             {
; 1016 :                 // If the order key is smaller than the current order key, the element
; 1017 :                 // is not in the hash.
; 1018 :                 return end();
; 1019 :             }
; 1020 :             else if (_Mylist::_Get_key(_Iterator) == _Order_key)

	jne	SHORT $LN2@Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1025 :                 if (!this->_M_comparator(this->_Key_function(*_Iterator), _Keyval))

	je	SHORT $LN140@Find
$LN2@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1012 :         for (_Full_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	jne	SHORT $LL4@Find
$LN3@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1033 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN140@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1027 :                     return _M_split_ordered_list._Get_iterator(_Iterator);

	mov	eax, ecx

; 1033 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Init@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXXZ
_TEXT	SEGMENT
?_Init@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXXZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 938  :     {

	npad	2
	push	esi
	mov	esi, ecx

; 939  :         // Allocate an array of segment pointers
; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	push	128					; 00000080H
	push	0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 941  : 
; 942  :         // Insert the first element in the split-ordered list
; 943  :         _Full_iterator _Dummy_node = _M_split_ordered_list._Begin();
; 944  :         _Set_bucket(0, _Dummy_node);

	mov	ecx, esi
	push	DWORD PTR [esi+132]
	push	0
	call	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Set_bucket
	pop	esi

; 945  :     }

	ret	0
?_Init@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXXZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -12						; size = 12
__Index$2 = 8						; size = 4
__Buckets$ = 8						; size = 4
?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::rehash, COMDAT
; _this$ = ecx

; 843  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 844  :         size_type _Current_buckets = _M_number_of_buckets;
; 845  : 
; 846  :         if (_Current_buckets > _Buckets)

	mov	edx, DWORD PTR __Buckets$[ebp]
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+148], edx
	ja	SHORT $LN1@rehash

; 847  :         {
; 848  :             return;
; 849  :         }
; 850  :         else if (_Buckets <= 0 || _Buckets > unsafe_max_bucket_count())

	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 2147483647				; 7fffffffH
	ja	SHORT $LN16@rehash

; 853  :         }
; 854  :         // Round up the number of buckets to the next largest power of 2
; 855  :         _M_number_of_buckets = ((size_type) 1) << _Get_msb(_Buckets*2-1);

	lea	eax, DWORD PTR [edx*2-1]

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$2[ebp], 0

; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	mov	DWORD PTR __Index$2[ebp], eax

; 853  :         }
; 854  :         // Round up the number of buckets to the next largest power of 2
; 855  :         _M_number_of_buckets = ((size_type) 1) << _Get_msb(_Buckets*2-1);

	mov	eax, 1
	mov	cl, BYTE PTR __Index$2[ebp]
	shl	eax, cl
	mov	DWORD PTR [esi+148], eax
$LN1@rehash:
	pop	esi

; 856  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN16@rehash:

; 851  :         {
; 852  :             throw std::out_of_range("invalid number of buckets");

	push	OFFSET ??_C@_0BK@KDCGEAPC@invalid?5number?5of?5buckets?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0out_of_range@std@@QAE@PBD@Z		; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN17@rehash:
$LN15@rehash:
	int	3
?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::rehash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?unsafe_max_bucket_count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIXZ
_TEXT	SEGMENT
?unsafe_max_bucket_count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIXZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::unsafe_max_bucket_count, COMDAT
; _this$ = ecx

; 577  :         return _Segment_size(_Pointers_per_table-1);

	mov	eax, -2147483648			; 80000000H

; 578  :     }

	ret	0
?unsafe_max_bucket_count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIXZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::unsafe_max_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamClient@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__Keyval$ = 8						; size = 4
?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamClient@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::count, COMDAT
; _this$ = ecx

; 506  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 507  :         size_type _Count = 0;
; 508  :         const_iterator _It = _Find(_Keyval);

	mov	esi, DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __It$[ebp]
	push	edi
	push	esi
	push	eax
	xor	edi, edi
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __It$[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 509  :         for (;_It != end() && !this->_M_comparator(this->_Key_function(*_It), _Keyval); _It++)

	je	SHORT $LN72@count
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	edx, DWORD PTR [esi]
	npad	1
$LL8@count:
	cmp	DWORD PTR [eax+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 509  :         for (;_It != end() && !this->_M_comparator(this->_Key_function(*_It), _Keyval); _It++)

	jne	SHORT $LN72@count

; 510  :         {
; 511  :             _Count++;

	inc	edi
$LL15@count:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 80   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	eax, eax
	je	SHORT $LN72@count
	mov	cl, BYTE PTR [eax+12]
	not	cl
	test	cl, 1
	jne	SHORT $LL15@count
	mov	cl, BYTE PTR [eax+12]
	not	cl

; 92   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	cl, 1
	jne	SHORT $LL15@count
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 509  :         for (;_It != end() && !this->_M_comparator(this->_Key_function(*_It), _Keyval); _It++)

	jmp	SHORT $LL8@count
$LN72@count:

; 512  :         }
; 513  :         return _Count;

	mov	eax, edi
	pop	edi
	pop	esi

; 514  :     }

	pop	ebp
	ret	4
?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamClient@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::find, COMDAT
; _this$ = ecx

; 475  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 476  :         return _Find(_Keyval);

	push	DWORD PTR __Keyval$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Find
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 477  :     }

	pop	ebp
	ret	8
?find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamClient@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::end, COMDAT
; _this$ = ecx

; 306  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 308  :     }

	pop	ebp
	ret	4
?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::end, COMDAT
; _this$ = ecx

; 293  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 295  :     }

	pop	ebp
	ret	4
?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Segment_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z
_TEXT	SEGMENT
__K$ = 8						; size = 4
?_Segment_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_size, COMDAT

; 197  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 198  :         return _K ? size_type(1)<<_K : 2;

	mov	ecx, DWORD PTR __K$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Segment_si
	mov	eax, 1
	shl	eax, cl

; 199  :     }

	pop	ebp
	ret	0
$LN3@Segment_si:

; 198  :         return _K ? size_type(1)<<_K : 2;

	mov	eax, 2

; 199  :     }

	pop	ebp
	ret	0
?_Segment_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Segment_base@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z
_TEXT	SEGMENT
__K$ = 8						; size = 4
?_Segment_base@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_base, COMDAT

; 192  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	ecx, DWORD PTR __K$[ebp]
	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 194  :     }

	pop	ebp
	ret	0
?_Segment_base@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Segment_index_of@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z
_TEXT	SEGMENT
__Index$1 = -4						; size = 4
__Index$ = 8						; size = 4
?_Segment_index_of@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_index_of, COMDAT

; 187  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, DWORD PTR __Index$[ebp]
	or	eax, 1

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$1[ebp], 0

; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	mov	DWORD PTR __Index$1[ebp], eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	eax, al

; 189  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Segment_index_of@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Segment_index_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ
_TEXT	SEGMENT
??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >, COMDAT
; _this$ = ecx

; 170  :     {

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 172  :         for (size_type _Index = 0; _Index < _Pointers_per_table; _Index++)

	xor	esi, esi
$LL4@Concurrent:

; 173  :         {
; 174  :             if (_M_buckets[_Index] != NULL)

	mov	eax, DWORD PTR [edi+esi*4+4]
	test	eax, eax
	je	SHORT $LN2@Concurrent

; 198  :         return _K ? size_type(1)<<_K : 2;

	test	esi, esi
	je	SHORT $LN12@Concurrent
	mov	edx, 1
	mov	ecx, esi
	shl	edx, cl
	jmp	SHORT $LN13@Concurrent
$LN12@Concurrent:
	mov	edx, 2
$LN13@Concurrent:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	edx, 1073741823				; 3fffffffH
	ja	$LN89@Concurrent

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	ecx, DWORD PTR [edx*4]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Concurrent

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	jne	SHORT $LN89@Concurrent

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN89@Concurrent

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN89@Concurrent

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	ja	SHORT $LN89@Concurrent

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN20@Concurrent:

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Concurrent:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 172  :         for (size_type _Index = 0; _Index < _Pointers_per_table; _Index++)

	inc	esi
	cmp	esi, 32					; 00000020H
	jb	SHORT $LL4@Concurrent
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 419  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi+132]

; 420  : 
; 421  :         _ASSERT_EXPR(this->_Myhead != NULL, L"Invalid head list node");
; 422  :         _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]

; 423  :         _Pnode->_M_next = NULL;

	mov	DWORD PTR [eax], 0

; 424  :         _Pnode = _Pnext;

	mov	eax, esi

; 425  : 
; 426  :         while (_Pnode != NULL)

	test	esi, esi
	je	SHORT $LN33@Concurrent
	npad	5
$LL32@Concurrent:

; 427  :         {
; 428  :             _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 430  :             _Pnode = _Pnext;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL32@Concurrent
$LN33@Concurrent:

; 397  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi+132]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 433  :         _M_element_count = 0;

	mov	DWORD PTR [edi+140], 0

; 398  :         this->_Myhead = NULL;

	mov	DWORD PTR [edi+132], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 184  :     }

	ret	0
$LN89@Concurrent:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN107@Concurrent:
$LN106@Concurrent:
	int	3
??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Number_of_buckets$ = 8				; size = 4
__Parg$ = 12						; size = 4
__Allocator$ = 16					; size = 4
??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >, COMDAT
; _this$ = ecx

; 126  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 56   :     _Concurrent_unordered_map_traits(const _Key_compare& _Traits) : _M_comparator(_Traits)

	mov	eax, DWORD PTR __Parg$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 126  :     {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 56   :     _Concurrent_unordered_map_traits(const _Key_compare& _Traits) : _M_comparator(_Traits)

	mov	ax, WORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 56   :     _Concurrent_unordered_map_traits(const _Key_compare& _Traits) : _M_comparator(_Traits)

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN38@Concurrent
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN64@Concurrent:
$LN38@Concurrent:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	DWORD PTR [eax+12], 0

; 216  :             _M_next = NULL;

	mov	DWORD PTR [eax], 0

; 313  :         this->_Myhead = _Buynode(0);

	mov	DWORD PTR [esi+132], eax

; 387  :     _Split_ordered_list(_Allocator_type _Allocator = allocator_type()) : _Mybase(_Allocator), _M_element_count(0)

	mov	DWORD PTR [esi+140], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 125  :         : _Traits(_Parg), _M_number_of_buckets(_Number_of_buckets), _M_split_ordered_list(_Allocator), _M_allocator(_Allocator), _M_maximum_bucket_size((float) _Initial_bucket_load)

	mov	eax, DWORD PTR __Number_of_buckets$[ebp]

; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	push	128					; 00000080H

; 125  :         : _Traits(_Parg), _M_number_of_buckets(_Number_of_buckets), _M_split_ordered_list(_Allocator), _M_allocator(_Allocator), _M_maximum_bucket_size((float) _Initial_bucket_load)

	mov	DWORD PTR [esi+148], eax

; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	lea	eax, DWORD PTR [esi+4]
	push	0
	push	eax

; 125  :         : _Traits(_Parg), _M_number_of_buckets(_Number_of_buckets), _M_split_ordered_list(_Allocator), _M_allocator(_Allocator), _M_maximum_bucket_size((float) _Initial_bucket_load)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi+152], 1082130432		; 40800000H

; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	call	_memset
	add	esp, 12					; 0000000cH

; 941  : 
; 942  :         // Insert the first element in the split-ordered list
; 943  :         _Full_iterator _Dummy_node = _M_split_ordered_list._Begin();
; 944  :         _Set_bucket(0, _Dummy_node);

	mov	ecx, esi
	push	DWORD PTR [esi+132]
	push	0
	call	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Set_bucket

; 127  :         _Init();
; 128  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN63@Concurrent:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	??1?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
__ehhandler$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@ABV?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Check_range@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@AAEXXZ
_TEXT	SEGMENT
?_Check_range@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@AAEXXZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Check_range, COMDAT
; _this$ = ecx

; 753  : #if defined (_DEBUG)
; 754  :         for (_Full_iterator _Iterator = _Begin(); _Iterator != _End(); _Iterator++)
; 755  :         {
; 756  :             _Full_iterator _Next_iterator = _Iterator;
; 757  :             _Next_iterator++;
; 758  : 
; 759  :             _ASSERT_EXPR(_Next_iterator == end() || _Next_iterator._Mynode()->_Get_order_key() >= _Iterator._Mynode()->_Get_order_key(), L"!!! List order inconsistency !!!");
; 760  :         }
; 761  : #endif  /* defined (_DEBUG) */
; 762  :     }

	ret	0
?_Check_range@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@AAEXXZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Check_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iterator$ = 12					; size = 4
__Order_key$ = 16					; size = 4
?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert_dummy, COMDAT
; _this$ = ecx

; 634  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR __Iterator$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edi, edi
	jne	SHORT $LN41@Insert_dum
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN126@Insert_dum:
$LN41@Insert_dum:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	ebx, DWORD PTR __Order_key$[ebp]
	mov	DWORD PTR [edi+12], ebx

; 216  :             _M_next = NULL;

	mov	DWORD PTR [edi], 0
	mov	ecx, DWORD PTR __Iterator$[ebp]
$LL2@Insert_dum:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 651  :             if (_Where == _Last || _Get_key(_Where) > _Order_key)

	je	SHORT $LN7@Insert_dum
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, ebx
	ja	SHORT $LN7@Insert_dum

; 674  :                 }
; 675  :             }
; 676  :             else if (_Get_key(_Where) == _Order_key)

	je	SHORT $LN119@Insert_dum

; 681  :             }
; 682  : 
; 683  :             // Move the iterator forward
; 684  :             _Iterator = _Where;

	mov	ecx, esi
	mov	DWORD PTR __Iterator$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 686  :         }

	jmp	SHORT $LL2@Insert_dum
$LN7@Insert_dum:

; 610  :         _New_node->_M_next = _Current_node;

	mov	DWORD PTR [edi], esi

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, edi
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [ecx], edx

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, esi
	je	SHORT $LN120@Insert_dum

; 652  :             {
; 653  :                 _ASSERT_EXPR(_Get_key(_Iterator) < _Order_key, L"Invalid node order in the list");
; 654  : 
; 655  :                 // Try to insert it in the right place
; 656  :                 _Nodeptr _Inserted_node = _Insert(_Iterator._Mynode(), _Dummy_node, _Where._Mynode());
; 657  : 
; 658  :                 if (_Inserted_node == _Dummy_node)

	cmp	eax, edi
	je	SHORT $LN120@Insert_dum
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR __Iterator$[ebp]
	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 673  :                     continue;

	jmp	SHORT $LL2@Insert_dum
$LN119@Insert_dum:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 680  :                 return _Where;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 680  :                 return _Where;

	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 688  :     }

	pop	ebp
	ret	12					; 0000000cH
$LN120@Insert_dum:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 688  :     }

	pop	ebp
	ret	12					; 0000000cH
$LN125@Insert_dum:
?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert_dummy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@5@0PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAJ@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Iterator$ = 12					; size = 4
__Next$ = 16						; size = 4
__List_node$ = 20					; size = 4
__New_count$ = 24					; size = 4
?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@5@0PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAJ@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert, COMDAT
; _this$ = ecx

; 616  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, DWORD PTR __Iterator$[ebp]
	push	ebx

; 610  :         _New_node->_M_next = _Current_node;

	mov	ebx, DWORD PTR __List_node$[ebp]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 83   : 		return (_Ptr);

	mov	edi, DWORD PTR __Next$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	esi, ebx

; 616  :     {

	mov	DWORD PTR _this$1$[ebp], ecx

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	eax, edi

; 610  :         _New_node->_M_next = _Current_node;

	mov	DWORD PTR [ebx], edi

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	lock	 cmpxchg DWORD PTR [edx], esi

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, edi
	je	SHORT $LN57@Insert

; 617  :         _Nodeptr _Inserted_node = _Insert(_Iterator._Mynode(), _List_node, _Next._Mynode());
; 618  : 
; 619  :         if (_Inserted_node == _List_node)

	cmp	eax, ebx
	je	SHORT $LN57@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 630  :     }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN57@Insert:

; 620  :         {
; 621  :             // If the insert succeeded, check that the order is correct and increment the element count
; 622  :             _Check_range();
; 623  :             *_New_count = _InterlockedIncrement(&_M_element_count);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax+8], ecx
	inc	ecx
	mov	eax, DWORD PTR __New_count$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ebx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 630  :     }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@5@0PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAJ@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAU4523@00@Z
_TEXT	SEGMENT
__Previous$ = 8						; size = 4
__New_node$ = 12					; size = 4
__Current_node$ = 16					; size = 4
?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAU4523@00@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert, COMDAT
; _this$ = ecx

; 609  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	ecx, DWORD PTR __Previous$[ebp]
	push	esi

; 610  :         _New_node->_M_next = _Current_node;

	mov	esi, DWORD PTR __Current_node$[ebp]

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	eax, esi
	push	edi

; 610  :         _New_node->_M_next = _Current_node;

	mov	edi, DWORD PTR __New_node$[ebp]

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, edi

; 610  :         _New_node->_M_next = _Current_node;

	mov	DWORD PTR [edi], esi

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	lock	 cmpxchg DWORD PTR [ecx], edx

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, esi
	cmove	eax, edi
	pop	edi
	pop	esi

; 611  :         return _Previous->_Atomic_set_next(_New_node, _Current_node);
; 612  :     }

	pop	ebp
	ret	12					; 0000000cH
?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAU4523@00@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Erase@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@@Z
_TEXT	SEGMENT
__Delete_node$ = 8					; size = 4
?_Erase@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Erase, COMDAT
; _this$ = ecx

; 597  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	DWORD PTR __Delete_node$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 604  :     }

	pop	ebp
	ret	4
?_Erase@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iterator$ = 12					; size = 4
?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_iterator, COMDAT
; _this$ = ecx

; 552  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Iterator$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 555  :     }

	pop	ebp
	ret	8
?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_iterator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iterator$ = 12					; size = 4
?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_iterator, COMDAT
; _this$ = ecx

; 544  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Iterator$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 547  :     }

	pop	ebp
	ret	8
?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_iterator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Get_key@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAIABV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z
_TEXT	SEGMENT
__Iterator$ = 8						; size = 4
?_Get_key@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAIABV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_key, COMDAT

; 537  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 538  :         return _Iterator._Mynode()->_Get_order_key();

	mov	eax, DWORD PTR __Iterator$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+12]

; 539  :     }

	pop	ebp
	ret	0
?_Get_key@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAIABV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Get_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_End@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_End@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_End, COMDAT
; _this$ = ecx

; 532  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 534  :     }

	pop	ebp
	ret	4
?_End@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_End@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_End@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_End, COMDAT
; _this$ = ecx

; 527  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 529  :     }

	pop	ebp
	ret	4
?_End@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Begin@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Begin@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Begin, COMDAT
; _this$ = ecx

; 516  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 518  :     }

	pop	ebp
	ret	4
?_Begin@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?end@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::end, COMDAT
; _this$ = ecx

; 456  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 458  :     }

	pop	ebp
	ret	4
?end@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?end@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::end, COMDAT
; _this$ = ecx

; 451  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 453  :     }

	pop	ebp
	ret	4
?end@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@23@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?clear@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXXZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::clear, COMDAT
; _this$ = ecx

; 413  :     {

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 414  : #if _ITERATOR_DEBUG_LEVEL == 2
; 415  :         _Orphan_ptr(*this, 0);
; 416  : #endif  /* _ITERATOR_DEBUG_LEVEL == 2 */
; 417  : 
; 418  :         _Nodeptr _Pnext;
; 419  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi]

; 420  : 
; 421  :         _ASSERT_EXPR(this->_Myhead != NULL, L"Invalid head list node");
; 422  :         _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]

; 423  :         _Pnode->_M_next = NULL;

	mov	DWORD PTR [eax], 0

; 424  :         _Pnode = _Pnext;

	mov	eax, esi

; 425  : 
; 426  :         while (_Pnode != NULL)

	test	esi, esi
	je	SHORT $LN38@clear
$LL2@clear:

; 427  :         {
; 428  :             _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 430  :             _Pnode = _Pnext;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL2@clear
$LN38@clear:

; 431  :         }
; 432  : 
; 433  :         _M_element_count = 0;

	mov	DWORD PTR [edi+8], 0
	pop	edi
	pop	esi

; 434  :     }

	ret	0
?clear@?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEXXZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??1?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ
_TEXT	SEGMENT
??1?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >, COMDAT
; _this$ = ecx

; 392  :     {

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 419  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi]

; 420  : 
; 421  :         _ASSERT_EXPR(this->_Myhead != NULL, L"Invalid head list node");
; 422  :         _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]

; 423  :         _Pnode->_M_next = NULL;

	mov	DWORD PTR [eax], 0

; 424  :         _Pnode = _Pnext;

	mov	eax, esi

; 425  : 
; 426  :         while (_Pnode != NULL)

	test	esi, esi
	je	SHORT $LN5@Split_orde
$LL4@Split_orde:

; 427  :         {
; 428  :             _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 430  :             _Pnode = _Pnext;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL4@Split_orde
$LN5@Split_orde:

; 393  :         // Clear the list
; 394  :         clear();
; 395  : 
; 396  :         // Remove the head element which is not cleared by clear()
; 397  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 433  :         _M_element_count = 0;

	mov	DWORD PTR [edi+8], 0

; 398  :         this->_Myhead = NULL;

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 403  :     }

	ret	0
??1?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z
_TEXT	SEGMENT
__Allocator$ = 8					; size = 1
??0?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >, COMDAT
; _this$ = ecx

; 388  :     {

	npad	2
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 388  :     {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN30@Split_orde
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN40@Split_orde:
$LN30@Split_orde:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	DWORD PTR [eax+12], 0

; 216  :             _M_next = NULL;

	mov	DWORD PTR [eax], 0

; 313  :         this->_Myhead = _Buynode(0);

	mov	DWORD PTR [esi], eax

; 389  :     }

	mov	eax, esi
	mov	DWORD PTR [esi+8], 0
	pop	esi
	ret	4
$LN39@Split_orde:
??0?$_Split_ordered_list@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_ordered_list<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Myval@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Myval, COMDAT

; 357  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 359  :     }

	pop	ebp
	ret	0
?_Myval@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAAAU?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Nextnode@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAAAPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAU4523@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAAAPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAU4523@@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Nextnode, COMDAT

; 351  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 353  :     }

	pop	ebp
	ret	0
?_Nextnode@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@SAAAPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@PAU4523@@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Buynode@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@I@Z
_TEXT	SEGMENT
__Order_key$ = 8					; size = 4
?_Buynode@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@I@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Buynode, COMDAT
; _this$ = ecx

; 342  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	ecx, ecx
	jne	SHORT $LN12@Buynode
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@Buynode:
$LN12@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	eax, DWORD PTR __Order_key$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 343  :         _Nodeptr _Pnode = this->_M_node_allocator.allocate(1);
; 344  :         _Pnode->_Init(_Order_key);
; 345  : 
; 346  :         return (_Pnode);

	mov	eax, ecx

; 216  :             _M_next = NULL;

	mov	DWORD PTR [ecx], 0

; 347  :     }

	pop	ebp
	ret	4
$LN19@Buynode:
?_Buynode@?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@23@I@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Buynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??1?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ
_TEXT	SEGMENT
??1?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >, COMDAT
; _this$ = ecx

; 318  :     }

	ret	0
??1?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@XZ ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::~_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z
_TEXT	SEGMENT
__Allocator$ = 8					; size = 1
??0?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >, COMDAT
; _this$ = ecx

; 310  :     {

	npad	2
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 310  :     {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN25@Split_orde
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN34@Split_orde:
$LN25@Split_orde:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	DWORD PTR [eax+12], 0

; 216  :             _M_next = NULL;

	mov	DWORD PTR [eax], 0

; 311  :         // Immediately allocate a dummy node with order key of 0. This node
; 312  :         // will always be the head of the list.
; 313  :         this->_Myhead = _Buynode(0);

	mov	DWORD PTR [esi], eax

; 314  :     }

	mov	eax, esi
	pop	esi
	ret	4
$LN33@Split_orde:
??0?$_Split_order_list_value@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_order_list_value<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@I@Z PROC ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 268435455				; 0fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 4

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@I@Z ENDP ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@I@Z PROC ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@I@Z ENDP ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Node>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z
_TEXT	SEGMENT
__Allocator$ = 8					; size = 1
??0?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >, COMDAT
; _this$ = ecx

; 261  :     }

	mov	eax, ecx
	ret	4
??0?$_Split_order_list_node@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@@Z ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >::_Split_order_list_node<std::pair<ISteamClient * const,IWrapSteamClient *>,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$equal_to@PAVISteamClient@@@std@@QBE_NABQAVISteamClient@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$equal_to@PAVISteamClient@@@std@@QBE_NABQAVISteamClient@@0@Z PROC ; std::equal_to<ISteamClient *>::operator(), COMDAT
; _this$ = ecx

; 219  : 		{	// apply operator== to operands

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 220  : 		return (_Left == _Right);
; 221  : 		}

	pop	ebp
	ret	8
??R?$equal_to@PAVISteamClient@@@std@@QBE_NABQAVISteamClient@@0@Z ENDP ; std::equal_to<ISteamClient *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$_Bitwise_hash@PAVISteamClient@@@std@@QBEIABQAVISteamClient@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Bitwise_hash@PAVISteamClient@@@std@@QBEIABQAVISteamClient@@@Z PROC ; std::_Bitwise_hash<ISteamClient *>::operator(), COMDAT
; _this$ = ecx

; 360  : 		{	// hash _Keyval to size_t value by pseudorandomizing transform

	npad	2
	push	ebp
	mov	ebp, esp

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619

; 361  : 		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
; 362  : 		}

	pop	ebp
	ret	4
??R?$_Bitwise_hash@PAVISteamClient@@@std@@QBEIABQAVISteamClient@@@Z ENDP ; std::_Bitwise_hash<ISteamClient *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??R?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QBE_NABQAVISteamClient@@0@Z
_TEXT	SEGMENT
__Keyval1$ = 8						; size = 4
__Keyval2$ = 12						; size = 4
??R?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QBE_NABQAVISteamClient@@0@Z PROC ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::operator(), COMDAT
; _this$ = ecx

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Keyval1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Keyval2$[ebp]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 51   :         return (!_M_key_compare_object(_Keyval1, _Keyval2));
; 52   :     }

	pop	ebp
	ret	8
??R?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QBE_NABQAVISteamClient@@0@Z ENDP ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??R?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QBEIABQAVISteamClient@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QBEIABQAVISteamClient@@@Z PROC ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::operator(), COMDAT
; _this$ = ecx

; 45   :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 47   :     }

	pop	ebp
	ret	4
??R?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QBEIABQAVISteamClient@@@Z ENDP ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??0?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QAE@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@@Z
_TEXT	SEGMENT
__Hasharg$ = 8						; size = 1
__Keyeqarg$ = 12					; size = 1
??0?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QAE@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@@Z PROC ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >, COMDAT
; _this$ = ecx

; 42   :     }

	mov	eax, ecx
	ret	8
??0?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@QAE@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@4@@Z ENDP ; Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??0?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@QAE@ABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@@Z
_TEXT	SEGMENT
__Traits$ = 8						; size = 4
??0?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@QAE@ABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@@Z PROC ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>, COMDAT
; _this$ = ecx

; 57   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 56   :     _Concurrent_unordered_map_traits(const _Key_compare& _Traits) : _M_comparator(_Traits)

	mov	eax, DWORD PTR __Traits$[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax

; 58   :     }

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Concurrent_unordered_map_traits@PAVISteamClient@@PAVIWrapSteamClient@@V?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@$0A@@details@Concurrency@@QAE@ABV?$_Hash_compare@PAVISteamClient@@U?$hash@PAVISteamClient@@@std@@U?$equal_to@PAVISteamClient@@@3@@12@@Z ENDP ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>::_Concurrent_unordered_map_traits<ISteamClient *,IWrapSteamClient *,Concurrency::details::_Hash_compare<ISteamClient *,std::hash<ISteamClient *>,std::equal_to<ISteamClient *> >,std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$pair@QAVISteamClient@@PAVIWrapSteamClient@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >::allocator<std::pair<ISteamClient * const,IWrapSteamClient *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Get_msb@details@Concurrency@@YAEI@Z
_TEXT	SEGMENT
__Index$ = -4						; size = 4
__Mask$ = 8						; size = 4
?_Get_msb@details@Concurrency@@YAEI@Z PROC		; Concurrency::details::_Get_msb, COMDAT

; 72   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 73   :     unsigned long _Index = 0;
; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, DWORD PTR __Mask$[ebp]
	mov	DWORD PTR __Index$[ebp], 0
	mov	DWORD PTR __Index$[ebp], eax

; 77   : #else  /* (defined (_M_IX86) || defined (_M_ARM)) */
; 78   :     _BitScanReverse64(&_Index, _Mask);
; 79   : #endif  /* (defined (_M_IX86) || defined (_M_ARM)) */
; 80   : 
; 81   :     return (unsigned char) _Index;
; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_msb@details@Concurrency@@YAEI@Z ENDP		; Concurrency::details::_Get_msb
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Reverse_byte@details@Concurrency@@YAEE@Z
_TEXT	SEGMENT
__Original_byte$ = 8					; size = 1
?_Reverse_byte@details@Concurrency@@YAEE@Z PROC		; Concurrency::details::_Reverse_byte, COMDAT

; 65   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 66   :     // return ((_Original_byte * 0x80200802ULL) & 0x0884422110ULL) * 0x0101010101ULL >> 32;
; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, BYTE PTR __Original_byte$[ebp]
	mov	eax, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB
	mov	al, BYTE PTR [ecx+eax]

; 68   : }

	pop	ebp
	ret	0
?_Reverse_byte@details@Concurrency@@YAEE@Z ENDP		; Concurrency::details::_Reverse_byte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 65   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 66   :     {
; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
;	COMDAT ??0out_of_range@std@@QAE@PBD@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@PBD@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 141  : 		{	// construct from message string

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept

; 141  : 		{	// construct from message string

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 52   :         : _Data()

	lea	edx, DWORD PTR [esi+4]

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$1[ebp], eax

; 55   :         __std_exception_copy(&_InitData, &_Data);

	lea	eax, DWORD PTR __InitData$1[ebp]
	push	edx
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	mov	BYTE PTR __InitData$1[ebp+4], 1
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept

; 141  : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 142  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@PBD@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 65   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 66   :     {
; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
;	COMDAT ??0logic_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@PBD@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 29   : 		{	// construct from message string

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept

; 29   : 		{	// construct from message string

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 52   :         : _Data()

	lea	edx, DWORD PTR [esi+4]

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$1[ebp], eax

; 55   :         __std_exception_copy(&_InitData, &_Data);

	lea	eax, DWORD PTR __InitData$1[ebp]
	push	edx
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	mov	BYTE PTR __InitData$1[ebp+4], 1
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept

; 29   : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@

; 30   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@PBD@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 98   :         return;
; 99   :     }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
	test	ecx, ecx
	cmovne	eax, ecx

; 90   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 85   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 68   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 53   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __InitData$[ebp], eax
	lea	edx, DWORD PTR [esi+4]
	mov	BYTE PTR __InitData$[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

	push	edx
	lea	eax, DWORD PTR __InitData$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 56   :     }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ?_Hash_seq@std@@YAIPBEI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Hash_seq@std@@YAIPBEI@Z PROC				; std::_Hash_seq, COMDAT

; 331  : 	{	// FNV-1a hash function for bytes in [_First, _First + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 332  :  #if defined(_WIN64)
; 333  : 	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 334  : 	const size_t _FNV_offset_basis = 14695981039346656037ULL;
; 335  : 	const size_t _FNV_prime = 1099511628211ULL;
; 336  : 
; 337  :  #else /* defined(_WIN64) */
; 338  : 	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
; 339  : 	const size_t _FNV_offset_basis = 2166136261U;
; 340  : 	const size_t _FNV_prime = 16777619U;
; 341  :  #endif /* defined(_WIN64) */
; 342  : 
; 343  : 	size_t _Val = _FNV_offset_basis;
; 344  : 	for (size_t _Next = 0; _Next < _Count; ++_Next)

	mov	esi, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	mov	edx, -2128831035			; 811c9dc5H
	test	esi, esi
	je	SHORT $LN12@Hash_seq
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
$LL8@Hash_seq:

; 345  : 		{	// fold in another byte
; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ecx+edi]
	inc	ecx
	xor	eax, edx

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	cmp	ecx, esi
	jb	SHORT $LL8@Hash_seq
	pop	edi
$LN12@Hash_seq:

; 348  : 		}
; 349  : 	return (_Val);

	mov	eax, edx
	pop	esi

; 350  : 	}

	pop	ebp
	ret	0
?_Hash_seq@std@@YAIPBEI@Z ENDP				; std::_Hash_seq
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ISteamClient@@QAE@XZ
_TEXT	SEGMENT
??0ISteamClient@@QAE@XZ PROC				; ISteamClient::ISteamClient, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ISteamClient@@6B@
	mov	eax, ecx
	ret	0
??0ISteamClient@@QAE@XZ ENDP				; ISteamClient::ISteamClient
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\client.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 272  : }

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
