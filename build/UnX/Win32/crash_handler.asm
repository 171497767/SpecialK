; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\diagnostics\crash_handler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?SetUnhandledExceptionFilter_Original@@3P6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@ZA ; SetUnhandledExceptionFilter_Original
PUBLIC	?SteamAPI_SetBreakpadAppID_NEVER@@3P6AXI@ZA	; SteamAPI_SetBreakpadAppID_NEVER
PUBLIC	?SteamAPI_UseBrakepadCrashHandler_NEVER@@3P6AXPBD00_NPAX2@ZA ; SteamAPI_UseBrakepadCrashHandler_NEVER
_BSS	SEGMENT
?SetUnhandledExceptionFilter_Original@@3P6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@ZA DD 01H DUP (?) ; SetUnhandledExceptionFilter_Original
?SteamAPI_SetBreakpadAppID_NEVER@@3P6AXI@ZA DD 01H DUP (?) ; SteamAPI_SetBreakpadAppID_NEVER
?SteamAPI_UseBrakepadCrashHandler_NEVER@@3P6AXPBD00_NPAX2@ZA DD 01H DUP (?) ; SteamAPI_UseBrakepadCrashHandler_NEVER
_BSS	ENDS
CONST	SEGMENT
$SG250068 DB	'W', 00H, 'A', 00H, 'V', 00H, 'E', 00H, 00H, 00H
$SG250097 DB	00H
$SG250291 DB	00H
$SG250072 DB	'w', 00H, 00H, 00H
$SG250073 DB	'l', 00H, 'o', 00H, 'g', 00H, 's', 00H, '/', 00H, 'c', 00H
	DB	'r', 00H, 'a', 00H, 's', 00H, 'h', 00H, '.', 00H, 'l', 00H, 'o'
	DB	00H, 'g', 00H, 00H, 00H
$SG250301 DB	00H
	ORG $+1
$SG250074 DB	'SetUnhandledExceptionFilter', 00H
$SG250075 DB	'k', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'e', 00H, 'l', 00H
	DB	'3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG250100 DB	'UNKNOWN', 00H
$SG250238 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'A', 00H, 'C', 00H, 'C', 00H, 'E', 00H, 'S', 00H
	DB	'S', 00H, '_', 00H, 'V', 00H, 'I', 00H, 'O', 00H, 'L', 00H, 'A'
	DB	00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, 00H, 00H
$SG250254 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'F', 00H, 'L', 00H, 'T', 00H, '_', 00H, 'O', 00H
	DB	'V', 00H, 'E', 00H, 'R', 00H, 'F', 00H, 'L', 00H, 'O', 00H, 'W'
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, 00H, 00H
$SG250240 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'A', 00H, 'R', 00H, 'R', 00H, 'A', 00H, 'Y', 00H
	DB	'_', 00H, 'B', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'D', 00H, 'S'
	DB	00H, '_', 00H, 'E', 00H, 'X', 00H, 'C', 00H, 'E', 00H, 'E', 00H
	DB	'D', 00H, 'E', 00H, 'D', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H
	DB	00H
	ORG $+2
$SG250242 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'B', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'K', 00H
	DB	'P', 00H, 'O', 00H, 'I', 00H, 'N', 00H, 'T', 00H, ' ', 00H, '>'
	DB	00H, '>', 00H, 00H, 00H
$SG250244 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, 'T', 00H
	DB	'Y', 00H, 'P', 00H, 'E', 00H, '_', 00H, 'M', 00H, 'I', 00H, 'S'
	DB	00H, 'A', 00H, 'L', 00H, 'I', 00H, 'G', 00H, 'N', 00H, 'M', 00H
	DB	'E', 00H, 'N', 00H, 'T', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H
	DB	00H
	ORG $+2
$SG250246 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'F', 00H, 'L', 00H, 'T', 00H, '_', 00H, 'D', 00H
	DB	'E', 00H, 'N', 00H, 'O', 00H, 'R', 00H, 'M', 00H, 'A', 00H, 'L'
	DB	00H, '_', 00H, 'O', 00H, 'P', 00H, 'E', 00H, 'R', 00H, 'A', 00H
	DB	'N', 00H, 'D', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H, 00H
$SG250266 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'I', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'O', 00H
	DB	'V', 00H, 'E', 00H, 'R', 00H, 'F', 00H, 'L', 00H, 'O', 00H, 'W'
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, 00H, 00H
$SG250248 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'F', 00H, 'L', 00H, 'T', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'V', 00H, 'I', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'B'
	DB	00H, 'Y', 00H, '_', 00H, 'Z', 00H, 'E', 00H, 'R', 00H, 'O', 00H
	DB	' ', 00H, '>', 00H, '>', 00H, 00H, 00H
$SG250250 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'F', 00H, 'L', 00H, 'T', 00H, '_', 00H, 'I', 00H
	DB	'N', 00H, 'E', 00H, 'X', 00H, 'A', 00H, 'C', 00H, 'T', 00H, '_'
	DB	00H, 'R', 00H, 'E', 00H, 'S', 00H, 'U', 00H, 'L', 00H, 'T', 00H
	DB	' ', 00H, '>', 00H, '>', 00H, 00H, 00H
$SG250252 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'F', 00H, 'L', 00H, 'T', 00H, '_', 00H, 'I', 00H
	DB	'N', 00H, 'V', 00H, 'A', 00H, 'L', 00H, 'I', 00H, 'D', 00H, '_'
	DB	00H, 'O', 00H, 'P', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'I', 00H, 'O', 00H, 'N', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H
	DB	00H
	ORG $+2
$SG250256 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'F', 00H, 'L', 00H, 'T', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'A', 00H, 'C', 00H, 'K', 00H, '_', 00H, 'C', 00H, 'H'
	DB	00H, 'E', 00H, 'C', 00H, 'K', 00H, ' ', 00H, '>', 00H, '>', 00H
	DB	00H, 00H
	ORG $+2
$SG250258 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'F', 00H, 'L', 00H, 'T', 00H, '_', 00H, 'U', 00H
	DB	'N', 00H, 'D', 00H, 'E', 00H, 'R', 00H, 'F', 00H, 'L', 00H, 'O'
	DB	00H, 'W', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG250274 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'S', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 'L', 00H
	DB	'E', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'P', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG250260 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'I', 00H, 'L', 00H, 'L', 00H, 'E', 00H, 'G', 00H
	DB	'A', 00H, 'L', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'S', 00H, 'T'
	DB	00H, 'R', 00H, 'U', 00H, 'C', 00H, 'T', 00H, 'I', 00H, 'O', 00H
	DB	'N', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG250262 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'I', 00H, 'N', 00H, '_', 00H, 'P', 00H, 'A', 00H
	DB	'G', 00H, 'E', 00H, '_', 00H, 'E', 00H, 'R', 00H, 'R', 00H, 'O'
	DB	00H, 'R', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG250279 DB	'[', 00H, '!', 00H, ' ', 00H, 'E', 00H, 'x', 00H, 'c', 00H
	DB	'e', 00H, 'p', 00H, 't', 00H, ' ', 00H, '!', 00H, ']', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, 00H, 00H
$SG250299 DB	'Scaleform', 00H
	ORG $+2
$SG250264 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'I', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'D', 00H
	DB	'I', 00H, 'V', 00H, 'I', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'B'
	DB	00H, 'Y', 00H, '_', 00H, 'Z', 00H, 'E', 00H, 'R', 00H, 'O', 00H
	DB	' ', 00H, '>', 00H, '>', 00H, 00H, 00H
$SG250268 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'I', 00H, 'N', 00H, 'V', 00H, 'A', 00H, 'L', 00H
	DB	'I', 00H, 'D', 00H, '_', 00H, 'D', 00H, 'I', 00H, 'S', 00H, 'P'
	DB	00H, 'O', 00H, 'S', 00H, 'I', 00H, 'T', 00H, 'I', 00H, 'O', 00H
	DB	'N', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG250308 DB	'l', 00H, 'o', 00H, 'g', 00H, 's', 00H, '\', 00H, 00H, 00H
$SG250270 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'N', 00H, 'O', 00H, 'N', 00H, 'C', 00H, 'O', 00H
	DB	'N', 00H, 'T', 00H, 'I', 00H, 'N', 00H, 'U', 00H, 'A', 00H, 'B'
	DB	00H, 'L', 00H, 'E', 00H, '_', 00H, 'E', 00H, 'X', 00H, 'C', 00H
	DB	'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, 00H, 00H
$SG250313 DB	'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'l', 00H, 'o', 00H, 'g'
	DB	00H, 00H, 00H
$SG250272 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'P', 00H, 'R', 00H, 'I', 00H, 'V', 00H, '_', 00H
	DB	'I', 00H, 'N', 00H, 'S', 00H, 'T', 00H, 'R', 00H, 'U', 00H, 'C'
	DB	00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, 00H, 00H
$SG250320 DB	'C', 00H, 'E', 00H, 'G', 00H, 'U', 00H, 'I', 00H, '.', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, 00H, 00H
$SG250276 DB	09H, 00H, '<', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'X', 00H
	DB	'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N'
	DB	00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'C', 00H, 'K', 00H
	DB	'_', 00H, 'O', 00H, 'V', 00H, 'E', 00H, 'R', 00H, 'F', 00H, 'L'
	DB	00H, 'O', 00H, 'W', 00H, ' ', 00H, '>', 00H, '>', 00H, 00H, 00H
$SG250278 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, 00H, 00H
$SG250280 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, 00H, 00H
$SG250281 DB	'[', 00H, ' ', 00H, 'F', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 'M', 00H, 'o', 00H, 'd', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '#', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, '.', 00H, '.', 00H, '.', 00H, '.', 00H, ':'
	DB	00H, ' ', 00H, '''', 00H, '%', 00H, 'h', 00H, 's', 00H, '''', 00H
	DB	00H, 00H
	ORG $+2
$SG250310 DB	'%', 00H, 'm', 00H, '-', 00H, '%', 00H, 'd', 00H, '-', 00H
	DB	'%', 00H, 'Y', 00H, '_', 00H, '_', 00H, '%', 00H, 'H', 00H, ''''
	DB	00H, '%', 00H, 'M', 00H, '''', 00H, '%', 00H, 'S', 00H, '\', 00H
	DB	00H, 00H
$SG250321 DB	'C', 00H, 'E', 00H, 'G', 00H, 'U', 00H, 'I', 00H, '.', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, 00H, 00H
$SG250282 DB	'[', 00H, ' ', 00H, 'F', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 'M', 00H, 'o', 00H, 'd', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '*', 00H, ' ', 00H, 'E', 00H, 'I', 00H, 'P', 00H
	DB	' ', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H, '.', 00H, ':'
	DB	00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, '+', 00H, '%', 00H
	DB	'0', 00H, '8', 00H, 'X', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG250324 DB	'a', 00H, 00H, 00H
$SG250283 DB	'[', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H
	DB	'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ']', 00H, ' '
	DB	00H, '<', 00H, '-', 00H, '>', 00H, ' ', 00H, 'E', 00H, 'i', 00H
	DB	'p', 00H, '=', 00H, '%', 00H, '0', 00H, '8', 00H, 'x', 00H, 'h'
	DB	00H, ',', 00H, ' ', 00H, 'E', 00H, 's', 00H, 'p', 00H, '=', 00H
	DB	'%', 00H, '0', 00H, '8', 00H, 'x', 00H, 'h', 00H, ',', 00H, ' '
	DB	00H, 'E', 00H, 'b', 00H, 'p', 00H, '=', 00H, '%', 00H, '0', 00H
	DB	'8', 00H, 'x', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG250326 DB	'a', 00H, 00H, 00H
$SG250284 DB	'[', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H
	DB	'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ']', 00H, ' '
	DB	00H, '>', 00H, '-', 00H, '<', 00H, ' ', 00H, 'E', 00H, 's', 00H
	DB	'i', 00H, '=', 00H, '%', 00H, '0', 00H, '8', 00H, 'x', 00H, 'h'
	DB	00H, ',', 00H, ' ', 00H, 'E', 00H, 'd', 00H, 'i', 00H, '=', 00H
	DB	'%', 00H, '0', 00H, '8', 00H, 'x', 00H, 'h', 00H, 00H, 00H
$SG250328 DB	'a', 00H, 00H, 00H
$SG250285 DB	'[', 00H, ' ', 00H, ' ', 00H, 'G', 00H, 'P', 00H, ' ', 00H
	DB	'R', 00H, 'e', 00H, 'g', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'e', 00H, 'a', 00H, 'x', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'8', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG250286 DB	'[', 00H, ' ', 00H, ' ', 00H, 'G', 00H, 'P', 00H, ' ', 00H
	DB	'R', 00H, 'e', 00H, 'g', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'e', 00H, 'b', 00H, 'x', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'8', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG250287 DB	'[', 00H, ' ', 00H, ' ', 00H, 'G', 00H, 'P', 00H, ' ', 00H
	DB	'R', 00H, 'e', 00H, 'g', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'e', 00H, 'c', 00H, 'x', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'8', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG250288 DB	'[', 00H, ' ', 00H, ' ', 00H, 'G', 00H, 'P', 00H, ' ', 00H
	DB	'R', 00H, 'e', 00H, 'g', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'e', 00H, 'd', 00H, 'x', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'8', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG250289 DB	'[', 00H, ' ', 00H, 'G', 00H, 'P', 00H, ' ', 00H, 'F', 00H
	DB	'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'E', 00H, 'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ':'
	DB	00H, ' ', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'8', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG250290 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, 00H, 00H
$SG250296 DB	'[', 00H, '-', 00H, '(', 00H, 'S', 00H, 'o', 00H, 'u', 00H
	DB	'r', 00H, 'c', 00H, 'e', 00H, ')', 00H, '-', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '{', 00H, '%', 00H
	DB	'2', 00H, '4', 00H, 'h', 00H, 's', 00H, '}', 00H, ' ', 00H, ' '
	DB	00H, '%', 00H, '#', 00H, '6', 00H, '4', 00H, 'h', 00H, 's', 00H
	DB	' ', 00H, ' ', 00H, '<', 00H, '%', 00H, 'h', 00H, 's', 00H, ':'
	DB	00H, '%', 00H, 'l', 00H, 'u', 00H, '>', 00H, 00H, 00H
$SG250297 DB	'[', 00H, '-', 00H, '-', 00H, '(', 00H, 'N', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, ')', 00H, '-', 00H, '-', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '{', 00H, '%', 00H
	DB	'2', 00H, '4', 00H, 'h', 00H, 's', 00H, '}', 00H, ' ', 00H, ' '
	DB	00H, '%', 00H, '#', 00H, '6', 00H, '4', 00H, 'h', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG250330 DB	'a', 00H, 00H, 00H
$SG250302 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, 00H, 00H
$SG250306 DB	'l', 00H, 'o', 00H, 'g', 00H, 's', 00H, '\', 00H, '*', 00H
	DB	'.', 00H, 'l', 00H, 'o', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG250309 DB	'c', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'h', 00H, '\', 00H
	DB	00H, 00H
	ORG $+2
$SG250453 DB	'W', 00H, 'A', 00H, 'V', 00H, 'E', 00H, 00H, 00H
CONST	ENDS
PUBLIC	?Init@CrashHandler@Diagnostics@SK@@YAXXZ	; SK::Diagnostics::CrashHandler::Init
PUBLIC	?InitSyms@CrashHandler@Diagnostics@SK@@YAXXZ	; SK::Diagnostics::CrashHandler::InitSyms
PUBLIC	?Shutdown@CrashHandler@Diagnostics@SK@@YAXXZ	; SK::Diagnostics::CrashHandler::Shutdown
PUBLIC	?Reinstall@CrashHandler@Diagnostics@SK@@YAXXZ	; SK::Diagnostics::CrashHandler::Reinstall
PUBLIC	_ReadAcquire
PUBLIC	?_InterlockedExchange@@YAKPCKK@Z		; _InterlockedExchange
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
PUBLIC	?SK_GetSymbolNameFromModuleAddr@@YAKPAUHINSTANCE__@@IPADK@Z ; SK_GetSymbolNameFromModuleAddr
PUBLIC	_wmemchr
PUBLIC	_wmemcmp
PUBLIC	_wmemcpy
PUBLIC	_wmemmove
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?compare@?$char_traits@_W@std@@SAHQB_W0I@Z	; std::char_traits<wchar_t>::compare
PUBLIC	?length@?$char_traits@_W@std@@SAIQB_W@Z		; std::char_traits<wchar_t>::length
PUBLIC	?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z	; std::char_traits<wchar_t>::copy
PUBLIC	?find@?$char_traits@_W@std@@SAPB_WQB_WIAB_W@Z	; std::char_traits<wchar_t>::find
PUBLIC	?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z	; std::char_traits<wchar_t>::move
PUBLIC	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z	; std::char_traits<wchar_t>::assign
PUBLIC	?compare@?$char_traits@D@std@@SAHQBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?max_size@?$allocator@_W@std@@QBEIXZ		; std::allocator<wchar_t>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
PUBLIC	?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
PUBLIC	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
PUBLIC	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
PUBLIC	??1AutoClose@iSK_Logger@@QAE@XZ			; iSK_Logger::AutoClose::~AutoClose
PUBLIC	??0AutoClose@iSK_Logger@@IAE@PAU1@@Z		; iSK_Logger::AutoClose::AutoClose
PUBLIC	?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ	; iSK_Logger::auto_close
PUBLIC	??0iSK_Logger@@QAE@XZ				; iSK_Logger::iSK_Logger
PUBLIC	??1iSK_Logger@@UAE@XZ				; iSK_Logger::~iSK_Logger
PUBLIC	??_GiSK_Logger@@UAEPAXI@Z			; iSK_Logger::`scalar deleting destructor'
PUBLIC	?lock@SK_Thread_CriticalSection@@QAEXXZ		; SK_Thread_CriticalSection::lock
PUBLIC	?unlock@SK_Thread_CriticalSection@@QAEXXZ	; SK_Thread_CriticalSection::unlock
PUBLIC	?UIntPtrToLongLong@@YAJIPA_J@Z			; UIntPtrToLongLong
PUBLIC	?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; SK_TopLevelExceptionFilter
PUBLIC	?SetUnhandledExceptionFilter_Detour@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z ; SetUnhandledExceptionFilter_Detour
PUBLIC	??0<unnamed-type-crash_sound>@@QAE@XZ		; <unnamed-type-crash_sound>::<unnamed-type-crash_sound>
PUBLIC	??$static_cast_p2p@X$$A6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z@@YAPAPAXPAP6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z@Z ; static_cast_p2p<void,long (__stdcall*__stdcall(long (__stdcall*)(_EXCEPTION_POINTERS *)))(_EXCEPTION_POINTERS *)>
PUBLIC	?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z ; SK_GetSymbolNameFromModuleAddr
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$min@K@std@@YAABKABK0@Z			; std::min<unsigned long>
PUBLIC	?SK_SymRefreshModuleList@@YGXPAX@Z		; SK_SymRefreshModuleList
PUBLIC	?SteamAPI_SetBreakpadAppID_Detour@@YAXI@Z	; SteamAPI_SetBreakpadAppID_Detour
PUBLIC	?SteamAPI_UseBreakpadCrashHandler_Detour@@YAXPBD00_NPAX2@Z ; SteamAPI_UseBreakpadCrashHandler_Detour
PUBLIC	?SK_BypassSteamCrashHandler@@YAXXZ		; SK_BypassSteamCrashHandler
PUBLIC	??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z ; std::_Traits_find<std::char_traits<wchar_t> >
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z		; std::addressof<wchar_t *>
PUBLIC	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Unfancy@_W@std@@YAPA_WPA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z		; std::forward<wchar_t * &>
PUBLIC	??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??_7iSK_Logger@@6B@				; iSK_Logger::`vftable'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	?crash_log@@3UiSK_Logger@@A			; crash_log
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R0?AUIUnknown@@@8				; IUnknown `RTTI Type Descriptor'
PUBLIC	??_R3IUnknown@@8				; IUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknown@@8				; IUnknown::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4iSK_Logger@@6B@				; iSK_Logger::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUiSK_Logger@@@8				; iSK_Logger `RTTI Type Descriptor'
PUBLIC	??_R3iSK_Logger@@8				; iSK_Logger::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2iSK_Logger@@8				; iSK_Logger::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@iSK_Logger@@8			; iSK_Logger::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp___strdup:PROC
EXTRN	__imp__strncat:PROC
EXTRN	__imp__DeleteFileW@4:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileW@8:PROC
EXTRN	__imp__FindNextFileW@8:PROC
EXTRN	__imp__SetUnhandledExceptionFilter@4:PROC
EXTRN	__imp__SetErrorMode@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__TerminateProcess@8:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetModuleHandleExW@12:PROC
EXTRN	__imp__LoadResource@8:PROC
EXTRN	__imp__LockResource@4:PROC
EXTRN	__imp__lstrcatW@8:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__FindResourceW@12:PROC
EXTRN	__imp__CopyFileExW@24:PROC
EXTRN	__imp__PlaySoundW@12:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__wcsftime:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	?SK_GetConfigPath@@YGPB_WXZ:PROC		; SK_GetConfigPath
EXTRN	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ:PROC		; SK_GetDLL
EXTRN	?SK_GetFramesDrawn@@YGKXZ:PROC			; SK_GetFramesDrawn
EXTRN	?SK_CreateDLLHook@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z:PROC ; SK_CreateDLLHook
EXTRN	?QueryInterface@iSK_Logger@@UAGJABU_GUID@@PAPAX@Z:PROC ; iSK_Logger::QueryInterface
EXTRN	?AddRef@iSK_Logger@@UAGKXZ:PROC			; iSK_Logger::AddRef
EXTRN	?Release@iSK_Logger@@UAGKXZ:PROC		; iSK_Logger::Release
EXTRN	?init@iSK_Logger@@UAG_NQB_W0@Z:PROC		; iSK_Logger::init
EXTRN	?close@iSK_Logger@@UAGXXZ:PROC			; iSK_Logger::close
EXTRN	?LogEx@iSK_Logger@@UAAX_NQB_WZZ:PROC		; iSK_Logger::LogEx
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?Log@iSK_Logger@@UAAXQBDZZ:PROC			; iSK_Logger::Log
EXTRN	??_EiSK_Logger@@UAEPAXI@Z:PROC			; iSK_Logger::`vector deleting destructor'
EXTRN	__imp___localtime64:PROC
EXTRN	__imp___time64:PROC
EXTRN	?SK_CreateDirectories@@YG_NPB_W@Z:PROC		; SK_CreateDirectories
EXTRN	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z:PROC ; SK_WideCharToUTF8
EXTRN	?SK_SelfDestruct@@YGXXZ:PROC			; SK_SelfDestruct
EXTRN	__imp__StackWalk@36:PROC
EXTRN	__imp__SymSetOptions@4:PROC
EXTRN	__imp__SymGetModuleBase64@12:PROC
EXTRN	__imp__SymGetModuleBase@8:PROC
EXTRN	__imp__SymGetLineFromAddr@16:PROC
EXTRN	__imp__SymInitialize@12:PROC
EXTRN	__imp__SymUnloadModule@8:PROC
EXTRN	__imp__SymFromAddr@20:PROC
EXTRN	__imp__SymRefreshModuleList@4:PROC
EXTRN	__imp__SymLoadModule64@28:PROC
EXTRN	__imp__SymLoadModule@24:PROC
EXTRN	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ:PROC		; SK_TLS_Bottom
EXTRN	__imp__StrStrW@8:PROC
EXTRN	__imp__StrStrIA@8:PROC
EXTRN	__imp__StrStrIW@8:PROC
EXTRN	__imp_??1String@CEGUI@@QAE@XZ:PROC
EXTRN	__imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?init@String@CEGUI@@AAEXXZ:PROC
EXTRN	__imp_?getDllSingleton@?$Singleton@VLogger@CEGUI@@@CEGUI@@SAAAVLogger@2@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?cs_dbghelp@@3PAVSK_Thread_HybridSpinlock@@A:DWORD ; cs_dbghelp
EXTRN	?__SK_DLL_Ending@@3JC:DWORD			; __SK_DLL_Ending
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	?budget_log@@3UiSK_Logger@@A:BYTE		; budget_log
EXTRN	?steam_log@@3UiSK_Logger@@A:BYTE		; steam_log
EXTRN	?game_debug@@3UiSK_Logger@@A:BYTE		; game_debug
EXTRN	?__SK_DLL_Attached@@3JC:DWORD			; __SK_DLL_Attached
_BSS	SEGMENT
?crash_sound@@3U<unnamed-type-crash_sound>@@A DQ 01H DUP (?) ; crash_sound
_BSS	ENDS
;	COMDAT ?init@?1??InitSyms@CrashHandler@Diagnostics@SK@@YAXXZ@4KC
_BSS	SEGMENT
?init@?1??InitSyms@CrashHandler@Diagnostics@SK@@YAXXZ@4KC DD 01H DUP (?) ; `SK::Diagnostics::CrashHandler::InitSyms'::`2'::init
_BSS	ENDS
CRT$XCU	SEGMENT
?crash_log$initializer$@@3P6AXXZA DD FLAT:??__Ecrash_log@@YAXXZ ; crash_log$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@iSK_Logger@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@iSK_Logger@@8 DD FLAT:??_R0?AUiSK_Logger@@@8 ; iSK_Logger::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3iSK_Logger@@8
rdata$r	ENDS
;	COMDAT ??_R2iSK_Logger@@8
rdata$r	SEGMENT
??_R2iSK_Logger@@8 DD FLAT:??_R1A@?0A@EA@iSK_Logger@@8	; iSK_Logger::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3iSK_Logger@@8
rdata$r	SEGMENT
??_R3iSK_Logger@@8 DD 00H				; iSK_Logger::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2iSK_Logger@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUiSK_Logger@@@8
data$r	SEGMENT
??_R0?AUiSK_Logger@@@8 DD FLAT:??_7type_info@@6B@	; iSK_Logger `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUiSK_Logger@@', 00H
data$r	ENDS
;	COMDAT ??_R4iSK_Logger@@6B@
rdata$r	SEGMENT
??_R4iSK_Logger@@6B@ DD 00H				; iSK_Logger::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUiSK_Logger@@@8
	DD	FLAT:??_R3iSK_Logger@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknown@@8
rdata$r	SEGMENT
??_R2IUnknown@@8 DD FLAT:??_R1A@?0A@EA@IUnknown@@8	; IUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT
??_R3IUnknown@@8 DD 00H					; IUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
data$r	SEGMENT
??_R0?AUIUnknown@@@8 DD FLAT:??_7type_info@@6B@		; IUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknown@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?crash_log@@3UiSK_Logger@@A DD FLAT:??_7iSK_Logger@@6B@	; crash_log
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_7iSK_Logger@@6B@
CONST	SEGMENT
??_7iSK_Logger@@6B@ DD FLAT:??_R4iSK_Logger@@6B@	; iSK_Logger::`vftable'
	DD	FLAT:?QueryInterface@iSK_Logger@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@iSK_Logger@@UAGKXZ
	DD	FLAT:?Release@iSK_Logger@@UAGKXZ
	DD	FLAT:??_EiSK_Logger@@UAEPAXI@Z
	DD	FLAT:?init@iSK_Logger@@UAG_NQB_W0@Z
	DD	FLAT:?close@iSK_Logger@@UAGXXZ
	DD	FLAT:?LogEx@iSK_Logger@@UAAX_NQB_WZZ
	DD	FLAT:?Log@iSK_Logger@@UAAXQBDZZ
	DD	FLAT:?Log@iSK_Logger@@UAAXQB_WZZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z$0
__ehfuncinfo$?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$5
	DD	01H
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1AutoClose@iSK_Logger@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$0
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$18
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$0
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$18
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT

; 24   : 	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits

	npad	2
	push	ebp
	mov	ebp, esp

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	ecx, DWORD PTR __Left_size$[ebp]
	cmp	ecx, DWORD PTR __Right_size$[ebp]
	jne	SHORT $LN3@Traits_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

	mov	edx, DWORD PTR __Left$[ebp]
	push	esi
	mov	esi, DWORD PTR __Right$[ebp]
	sub	ecx, 4
	jb	SHORT $LN10@Traits_equ
	npad	7
$LL11@Traits_equ:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN9@Traits_equ
	add	edx, 4
	add	esi, 4
	sub	ecx, 4
	jae	SHORT $LL11@Traits_equ
$LN10@Traits_equ:
	cmp	ecx, -4					; fffffffcH
	je	SHORT $LN8@Traits_equ
$LN9@Traits_equ:
	mov	al, BYTE PTR [edx]
	cmp	al, BYTE PTR [esi]
	jne	SHORT $LN12@Traits_equ
	cmp	ecx, -3					; fffffffdH
	je	SHORT $LN8@Traits_equ
	mov	al, BYTE PTR [edx+1]
	cmp	al, BYTE PTR [esi+1]
	jne	SHORT $LN12@Traits_equ
	cmp	ecx, -2					; fffffffeH
	je	SHORT $LN8@Traits_equ
	mov	al, BYTE PTR [edx+2]
	cmp	al, BYTE PTR [esi+2]
	jne	SHORT $LN12@Traits_equ
	cmp	ecx, -1
	je	SHORT $LN8@Traits_equ
	mov	al, BYTE PTR [edx+3]
	cmp	al, BYTE PTR [esi+3]
	je	SHORT $LN8@Traits_equ
$LN12@Traits_equ:
	sbb	eax, eax
	or	eax, 1
	jmp	SHORT $LN13@Traits_equ
$LN8@Traits_equ:
	xor	eax, eax
$LN13@Traits_equ:
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	test	eax, eax
	jne	SHORT $LN3@Traits_equ
	mov	al, 1

; 26   : 	}

	pop	ebp
	ret	0
$LN3@Traits_equ:

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	xor	al, al

; 26   : 	}

	pop	ebp
	ret	0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 22   : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 24   : 	}

	pop	ebp
	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1705 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1705 : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z
_TEXT	SEGMENT
__Haystack$ = 8						; size = 4
__Hay_size$ = 12					; size = 4
__Start_at$ = 16					; size = 4
__Needle$ = 20						; size = 4
__Possible_matches_end$1$ = 24				; size = 4
__Needle_size$ = 24					; size = 4
??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z PROC ; std::_Traits_find<std::char_traits<wchar_t> >, COMDAT

; 56   : 	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at

	npad	2
	push	ebp
	mov	ebp, esp

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

	mov	ecx, DWORD PTR __Hay_size$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Needle_size$[ebp]
	cmp	ebx, ecx
	ja	$LN6@Traits_fin
	mov	eax, DWORD PTR __Start_at$[ebp]
	sub	ecx, ebx
	cmp	eax, ecx
	ja	SHORT $LN6@Traits_fin

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

	test	ebx, ebx
	je	SHORT $LN3@Traits_fin

; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	mov	edx, DWORD PTR __Haystack$[ebp]
	inc	ecx
	push	esi
	push	edi
	lea	ecx, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR __Possible_matches_end$1$[ebp], ecx

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

	lea	eax, DWORD PTR [edx+eax*2]
$LL4@Traits_fin:

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

	sub	ecx, eax
	sar	ecx, 1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	je	SHORT $LN34@Traits_fin

; 204  :             if (*_S == _C)

	mov	esi, DWORD PTR __Needle$[ebp]
	movzx	edx, WORD PTR [esi]
	npad	4
$LL17@Traits_fin:
	cmp	WORD PTR [eax], dx
	je	SHORT $LN32@Traits_fin

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	eax, 2
	sub	ecx, 1
	jne	SHORT $LL17@Traits_fin
$LN34@Traits_fin:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 80   : 			return (static_cast<size_t>(-1));

	or	eax, -1
	pop	esi
$LN3@Traits_fin:
	pop	ebx

; 86   : 			}
; 87   : 		}
; 88   : 	}

	pop	ebp
	ret	0
$LN32@Traits_fin:

; 78   : 		if (!_Match_try)

	test	eax, eax
	je	SHORT $LN34@Traits_fin
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	mov	edx, esi
	mov	edi, ebx
	mov	esi, eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	ebx, ebx
	je	SHORT $LN35@Traits_fin
$LL26@Traits_fin:

; 217  :             if (*_S1 != *_S2)

	mov	cx, WORD PTR [esi]
	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN48@Traits_fin

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	esi, 2
	add	edx, 2
	sub	edi, 1
	jne	SHORT $LL26@Traits_fin
$LN35@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 85   : 			return (_Match_try - _Haystack);

	sub	eax, DWORD PTR __Haystack$[ebp]
	pop	edi
	pop	esi
	sar	eax, 1
	pop	ebx

; 86   : 			}
; 87   : 		}
; 88   : 	}

	pop	ebp
	ret	0
$LN48@Traits_fin:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	sbb	ecx, ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

	je	SHORT $LN35@Traits_fin

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

	mov	ecx, DWORD PTR __Possible_matches_end$1$[ebp]
	add	eax, 2
	jmp	SHORT $LL4@Traits_fin
$LN6@Traits_fin:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// C++14 21.4.7.2 [string::find]/1.1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

	or	eax, -1
	pop	ebx

; 86   : 			}
; 87   : 		}
; 88   : 	}

	pop	ebp
	ret	0
??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z ENDP ; std::_Traits_find<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
?SK_BypassSteamCrashHandler@@YAXXZ PROC			; SK_BypassSteamCrashHandler

; 939  : #if 0
; 940  :   if (! config.steam.silent)
; 941  :   {
; 942  : #ifdef _WIN64
; 943  :     const wchar_t* wszSteamDLL = L"steam_api64.dll";
; 944  : #else
; 945  :     const wchar_t* wszSteamDLL = L"steam_api.dll";
; 946  : #endif
; 947  : 
; 948  :     if (SK_GetFileSize (wszSteamDLL) > 0)
; 949  :     {
; 950  :       HMODULE hMod = LoadLibraryW_Original (wszSteamDLL);
; 951  : 
; 952  :       if (hMod)
; 953  :       {
; 954  :         crash_log.Log (L"Disabling Steam Breakpad...");
; 955  : 
; 956  :         SK_CreateDLLHook2 (       wszSteamDLL,
; 957  :                                   "SteamAPI_UseBreakpadCrashHandler",
; 958  :                                    SteamAPI_UseBreakpadCrashHandler_Detour,
; 959  :           static_cast_p2p <void> (&SteamAPI_UseBrakepadCrashHandler_NEVER) );
; 960  :       
; 961  :         SK_CreateDLLHook2 (       wszSteamDLL,
; 962  :                                   "SteamAPI_SetBreakpadAppID",
; 963  :                                    SteamAPI_SetBreakpadAppID_Detour,
; 964  :           static_cast_p2p <void> (&SteamAPI_SetBreakpadAppID_NEVER) );
; 965  : 
; 966  :         SK_ApplyQueuedHooks ();
; 967  :       }
; 968  :     }
; 969  :   }
; 970  : #endif
; 971  : }

	ret	0
?SK_BypassSteamCrashHandler@@YAXXZ ENDP			; SK_BypassSteamCrashHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
_pchVersion$ = 8					; size = 4
_pchDate$ = 12						; size = 4
_pchTime$ = 16						; size = 4
_bFullMemoryDumps$ = 20					; size = 1
_pvContext$ = 24					; size = 4
_m_pfnPreMinidumpCallback$ = 28				; size = 4
?SteamAPI_UseBreakpadCrashHandler_Detour@@YAXPBD00_NPAX2@Z PROC ; SteamAPI_UseBreakpadCrashHandler_Detour

; 926  :   UNREFERENCED_PARAMETER (pchVersion);
; 927  :   UNREFERENCED_PARAMETER (pchDate);
; 928  :   UNREFERENCED_PARAMETER (pchTime);
; 929  :   UNREFERENCED_PARAMETER (bFullMemoryDumps);
; 930  :   UNREFERENCED_PARAMETER (pvContext);
; 931  :   UNREFERENCED_PARAMETER (m_pfnPreMinidumpCallback);
; 932  : }

	ret	0
?SteamAPI_UseBreakpadCrashHandler_Detour@@YAXPBD00_NPAX2@Z ENDP ; SteamAPI_UseBreakpadCrashHandler_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
_unAppId$ = 8						; size = 4
?SteamAPI_SetBreakpadAppID_Detour@@YAXI@Z PROC		; SteamAPI_SetBreakpadAppID_Detour

; 914  :   UNREFERENCED_PARAMETER (unAppId);
; 915  : }

	ret	0
?SteamAPI_SetBreakpadAppID_Detour@@YAXI@Z ENDP		; SteamAPI_SetBreakpadAppID_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
_hProc$ = 8						; size = 4
?SK_SymRefreshModuleList@@YGXPAX@Z PROC			; SK_SymRefreshModuleList

; 892  : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 264  :     EnterCriticalSection (cs_);

	mov	eax, DWORD PTR ?cs_dbghelp@@3PAVSK_Thread_HybridSpinlock@@A ; cs_dbghelp
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 896  :   SymRefreshModuleList (hProc);

	push	DWORD PTR _hProc$[ebp]
	call	DWORD PTR __imp__SymRefreshModuleList@4
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 269  :     LeaveCriticalSection (cs_);

	mov	eax, DWORD PTR ?cs_dbghelp@@3PAVSK_Thread_HybridSpinlock@@A ; cs_dbghelp
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 900  : }

	pop	ebp
	ret	4
?SK_SymRefreshModuleList@@YGXPAX@Z ENDP			; SK_SymRefreshModuleList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$min@K@std@@YAABKABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@K@std@@YAABKABK0@Z PROC				; std::min<unsigned long>, COMDAT

; 3778 : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 3780 : 	}

	pop	ebp
	ret	0
??$min@K@std@@YAABKABK0@Z ENDP				; std::min<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3843 : 	{	// test for string vs. NTCTS equality

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, edx
	push	esi
	lea	esi, DWORD PTR [ecx+1]
	npad	2
$LL34@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL34@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1844 : 		return (_Get_data()._Mysize);

	mov	eax, DWORD PTR __Left$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	sub	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1844 : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [eax+16]

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN28@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN28@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3421 : 		return (_Traits_equal<_Traits>(this->_Myptr(), this->_Mysize(), _Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	push	DWORD PTR [esi]
	push	eax
	call	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ; std::_Traits_equal<std::char_traits<char> >
	add	esp, 16					; 00000010H
	pop	esi

; 3844 : 	return (_Left._Equal(_Right));
; 3845 : 	}

	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??__Fcrash_log@@YAXXZ
text$yd	SEGMENT
??__Fcrash_log@@YAXXZ PROC				; `dynamic atexit destructor for 'crash_log'', COMDAT
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 180  :     Release ();

	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A, OFFSET ??_7iSK_Logger@@6B@
	call	?Release@iSK_Logger@@UAGKXZ		; iSK_Logger::Release
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3606 : 		this->_Orphan_all();

	mov	ecx, OFFSET ?crash_log@@3UiSK_Logger@@A+8
	call	?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR ?crash_log@@3UiSK_Logger@@A+28, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN10@dynamic
	push	esi

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR ?crash_log@@3UiSK_Logger@@A+8

; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));

	mov	ecx, OFFSET ?crash_log@@3UiSK_Logger@@A+8
	push	OFFSET ?crash_log@@3UiSK_Logger@@A+8
	call	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	mov	eax, DWORD PTR ?crash_log@@3UiSK_Logger@@A+28
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	esi
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	esi
$LN10@dynamic:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+24, 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+28, 7

; 2217 : 		}

	mov	ecx, OFFSET ?crash_log@@3UiSK_Logger@@A+8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR ?crash_log@@3UiSK_Logger@@A+8, ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	jmp	??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
??__Fcrash_log@@YAXXZ ENDP				; `dynamic atexit destructor for 'crash_log''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
;	COMDAT ??__Ecrash_log@@YAXXZ
text$di	SEGMENT
??__Ecrash_log@@YAXXZ PROC				; `dynamic initializer for 'crash_log'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?crash_log@@3UiSK_Logger@@A+8
	call	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+24, 0

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
	mov	ecx, OFFSET ?crash_log@@3UiSK_Logger@@A+8

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+28, 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR ?crash_log@@3UiSK_Logger@@A+8, ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 205  :   bool             silent      = false;

	mov	WORD PTR ?crash_log@@3UiSK_Logger@@A+32, 0
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	movups	XMMWORD PTR ?crash_log@@3UiSK_Logger@@A+36, xmm0
	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+60, 0
	movq	QWORD PTR ?crash_log@@3UiSK_Logger@@A+52, xmm0

; 206  :   bool             initialized = false;
; 207  :   int              lines       =   0;
; 208  :   CRITICAL_SECTION log_mutex   = {   };
; 209  :   ULONG            refs        =   0UL;

	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+64, 0

; 210  :   DWORD            last_flush  =   0;

	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+68, 0

; 211  :   DWORD            flush_freq  =   100; // msecs

	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+72, 100 ; 00000064H

; 212  : 
; 213  : public:
; 214  :   // Temporary augmentation for log issues during thread suspension
; 215  :   bool             lock   (void) { if (! lockless) { EnterCriticalSection (&log_mutex); return true; } return false; }
; 216  :   bool             unlock (void) { if (! lockless) { LeaveCriticalSection (&log_mutex); return true; } return false; }
; 217  :   bool             lockless    = true;

	mov	BYTE PTR ?crash_log@@3UiSK_Logger@@A+76, 1
	call	?AddRef@iSK_Logger@@UAGKXZ		; iSK_Logger::AddRef
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 215  : iSK_Logger crash_log;

	push	OFFSET ??__Fcrash_log@@YAXXZ		; `dynamic atexit destructor for 'crash_log''
	call	_atexit
	pop	ecx
	ret	0
??__Ecrash_log@@YAXXZ ENDP				; `dynamic initializer for 'crash_log''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
_sip$ = -2388						; size = 2096
_szModName$ = -292					; size = 262
_Displacement$ = -28					; size = 8
_BaseAddr$1$ = -20					; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_hMod$ = 12						; size = 4
_addr$ = 16						; size = 4
?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z PROC ; SK_GetSymbolNameFromModuleAddr

; 144  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 2376				; 00000948H
	push	ebx
	push	esi
	mov	DWORD PTR $T2[ebp], 0
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, edi
	push	0
	push	OFFSET $SG250097
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 144  : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 212  :   return ret;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 1
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	DWORD PTR _addr$[ebp]
	mov	ebx, eax
	push	ebx
	call	DWORD PTR __imp__SymGetModuleBase@8
	push	262					; 00000106H
	mov	DWORD PTR _BaseAddr$1$[ebp], eax
	lea	eax, DWORD PTR _szModName$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _szModName$[ebp]
	push	260					; 00000104H
	push	eax
	push	DWORD PTR _hMod$[ebp]
	call	DWORD PTR __imp__GetModuleFileNameA@12
	lea	eax, DWORD PTR _szModName$[ebp]
	push	eax
	call	DWORD PTR __imp___strdup
	add	esp, 4
	mov	esi, eax
	push	esi
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, esi
	cmp	eax, esi
	jbe	SHORT $LN52@SK_GetSymb
$LL2@SK_GetSymb:

; 145  :   std::string ret = "";
; 146  : 
; 147  :   HANDLE hProc =
; 148  :     GetCurrentProcess ();
; 149  : 
; 150  : #ifdef _WIN64
; 151  :   DWORD64  ip = addr;
; 152  : #else
; 153  :   DWORD    ip = addr;
; 154  : #endif
; 155  : 
; 156  : #ifdef _WIN64
; 157  :   DWORD64 BaseAddr =
; 158  :     SymGetModuleBase64 ( hProc, ip );
; 159  : #else
; 160  :   DWORD BaseAddr =
; 161  :     SymGetModuleBase   ( hProc, ip );
; 162  : #endif
; 163  : 
; 164  :   char szModName [MAX_PATH + 2] = { };
; 165  : 
; 166  :   GetModuleFileNameA   ( hMod, szModName, MAX_PATH );
; 167  : 
; 168  :   char* szDupName    = _strdup (szModName);
; 169  :   char* pszShortName = szDupName + lstrlenA (szDupName);
; 170  : 
; 171  :   while (  pszShortName      >  szDupName &&

	cmp	BYTE PTR [eax-1], 92			; 0000005cH
	je	SHORT $LN52@SK_GetSymb

; 172  :          *(pszShortName - 1) != '\\')
; 173  :     --pszShortName;

	dec	eax
	cmp	eax, esi
	ja	SHORT $LL2@SK_GetSymb
$LN52@SK_GetSymb:

; 174  : 
; 175  : #ifdef _WIN64
; 176  :   SymLoadModule64 ( hProc,
; 177  :                       nullptr,
; 178  :                         pszShortName,
; 179  :                           nullptr,
; 180  :                             BaseAddr,
; 181  :                               0 );
; 182  : #else
; 183  :   SymLoadModule ( hProc,

	push	0
	push	DWORD PTR _BaseAddr$1$[ebp]
	push	0
	push	eax
	push	0
	push	ebx
	call	DWORD PTR __imp__SymLoadModule@24

; 184  :                     nullptr,
; 185  :                       pszShortName,
; 186  :                         nullptr,
; 187  :                           BaseAddr,
; 188  :                             0 );
; 189  : #endif
; 190  : 
; 191  :   SYMBOL_INFO_PACKAGE sip;
; 192  :   sip.si.SizeOfStruct = sizeof SYMBOL_INFO;
; 193  :   sip.si.MaxNameLen   = sizeof sip.name;
; 194  : 
; 195  :   DWORD64 Displacement = 0;
; 196  : 
; 197  :   if ( SymFromAddr ( hProc,

	lea	eax, DWORD PTR _sip$[ebp]
	mov	DWORD PTR _sip$[ebp], 88		; 00000058H
	push	eax
	lea	eax, DWORD PTR _Displacement$[ebp]
	mov	DWORD PTR _sip$[ebp+80], 2001		; 000007d1H
	push	eax
	push	0
	push	DWORD PTR _addr$[ebp]
	xorps	xmm0, xmm0
	push	ebx
	movlpd	QWORD PTR _Displacement$[ebp], xmm0
	call	DWORD PTR __imp__SymFromAddr@20
	test	eax, eax
	je	SHORT $LN4@SK_GetSymb
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	ecx, DWORD PTR _sip$[ebp+84]
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL51@SK_GetSymb:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL51@SK_GetSymb
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	eax, DWORD PTR _sip$[ebp+84]
	push	ecx
	push	eax
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 205  :   else

	jmp	SHORT $LN54@SK_GetSymb
$LN4@SK_GetSymb:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	7
	push	OFFSET $SG250100
$LN54@SK_GetSymb:
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 210  :   free (szDupName);

	push	esi
	call	DWORD PTR __imp__free

; 213  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	add	esp, 4
	mov	eax, edi
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN8@SK_GetSymb
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@SK_GetSymb:
	ret	0
__ehhandler$?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_GetSymbolNameFromModuleAddr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHINSTANCE__@@I@Z ENDP ; SK_GetSymbolNameFromModuleAddr
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z@@YAPAPAXPAP6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z@@YAPAPAXPAP6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z@Z PROC ; static_cast_p2p<void,long (__stdcall*__stdcall(long (__stdcall*)(_EXCEPTION_POINTERS *)))(_EXCEPTION_POINTERS *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z@@YAPAPAXPAP6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z@Z ENDP ; static_cast_p2p<void,long (__stdcall*__stdcall(long (__stdcall*)(_EXCEPTION_POINTERS *)))(_EXCEPTION_POINTERS *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-crash_sound>@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-crash_sound>@@QAE@XZ PROC		; <unnamed-type-crash_sound>::<unnamed-type-crash_sound>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0<unnamed-type-crash_sound>@@QAE@XZ ENDP		; <unnamed-type-crash_sound>::<unnamed-type-crash_sound>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
_lpTopLevelExceptionFilter$ = 8				; size = 4
?SetUnhandledExceptionFilter_Detour@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z PROC ; SetUnhandledExceptionFilter_Detour

; 71   :   UNREFERENCED_PARAMETER (lpTopLevelExceptionFilter);
; 72   : 
; 73   :   return SetUnhandledExceptionFilter_Original (SK_TopLevelExceptionFilter);

	push	OFFSET ?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; SK_TopLevelExceptionFilter
	call	DWORD PTR ?SetUnhandledExceptionFilter_Original@@3P6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@ZA ; SetUnhandledExceptionFilter_Original

; 74   : }

	ret	4
?SetUnhandledExceptionFilter_Detour@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z ENDP ; SetUnhandledExceptionFilter_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
_wszFindPattern$2 = -9876				; size = 1040
_sip$3 = -8836						; size = 2096
_wszOutDir$4 = -6740					; size = 1040
_wszBaseDir$5 = -5700					; size = 1040
_ctx$ = -4660						; size = 716
_wszTime$6 = -3944					; size = 524
_wszOrigPath$7 = -3420					; size = 1042
_wszDestPath$8 = -2376					; size = 1042
_szModName$ = -1332					; size = 262
$T9 = -1068						; size = 152
_fd$10 = -916						; size = 592
_stackframe$ = -324					; size = 164
$T11 = -160						; size = 24
_Displacement$12 = -136					; size = 8
_ihl$13 = -128						; size = 20
_now$14 = -108						; size = 8
_closeme_crash_log$15 = -100				; size = 4
_top_func$ = -96					; size = 24
_last_chance$1$ = -72					; size = 4
_last_exc$1$ = -68					; size = 4
_last_ctx$1$ = -64					; size = 4
tv1372 = -60						; size = 4
_desc$ = -56						; size = 24
_hModSource$ = -32					; size = 4
_BaseAddr$2$ = -28					; size = 4
_BaseAddr$1$ = -28					; size = 4
_ip$1$ = -24						; size = 4
_Disp$16 = -24						; size = 4
_hProc$1$ = -20						; size = 4
_szDupName$1$ = -16					; size = 4
_ip$2$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hFind$1$ = 8						; size = 4
_ExceptionInfo$ = 8					; size = 4
?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z PROC ; SK_TopLevelExceptionFilter

; 227  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z
	push	eax
	mov	eax, 9864				; 00002688H
	mov	DWORD PTR fs:0, esp
	call	__chkstk
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__SK_DLL_Ending@@3JC	; __SK_DLL_Ending
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 230  :   if ( ReadAcquire (&__SK_DLL_Ending)   != 0 ||

	mov	edi, DWORD PTR __imp__GetCurrentProcess@0
	test	eax, eax
	jne	SHORT $LN15@SK_TopLeve
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__SK_DLL_Attached@@3JC	; __SK_DLL_Attached
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 230  :   if ( ReadAcquire (&__SK_DLL_Ending)   != 0 ||

	test	eax, eax
	jne	SHORT $LN14@SK_TopLeve
$LN15@SK_TopLeve:

; 231  :        ReadAcquire (&__SK_DLL_Attached) == 0 )
; 232  :   {
; 233  :     TerminateProcess (GetCurrentProcess (), (UINT)-1);

	push	-1
	call	edi
	push	eax
	call	DWORD PTR __imp__TerminateProcess@8
$LN14@SK_TopLeve:

; 234  :   }
; 235  : 
; 236  : 
; 237  :   bool scaleform = false;

	xor	al, al

; 238  : 
; 239  : #if 1
; 240  :   SymSetOptions ( SYMOPT_CASE_INSENSITIVE | SYMOPT_LOAD_LINES    | SYMOPT_UNDNAME |

	push	524311					; 00080017H
	mov	DWORD PTR tv1372[ebp], eax
	call	DWORD PTR __imp__SymSetOptions@4

; 241  :                   SYMOPT_NO_PROMPTS       | SYMOPT_DEFERRED_LOADS );
; 242  : #else
; 243  :   SymSetOptions ( SYMOPT_ALLOW_ZERO_ADDRESS | SYMOPT_LOAD_LINES |
; 244  :                   SYMOPT_LOAD_ANYTHING      | SYMOPT_UNDNAME    |
; 245  :                   SYMOPT_DEFERRED_LOADS );
; 246  : #endif
; 247  : 
; 248  : 
; 249  :   SymRefreshModuleList (GetCurrentProcess ());

	call	edi
	push	eax
	call	DWORD PTR __imp__SymRefreshModuleList@4

; 250  :   //SymInitialize (
; 251  :   //  GetCurrentProcess (),
; 252  :   //    NULL,
; 253  :   //      TRUE );
; 254  : 
; 255  :   bool&             last_chance = SK_TLS_Bottom ()->debug.last_chance;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	add	eax, 852				; 00000354H
	mov	DWORD PTR _last_chance$1$[ebp], eax

; 256  : 
; 257  :   CONTEXT&          last_ctx    = SK_TLS_Bottom ()->debug.last_ctx;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	add	eax, 56					; 00000038H
	mov	DWORD PTR _last_ctx$1$[ebp], eax

; 258  :   EXCEPTION_RECORD& last_exc    = SK_TLS_Bottom ()->debug.last_exc;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	add	eax, 772				; 00000304H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR _desc$[ebp+16], 0
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 258  :   EXCEPTION_RECORD& last_exc    = SK_TLS_Bottom ()->debug.last_exc;

	mov	DWORD PTR _last_exc$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _desc$[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR _desc$[ebp], ax
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 262  :   switch (ExceptionInfo->ExceptionRecord->ExceptionCode)

	mov	esi, DWORD PTR _ExceptionInfo$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	cmp	eax, -1073741819			; c0000005H
	ja	SHORT $LN65@SK_TopLeve
	je	SHORT $LN16@SK_TopLeve
	cmp	eax, -2147483646			; 80000002H
	je	SHORT $LN19@SK_TopLeve
	cmp	eax, -2147483645			; 80000003H
	je	SHORT $LN18@SK_TopLeve
	cmp	eax, -2147483644			; 80000004H
	jne	$LN2@SK_TopLeve

; 366  : 
; 367  :     case EXCEPTION_SINGLE_STEP:
; 368  :       desc = L"\t<< EXCEPTION_SINGLE_STEP >>";

	push	OFFSET $SG250274

; 369  :              //L"A trace trap or other single-instruction mechanism signaled "
; 370  :              //L"that one instruction has been executed.";
; 371  :       break;

	jmp	$LN510@SK_TopLeve
$LN18@SK_TopLeve:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	27					; 0000001bH
	push	OFFSET $SG250242
	lea	ecx, DWORD PTR _desc$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 279  :       break;

	jmp	$LN2@SK_TopLeve
$LN19@SK_TopLeve:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	38					; 00000026H
	push	OFFSET $SG250244
	lea	ecx, DWORD PTR _desc$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 285  :       break;

	jmp	$LN2@SK_TopLeve
$LN16@SK_TopLeve:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	33					; 00000021H
	push	OFFSET $SG250238
	lea	ecx, DWORD PTR _desc$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 268  :       break;

	jmp	$LN2@SK_TopLeve
$LN65@SK_TopLeve:

; 262  :   switch (ExceptionInfo->ExceptionRecord->ExceptionCode)

	add	eax, 1073741818				; 3ffffffaH
	cmp	eax, 247				; 000000f7H
	ja	$LN2@SK_TopLeve
	movzx	eax, BYTE PTR $LN495@SK_TopLeve[eax]
	jmp	DWORD PTR $LN511@SK_TopLeve[eax*4]
$LN17@SK_TopLeve:

; 269  : 
; 270  :     case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
; 271  :       desc = L"\t<< EXCEPTION_ARRAY_BOUNDS_EXCEEDED >>";

	push	OFFSET $SG250240

; 272  :              //L"The thread tried to access an array element that is out of "
; 273  :              //L"bounds and the underlying hardware supports bounds checking.";
; 274  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN20@SK_TopLeve:

; 286  : 
; 287  :     case EXCEPTION_FLT_DENORMAL_OPERAND:
; 288  :       desc = L"\t<< EXCEPTION_FLT_DENORMAL_OPERAND >>";

	push	OFFSET $SG250246

; 289  :              //L"One of the operands in a floating-point operation is denormal.";
; 290  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN21@SK_TopLeve:

; 291  : 
; 292  :     case EXCEPTION_FLT_DIVIDE_BY_ZERO:
; 293  :       desc = L"\t<< EXCEPTION_FLT_DIVIDE_BY_ZERO >>";

	push	OFFSET $SG250248

; 294  :              //L"The thread tried to divide a floating-point value by a "
; 295  :              //L"floating-point divisor of zero.";
; 296  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN22@SK_TopLeve:

; 297  : 
; 298  :     case EXCEPTION_FLT_INEXACT_RESULT:
; 299  :       desc = L"\t<< EXCEPTION_FLT_INEXACT_RESULT >>";

	push	OFFSET $SG250250

; 300  :              //L"The result of a floating-point operation cannot be represented "
; 301  :              //L"exactly as a decimal fraction.";
; 302  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN23@SK_TopLeve:

; 303  : 
; 304  :     case EXCEPTION_FLT_INVALID_OPERATION:
; 305  :       desc = L"\t<< EXCEPTION_FLT_INVALID_OPERATION >>";

	push	OFFSET $SG250252

; 306  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN24@SK_TopLeve:

; 307  : 
; 308  :     case EXCEPTION_FLT_OVERFLOW:
; 309  :       desc = L"\t<< EXCEPTION_FLT_OVERFLOW >>";

	push	OFFSET $SG250254

; 310  :              //L"The exponent of a floating-point operation is greater than the "
; 311  :              //L"magnitude allowed by the corresponding type.";
; 312  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN25@SK_TopLeve:

; 313  : 
; 314  :     case EXCEPTION_FLT_STACK_CHECK:
; 315  :       desc = L"\t<< EXCEPTION_FLT_STACK_CHECK >>";

	push	OFFSET $SG250256

; 316  :              //L"The stack overflowed or underflowed as the result of a "
; 317  :              //L"floating-point operation.";
; 318  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN26@SK_TopLeve:

; 319  : 
; 320  :     case EXCEPTION_FLT_UNDERFLOW:
; 321  :       desc = L"\t<< EXCEPTION_FLT_UNDERFLOW >>";

	push	OFFSET $SG250258

; 322  :              //L"The exponent of a floating-point operation is less than the "
; 323  :              //L"magnitude allowed by the corresponding type.";
; 324  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN27@SK_TopLeve:

; 325  : 
; 326  :     case EXCEPTION_ILLEGAL_INSTRUCTION:
; 327  :       desc = L"\t<< EXCEPTION_ILLEGAL_INSTRUCTION >>";

	push	OFFSET $SG250260

; 328  :              //L"The thread tried to execute an invalid instruction.";
; 329  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN28@SK_TopLeve:

; 330  : 
; 331  :     case EXCEPTION_IN_PAGE_ERROR:
; 332  :       desc = L"\t<< EXCEPTION_IN_PAGE_ERROR >>";

	push	OFFSET $SG250262

; 333  :              //L"The thread tried to access a page that was not present, "
; 334  :              //L"and the system was unable to load the page.";
; 335  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN29@SK_TopLeve:

; 336  : 
; 337  :     case EXCEPTION_INT_DIVIDE_BY_ZERO:
; 338  :       desc = L"\t<< EXCEPTION_INT_DIVIDE_BY_ZERO >>";

	push	OFFSET $SG250264

; 339  :              //L"The thread tried to divide an integer value by an integer "
; 340  :              //L"divisor of zero.";
; 341  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN30@SK_TopLeve:

; 342  : 
; 343  :     case EXCEPTION_INT_OVERFLOW:
; 344  :       desc = L"\t<< EXCEPTION_INT_OVERFLOW >>";

	push	OFFSET $SG250266

; 345  :              //L"The result of an integer operation caused a carry out of the "
; 346  :              //L"most significant bit of the result.";
; 347  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN31@SK_TopLeve:

; 348  : 
; 349  :     case EXCEPTION_INVALID_DISPOSITION:
; 350  :       desc = L"\t<< EXCEPTION_INVALID_DISPOSITION >>";

	push	OFFSET $SG250268

; 351  :              //L"An exception handler returned an invalid disposition to the "
; 352  :              //L"exception dispatcher.";
; 353  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN32@SK_TopLeve:

; 354  : 
; 355  :     case EXCEPTION_NONCONTINUABLE_EXCEPTION:
; 356  :       desc = L"\t<< EXCEPTION_NONCONTINUABLE_EXCEPTION >>";

	push	OFFSET $SG250270

; 357  :              //L"The thread tried to continue execution after a noncontinuable "
; 358  :              //L"exception occurred.";
; 359  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN33@SK_TopLeve:

; 360  : 
; 361  :     case EXCEPTION_PRIV_INSTRUCTION:
; 362  :       desc = L"\t<< EXCEPTION_PRIV_INSTRUCTION >>";

	push	OFFSET $SG250272

; 363  :              //L"The thread tried to execute an instruction whose operation is "
; 364  :              //L"not allowed in the current machine mode.";
; 365  :       break;

	jmp	SHORT $LN510@SK_TopLeve
$LN35@SK_TopLeve:

; 372  : 
; 373  :     case EXCEPTION_STACK_OVERFLOW:
; 374  :       desc = L"\t<< EXCEPTION_STACK_OVERFLOW >>";

	push	OFFSET $SG250276
$LN510@SK_TopLeve:
	lea	ecx, DWORD PTR _desc$[ebp]
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
$LN2@SK_TopLeve:

; 375  :              //L"The thread used up its stack.";
; 376  :       break;
; 377  :   }
; 378  : 
; 379  :   HMODULE hModSource               = nullptr;
; 380  :   char    szModName [MAX_PATH + 2] = { };

	push	262					; 00000106H
	lea	eax, DWORD PTR _szModName$[ebp]
	mov	DWORD PTR _hModSource$[ebp], 0
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 381  :   HANDLE  hProc                    = GetCurrentProcess ();

	call	edi
	mov	edi, eax

; 382  : 
; 383  :   SymRefreshModuleList ( hProc );

	push	edi
	mov	DWORD PTR _hProc$1$[ebp], edi
	call	DWORD PTR __imp__SymRefreshModuleList@4

; 384  : 
; 385  : #ifdef _WIN64
; 386  :   DWORD64  ip = ExceptionInfo->ContextRecord->Rip;
; 387  : #else
; 388  :   DWORD    ip = ExceptionInfo->ContextRecord->Eip;

	mov	ecx, DWORD PTR [esi+4]

; 389  : #endif
; 390  : 
; 391  :   if (GetModuleHandleEx ( GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,

	lea	eax, DWORD PTR _hModSource$[ebp]
	push	eax
	mov	esi, DWORD PTR [ecx+184]
	push	esi
	push	4
	mov	DWORD PTR _ip$1$[ebp], esi
	call	DWORD PTR __imp__GetModuleHandleExW@12
	test	eax, eax
	je	SHORT $LN36@SK_TopLeve

; 392  :                             (LPCWSTR)ip,
; 393  :                               &hModSource )) {
; 394  :     GetModuleFileNameA (hModSource, szModName, MAX_PATH);

	push	260					; 00000104H
	lea	eax, DWORD PTR _szModName$[ebp]
	push	eax
	push	DWORD PTR _hModSource$[ebp]
	call	DWORD PTR __imp__GetModuleFileNameA@12
$LN36@SK_TopLeve:

; 395  :   }
; 396  : 
; 397  : #ifdef _WIN64
; 398  :   DWORD64 BaseAddr =
; 399  :     SymGetModuleBase64 ( hProc, ip );
; 400  : #else
; 401  :   DWORD BaseAddr =
; 402  :     SymGetModuleBase   ( hProc, ip );

	push	esi
	push	edi
	call	DWORD PTR __imp__SymGetModuleBase@8
	mov	DWORD PTR _BaseAddr$1$[ebp], eax

; 403  : #endif
; 404  : 
; 405  :   char* szDupName    = _strdup (szModName);

	lea	eax, DWORD PTR _szModName$[ebp]
	push	eax
	call	DWORD PTR __imp___strdup
	add	esp, 4
	mov	DWORD PTR _szDupName$1$[ebp], eax

; 406  :   char* pszShortName = szDupName + lstrlenA (szDupName);

	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	mov	ecx, DWORD PTR _szDupName$1$[ebp]
	lea	esi, DWORD PTR [ecx+eax]

; 407  : 
; 408  :   while (  pszShortName      >  szDupName &&

	cmp	esi, ecx
	jbe	SHORT $LN507@SK_TopLeve
	npad	3
$LL4@SK_TopLeve:
	cmp	BYTE PTR [esi-1], 92			; 0000005cH
	je	SHORT $LN507@SK_TopLeve

; 409  :          *(pszShortName - 1) != '\\')
; 410  :     --pszShortName;

	dec	esi
	cmp	esi, ecx
	ja	SHORT $LL4@SK_TopLeve
$LN507@SK_TopLeve:

; 411  : 
; 412  :   crash_log.Log (L"-----------------------------------------------------------");

	push	OFFSET $SG250278
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _desc$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _desc$[ebp]
	cmovae	eax, DWORD PTR _desc$[ebp]
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 413  :   crash_log.Log (L"[! Except !] %s", desc.c_str ());

	push	eax
	push	OFFSET $SG250279
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 414  :   crash_log.Log (L"-----------------------------------------------------------");

	push	OFFSET $SG250280
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 415  :   crash_log.Log (L"[ FaultMod ]  # File.....: '%hs'",  szModName);

	lea	eax, DWORD PTR _szModName$[ebp]
	push	eax
	push	OFFSET $SG250281
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 416  : #ifndef _WIN64
; 417  :   crash_log.Log (L"[ FaultMod ]  * EIP Addr.: %hs+%08Xh", pszShortName, ip-BaseAddr);

	mov	eax, DWORD PTR _ip$1$[ebp]
	sub	eax, DWORD PTR _BaseAddr$1$[ebp]
	push	eax
	push	esi
	push	OFFSET $SG250282
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 418  : 
; 419  :   crash_log.Log ( L"[StackFrame] <-> Eip=%08xh, Esp=%08xh, Ebp=%08xh",

	mov	esi, DWORD PTR _ExceptionInfo$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR [eax+180]
	push	DWORD PTR [eax+196]
	push	DWORD PTR _ip$1$[ebp]
	push	OFFSET $SG250283
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 420  :                   ip,
; 421  :                     ExceptionInfo->ContextRecord->Esp,
; 422  :                       ExceptionInfo->ContextRecord->Ebp );
; 423  :   crash_log.Log ( L"[StackFrame] >-< Esi=%08xh, Edi=%08xh",

	mov	eax, DWORD PTR [esi+4]
	add	esp, 76					; 0000004cH
	push	DWORD PTR [eax+156]
	push	DWORD PTR [eax+160]
	push	OFFSET $SG250284
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 424  :                   ExceptionInfo->ContextRecord->Esi,
; 425  :                     ExceptionInfo->ContextRecord->Edi );
; 426  : 
; 427  :   crash_log.Log ( L"[  GP Reg  ]       eax:     0x%08x",

	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR [eax+176]
	push	OFFSET $SG250285
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 428  :                   ExceptionInfo->ContextRecord->Eax );
; 429  :   crash_log.Log ( L"[  GP Reg  ]       ebx:     0x%08x",

	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR [eax+164]
	push	OFFSET $SG250286
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 430  :                   ExceptionInfo->ContextRecord->Ebx );
; 431  :   crash_log.Log ( L"[  GP Reg  ]       ecx:     0x%08x",

	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR [eax+172]
	push	OFFSET $SG250287
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 432  :                   ExceptionInfo->ContextRecord->Ecx );
; 433  :   crash_log.Log ( L"[  GP Reg  ]       edx:     0x%08x",

	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR [eax+168]
	push	OFFSET $SG250288
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 434  :                   ExceptionInfo->ContextRecord->Edx );
; 435  :   crash_log.Log ( L"[ GP Flags ]       EFlags:  0x%08x",

	mov	eax, DWORD PTR [esi+4]
	add	esp, 64					; 00000040H
	push	DWORD PTR [eax+192]
	push	OFFSET $SG250289
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 436  :                   ExceptionInfo->ContextRecord->EFlags );
; 437  : #else
; 438  :   crash_log.Log (L"[ FaultMod ]  * RIP Addr.: %hs+%ph", pszShortName, (LPVOID)((uintptr_t)ip-(uintptr_t)BaseAddr));
; 439  : 
; 440  :   crash_log.Log ( L"[StackFrame] <-> Rip=%012llxh, Rsp=%012llxh, Rbp=%012llxh",
; 441  :                   ip,
; 442  :                     ExceptionInfo->ContextRecord->Rsp,
; 443  :                       ExceptionInfo->ContextRecord->Rbp );
; 444  :   crash_log.Log ( L"[StackFrame] >-< Rsi=%012llxh, Rdi=%012llxh",
; 445  :                   ExceptionInfo->ContextRecord->Rsi,
; 446  :                     ExceptionInfo->ContextRecord->Rdi );
; 447  : 
; 448  :   crash_log.Log ( L"[  GP Reg  ]       rax:     0x%012llx",
; 449  :                   ExceptionInfo->ContextRecord->Rax );
; 450  :   crash_log.Log ( L"[  GP Reg  ]       rbx:     0x%012llx",
; 451  :                   ExceptionInfo->ContextRecord->Rbx );
; 452  :   crash_log.Log ( L"[  GP Reg  ]       rcx:     0x%012llx",
; 453  :                   ExceptionInfo->ContextRecord->Rcx );
; 454  :   crash_log.Log ( L"[  GP Reg  ]       rdx:     0x%012llx",
; 455  :                   ExceptionInfo->ContextRecord->Rdx );
; 456  :   crash_log.Log ( L"[  GP Reg  ]        r8:     0x%012llx       r9:      0x%012llx",
; 457  :                   ExceptionInfo->ContextRecord->R8,
; 458  :                   ExceptionInfo->ContextRecord->R9 );
; 459  :   crash_log.Log ( L"[  GP Reg  ]       r10:     0x%012llx      r11:      0x%012llx",
; 460  :                   ExceptionInfo->ContextRecord->R10,
; 461  :                   ExceptionInfo->ContextRecord->R11 );
; 462  :   crash_log.Log ( L"[  GP Reg  ]       r12:     0x%012llx      r13:      0x%012llx",
; 463  :                   ExceptionInfo->ContextRecord->R12,
; 464  :                   ExceptionInfo->ContextRecord->R13 );
; 465  :   crash_log.Log ( L"[  GP Reg  ]       r14:     0x%012llx      r15:      0x%012llx",
; 466  :                   ExceptionInfo->ContextRecord->R14,
; 467  :                   ExceptionInfo->ContextRecord->R15 );
; 468  :   crash_log.Log ( L"[ GP Flags ]       EFlags:  0x%08x",
; 469  :                   ExceptionInfo->ContextRecord->EFlags );
; 470  : #endif
; 471  : 
; 472  :   crash_log.Log (

	push	OFFSET $SG250290
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 473  :     L"-----------------------------------------------------------");
; 474  : 
; 475  : #ifdef _WIN64
; 476  :   SymUnloadModule64 (hProc, BaseAddr);
; 477  : #else
; 478  :   SymUnloadModule   (hProc, BaseAddr);

	push	DWORD PTR _BaseAddr$1$[ebp]
	push	edi
	call	DWORD PTR __imp__SymUnloadModule@8

; 479  : #endif
; 480  : 
; 481  :   free (szDupName);

	mov	eax, DWORD PTR _szDupName$1$[ebp]
	push	eax
	call	DWORD PTR __imp__free

; 482  : 
; 483  :   CONTEXT ctx (*ExceptionInfo->ContextRecord);

	mov	esi, DWORD PTR [esi+4]
	lea	edi, DWORD PTR _ctx$[ebp]
	mov	ecx, 179				; 000000b3H
	rep movsd

; 488  :   STACKFRAME   stackframe = { };

	push	164					; 000000a4H
	lea	eax, DWORD PTR _stackframe$[ebp]
	push	0
	push	eax
	call	_memset

; 492  :   stackframe.AddrPC.Offset = ip;

	mov	eax, DWORD PTR _ip$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	ecx, DWORD PTR _top_func$[ebp]
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 488  :   STACKFRAME   stackframe = { };

	add	esp, 16					; 00000010H

; 492  :   stackframe.AddrPC.Offset = ip;

	mov	DWORD PTR _stackframe$[ebp], eax

; 495  : #ifdef _WIN64
; 496  :   stackframe.AddrStack.Offset = ctx.Rsp;
; 497  : #else
; 498  :   stackframe.AddrStack.Offset = ctx.Esp;

	mov	eax, DWORD PTR _ctx$[ebp+196]
	mov	DWORD PTR _stackframe$[ebp+36], eax

; 502  : #ifdef _WIN64
; 503  :   stackframe.AddrFrame.Offset = ctx.Rbp;
; 504  : #else
; 505  :   stackframe.AddrFrame.Offset = ctx.Ebp;

	mov	eax, DWORD PTR _ctx$[ebp+180]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET $SG250291
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 491  :   stackframe.AddrPC.Mode   = AddrModeFlat;

	mov	DWORD PTR _stackframe$[ebp+8], 3

; 493  : 
; 494  :   stackframe.AddrStack.Mode = AddrModeFlat;

	mov	DWORD PTR _stackframe$[ebp+44], 3

; 499  : #endif
; 500  : 
; 501  :   stackframe.AddrFrame.Mode = AddrModeFlat;

	mov	DWORD PTR _stackframe$[ebp+32], 3

; 502  : #ifdef _WIN64
; 503  :   stackframe.AddrFrame.Offset = ctx.Rbp;
; 504  : #else
; 505  :   stackframe.AddrFrame.Offset = ctx.Ebp;

	mov	DWORD PTR _stackframe$[ebp+24], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR _top_func$[ebp+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _top_func$[ebp+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR _top_func$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 508  :   std::string top_func = "";

	mov	esi, DWORD PTR _hProc$1$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
$LL8@SK_TopLeve:

; 509  : 
; 510  :   BOOL ret = TRUE;
; 511  : 
; 512  :   do
; 513  :   {
; 514  :     SymRefreshModuleList ( hProc );

	push	esi
	call	DWORD PTR __imp__SymRefreshModuleList@4

; 515  : 
; 516  :     ip = stackframe.AddrPC.Offset;

	mov	edi, DWORD PTR _stackframe$[ebp]

; 517  : 
; 518  :     if ( GetModuleHandleEx ( GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,

	lea	eax, DWORD PTR _hModSource$[ebp]
	push	eax
	push	edi
	push	4
	mov	DWORD PTR _ip$2$[ebp], edi
	call	DWORD PTR __imp__GetModuleHandleExW@12
	test	eax, eax
	je	SHORT $LN37@SK_TopLeve

; 519  :               reinterpret_cast <LPCWSTR> (ip),
; 520  :                                  &hModSource ) )
; 521  :     {
; 522  :       GetModuleFileNameA (hModSource, szModName, MAX_PATH);

	push	260					; 00000104H
	lea	eax, DWORD PTR _szModName$[ebp]
	push	eax
	push	DWORD PTR _hModSource$[ebp]
	call	DWORD PTR __imp__GetModuleFileNameA@12
$LN37@SK_TopLeve:

; 523  :     }
; 524  : 
; 525  : #ifdef _WIN64
; 526  :     BaseAddr =
; 527  :       SymGetModuleBase64 ( hProc, ip );
; 528  : #else
; 529  :     BaseAddr =

	push	edi
	push	esi
	call	DWORD PTR __imp__SymGetModuleBase@8
	mov	DWORD PTR _BaseAddr$2$[ebp], eax

; 530  :       SymGetModuleBase   ( hProc, ip );
; 531  : #endif
; 532  : 
; 533  :     szDupName    = _strdup (szModName);

	lea	eax, DWORD PTR _szModName$[ebp]
	push	eax
	call	DWORD PTR __imp___strdup
	add	esp, 4
	mov	edi, eax

; 534  :     pszShortName = szDupName + lstrlenA (szDupName);

	push	edi
	call	DWORD PTR __imp__lstrlenA@4
	lea	esi, DWORD PTR [edi+eax]

; 535  : 
; 536  :     while (  pszShortName      >  szDupName &&

	cmp	esi, edi
	jbe	SHORT $LN508@SK_TopLeve
$LL9@SK_TopLeve:
	cmp	BYTE PTR [esi-1], 92			; 0000005cH
	je	SHORT $LN508@SK_TopLeve

; 537  :            *(pszShortName - 1) != '\\')
; 538  :       --pszShortName;

	dec	esi
	cmp	esi, edi
	ja	SHORT $LL9@SK_TopLeve
$LN508@SK_TopLeve:

; 539  : 
; 540  : #ifdef _WIN64
; 541  :     SymLoadModule64 ( hProc,
; 542  :                         nullptr,
; 543  :                           pszShortName,
; 544  :                             nullptr,
; 545  :                               BaseAddr,
; 546  :                                 0 );
; 547  : #else
; 548  :     SymLoadModule ( hProc,

	push	0
	push	DWORD PTR _BaseAddr$2$[ebp]
	push	0
	push	esi
	push	0
	push	DWORD PTR _hProc$1$[ebp]
	call	DWORD PTR __imp__SymLoadModule@24

; 549  :                       nullptr,
; 550  :                         pszShortName,
; 551  :                           nullptr,
; 552  :                             BaseAddr,
; 553  :                               0 );
; 554  : #endif
; 555  : 
; 556  :     SYMBOL_INFO_PACKAGE sip = { };

	push	2096					; 00000830H
	lea	eax, DWORD PTR _sip$3[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 557  : 
; 558  :     sip.si.SizeOfStruct = sizeof SYMBOL_INFO;

	mov	DWORD PTR _sip$3[ebp], 88		; 00000058H

; 559  :     sip.si.MaxNameLen   = sizeof sip.name;
; 560  : 
; 561  :     DWORD64 Displacement = 0;
; 562  : 
; 563  :     if ( SymFromAddr ( hProc,

	lea	eax, DWORD PTR _sip$3[ebp]
	mov	DWORD PTR _sip$3[ebp+80], 2001		; 000007d1H
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _Displacement$12[ebp], xmm0
	push	eax
	lea	eax, DWORD PTR _Displacement$12[ebp]
	push	eax
	push	0
	push	DWORD PTR _ip$2$[ebp]
	push	DWORD PTR _hProc$1$[ebp]
	call	DWORD PTR __imp__SymFromAddr@20
	test	eax, eax
	je	$LN38@SK_TopLeve

; 564  :              static_cast <DWORD64> (ip),
; 565  :                            &Displacement,
; 566  :                              &sip.si ) )
; 567  :     {
; 568  :       DWORD Disp = 0x00UL;
; 569  : #ifdef _WIN64
; 570  :       IMAGEHLP_LINE64 ihl64;
; 571  :       ihl64.SizeOfStruct = sizeof IMAGEHLP_LINE64;
; 572  : 
; 573  :       BOOL  bFileAndLine =
; 574  :         SymGetLineFromAddr64 ( hProc, ip, &Disp, &ihl64 );
; 575  : 
; 576  :       if (bFileAndLine)
; 577  :       {
; 578  :         crash_log.Log ( L"[-(Source)-] [!] {%24hs} %#64hs  <%hs:%lu> ",
; 579  :                         pszShortName,
; 580  :                           sip.si.Name,
; 581  :                             ihl64.FileName,
; 582  :                               ihl64.LineNumber );
; 583  : #else
; 584  :       IMAGEHLP_LINE ihl              = {                  };
; 585  :                     ihl.SizeOfStruct = sizeof IMAGEHLP_LINE;
; 586  : 
; 587  :       const BOOL bFileAndLine =
; 588  :         SymGetLineFromAddr ( hProc, ip, &Disp, &ihl );

	lea	eax, DWORD PTR _ihl$13[ebp]
	mov	DWORD PTR _Disp$16[ebp], 0
	push	eax
	lea	eax, DWORD PTR _Disp$16[ebp]
	mov	DWORD PTR _ihl$13[ebp+16], 0
	push	eax
	push	DWORD PTR _ip$2$[ebp]
	xorps	xmm0, xmm0
	push	DWORD PTR _hProc$1$[ebp]
	movups	XMMWORD PTR _ihl$13[ebp], xmm0
	mov	DWORD PTR _ihl$13[ebp], 20		; 00000014H
	call	DWORD PTR __imp__SymGetLineFromAddr@16

; 589  : 
; 590  :       if (bFileAndLine)

	test	eax, eax

; 591  :       {
; 592  :         crash_log.Log ( L"[-(Source)-] [!] {%24hs}  %#64hs  <%hs:%lu>",

	lea	eax, DWORD PTR _sip$3[ebp+84]
	je	SHORT $LN39@SK_TopLeve
	push	DWORD PTR _ihl$13[ebp+8]
	push	DWORD PTR _ihl$13[ebp+12]
	push	eax
	push	esi
	push	OFFSET $SG250296
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 24					; 00000018H

; 593  :                         pszShortName,
; 594  :                           sip.si.Name,
; 595  :                             ihl.FileName,
; 596  :                               ihl.LineNumber );
; 597  : #endif
; 598  :       }
; 599  : 
; 600  :       else

	jmp	SHORT $LN40@SK_TopLeve
$LN39@SK_TopLeve:

; 601  :       {
; 602  :         crash_log.Log ( L"[--(Name)--] [!] {%24hs}  %#64hs",

	push	eax
	push	esi
	push	OFFSET $SG250297
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H
$LN40@SK_TopLeve:

; 607  :       if (StrStrIA (sip.si.Name, "Scaleform"))

	push	OFFSET $SG250299
	lea	eax, DWORD PTR _sip$3[ebp+84]
	push	eax
	call	DWORD PTR __imp__StrStrIA@8
	mov	ecx, DWORD PTR tv1372[ebp]
	test	eax, eax
	movzx	ecx, cl
	mov	eax, 1
	cmovne	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	cmp	DWORD PTR _top_func$[ebp+16], 0
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 607  :       if (StrStrIA (sip.si.Name, "Scaleform"))

	mov	DWORD PTR tv1372[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	jne	SHORT $LN42@SK_TopLeve
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	jne	SHORT $LN42@SK_TopLeve
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	ecx, DWORD PTR _sip$3[ebp+84]
	lea	edx, DWORD PTR [ecx+1]
	npad	2
$LL496@SK_TopLeve:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL496@SK_TopLeve
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	eax, DWORD PTR _sip$3[ebp+84]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _top_func$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN42@SK_TopLeve:
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 613  :       free (szDupName);

	push	edi
	call	DWORD PTR __imp__free
	add	esp, 4
$LN38@SK_TopLeve:

; 614  :     }
; 615  : 
; 616  : #ifdef _WIN64
; 617  :     SymUnloadModule64 (hProc, BaseAddr);
; 618  : #else
; 619  :     SymUnloadModule   (hProc, BaseAddr);

	push	DWORD PTR _BaseAddr$2$[ebp]
	mov	esi, DWORD PTR _hProc$1$[ebp]
	push	esi
	call	DWORD PTR __imp__SymUnloadModule@8

; 620  : #endif
; 621  : 
; 622  : #ifdef _WIN64
; 623  :     ret =
; 624  :       StackWalk64 ( IMAGE_FILE_MACHINE_AMD64,
; 625  :                       hProc,
; 626  :                         GetCurrentThread (),
; 627  :                           &stackframe,
; 628  :                             &ctx,
; 629  :                               nullptr, nullptr,
; 630  :                                 nullptr, nullptr );
; 631  : #else
; 632  :     ret =

	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	lea	eax, DWORD PTR _stackframe$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	push	esi
	push	332					; 0000014cH
	call	DWORD PTR __imp__StackWalk@36

; 633  :       StackWalk ( IMAGE_FILE_MACHINE_I386,
; 634  :                     hProc,
; 635  :                       GetCurrentThread (),
; 636  :                         &stackframe,
; 637  :                           &ctx,
; 638  :                             nullptr, nullptr,
; 639  :                               nullptr, nullptr );
; 640  : 
; 641  : #endif
; 642  :   } while (ret == TRUE);

	cmp	eax, 1
	je	$LL8@SK_TopLeve

; 643  : 
; 644  :   crash_log.Log (L"-----------------------------------------------------------");

	push	OFFSET $SG250302
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 645  : 
; 646  : 
; 647  :   // On second chance it's pretty clear that no exception handler exists,
; 648  :   //   terminate the software.
; 649  :   const bool repeated = ( !memcmp (&last_ctx, ExceptionInfo->ContextRecord,   sizeof CONTEXT)         ) &&

	mov	edi, DWORD PTR _ExceptionInfo$[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR _last_ctx$1$[ebp]
	mov	esi, 712				; 000002c8H
	mov	edi, DWORD PTR [edi+4]
	mov	edx, edi
$LL498@SK_TopLeve:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN66@SK_TopLeve
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL498@SK_TopLeve
	mov	eax, DWORD PTR _ExceptionInfo$[ebp]
	mov	esi, 76					; 0000004cH
	mov	ecx, DWORD PTR _last_exc$1$[ebp]
	mov	edx, DWORD PTR [eax]
$LL500@SK_TopLeve:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN66@SK_TopLeve
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL500@SK_TopLeve
	mov	cl, 1
	jmp	SHORT $LN67@SK_TopLeve
$LN66@SK_TopLeve:
	xor	cl, cl
$LN67@SK_TopLeve:

; 650  :                         ( !memcmp (&last_exc, ExceptionInfo->ExceptionRecord, sizeof EXCEPTION_RECORD) );
; 651  :   const bool non_continue = ExceptionInfo->ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE;

	mov	edx, DWORD PTR _ExceptionInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	al, BYTE PTR [eax+4]
	and	al, 1

; 652  : 
; 653  :   if ( (repeated || non_continue) && (! scaleform) && desc.length () )

	test	cl, cl
	jne	SHORT $LN44@SK_TopLeve
	test	al, al
	je	$LN43@SK_TopLeve
$LN44@SK_TopLeve:
	mov	eax, DWORD PTR tv1372[ebp]
	test	al, al
	jne	$LN43@SK_TopLeve
	cmp	DWORD PTR _desc$[ebp+16], 0
	je	$LN43@SK_TopLeve

; 654  :   {
; 655  :     if (! config.system.handle_crashes)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+840, al
	jne	SHORT $LN45@SK_TopLeve

; 656  :       TerminateProcess (GetCurrentProcess (), 0xdeadbeef);

	push	-559038737				; deadbeefH
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__TerminateProcess@8
$LN45@SK_TopLeve:

; 657  : 
; 658  :     SK_AutoClose_Log (crash_log);

	lea	eax, DWORD PTR _closeme_crash_log$15[ebp]
	mov	ecx, OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	push	eax
	call	?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ ; iSK_Logger::auto_close

; 659  : 
; 660  :     last_chance = true;

	mov	eax, DWORD PTR _last_chance$1$[ebp]

; 661  : 
; 662  :     WIN32_FIND_DATA fd     = {                  };

	push	592					; 00000250H
	push	0
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR [eax], 1
	lea	eax, DWORD PTR _fd$10[ebp]
	push	eax
	call	_memset

; 663  :     HANDLE          hFind  = INVALID_HANDLE_VALUE;
; 664  :     size_t          files  =   0UL;
; 665  :     LARGE_INTEGER   liSize = { 0ULL };
; 666  : 
; 667  :     wchar_t wszFindPattern [MAX_PATH * 2] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _wszFindPattern$2[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 24					; 00000018H

; 668  : 
; 669  :     lstrcatW (wszFindPattern, SK_GetConfigPath ());

	call	?SK_GetConfigPath@@YGPB_WXZ		; SK_GetConfigPath
	mov	edi, DWORD PTR __imp__lstrcatW@8
	push	eax
	lea	eax, DWORD PTR _wszFindPattern$2[ebp]
	push	eax
	call	edi

; 670  :     lstrcatW (wszFindPattern, L"logs\\*.log");

	push	OFFSET $SG250306
	lea	eax, DWORD PTR _wszFindPattern$2[ebp]
	push	eax
	call	edi

; 671  : 
; 672  :     hFind =

	lea	eax, DWORD PTR _fd$10[ebp]
	push	eax
	lea	eax, DWORD PTR _wszFindPattern$2[ebp]
	push	eax
	call	DWORD PTR __imp__FindFirstFileW@8
	mov	DWORD PTR _hFind$1$[ebp], eax

; 673  :       FindFirstFileW (wszFindPattern, &fd);
; 674  : 
; 675  :     if (hFind != INVALID_HANDLE_VALUE)

	cmp	eax, -1
	je	$LN46@SK_TopLeve

; 676  :     {
; 677  :       wchar_t wszBaseDir [MAX_PATH * 2] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _wszBaseDir$5[ebp]
	push	0
	push	eax
	call	_memset

; 678  :       wchar_t wszOutDir  [MAX_PATH * 2] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _wszOutDir$4[ebp]
	push	0
	push	eax
	call	_memset

; 679  :       wchar_t wszTime    [MAX_PATH + 2] = { };

	push	524					; 0000020cH
	lea	eax, DWORD PTR _wszTime$6[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 36					; 00000024H

; 680  : 
; 681  :       lstrcatW (wszBaseDir, SK_GetConfigPath ( ));

	call	?SK_GetConfigPath@@YGPB_WXZ		; SK_GetConfigPath
	push	eax
	lea	eax, DWORD PTR _wszBaseDir$5[ebp]
	push	eax
	call	edi

; 682  :       lstrcatW (wszBaseDir, L"logs\\");

	push	OFFSET $SG250308
	lea	eax, DWORD PTR _wszBaseDir$5[ebp]
	push	eax
	call	edi

; 683  : 
; 684  :       wcscpy (wszOutDir, wszBaseDir);

	xor	ecx, ecx
	npad	3
$LL68@SK_TopLeve:
	movzx	eax, WORD PTR _wszBaseDir$5[ebp+ecx]
	lea	ecx, DWORD PTR [ecx+2]
	mov	WORD PTR _wszOutDir$4[ebp+ecx-2], ax
	test	ax, ax
	jne	SHORT $LL68@SK_TopLeve

; 685  :       lstrcatW (wszOutDir, L"crash\\");

	push	OFFSET $SG250309
	lea	eax, DWORD PTR _wszOutDir$4[ebp]
	push	eax
	call	edi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

	lea	eax, DWORD PTR _now$14[ebp]
	xorps	xmm0, xmm0
	push	eax
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 687  :              time_t now = { };

	movlpd	QWORD PTR _now$14[ebp], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

	call	DWORD PTR __imp___time64

; 511  :             return _localtime64(_Time);

	lea	eax, DWORD PTR _now$14[ebp]
	push	eax
	call	DWORD PTR __imp___localtime64
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 695  :       wcsftime (wszTime, MAX_PATH, wszTimestamp, now_tm);

	push	eax
	push	OFFSET $SG250310
	lea	eax, DWORD PTR _wszTime$6[ebp]
	push	260					; 00000104H
	push	eax
	call	DWORD PTR __imp__wcsftime
	add	esp, 24					; 00000018H

; 696  :       lstrcatW (wszOutDir, wszTime);

	lea	eax, DWORD PTR _wszTime$6[ebp]
	push	eax
	lea	eax, DWORD PTR _wszOutDir$4[ebp]
	push	eax
	call	edi

; 697  : 
; 698  :       wchar_t wszOrigPath [MAX_PATH * 2 + 1] = { };

	push	1042					; 00000412H
	lea	eax, DWORD PTR _wszOrigPath$7[ebp]
	push	0
	push	eax
	call	_memset

; 699  :       wchar_t wszDestPath [MAX_PATH * 2 + 1] = { };

	push	1042					; 00000412H
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	0
	push	eax
	call	_memset
	mov	esi, DWORD PTR __imp__CopyFileExW@24
	add	esp, 24					; 00000018H
	npad	4
$LL13@SK_TopLeve:

; 700  : 
; 701  :       do
; 702  :       {
; 703  :         if (fd.dwFileAttributes != INVALID_FILE_ATTRIBUTES)

	cmp	DWORD PTR _fd$10[ebp], -1
	je	$LN11@SK_TopLeve

; 704  :         {
; 705  :           *wszOrigPath = L'\0';

	xor	eax, eax
	mov	WORD PTR _wszOrigPath$7[ebp], ax

; 706  :           *wszDestPath = L'\0';

	mov	WORD PTR _wszDestPath$8[ebp], ax

; 707  : 
; 708  :           lstrcatW (wszOrigPath, wszBaseDir);

	lea	eax, DWORD PTR _wszBaseDir$5[ebp]
	push	eax
	lea	eax, DWORD PTR _wszOrigPath$7[ebp]
	push	eax
	call	edi

; 709  :           lstrcatW (wszOrigPath, fd.cFileName);

	lea	eax, DWORD PTR _fd$10[ebp+44]
	push	eax
	lea	eax, DWORD PTR _wszOrigPath$7[ebp]
	push	eax
	call	edi

; 710  : 
; 711  :           lstrcatW (wszDestPath, wszOutDir);

	lea	eax, DWORD PTR _wszOutDir$4[ebp]
	push	eax
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	call	edi

; 712  :           lstrcatW (wszDestPath, fd.cFileName);

	lea	eax, DWORD PTR _fd$10[ebp+44]
	push	eax
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	call	edi

; 713  : 
; 714  :           SK_CreateDirectories (wszDestPath);

	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	call	?SK_CreateDirectories@@YG_NPB_W@Z	; SK_CreateDirectories

; 715  : 
; 716  :           if (! StrStrIW (wszOrigPath, L"installer.log"))

	push	OFFSET $SG250313
	lea	eax, DWORD PTR _wszOrigPath$7[ebp]
	push	eax
	call	DWORD PTR __imp__StrStrIW@8
	test	eax, eax
	jne	$LN11@SK_TopLeve
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	ecx, DWORD PTR _fd$10[ebp+44]
	lea	edx, DWORD PTR [ecx+2]
	npad	4
$LL501@SK_TopLeve:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL501@SK_TopLeve
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	mov	eax, OFFSET ?dll_log@@3UiSK_Logger@@A+8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR ?dll_log@@3UiSK_Logger@@A+28, 8

; 3228 : 		return (static_cast<size_type>(

	push	ecx

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR ?dll_log@@3UiSK_Logger@@A+8

; 3228 : 		return (static_cast<size_type>(

	lea	ecx, DWORD PTR _fd$10[ebp+44]
	push	ecx
	push	0
	push	DWORD PTR ?dll_log@@3UiSK_Logger@@A+24
	push	eax
	call	??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z ; std::_Traits_find<std::char_traits<wchar_t> >
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 718  :             if (dll_log.name.find (fd.cFileName) != std::wstring::npos)

	cmp	eax, -1
	je	SHORT $LN49@SK_TopLeve

; 719  :             {
; 720  :               dll_log.close ();

	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?close@iSK_Logger@@UAGXXZ		; iSK_Logger::close
$LN49@SK_TopLeve:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	ecx, DWORD PTR _fd$10[ebp+44]
	lea	edx, DWORD PTR [ecx+2]
$LL502@SK_TopLeve:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL502@SK_TopLeve
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	mov	eax, OFFSET ?steam_log@@3UiSK_Logger@@A+8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR ?steam_log@@3UiSK_Logger@@A+28, 8

; 3228 : 		return (static_cast<size_type>(

	push	ecx

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR ?steam_log@@3UiSK_Logger@@A+8

; 3228 : 		return (static_cast<size_type>(

	lea	ecx, DWORD PTR _fd$10[ebp+44]
	push	ecx
	push	0
	push	DWORD PTR ?steam_log@@3UiSK_Logger@@A+24
	push	eax
	call	??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z ; std::_Traits_find<std::char_traits<wchar_t> >
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 728  :             if (steam_log.name.find (fd.cFileName) != std::wstring::npos)

	cmp	eax, -1
	je	SHORT $LN50@SK_TopLeve

; 729  :             {
; 730  :               steam_log.close ();

	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?close@iSK_Logger@@UAGXXZ		; iSK_Logger::close
$LN50@SK_TopLeve:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	ecx, DWORD PTR _fd$10[ebp+44]
	lea	edx, DWORD PTR [ecx+2]
$LL503@SK_TopLeve:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL503@SK_TopLeve
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	mov	eax, OFFSET ?game_debug@@3UiSK_Logger@@A+8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR ?game_debug@@3UiSK_Logger@@A+28, 8

; 3228 : 		return (static_cast<size_type>(

	push	ecx

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR ?game_debug@@3UiSK_Logger@@A+8

; 3228 : 		return (static_cast<size_type>(

	lea	ecx, DWORD PTR _fd$10[ebp+44]
	push	ecx
	push	0
	push	DWORD PTR ?game_debug@@3UiSK_Logger@@A+24
	push	eax
	call	??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z ; std::_Traits_find<std::char_traits<wchar_t> >
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 733  :             if (game_debug.name.find (fd.cFileName) != std::wstring::npos)

	cmp	eax, -1
	je	SHORT $LN51@SK_TopLeve

; 734  :             {
; 735  :               game_debug.close ();

	push	OFFSET ?game_debug@@3UiSK_Logger@@A	; game_debug
	call	?close@iSK_Logger@@UAGXXZ		; iSK_Logger::close
$LN51@SK_TopLeve:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	eax, DWORD PTR _fd$10[ebp+44]
	lea	edx, DWORD PTR [eax+2]
	npad	7
$LL504@SK_TopLeve:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL504@SK_TopLeve
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	mov	ecx, OFFSET ?budget_log@@3UiSK_Logger@@A+8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR ?budget_log@@3UiSK_Logger@@A+28, 8

; 3228 : 		return (static_cast<size_type>(

	push	eax

; 1621 : 		return (_Large_string_engaged()

	cmovae	ecx, DWORD PTR ?budget_log@@3UiSK_Logger@@A+8

; 3228 : 		return (static_cast<size_type>(

	lea	eax, DWORD PTR _fd$10[ebp+44]
	push	eax
	push	0
	push	DWORD PTR ?budget_log@@3UiSK_Logger@@A+24
	push	ecx
	call	??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z ; std::_Traits_find<std::char_traits<wchar_t> >
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 738  :             if (budget_log.name.find (fd.cFileName) != std::wstring::npos)

	cmp	eax, -1
	je	SHORT $LN52@SK_TopLeve

; 739  :             {
; 740  :               budget_log.close ();

	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?close@iSK_Logger@@UAGXXZ		; iSK_Logger::close
$LN52@SK_TopLeve:

; 741  :             }
; 742  : 
; 743  :             // There's a small chance that we may crash prior to loading CEGUI's DLLs, in which case
; 744  :             //   trying to grab a static reference to the Logger Singleton would blow stuff up.
; 745  :             //
; 746  :             //   Avoid this by counting the number of frames actually drawn.
; 747  :             if (StrStrW (fd.cFileName, L"CEGUI.log") && SK_GetFramesDrawn () > 120)

	push	OFFSET $SG250320
	lea	eax, DWORD PTR _fd$10[ebp+44]
	push	eax
	call	DWORD PTR __imp__StrStrW@8
	test	eax, eax
	je	$LN53@SK_TopLeve
	call	?SK_GetFramesDrawn@@YGKXZ		; SK_GetFramesDrawn
	cmp	eax, 120				; 00000078H
	jbe	$LN53@SK_TopLeve

; 748  :             {
; 749  :               CopyFileExW ( L"CEGUI.log", wszDestPath,

	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	push	OFFSET $SG250321
	call	esi

; 752  :               CEGUI::Logger::getDllSingleton ().

	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 752  :               CEGUI::Logger::getDllSingleton ().

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN366@SK_TopLeve
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN366@SK_TopLeve:
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL505@SK_TopLeve:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL505@SK_TopLeve
	sub	ecx, edx
	push	ecx
	push	esi
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 752  :               CEGUI::Logger::getDllSingleton ().

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	DWORD PTR __imp_?getDllSingleton@?$Singleton@VLogger@CEGUI@@@CEGUI@@SAAAVLogger@2@XZ
	push	1
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
	lea	ecx, DWORD PTR $T11[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	esi, DWORD PTR __imp__CopyFileExW@24
	jmp	$LN59@SK_TopLeve
$LN53@SK_TopLeve:

; 753  :                 setLogFilename (SK_WideCharToUTF8 (wszDestPath).c_str (), true);
; 754  :             }
; 755  : 
; 756  :             else if (CopyFileExW (wszOrigPath, wszDestPath, nullptr, nullptr,nullptr, 0x00))

	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	lea	eax, DWORD PTR _wszOrigPath$7[ebp]
	push	eax
	call	esi
	test	eax, eax
	je	$LN59@SK_TopLeve

; 757  :             {
; 758  :               ++files;
; 759  : 
; 760  :               if (dll_log.name.find (fd.cFileName) != std::wstring::npos)

	push	0
	lea	eax, DWORD PTR _fd$10[ebp+44]
	mov	ecx, OFFSET ?dll_log@@3UiSK_Logger@@A+8
	push	eax
	call	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
	cmp	eax, -1
	je	SHORT $LN56@SK_TopLeve

; 761  :               {
; 762  :                 dll_log.init  (wszDestPath, L"a");

	push	OFFSET $SG250324
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?init@iSK_Logger@@UAG_NQB_W0@Z		; iSK_Logger::init
$LN56@SK_TopLeve:

; 763  :               }
; 764  : 
; 765  :               if (steam_log.name.find (fd.cFileName) != std::wstring::npos)

	push	0
	lea	eax, DWORD PTR _fd$10[ebp+44]
	mov	ecx, OFFSET ?steam_log@@3UiSK_Logger@@A+8
	push	eax
	call	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
	cmp	eax, -1
	je	SHORT $LN57@SK_TopLeve

; 766  :               {
; 767  :                 steam_log.init  (wszDestPath, L"a");

	push	OFFSET $SG250326
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?init@iSK_Logger@@UAG_NQB_W0@Z		; iSK_Logger::init
$LN57@SK_TopLeve:

; 768  :               }
; 769  : 
; 770  :               if (game_debug.name.find (fd.cFileName) != std::wstring::npos)

	push	0
	lea	eax, DWORD PTR _fd$10[ebp+44]
	mov	ecx, OFFSET ?game_debug@@3UiSK_Logger@@A+8
	push	eax
	call	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
	cmp	eax, -1
	je	SHORT $LN58@SK_TopLeve

; 771  :               {
; 772  :                 game_debug.init  (wszDestPath, L"a");

	push	OFFSET $SG250328
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	push	OFFSET ?game_debug@@3UiSK_Logger@@A	; game_debug
	call	?init@iSK_Logger@@UAG_NQB_W0@Z		; iSK_Logger::init
$LN58@SK_TopLeve:

; 773  :               }
; 774  : 
; 775  :               if (budget_log.name.find (fd.cFileName) != std::wstring::npos)

	push	0
	lea	eax, DWORD PTR _fd$10[ebp+44]
	mov	ecx, OFFSET ?budget_log@@3UiSK_Logger@@A+8
	push	eax
	call	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
	cmp	eax, -1
	je	SHORT $LN59@SK_TopLeve

; 776  :               {
; 777  :                 budget_log.init  (wszDestPath, L"a");

	push	OFFSET $SG250330
	lea	eax, DWORD PTR _wszDestPath$8[ebp]
	push	eax
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?init@iSK_Logger@@UAG_NQB_W0@Z		; iSK_Logger::init
$LN59@SK_TopLeve:

; 778  :               }
; 779  :             }
; 780  : 
; 781  :             DeleteFileW (wszOrigPath);

	lea	eax, DWORD PTR _wszOrigPath$7[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteFileW@4
$LN11@SK_TopLeve:

; 782  :           }
; 783  :         }
; 784  :       } while (FindNextFileW (hFind, &fd) != 0);

	lea	eax, DWORD PTR _fd$10[ebp]
	push	eax
	push	DWORD PTR _hFind$1$[ebp]
	call	DWORD PTR __imp__FindNextFileW@8
	test	eax, eax
	jne	$LL13@SK_TopLeve

; 785  : 
; 786  :       FindClose (hFind);

	push	DWORD PTR _hFind$1$[ebp]
	call	DWORD PTR __imp__FindClose@4
$LN46@SK_TopLeve:

; 787  :     }
; 788  : 
; 789  :     if (crash_log.fLog && (! crash_log.silent))

	cmp	DWORD PTR ?crash_log@@3UiSK_Logger@@A+4, 0
	je	SHORT $LN60@SK_TopLeve
	cmp	BYTE PTR ?crash_log@@3UiSK_Logger@@A+32, 0
	jne	SHORT $LN60@SK_TopLeve

; 790  :       PlaySound ( reinterpret_cast <LPCWSTR> (crash_sound.buf),

	push	4
	push	0
	push	DWORD PTR ?crash_sound@@3U<unnamed-type-crash_sound>@@A+4
	call	DWORD PTR __imp__PlaySoundW@12
$LN60@SK_TopLeve:

; 791  :                     nullptr,
; 792  :                       SND_SYNC |
; 793  :                       SND_MEMORY );
; 794  : 
; 795  : 
; 796  :     // Shutdown the module gracefully
; 797  :     SK_SelfDestruct ();

	call	?SK_SelfDestruct@@YGXXZ			; SK_SelfDestruct
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 158  :       if (log_ != nullptr)

	mov	eax, DWORD PTR _closeme_crash_log$15[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN402@SK_TopLeve

; 159  :         log_->close ();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+20]
$LN402@SK_TopLeve:
	mov	esi, 1
	jmp	SHORT $LN75@SK_TopLeve
$LN43@SK_TopLeve:
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 802  :   last_ctx = *ExceptionInfo->ContextRecord;

	mov	esi, edi
	mov	ecx, 179				; 000000b3H
	mov	edi, DWORD PTR _last_ctx$1$[ebp]
	rep movsd

; 803  :   last_exc = *ExceptionInfo->ExceptionRecord;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _last_exc$1$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR [ecx+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	movups	XMMWORD PTR [ecx+64], xmm0

; 804  : 
; 805  : 
; 806  :   if ( ExceptionInfo->ExceptionRecord->ExceptionFlags == 0 ||

	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN63@SK_TopLeve
	cmp	DWORD PTR _desc$[ebp+16], 0
	je	SHORT $LN63@SK_TopLeve

; 811  :   }
; 812  : 
; 813  :   else
; 814  :   {
; 815  :     return EXCEPTION_EXECUTE_HANDLER;

	mov	esi, 1
	jmp	SHORT $LN75@SK_TopLeve
$LN63@SK_TopLeve:

; 807  :        (! desc.length ())
; 808  :      )
; 809  :   {
; 810  :     return EXCEPTION_CONTINUE_EXECUTION;

	or	esi, -1
$LN75@SK_TopLeve:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _top_func$[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN421@SK_TopLeve
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _top_func$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN421@SK_TopLeve:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR _desc$[ebp+20]

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR _top_func$[ebp+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _top_func$[ebp+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR _top_func$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN506@SK_TopLeve
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _desc$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN506@SK_TopLeve:
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 817  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN511@SK_TopLeve:
	DD	$LN28@SK_TopLeve
	DD	$LN27@SK_TopLeve
	DD	$LN32@SK_TopLeve
	DD	$LN31@SK_TopLeve
	DD	$LN17@SK_TopLeve
	DD	$LN20@SK_TopLeve
	DD	$LN21@SK_TopLeve
	DD	$LN22@SK_TopLeve
	DD	$LN23@SK_TopLeve
	DD	$LN24@SK_TopLeve
	DD	$LN25@SK_TopLeve
	DD	$LN26@SK_TopLeve
	DD	$LN29@SK_TopLeve
	DD	$LN30@SK_TopLeve
	DD	$LN33@SK_TopLeve
	DD	$LN35@SK_TopLeve
	DD	$LN2@SK_TopLeve
$LN495@SK_TopLeve:
	DB	0
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	1
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	2
	DB	3
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	15					; 0000000fH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$0:
	lea	ecx, DWORD PTR _desc$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$1:
	lea	ecx, DWORD PTR _top_func$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$2:
	lea	ecx, DWORD PTR _closeme_crash_log$15[ebp]
	jmp	??1AutoClose@iSK_Logger@@QAE@XZ		; iSK_Logger::AutoClose::~AutoClose
__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$4:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z$5:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__ehhandler$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ENDP ; SK_TopLevelExceptionFilter
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\intsafe.h
;	COMDAT ?UIntPtrToLongLong@@YAJIPA_J@Z
_TEXT	SEGMENT
_uOperand$ = 8						; size = 4
_pllResult$ = 12					; size = 4
?UIntPtrToLongLong@@YAJIPA_J@Z PROC			; UIntPtrToLongLong, COMDAT

; 2868 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2869 :     *pllResult = (LONGLONG)uOperand;

	mov	ecx, DWORD PTR _pllResult$[ebp]
	mov	eax, DWORD PTR _uOperand$[ebp]
	mov	DWORD PTR [ecx], eax

; 2870 :     return S_OK;

	xor	eax, eax
	mov	DWORD PTR [ecx+4], 0

; 2871 : }

	pop	ebp
	ret	0
?UIntPtrToLongLong@@YAJIPA_J@Z ENDP			; UIntPtrToLongLong
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?unlock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?unlock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::unlock, COMDAT
; _this$ = ecx

; 269  :     LeaveCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 270  :   }

	ret	0
?unlock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?lock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?lock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::lock, COMDAT
; _this$ = ecx

; 264  :     EnterCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__EnterCriticalSection@4

; 265  :   }

	ret	0
?lock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 534  :         {

	npad	2
	push	ebp
	mov	ebp, esp

; 536  :         }

	pop	ebp

; 535  :             return _time64(_Time);

	jmp	DWORD PTR __imp___time64
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC

; 508  :         {

	npad	2
	push	ebp
	mov	ebp, esp

; 512  :             #pragma warning(pop)
; 513  :         }

	pop	ebp

; 509  :             #pragma warning(push)
; 510  :             #pragma warning(disable: 4996)
; 511  :             return _localtime64(_Time);

	jmp	DWORD PTR __imp___localtime64
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ??_GiSK_Logger@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GiSK_Logger@@UAEPAXI@Z PROC				; iSK_Logger::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 180  :     Release ();

	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7iSK_Logger@@6B@
	call	?Release@iSK_Logger@@UAGKXZ		; iSK_Logger::Release
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN11@scalar
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+8]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN11@scalar:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+24], 0
	test	BYTE PTR ___flags$[ebp], 1

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+28], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi+8], ax
	je	SHORT $LN37@scalar
	push	80					; 00000050H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN37@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GiSK_Logger@@UAEPAXI@Z ENDP				; iSK_Logger::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
;	COMDAT ??1iSK_Logger@@UAE@XZ
_TEXT	SEGMENT
??1iSK_Logger@@UAE@XZ PROC				; iSK_Logger::~iSK_Logger, COMDAT
; _this$ = ecx

; 179  :   virtual ~iSK_Logger (void) {

	npad	2
	push	esi
	mov	esi, ecx

; 180  :     Release ();

	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7iSK_Logger@@6B@
	call	?Release@iSK_Logger@@UAGKXZ		; iSK_Logger::Release
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN7@iSK_Logger
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+8]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN7@iSK_Logger:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+28], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi+8], ax
	pop	esi
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 181  :   }

	ret	0
??1iSK_Logger@@UAE@XZ ENDP				; iSK_Logger::~iSK_Logger
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
;	COMDAT ??0iSK_Logger@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iSK_Logger@@QAE@XZ PROC				; iSK_Logger::iSK_Logger, COMDAT
; _this$ = ecx

; 175  :   iSK_Logger (void) {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 204  :   std::wstring     name        = L"";

	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 175  :   iSK_Logger (void) {

	mov	DWORD PTR [esi], OFFSET ??_7iSK_Logger@@6B@

; 178  : 
; 179  :   virtual ~iSK_Logger (void) {
; 180  :     Release ();
; 181  :   }
; 182  : 
; 183  :   /*** IUnknown methods ***/
; 184  :   STDMETHOD  (       QueryInterface)(THIS_ REFIID riid, void** ppvObj);
; 185  :   STDMETHOD_ (ULONG, AddRef)        (THIS);
; 186  :   STDMETHOD_ (ULONG, Release)       (THIS);
; 187  : 
; 188  :   STDMETHOD_ (bool, init)(THIS_ const wchar_t* const wszFilename,
; 189  :                                 const wchar_t* const wszMode );
; 190  :   STDMETHOD_ (void, close)(THIS);
; 191  : 
; 192  :   STDMETHOD_ (void, LogEx)(THIS_ bool                 _Timestamp,
; 193  :                               _In_z_ _Printf_format_string_
; 194  :                                  wchar_t const* const _Format,
; 195  :                                                       ... );
; 196  :   STDMETHOD_ (void, Log)  (THIS_ _In_z_ _Printf_format_string_
; 197  :                                  wchar_t const* const _Format,
; 198  :                                                       ... );
; 199  :   STDMETHOD_ (void, Log)  (THIS_ _In_z_ _Printf_format_string_
; 200  :                                  char const* const    _Format,
; 201  :                                                       ... );
; 202  : 
; 203  :   FILE*            fLog        = nullptr;

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 205  :   bool             silent      = false;

	mov	WORD PTR [esi+32], 0

; 206  :   bool             initialized = false;
; 207  :   int              lines       =   0;

	mov	DWORD PTR [esi+36], 0
	movups	XMMWORD PTR [esi+40], xmm0
	push	esi
	movq	QWORD PTR [esi+56], xmm0

; 208  :   CRITICAL_SECTION log_mutex   = {   };
; 209  :   ULONG            refs        =   0UL;

	mov	DWORD PTR [esi+64], 0

; 210  :   DWORD            last_flush  =   0;

	mov	DWORD PTR [esi+68], 0

; 211  :   DWORD            flush_freq  =   100; // msecs

	mov	DWORD PTR [esi+72], 100			; 00000064H

; 212  : 
; 213  : public:
; 214  :   // Temporary augmentation for log issues during thread suspension
; 215  :   bool             lock   (void) { if (! lockless) { EnterCriticalSection (&log_mutex); return true; } return false; }
; 216  :   bool             unlock (void) { if (! lockless) { LeaveCriticalSection (&log_mutex); return true; } return false; }
; 217  :   bool             lockless    = true;

	mov	BYTE PTR [esi+76], 1
	call	?AddRef@iSK_Logger@@UAGKXZ		; iSK_Logger::AddRef
	mov	eax, esi
	pop	esi

; 176  :     AddRef ();
; 177  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
??0iSK_Logger@@QAE@XZ ENDP				; iSK_Logger::iSK_Logger
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
;	COMDAT ?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ PROC	; iSK_Logger::auto_close, COMDAT
; _this$ = ecx

; 171  :   AutoClose auto_close (void) {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 165  :     AutoClose (iSK_Logger* log) : log_ (log) { }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR [eax], ecx

; 172  :     return AutoClose (this);
; 173  :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ ENDP	; iSK_Logger::auto_close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
;	COMDAT ??0AutoClose@iSK_Logger@@IAE@PAU1@@Z
_TEXT	SEGMENT
_log$ = 8						; size = 4
??0AutoClose@iSK_Logger@@IAE@PAU1@@Z PROC		; iSK_Logger::AutoClose::AutoClose, COMDAT
; _this$ = ecx

; 165  :     AutoClose (iSK_Logger* log) : log_ (log) { }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _log$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0AutoClose@iSK_Logger@@IAE@PAU1@@Z ENDP		; iSK_Logger::AutoClose::AutoClose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
;	COMDAT ??1AutoClose@iSK_Logger@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1AutoClose@iSK_Logger@@QAE@XZ PROC			; iSK_Logger::AutoClose::~AutoClose, COMDAT
; _this$ = ecx

; 157  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1AutoClose@iSK_Logger@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 158  :       if (log_ != nullptr)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@AutoClose

; 159  :         log_->close ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+20]
$LN4@AutoClose:

; 160  : 
; 161  :       log_ = nullptr;
; 162  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1AutoClose@iSK_Logger@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1AutoClose@iSK_Logger@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AutoClose@iSK_Logger@@QAE@XZ ENDP			; iSK_Logger::AutoClose::~AutoClose
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT

; 3646 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 3629 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@Check_offs

; 3633 : 			}
; 3634 : 		}

	pop	ebp
	ret	4
$LN14@Check_offs:

; 3631 : 			{
; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN16@Check_offs:
$LN13@Check_offs:
	int	3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT

; 3625 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3602 : 		}

	ret	0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 3588 : 		{	// test if _Ptr points inside string

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@Inside
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN14@Inside
$LN13@Inside:
	mov	edx, ecx
$LN14@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	cmp	edx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*2]
	cmp	DWORD PTR __Ptr$[ebp], eax
	jae	SHORT $LN3@Inside
	mov	al, 1

; 3592 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	xor	al, al

; 3592 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 3572 : 		{	// ensure buffer is big enough

	npad	2
	push	ebp
	mov	ebp, esp

; 3573 : 		if (_Newsize == 0)

	mov	eax, DWORD PTR __Newsize$[ebp]
	test	eax, eax
	jne	SHORT $LN2@Grow

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN16@Grow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN16@Grow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	xor	al, al

; 3585 : 		}

	pop	ebp
	ret	4
$LN2@Grow:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], eax
	jae	SHORT $LN3@Grow

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	eax
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN3@Grow:

; 3582 : 			}
; 3583 : 
; 3584 : 		return (true);	// return true only if more work to do

	mov	al, 1

; 3585 : 		}

	pop	ebp
	ret	4
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 3566 : 		{	// set new length and null terminator

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 3567 : 		auto& _My_data = this->_Get_data();
; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [ecx+edx*2], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Oldres$ = -28						; size = 4
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 3514 : 		{	// reallocate to new buffer of at least _Newsize, copying existing elements there

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 3515 : 		const auto _Max = max_size();
; 3516 : 		if (_Newsize > _Max)

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	eax, 2147483646				; 7ffffffeH
	jbe	SHORT $LN2@Copy

; 3517 : 			{	// too long
; 3518 : 			_Xlen();

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN102@Copy:
$LN2@Copy:

; 3519 : 			}
; 3520 : 
; 3521 : 		auto& _My_data = this->_Get_data();
; 3522 : 		const size_type _Oldres = _My_data._Myres;

	mov	ebx, DWORD PTR [esi+20]

; 3523 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	edi, eax
	or	edi, 7
	mov	DWORD PTR __Oldres$[ebp], ebx

; 3524 : 		if (_Max < _Newres)

	cmp	edi, 2147483646				; 7ffffffeH
	jbe	SHORT $LN3@Copy

; 3525 : 			{
; 3526 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN8@Copy
$LN3@Copy:

; 3527 : 			}
; 3528 : 		else if (_Oldres / 2 <= _Newres / 3)

	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, ebx
	mul	edi
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN8@Copy

; 3529 : 			;
; 3530 : 		else if (_Oldres <= _Max - _Oldres / 2)

	mov	eax, 2147483646				; 7ffffffeH

; 3531 : 			{
; 3532 : 			_Newres = _Oldres + _Oldres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN8@Copy

; 3533 : 			}
; 3534 : 		else
; 3535 : 			{
; 3536 : 			_Newres = _Max;	// settle for max_size()

	mov	edi, 2147483646				; 7ffffffeH
$LN8@Copy:

; 3537 : 			}
; 3538 : 
; 3539 : 		auto& _Al = this->_Getal();
; 3540 : 		pointer _Ptr;
; 3541 : 		_TRY_BEGIN
; 3542 : 			_Ptr = _Al.allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	mov	ecx, esi
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
	jmp	SHORT $LN100@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$0:

; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	mov	ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	DWORD PTR __Newres$[ebp], eax

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	mov	DWORD PTR __Ptr$[ebp], eax

; 3546 : 		_CATCH_END

	mov	eax, $LN97@Copy
	ret	0
$LN97@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR __Oldres$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN100@Copy:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3546 : 		_CATCH_END

	mov	DWORD PTR __Ptr$1$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [eax*2+2]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3550 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN10@Copy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	DWORD PTR [esi]
	push	ecx
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3553 : 			_Al.deallocate(_My_data._Bx._Ptr, _Oldres + 1);

	lea	eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3556 : 		else

	jmp	SHORT $LN101@Copy
$LN10@Copy:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	esi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN101@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3563 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3562 : 		_My_data._Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 3563 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN99@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 3410 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3412 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find, COMDAT
; _this$ = ecx

; 3227 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edi
	lea	edi, DWORD PTR [edx+2]
	npad	4
$LL31@find:
	mov	ax, WORD PTR [edx]
	add	edx, 2
	test	ax, ax
	jne	SHORT $LL31@find
	sub	edx, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	edx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8
	pop	edi

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN25@find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN25@find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3228 : 		return (static_cast<size_type>(

	push	edx
	push	DWORD PTR __Ptr$[ebp]
	push	DWORD PTR __Off$[ebp]
	push	DWORD PTR [eax]
	push	ecx
	call	??$_Traits_find@U?$char_traits@_W@std@@@std@@YAIQB_WII0I@Z ; std::_Traits_find<std::char_traits<wchar_t> >
	add	esp, 20					; 00000014H

; 3229 : 			_Traits_find<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Traits::length(_Ptr))));
; 3230 : 		}

	pop	ebp
	ret	8
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 3030 : 		const size_type _Num = this->_Getal().max_size();
; 3031 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, 2147483646				; 7ffffffeH

; 3032 : 		}

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length, COMDAT
; _this$ = ecx

; 3020 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 3021 : 		}

	ret	0
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Off$[ebp]
	push	ebx
	push	esi

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edi, DWORD PTR [esi+16]
	cmp	edi, edx
	jb	$LN97@erase

; 2593 : 		_Check_offset(_Off);
; 2594 : 		if (this->_Mysize() - _Off <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, edx
	cmp	eax, ebx
	ja	SHORT $LN2@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN38@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN38@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2607 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 2595 : 			{
; 2596 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 2597 : 			}
; 2598 : 		else if (_Count != 0)

	test	ebx, ebx
	je	SHORT $LN94@erase

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN57@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN58@erase
$LN57@erase:
	mov	eax, esi
$LN58@erase:

; 2599 : 			{	// move elements down
; 2600 : 			value_type *_Ptr = this->_Myptr() + _Off;

	lea	ecx, DWORD PTR [eax+edx*2]

; 2601 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, ebx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, edi
	sub	eax, edx
	add	eax, eax
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ecx+ebx*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN87@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN87@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
$LN94@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN97@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN99@erase:
$LN96@erase:
	int	3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 2585 : 		{	// erase elements [_Off, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN36@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	esi, esi
	mov	WORD PTR [edx+eax*2], si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx
	pop	esi

; 2589 : 		}

	pop	ebp
	ret	4
$LN26@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	esi, esi
	mov	WORD PTR [edx+eax*2], si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx
	pop	esi

; 2589 : 		}

	pop	ebp
	ret	4
$LN36@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN38@erase:
$LN35@erase:
	int	3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2428 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2428 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [eax+2]
$LL6@assign:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL6@assign
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
	pop	esi

; 2430 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2412 : 		{	// assign [_Ptr, _Ptr + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN17@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN18@assign
$LN17@assign:
	mov	edx, esi
$LN18@assign:

; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	mov	edi, DWORD PTR __Ptr$[ebp]
	cmp	edx, edi
	ja	SHORT $LN2@assign
	mov	eax, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [edx+eax*2]
	cmp	edi, eax
	jae	SHORT $LN2@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN33@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN34@assign
$LN33@assign:
	mov	eax, esi
$LN34@assign:

; 2413 : 		if (_Inside(_Ptr))
; 2414 : 			{
; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
	sub	edi, eax
	mov	ecx, esi
	sar	edi, 1
	push	edi
	push	esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	ebx

; 3573 : 		if (_Newsize == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	jne	SHORT $LN40@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN53@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN53@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
$LN40@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	ecx, ebx
	jae	SHORT $LN41@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN41@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN81@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN82@assign
$LN81@assign:
	mov	eax, esi
$LN82@assign:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	ecx, DWORD PTR [ebx+ebx]
	push	ecx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN102@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN102@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
	pop	ebx
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jb	$LN161@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	eax, edi
	cmovb	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2382 : 		if (this == _STD addressof(_Right))

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 2383 : 			{	// substring
; 2384 : 			erase(_Roff + _Count);

	lea	eax, DWORD PTR [ecx+edi]

; 3630 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], eax
	jb	$LN163@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN62@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN63@assign
$LN62@assign:
	mov	edx, esi
$LN63@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	push	ecx
	push	edi
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edx+eax*2], di
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	call	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN72@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN85@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN72@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN73@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]
$LN73@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN113@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN113@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN129@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN130@assign
$LN129@assign:
	mov	edx, esi
$LN130@assign:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [edi+edi]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2389 : 			_Traits::copy(this->_Myptr(), _Right._Myptr() + _Roff, _Count);

	lea	eax, DWORD PTR [ebx+ecx*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN150@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN150@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN161@assign:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN164@assign:
$LN163@assign:
	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN165@assign:
$LN160@assign:
	int	3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 2250 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2250 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [eax+2]
$LL8@operator:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL8@operator
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
	pop	esi

; 2251 : 		return (assign(_Ptr));
; 2252 : 		}

	pop	ebp
	ret	4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1980 : 		{	// construct from [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1980 : 		{	// construct from [_Ptr, <null>)

	mov	esi, ecx
	push	edi

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax

; 289  : 		return (_CSTD wcslen(_First));

	mov	eax, edx
	lea	edi, DWORD PTR [eax+2]
$LL25@basic_stri:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL25@basic_stri
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi

; 1981 : 		_Tidy_init();
; 1982 : 		assign(_Ptr);
; 1983 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1941 : 		}

	mov	eax, ecx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 1849 : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 1850 : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1845 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 1839 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1840 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 1824 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1825 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1697 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1697 : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1686 : 		}

	ret	0
$LN11@Myptr:

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1686 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1634 : 			{	// user-provided, for fancy pointers
; 1635 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 8
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
$LN3@Myptr:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1598 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 2147483647				; 7fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 2147483647				; 7fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 2147483647				; 7fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 3646 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 3629 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@Check_offs

; 3633 : 			}
; 3634 : 		}

	pop	ebp
	ret	4
$LN14@Check_offs:

; 3631 : 			{
; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN16@Check_offs:
$LN13@Check_offs:
	int	3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3625 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3596 : 		auto& _My_data = this->_Get_data();
; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3602 : 		}

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 3588 : 		{	// test if _Ptr points inside string

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@Inside
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN14@Inside
$LN13@Inside:
	mov	edx, ecx
$LN14@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	cmp	edx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	eax, DWORD PTR [ecx+16]
	add	eax, edx
	cmp	DWORD PTR __Ptr$[ebp], eax
	jae	SHORT $LN3@Inside
	mov	al, 1

; 3592 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	xor	al, al

; 3592 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 3572 : 		{	// ensure buffer is big enough

	npad	2
	push	ebp
	mov	ebp, esp

; 3573 : 		if (_Newsize == 0)

	mov	eax, DWORD PTR __Newsize$[ebp]
	test	eax, eax
	jne	SHORT $LN2@Grow

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN16@Grow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN16@Grow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	xor	al, al

; 3585 : 		}

	pop	ebp
	ret	4
$LN2@Grow:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], eax
	jae	SHORT $LN3@Grow

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	eax
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN3@Grow:

; 3582 : 			}
; 3583 : 
; 3584 : 		return (true);	// return true only if more work to do

	mov	al, 1

; 3585 : 		}

	pop	ebp
	ret	4
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3566 : 		{	// set new length and null terminator

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3567 : 		auto& _My_data = this->_Get_data();
; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Oldres$ = -28						; size = 4
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 3514 : 		{	// reallocate to new buffer of at least _Newsize, copying existing elements there

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 3515 : 		const auto _Max = max_size();
; 3516 : 		if (_Newsize > _Max)

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	eax, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 3517 : 			{	// too long
; 3518 : 			_Xlen();

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN94@Copy:
$LN2@Copy:

; 3519 : 			}
; 3520 : 
; 3521 : 		auto& _My_data = this->_Get_data();
; 3522 : 		const size_type _Oldres = _My_data._Myres;

	mov	ebx, DWORD PTR [esi+20]

; 3523 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	edi, eax
	or	edi, 15					; 0000000fH
	mov	DWORD PTR __Oldres$[ebp], ebx

; 3524 : 		if (_Max < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN3@Copy

; 3525 : 			{
; 3526 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN8@Copy
$LN3@Copy:

; 3527 : 			}
; 3528 : 		else if (_Oldres / 2 <= _Newres / 3)

	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, ebx
	mul	edi
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN8@Copy

; 3529 : 			;
; 3530 : 		else if (_Oldres <= _Max - _Oldres / 2)

	mov	eax, -2					; fffffffeH

; 3531 : 			{
; 3532 : 			_Newres = _Oldres + _Oldres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN8@Copy

; 3533 : 			}
; 3534 : 		else
; 3535 : 			{
; 3536 : 			_Newres = _Max;	// settle for max_size()

	mov	edi, -2					; fffffffeH
$LN8@Copy:

; 3537 : 			}
; 3538 : 
; 3539 : 		auto& _Al = this->_Getal();
; 3540 : 		pointer _Ptr;
; 3541 : 		_TRY_BEGIN
; 3542 : 			_Ptr = _Al.allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	eax
	mov	ecx, esi
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	ecx, eax
	jmp	SHORT $LN92@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$0:

; 3543 : 		_CATCH_ALL
; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	push	eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 3546 : 		_CATCH_END

	mov	eax, $LN89@Copy
	ret	0
$LN89@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR __Oldres$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN92@Copy:

; 3551 : 			{	// copy and deallocate old buffer
; 3552 : 			_Traits::copy(_Unfancy(_Ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	mov	DWORD PTR __Ptr$1$[ebp], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3550 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN10@Copy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR [esi]
	push	ecx
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3553 : 			_Al.deallocate(_My_data._Bx._Ptr, _Oldres + 1);

	lea	eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3556 : 		else

	jmp	SHORT $LN93@Copy
$LN10@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN93@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3563 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3562 : 		_My_data._Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 3563 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN91@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT
; _this$ = ecx

; 3420 : 		{	// compare [0, _Mysize()) with _Ptr for equality

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edi
	lea	edi, DWORD PTR [edx+1]
	npad	4
$LL31@Equal:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL31@Equal
	sub	edx, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	pop	edi

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN25@Equal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN25@Equal:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3421 : 		return (_Traits_equal<_Traits>(this->_Myptr(), this->_Mysize(), _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	DWORD PTR __Ptr$[ebp]
	push	DWORD PTR [eax]
	push	ecx
	call	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ; std::_Traits_equal<std::char_traits<char> >
	add	esp, 16					; 00000010H

; 3422 : 		}

	pop	ebp
	ret	4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 3410 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3412 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3030 : 		const size_type _Num = this->_Getal().max_size();
; 3031 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 3032 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Off$[ebp]
	push	ebx
	push	esi

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edi, DWORD PTR [esi+16]
	cmp	edi, edx
	jb	SHORT $LN95@erase

; 2593 : 		_Check_offset(_Off);
; 2594 : 		if (this->_Mysize() - _Off <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, edx
	cmp	eax, ebx
	ja	SHORT $LN2@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN38@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN38@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2607 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 2595 : 			{
; 2596 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 2597 : 			}
; 2598 : 		else if (_Count != 0)

	test	ebx, ebx
	je	SHORT $LN92@erase

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN57@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN58@erase
$LN57@erase:
	mov	eax, esi
$LN58@erase:

; 2599 : 			{	// move elements down
; 2600 : 			value_type *_Ptr = this->_Myptr() + _Off;

	lea	ecx, DWORD PTR [eax+edx]

; 2601 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, ebx

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ecx+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN85@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN92@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN95@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN97@erase:
$LN94@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2585 : 		{	// erase elements [_Off, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN36@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx

; 2589 : 		}

	pop	ebp
	ret	4
$LN26@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx

; 2589 : 		}

	pop	ebp
	ret	4
$LN36@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN38@erase:
$LN35@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2428 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2428 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	edi, DWORD PTR [eax+1]
$LL6@assign:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL6@assign
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 2430 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2412 : 		{	// assign [_Ptr, _Ptr + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN17@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN18@assign
$LN17@assign:
	mov	edx, esi
$LN18@assign:

; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	mov	ebx, DWORD PTR __Ptr$[ebp]
	cmp	edx, ebx
	ja	SHORT $LN2@assign
	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	ebx, eax
	jae	SHORT $LN2@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN33@assign

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN33@assign:

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 3573 : 		if (_Newsize == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	jne	SHORT $LN40@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN53@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN53@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
$LN40@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	ecx, edi
	jae	SHORT $LN41@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN41@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN81@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN82@assign
$LN81@assign:
	mov	eax, esi
$LN82@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN100@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN100@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Roff$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, eax
	jb	$LN159@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	ecx, edi
	cmovb	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2382 : 		if (this == _STD addressof(_Right))

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 2383 : 			{	// substring
; 2384 : 			erase(_Roff + _Count);

	lea	ecx, DWORD PTR [eax+edi]

; 3630 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], ecx
	jb	$LN161@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN62@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	push	eax
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN62@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, esi

; 2385 : 			erase(0, _Roff);

	push	eax
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN72@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN85@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN72@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN73@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	eax, DWORD PTR __Roff$[ebp]
$LN73@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN113@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN113@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN129@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN130@assign
$LN129@assign:
	mov	ecx, esi
$LN130@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2389 : 			_Traits::copy(this->_Myptr(), _Right._Myptr() + _Roff, _Count);

	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN148@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN148@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN159@assign:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN162@assign:
$LN161@assign:
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN163@assign:
$LN158@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2250 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2250 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	edi, DWORD PTR [eax+1]
$LL8@operator:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL8@operator
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 2251 : 		return (assign(_Ptr));
; 2252 : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2122 : 		{	// assign by stealing _Right's buffer, memcpy optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2123 : 			// pre: this != &_Right
; 2124 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2125 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2126 : 		auto& _Right_data = _Right._Get_data();
; 2127 : 
; 2128 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2129 : 		if (_Right_data._Large_string_engaged())
; 2130 : 			{	// take ownership of _Right's iterators along with its buffer
; 2131 : 			this->_Swap_all(_Right);
; 2132 : 			}
; 2133 : 		else
; 2134 : 			{
; 2135 : 			_Right._Orphan_all();
; 2136 : 			}
; 2137 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2138 : 
; 2139 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2140 : 			+ _Memcpy_move_offset;
; 2141 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2142 : 			+ _Memcpy_move_offset;
; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2145 : 		}

	pop	ebp
	ret	8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2054 : 		{	// construct by moving _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2056 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1980 : 		{	// construct from [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1980 : 		{	// construct from [_Ptr, <null>)

	mov	esi, ecx
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	edi, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
$LL25@basic_stri:

; 480  : 		return (_CSTD strlen(_First));

	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL25@basic_stri
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 1981 : 		_Tidy_init();
; 1982 : 		assign(_Ptr);
; 1983 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 1849 : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 1850 : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1845 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 1839 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1840 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1824 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1825 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1697 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1697 : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1686 : 		}

	ret	0
$LN11@Myptr:

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1686 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1634 : 			{	// user-provided, for fancy pointers
; 1635 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
$LN3@Myptr:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1598 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate
$LN15@allocate:

; 1077 : 		return (_Mybase::allocate(_Count));
; 1078 : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN10@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN11@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN11@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 1077 : 		return (_Mybase::allocate(_Count));
; 1078 : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN15@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN17@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	or	eax, -1

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 852  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 516  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 517  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 518  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 505  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 507  : 		}

	pop	ebp

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 485  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH

; 487  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 479  : 		{	// find length of null-terminated string

	npad	2
	push	ebp
	mov	ebp, esp

; 480  : 		return (_CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 481  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHQBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHQBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 474  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __First1$[ebp]
	push	esi
	mov	esi, DWORD PTR __First2$[ebp]
	sub	ecx, 4
	jb	SHORT $LN5@compare
$LL6@compare:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN4@compare
	add	edx, 4
	add	esi, 4
	sub	ecx, 4
	jae	SHORT $LL6@compare
$LN5@compare:
	cmp	ecx, -4					; fffffffcH
	je	SHORT $LN3@compare
$LN4@compare:
	mov	al, BYTE PTR [edx]
	cmp	al, BYTE PTR [esi]
	jne	SHORT $LN7@compare
	cmp	ecx, -3					; fffffffdH
	je	SHORT $LN3@compare
	mov	al, BYTE PTR [edx+1]
	cmp	al, BYTE PTR [esi+1]
	jne	SHORT $LN7@compare
	cmp	ecx, -2					; fffffffeH
	je	SHORT $LN3@compare
	mov	al, BYTE PTR [edx+2]
	cmp	al, BYTE PTR [esi+2]
	jne	SHORT $LN7@compare
	cmp	ecx, -1
	je	SHORT $LN3@compare
	mov	al, BYTE PTR [edx+3]
	cmp	al, BYTE PTR [esi+3]
	je	SHORT $LN3@compare
$LN7@compare:
	sbb	eax, eax
	or	eax, 1
	pop	esi

; 476  : 		}

	pop	ebp
	ret	0
$LN3@compare:

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

	xor	eax, eax
	pop	esi

; 476  : 		}

	pop	ebp
	ret	0
?compare@?$char_traits@D@std@@SAHQBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 325  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 326  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	WORD PTR [eax], cx

; 327  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 314  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, eax
	mov	DWORD PTR __Count$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 316  : 		}

	pop	ebp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?find@?$char_traits@_W@std@@SAPB_WQB_WIAB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@_W@std@@SAPB_WQB_WIAB_W@Z PROC	; std::char_traits<wchar_t>::find, COMDAT

; 308  : 		{	// look for _Ch in [_First, _First + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 309  : 		return ((const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));

	mov	edx, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	edx, edx
	je	SHORT $LN5@find

; 204  :             if (*_S == _C)

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, WORD PTR [eax]
$LL6@find:
	cmp	WORD PTR [ecx], ax
	je	SHORT $LN10@find

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	ecx, 2
	sub	edx, 1
	jne	SHORT $LL6@find
$LN5@find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 309  : 		return ((const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));

	xor	eax, eax

; 310  : 		}

	pop	ebp
	ret	0
$LN10@find:

; 309  : 		return ((const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));

	mov	eax, ecx

; 310  : 		}

	pop	ebp
	ret	0
?find@?$char_traits@_W@std@@SAPB_WQB_WIAB_W@Z ENDP	; std::char_traits<wchar_t>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 294  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, eax
	push	eax
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 296  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIQB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIQB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 288  : 		{	// find length of null-terminated sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 289  : 		return (_CSTD wcslen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+2]
	npad	5
$LL3@length:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL3@length
	sub	eax, edx
	sar	eax, 1

; 290  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@_W@std@@SAIQB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?compare@?$char_traits@_W@std@@SAHQB_W0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@_W@std@@SAHQB_W0I@Z PROC		; std::char_traits<wchar_t>::compare, COMDAT

; 283  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __First1$[ebp]
	push	esi
	mov	esi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN5@compare
$LL6@compare:

; 217  :             if (*_S1 != *_S2)

	mov	cx, WORD PTR [eax]
	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN14@compare

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	eax, 2
	add	edx, 2
	sub	esi, 1
	jne	SHORT $LL6@compare
$LN5@compare:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	xor	eax, eax
	pop	esi

; 285  : 		}

	pop	ebp
	ret	0
$LN14@compare:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	sbb	eax, eax
	and	eax, -2					; fffffffeH
	inc	eax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 285  : 		}

	pop	ebp
	ret	0
?compare@?$char_traits@_W@std@@SAHQB_W0I@Z ENDP		; std::char_traits<wchar_t>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __N$[ebp]
	add	eax, eax
	mov	DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

	pop	ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	jmp	DWORD PTR __imp__memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __N$[ebp]
	add	eax, eax
	mov	DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

	pop	ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	jmp	_memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcmp
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcmp PROC						; COMDAT

; 215  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	mov	esi, DWORD PTR __N$[ebp]
	test	esi, esi
	je	SHORT $LN3@wmemcmp
	mov	ecx, DWORD PTR __S2$[ebp]
	mov	edx, DWORD PTR __S1$[ebp]
$LL4@wmemcmp:

; 217  :             if (*_S1 != *_S2)

	mov	ax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	jne	SHORT $LN8@wmemcmp

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	edx, 2
	add	ecx, 2
	sub	esi, 1
	jne	SHORT $LL4@wmemcmp
$LN3@wmemcmp:

; 219  : 
; 220  :         return 0;

	xor	eax, eax
	pop	esi

; 221  :     }

	pop	ebp
	ret	0
$LN8@wmemcmp:

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	movzx	eax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	pop	esi
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	inc	eax

; 221  :     }

	pop	ebp
	ret	0
_wmemcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemchr
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 2
__N$ = 16						; size = 4
_wmemchr PROC						; COMDAT

; 202  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 203  :         for (; 0 < _N; ++_S, --_N)

	mov	ecx, DWORD PTR __N$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@wmemchr
	mov	dx, WORD PTR __C$[ebp]
	mov	eax, DWORD PTR __S$[ebp]
$LL4@wmemchr:

; 204  :             if (*_S == _C)

	cmp	WORD PTR [eax], dx
	je	SHORT $LN1@wmemchr

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	eax, 2
	sub	ecx, 1
	jne	SHORT $LL4@wmemchr
$LN3@wmemchr:

; 205  :                 return (wchar_t _CONST_RETURN*)_S;
; 206  : 
; 207  :         return 0;

	xor	eax, eax
$LN1@wmemchr:

; 208  :     }

	pop	ebp
	ret	0
_wmemchr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
_sip$ = -2372						; size = 2096
_szModName$ = -276					; size = 262
_Displacement$ = -12					; size = 8
_BaseAddr$1$ = -4					; size = 4
_hMod$ = 8						; size = 4
_addr$ = 12						; size = 4
_pszOut$ = 16						; size = 4
_ulLen$ = 20						; size = 4
?SK_GetSymbolNameFromModuleAddr@@YAKPAUHINSTANCE__@@IPADK@Z PROC ; SK_GetSymbolNameFromModuleAddr

; 822  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 2372				; 00000944H
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 264  :     EnterCriticalSection (cs_);

	mov	eax, DWORD PTR ?cs_dbghelp@@3PAVSK_Thread_HybridSpinlock@@A ; cs_dbghelp
	push	ebx
	push	esi
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 829  :     GetCurrentProcess ();

	call	DWORD PTR __imp__GetCurrentProcess@0

; 830  : 
; 831  :   DWORD64                           ip;
; 832  : 
; 833  :   UIntPtrToInt64 (addr, (int64_t *)&ip);
; 834  : 
; 835  :   DWORD64 BaseAddr =
; 836  :     SymGetModuleBase64 ( hProc, ip );

	push	0
	push	DWORD PTR _addr$[ebp]
	mov	esi, eax
	push	esi
	call	DWORD PTR __imp__SymGetModuleBase64@12

; 837  : 
; 838  :   char szModName [MAX_PATH + 2] = {  };

	push	262					; 00000106H
	mov	ebx, eax
	mov	DWORD PTR _BaseAddr$1$[ebp], edx
	lea	eax, DWORD PTR _szModName$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 839  : 
; 840  :   int len =
; 841  :     GetModuleFileNameA  ( hMod,

	lea	eax, DWORD PTR _szModName$[ebp]
	push	260					; 00000104H
	push	eax
	push	DWORD PTR _hMod$[ebp]
	call	DWORD PTR __imp__GetModuleFileNameA@12

; 842  :                             szModName,
; 843  :                               MAX_PATH );
; 844  : 
; 845  :   char* pszShortName = szModName + len- 1;

	lea	ecx, DWORD PTR _szModName$[ebp]
	dec	ecx
	add	eax, ecx

; 846  : 
; 847  :   while (  pszShortName      >  szModName &&

	lea	ecx, DWORD PTR _szModName$[ebp]
	cmp	eax, ecx
	jbe	SHORT $LN21@SK_GetSymb
$LL2@SK_GetSymb:
	cmp	BYTE PTR [eax-1], 92			; 0000005cH
	je	SHORT $LN21@SK_GetSymb

; 848  :          *(pszShortName - 1) != '\\')
; 849  :     --pszShortName;

	dec	eax
	lea	ecx, DWORD PTR _szModName$[ebp]
	cmp	eax, ecx
	ja	SHORT $LL2@SK_GetSymb
$LN21@SK_GetSymb:

; 850  : 
; 851  :   SymLoadModule64 ( hProc,

	push	0
	push	DWORD PTR _BaseAddr$1$[ebp]
	push	ebx
	push	0
	push	eax
	push	0
	push	esi
	call	DWORD PTR __imp__SymLoadModule64@28

; 852  :                       nullptr,
; 853  :                         pszShortName,
; 854  :                           nullptr,
; 855  :                             BaseAddr,
; 856  :                               0 );
; 857  : 
; 858  :   SYMBOL_INFO_PACKAGE sip                 = {                };

	push	2096					; 00000830H
	lea	eax, DWORD PTR _sip$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 859  :                       sip.si.SizeOfStruct = sizeof SYMBOL_INFO;

	mov	DWORD PTR _sip$[ebp], 88		; 00000058H

; 860  :                       sip.si.MaxNameLen   = sizeof sip.name;
; 861  : 
; 862  :   DWORD64 Displacement = 0;
; 863  : 
; 864  :   if ( SymFromAddr ( hProc,

	lea	eax, DWORD PTR _sip$[ebp]
	mov	DWORD PTR _sip$[ebp+80], 2001		; 000007d1H
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _Displacement$[ebp], xmm0
	push	eax
	lea	eax, DWORD PTR _Displacement$[ebp]
	push	eax
	push	0
	push	DWORD PTR _addr$[ebp]
	push	esi
	call	DWORD PTR __imp__SymFromAddr@20
	test	eax, eax
	je	SHORT $LN4@SK_GetSymb
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, DWORD PTR _ulLen$[ebp]
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 871  :     strncat             ( pszOut, sip.si.Name,

	lea	eax, DWORD PTR _sip$[ebp+84]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	DWORD PTR _sip$[ebp+76], ecx
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 869  :     *pszOut = '\0';

	mov	esi, DWORD PTR _pszOut$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovb	ecx, DWORD PTR _sip$[ebp+76]
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 871  :     strncat             ( pszOut, sip.si.Name,

	push	ecx
	push	eax
	push	esi
	mov	BYTE PTR [esi], 0
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH

; 872  :                             std::min (ulLen, sip.si.NameLen) );
; 873  :     ret =

	lea	ecx, DWORD PTR [esi+1]
	npad	4
$LL20@SK_GetSymb:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL20@SK_GetSymb
	sub	esi, ecx

; 874  :       static_cast <ULONG> (strlen (pszOut));
; 875  :   }
; 876  : 
; 877  :   else

	jmp	SHORT $LN5@SK_GetSymb
$LN4@SK_GetSymb:

; 878  :   {
; 879  :     *pszOut = '\0';

	mov	eax, DWORD PTR _pszOut$[ebp]

; 880  :     ret     = 0;

	xor	esi, esi
	mov	BYTE PTR [eax], 0
$LN5@SK_GetSymb:
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 269  :     LeaveCriticalSection (cs_);

	mov	eax, DWORD PTR ?cs_dbghelp@@3PAVSK_Thread_HybridSpinlock@@A ; cs_dbghelp
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 886  :   return ret;

	mov	eax, esi
	pop	esi
	pop	ebx

; 887  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_GetSymbolNameFromModuleAddr@@YAKPAUHINSTANCE__@@IPADK@Z ENDP ; SK_GetSymbolNameFromModuleAddr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
??0IUnknown@@QAE@XZ PROC				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
;	COMDAT ?_InterlockedExchange@@YAKPCKK@Z
_TEXT	SEGMENT
_Target$ = 8						; size = 4
_Value$ = 12						; size = 4
?_InterlockedExchange@@YAKPCKK@Z PROC			; _InterlockedExchange, COMDAT

; 8902 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8903 :     return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);

	mov	eax, DWORD PTR _Value$[ebp]
	mov	ecx, DWORD PTR _Target$[ebp]
	xchg	DWORD PTR [ecx], eax

; 8904 : }

	pop	ebp
	ret	0
?_InterlockedExchange@@YAKPCKK@Z ENDP			; _InterlockedExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _ReadAcquire
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_ReadAcquire PROC					; COMDAT

; 8059 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8060 : 
; 8061 :     LONG Value;
; 8062 : 
; 8063 :     Value = *Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	eax, DWORD PTR [eax]

; 8064 :     return Value;
; 8065 : }

	pop	ebp
	ret	0
_ReadAcquire ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
?Reinstall@CrashHandler@Diagnostics@SK@@YAXXZ PROC	; SK::Diagnostics::CrashHandler::Reinstall

; 80   :   SetErrorMode                (SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS);

	push	3
	call	DWORD PTR __imp__SetErrorMode@4

; 81   :   SetUnhandledExceptionFilter (SK_TopLevelExceptionFilter);

	push	OFFSET ?SK_TopLevelExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; SK_TopLevelExceptionFilter
	call	DWORD PTR __imp__SetUnhandledExceptionFilter@4

; 82   : }

	ret	0
?Reinstall@CrashHandler@Diagnostics@SK@@YAXXZ ENDP	; SK::Diagnostics::CrashHandler::Reinstall
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
?Shutdown@CrashHandler@Diagnostics@SK@@YAXXZ PROC	; SK::Diagnostics::CrashHandler::Shutdown

; 137  :   crash_log.close ();

	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	call	?close@iSK_Logger@@UAGXXZ		; iSK_Logger::close

; 138  : }

	ret	0
?Shutdown@CrashHandler@Diagnostics@SK@@YAXXZ ENDP	; SK::Diagnostics::CrashHandler::Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
?InitSyms@CrashHandler@Diagnostics@SK@@YAXXZ PROC	; SK::Diagnostics::CrashHandler::InitSyms
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 264  :     EnterCriticalSection (cs_);

	mov	eax, DWORD PTR ?cs_dbghelp@@3PAVSK_Thread_HybridSpinlock@@A ; cs_dbghelp
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 8903 :     return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);

	mov	eax, 1
	mov	ecx, OFFSET ?init@?1??InitSyms@CrashHandler@Diagnostics@SK@@YAXXZ@4KC
	xchg	DWORD PTR [ecx], eax
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 983  :   if (! InterlockedExchange (&init, 1))

	test	eax, eax
	jne	SHORT $LN2@InitSyms

; 984  :   {
; 985  :     if (config.system.handle_crashes)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+840, al
	je	SHORT $LN5@InitSyms

; 986  :     {
; 987  :       HRSRC   default_sound =
; 988  :         FindResource (SK_GetDLL (), MAKEINTRESOURCE (IDR_CRASH), L"WAVE");

	push	OFFSET $SG250453
	push	102					; 00000066H
	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	call	DWORD PTR __imp__FindResourceW@12

; 989  : 
; 990  :       if (default_sound != nullptr)

	test	eax, eax
	je	SHORT $LN5@InitSyms

; 991  :       {
; 992  :         crash_sound.ref   =

	push	eax
	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	call	DWORD PTR __imp__LoadResource@8
	mov	DWORD PTR ?crash_sound@@3U<unnamed-type-crash_sound>@@A, eax

; 993  :           LoadResource (SK_GetDLL (), default_sound);
; 994  : 
; 995  :         if (crash_sound.ref != nullptr)

	test	eax, eax
	je	SHORT $LN5@InitSyms

; 996  :         {
; 997  :           crash_sound.buf =

	push	eax
	call	DWORD PTR __imp__LockResource@4
	mov	DWORD PTR ?crash_sound@@3U<unnamed-type-crash_sound>@@A+4, eax
$LN5@InitSyms:

; 998  :             reinterpret_cast <uint8_t *> (LockResource (crash_sound.ref));
; 999  :         }
; 1000 :       }
; 1001 : 
; 1002 :       if (! config.steam.silent)
; 1003 :         SK_BypassSteamCrashHandler ();
; 1004 :     }
; 1005 : 
; 1006 :     SymSetOptions ( SYMOPT_CASE_INSENSITIVE | SYMOPT_LOAD_LINES    | SYMOPT_UNDNAME |

	push	524311					; 00080017H
	call	DWORD PTR __imp__SymSetOptions@4

; 1007 :                     SYMOPT_NO_PROMPTS       | SYMOPT_DEFERRED_LOADS );
; 1008 : 
; 1009 :     SymInitialize (

	push	1
	push	0
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__SymInitialize@12
$LN2@InitSyms:
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 269  :     LeaveCriticalSection (cs_);

	mov	eax, DWORD PTR ?cs_dbghelp@@3PAVSK_Thread_HybridSpinlock@@A ; cs_dbghelp
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp

; 1017 : }

	ret	0
?InitSyms@CrashHandler@Diagnostics@SK@@YAXXZ ENDP	; SK::Diagnostics::CrashHandler::InitSyms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\diagnostics\crash_handler.cpp
_TEXT	SEGMENT
?Init@CrashHandler@Diagnostics@SK@@YAXXZ PROC		; SK::Diagnostics::CrashHandler::Init

; 94   :   HRSRC   default_sound =
; 95   :     FindResource (SK_GetDLL (), MAKEINTRESOURCE (IDR_CRASH), L"WAVE");

	push	OFFSET $SG250068
	push	102					; 00000066H
	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	call	DWORD PTR __imp__FindResourceW@12

; 96   : 
; 97   :   if (default_sound != nullptr)

	test	eax, eax
	je	SHORT $LN3@Init

; 98   :   {
; 99   :     crash_sound.ref   =

	push	eax
	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	call	DWORD PTR __imp__LoadResource@8
	mov	DWORD PTR ?crash_sound@@3U<unnamed-type-crash_sound>@@A, eax

; 100  :       LoadResource (SK_GetDLL (), default_sound);
; 101  : 
; 102  :     if (crash_sound.ref != nullptr)

	test	eax, eax
	je	SHORT $LN3@Init

; 103  :     {
; 104  :       crash_sound.buf =

	push	eax
	call	DWORD PTR __imp__LockResource@4
	mov	DWORD PTR ?crash_sound@@3U<unnamed-type-crash_sound>@@A+4, eax
$LN3@Init:

; 105  :         static_cast <uint8_t *> (LockResource (crash_sound.ref));
; 106  :     }
; 107  :   }
; 108  : 
; 109  :   if (! crash_log.initialized)

	cmp	BYTE PTR ?crash_log@@3UiSK_Logger@@A+33, 0
	jne	SHORT $LN4@Init

; 110  :   {
; 111  :     crash_log.flush_freq = 0;
; 112  :     crash_log.lockless   = true;
; 113  :     crash_log.init (L"logs/crash.log", L"w");

	push	OFFSET $SG250072
	push	OFFSET $SG250073
	push	OFFSET ?crash_log@@3UiSK_Logger@@A	; crash_log
	mov	DWORD PTR ?crash_log@@3UiSK_Logger@@A+72, 0
	mov	BYTE PTR ?crash_log@@3UiSK_Logger@@A+76, 1
	call	?init@iSK_Logger@@UAG_NQB_W0@Z		; iSK_Logger::init
$LN4@Init:

; 114  :   }
; 115  : 
; 116  :   SK_CreateDLLHook  (       L"kernel32.dll",

	push	0
	push	OFFSET ?SetUnhandledExceptionFilter_Original@@3P6GP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@ZA ; SetUnhandledExceptionFilter_Original
	push	OFFSET ?SetUnhandledExceptionFilter_Detour@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z ; SetUnhandledExceptionFilter_Detour
	push	OFFSET $SG250074
	push	OFFSET $SG250075
	call	?SK_CreateDLLHook@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook

; 117  :                              "SetUnhandledExceptionFilter",
; 118  :                               SetUnhandledExceptionFilter_Detour,
; 119  :      static_cast_p2p <void> (&SetUnhandledExceptionFilter_Original) );
; 120  : 
; 121  :   SymSetOptions ( SYMOPT_CASE_INSENSITIVE | SYMOPT_LOAD_LINES    | SYMOPT_UNDNAME |

	push	524311					; 00080017H
	call	DWORD PTR __imp__SymSetOptions@4

; 122  :                   SYMOPT_NO_PROMPTS       | SYMOPT_DEFERRED_LOADS );
; 123  : 
; 124  :   SymRefreshModuleList (GetCurrentProcess ());

	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__SymRefreshModuleList@4

; 125  : 
; 126  :   //SymInitialize (
; 127  :   //  GetCurrentProcess (),
; 128  :   //    NULL,
; 129  :   //      TRUE );
; 130  : 
; 131  : Reinstall ();

	jmp	?Reinstall@CrashHandler@Diagnostics@SK@@YAXXZ ; SK::Diagnostics::CrashHandler::Reinstall
?Init@CrashHandler@Diagnostics@SK@@YAXXZ ENDP		; SK::Diagnostics::CrashHandler::Init
_TEXT	ENDS
END
