; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\imgui\imgui_demo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG11264 DB	'Multi-line Text Input', 00H
$SG11382 DB	00H
$SG11389 DB	00H
$SG11265 DB	'Read-only', 00H
$SG11494 DB	00H
$SG11622 DB	00H
$SG12290 DB	'Example: Fixed Overlay', 00H
$SG11634 DB	00H
$SG11266 DB	'##source', 00H
$SG11767 DB	00H
$SG11816 DB	00H
$SG11818 DB	00H
$SG12291 DB	'Simple overlay', 0aH, 'on the top-left side of the scree'
	DB	'n.', 00H
$SG11820 DB	00H
$SG12292 DB	'Mouse Position: (%.1f,%.1f)', 00H
$SG11268 DB	'Button', 00H
$SG11822 DB	00H
$SG11270 DB	'Thanks for clicking me!', 00H
$SG11271 DB	'checkbox', 00H
$SG12049 DB	00H
$SG12057 DB	00H
$SG12074 DB	00H
$SG11272 DB	'radio a', 00H
$SG11273 DB	'radio b', 00H
$SG11274 DB	'radio c', 00H
$SG11276 DB	'Click', 00H
$SG12172 DB	00H
$SG12205 DB	00H
$SG12301 DB	'Same title as another window##1', 00H
$SG11277 DB	'Hover over me', 00H
	ORG $+6
$SG12302 DB	'This is window 1.', 0aH, 'My title is the same as window'
	DB	' 2, but my identifier is unique.', 00H
	ORG $+3
$SG12303 DB	'Same title as another window##2', 00H
$SG11279 DB	'I am a tooltip', 00H
	ORG $+1
$SG11280 DB	'- or me', 00H
$SG12307 DB	'This window has a changing title.', 00H
	ORG $+2
$SG12304 DB	'This is window 2.', 0aH, 'My title is the same as window'
	DB	' 1, but my identifier is unique.', 00H
	ORG $+3
$SG12305 DB	'|/-\', 00H
	ORG $+3
$SG12306 DB	'Animated title %c %d###AnimatedTitle', 00H
	ORG $+3
$SG11282 DB	'I am a fancy tooltip', 00H
	ORG $+3
$SG11283 DB	'Curve', 00H
	ORG $+2
$SG11284 DB	'Value', 00H
	ORG $+2
$SG11285 DB	'label', 00H
	ORG $+2
$SG11286 DB	'aaaa', 00H, 'bbbb', 00H, 'cccc', 00H, 'dddd', 00H, 'eeee'
	DB	00H, 00H, 00H
	ORG $+1
$SG11287 DB	'combo', 00H
	ORG $+2
$SG11288 DB	'AAAA', 00H
	ORG $+3
$SG11289 DB	'BBBB', 00H
	ORG $+3
$SG11290 DB	'CCCC', 00H
	ORG $+3
$SG11291 DB	'DDDD', 00H
	ORG $+3
$SG11292 DB	'EEEE', 00H
	ORG $+3
$SG11293 DB	'FFFF', 00H
	ORG $+3
$SG11294 DB	'GGGG', 00H
	ORG $+3
$SG11295 DB	'HHHH', 00H
	ORG $+3
$SG11296 DB	'IIII', 00H
	ORG $+3
$SG11297 DB	'JJJJ', 00H
	ORG $+3
$SG11298 DB	'KKKK', 00H
	ORG $+3
$SG11299 DB	'combo scroll', 00H
	ORG $+3
$SG11300 DB	'input text', 00H
	ORG $+1
$SG11302 DB	'input int', 00H
	ORG $+2
$SG11301 DB	'Hold SHIFT or use mouse to select text.', 0aH, 'CTRL+Lef'
	DB	't/Right to word jump.', 0aH, 'CTRL+A or double-click to selec'
	DB	't all.', 0aH, 'CTRL+X,CTRL+C,CTRL+V clipboard.', 0aH, 'CTRL+Z'
	DB	',CTRL+Y undo/redo.', 0aH, 'ESCAPE to revert.', 0aH, 00H
$SG11303 DB	'You can apply arithmetic operators +,*,/ on numerical va'
	DB	'lues.', 0aH, '  e.g. [ 100 ], input ''*2'', result becomes [ '
	DB	'200 ]', 0aH, 'Use +- to subtract.', 0aH, 00H
	ORG $+2
$SG11304 DB	'input float', 00H
$SG11305 DB	'input float3', 00H
	ORG $+3
$SG11306 DB	'%.0f', 00H
	ORG $+3
$SG11307 DB	'drag int', 00H
	ORG $+3
$SG11308 DB	'Click and drag to edit value.', 0aH, 'Hold SHIFT/ALT for'
	DB	' faster/slower edit.', 0aH, 'Double-click or CTRL+click to in'
	DB	'put value.', 00H
$SG11309 DB	'%.0f%%', 00H
	ORG $+1
$SG11310 DB	'drag int 0..100', 00H
$SG11311 DB	'%.3f', 00H
	ORG $+3
$SG11312 DB	'drag float', 00H
	ORG $+1
$SG11313 DB	'%.06f ns', 00H
	ORG $+3
$SG11314 DB	'drag small float', 00H
	ORG $+3
$SG11315 DB	'%.0f', 00H
	ORG $+3
$SG11316 DB	'slider int', 00H
	ORG $+1
$SG11317 DB	'CTRL+click to input value.', 00H
	ORG $+1
$SG11318 DB	'ratio = %.3f', 00H
	ORG $+3
$SG11319 DB	'slider float', 00H
	ORG $+3
$SG11320 DB	'%.4f', 00H
	ORG $+3
$SG11321 DB	'slider log float', 00H
	ORG $+3
$SG11322 DB	'slider angle', 00H
	ORG $+3
$SG11323 DB	'color 1', 00H
$SG11324 DB	'Click on the colored square to change edit mode.', 0aH, 'C'
	DB	'TRL+click on individual component to input value.', 0aH, 00H
	ORG $+3
$SG11325 DB	'color 2', 00H
$SG11326 DB	'Apple', 00H
	ORG $+2
$SG11327 DB	'Banana', 00H
	ORG $+1
$SG11328 DB	'Cherry', 00H
	ORG $+1
$SG11329 DB	'Kiwi', 00H
	ORG $+3
$SG10305 DB	'(?)', 00H
$SG11330 DB	'Mango', 00H
	ORG $+2
$SG11331 DB	'Orange', 00H
	ORG $+1
$SG11332 DB	'Pineapple', 00H
	ORG $+2
$SG11333 DB	'Strawberry', 00H
	ORG $+1
$SG10309 DB	'Double-click on title bar to collapse window.', 00H
	ORG $+2
$SG11334 DB	'Watermelon', 00H
	ORG $+1
$SG10310 DB	'Click and drag on lower right corner to resize window.', 00H
	ORG $+1
$SG11335 DB	'listbox', 0aH, '(single select)', 00H
$SG10311 DB	'Click and drag on any empty space to move window.', 00H
	ORG $+2
$SG10312 DB	'Mouse Wheel to scroll.', 00H
	ORG $+1
$SG11337 DB	'Range Widgets', 00H
	ORG $+2
$SG11338 DB	'Max: %.1f %%', 00H
	ORG $+3
$SG10314 DB	'CTRL+Mouse Wheel to zoom window contents.', 00H
	ORG $+2
$SG11339 DB	'Min: %.1f %%', 00H
	ORG $+3
$SG10315 DB	'TAB/SHIFT+TAB to cycle through keyboard editable fields.'
	DB	00H
	ORG $+3
$SG11340 DB	'range', 00H
	ORG $+2
$SG10316 DB	'CTRL+Click on a slider or drag box to input text.', 00H
	ORG $+2
$SG11341 DB	'Max: %.0f units', 00H
$SG10317 DB	'While editing text:', 0aH, '- Hold SHIFT or use mouse to'
	DB	' select text', 0aH, '- CTRL+Left/Right to word jump', 0aH, '-'
	DB	' CTRL+A or double-click to select all', 0aH, '- CTRL+X,CTRL+C'
	DB	',CTRL+V clipboard', 0aH, '- CTRL+Z,CTRL+Y undo/redo', 0aH, '-'
	DB	' ESCAPE to revert', 0aH, '- You can apply arithmetic operator'
	DB	's +,*,/ on numerical values.', 0aH, '  Use +- to subtract.', 0aH
	DB	00H
$SG11342 DB	'Min: %.0f units', 00H
$SG11343 DB	'range int (no bounds)', 00H
	ORG $+2
$SG11345 DB	'Multi-component Widgets', 00H
$SG11346 DB	'input float2', 00H
	ORG $+3
$SG11347 DB	'%.3f', 00H
	ORG $+3
$SG11348 DB	'drag float2', 00H
$SG11349 DB	'%.3f', 00H
	ORG $+3
$SG11350 DB	'slider float2', 00H
	ORG $+2
$SG11351 DB	'%.0f', 00H
	ORG $+3
$SG11352 DB	'drag int2', 00H
	ORG $+2
$SG11353 DB	'input int2', 00H
	ORG $+1
$SG11354 DB	'%.0f', 00H
	ORG $+3
$SG11355 DB	'slider int2', 00H
$SG11356 DB	'input float3', 00H
	ORG $+3
$SG11357 DB	'%.3f', 00H
	ORG $+3
$SG11358 DB	'drag float3', 00H
$SG11359 DB	'%.3f', 00H
	ORG $+3
$SG11360 DB	'slider float3', 00H
	ORG $+2
$SG11361 DB	'%.0f', 00H
	ORG $+3
$SG11362 DB	'drag int3', 00H
	ORG $+2
$SG11363 DB	'input int3', 00H
	ORG $+1
$SG11364 DB	'%.0f', 00H
	ORG $+3
$SG11365 DB	'slider int3', 00H
$SG11366 DB	'input float4', 00H
	ORG $+3
$SG11367 DB	'%.3f', 00H
	ORG $+3
$SG11368 DB	'drag float4', 00H
$SG11369 DB	'%.3f', 00H
	ORG $+3
$SG11370 DB	'slider float4', 00H
	ORG $+2
$SG11371 DB	'input int4', 00H
	ORG $+1
$SG11372 DB	'%.0f', 00H
	ORG $+3
$SG11373 DB	'drag int4', 00H
	ORG $+2
$SG11374 DB	'%.0f', 00H
	ORG $+3
$SG11375 DB	'slider int4', 00H
$SG11377 DB	'Vertical Sliders', 00H
	ORG $+3
$SG11378 DB	'%.0f', 00H
	ORG $+3
$SG12403 DB	'Example: Custom rendering', 00H
	ORG $+2
$SG11379 DB	'##int', 00H
	ORG $+2
$SG12404 DB	'Primitives', 00H
	ORG $+1
$SG11380 DB	'set1', 00H
	ORG $+3
$SG12405 DB	'%.0f', 00H
	ORG $+3
$SG12406 DB	'Size', 00H
	ORG $+3
$SG12407 DB	'Color', 00H
	ORG $+2
$SG11383 DB	'##v', 00H
$SG12408 DB	'Canvas example', 00H
	ORG $+1
$SG12410 DB	'Clear', 00H
	ORG $+2
$SG11386 DB	'%.3f', 00H
	ORG $+3
$SG11387 DB	'set2', 00H
	ORG $+3
$SG12413 DB	'Undo', 00H
	ORG $+3
$SG12414 DB	'Left-click and drag to add lines,', 0aH, 'Right-click to'
	DB	' undo', 00H
	ORG $+2
$SG11390 DB	'##v', 00H
$SG12417 DB	'canvas', 00H
	ORG $+1
$SG11393 DB	'%.3f', 00H
	ORG $+3
$SG11394 DB	'set3', 00H
	ORG $+3
$SG11396 DB	'%.2f', 0aH, 'sec', 00H
	ORG $+3
$SG11397 DB	'##v', 00H
$SG11399 DB	'Plots widgets', 00H
	ORG $+2
$SG11400 DB	'Animate', 00H
$SG11401 DB	'Frame Times', 00H
$SG11404 DB	'avg 0.0', 00H
$SG11405 DB	'Lines', 00H
	ORG $+2
$SG11406 DB	'Histogram', 00H
	ORG $+2
$SG11407 DB	'Sin', 00H, 'Saw', 00H, 00H
	ORG $+3
$SG11408 DB	'func', 00H
	ORG $+3
$SG11409 DB	'%.0f', 00H
	ORG $+3
$SG11410 DB	'Sample count', 00H
	ORG $+3
$SG11411 DB	'Lines', 00H
	ORG $+2
$SG11412 DB	'Histogram', 00H
	ORG $+2
$SG11416 DB	'Progress Bar', 00H
	ORG $+3
$SG11417 DB	'%d/%d', 00H
	ORG $+2
$SG11419 DB	'Layout', 00H
	ORG $+1
$SG11421 DB	'Child regions', 00H
	ORG $+2
$SG11422 DB	'Without border', 00H
	ORG $+1
$SG11423 DB	'Goto', 00H
	ORG $+3
$SG11424 DB	'##Line', 00H
	ORG $+1
$SG11425 DB	'Sub1', 00H
	ORG $+3
$SG11426 DB	'%04d: scrollable region', 00H
$SG11429 DB	'Sub2', 00H
	ORG $+3
$SG11430 DB	'With border', 00H
$SG11432 DB	'%08x', 00H
	ORG $+3
$SG11434 DB	'Pressed ''%s''', 0aH, 00H
	ORG $+2
$SG11436 DB	'Widgets Width', 00H
	ORG $+2
$SG11437 DB	'PushItemWidth(100)', 00H
	ORG $+1
$SG11438 DB	'Fixed width.', 00H
	ORG $+3
$SG11439 DB	'%.3f', 00H
	ORG $+3
$SG11440 DB	'float##1', 00H
	ORG $+3
$SG11441 DB	'PushItemWidth(GetWindowWidth() * 0.5f)', 00H
	ORG $+1
$SG11442 DB	'Half of window width.', 00H
	ORG $+2
$SG11443 DB	'%.3f', 00H
	ORG $+3
$SG11444 DB	'float##2', 00H
	ORG $+3
$SG11445 DB	'PushItemWidth(GetContentRegionAvailWidth() * 0.5f)', 00H
	ORG $+1
$SG11446 DB	'Half of available width.', 0aH, '(~ right-cursor_pos)', 0aH
	DB	'(works within a column set)', 00H
	ORG $+2
$SG11447 DB	'%.3f', 00H
	ORG $+3
$SG11448 DB	'float##3', 00H
	ORG $+3
$SG11449 DB	'PushItemWidth(-100)', 00H
$SG11450 DB	'Align to right edge minus 100', 00H
	ORG $+2
$SG11451 DB	'%.3f', 00H
	ORG $+3
$SG11452 DB	'float##4', 00H
	ORG $+3
$SG11453 DB	'PushItemWidth(-1)', 00H
	ORG $+2
$SG11454 DB	'Align to right edge', 00H
$SG11455 DB	'%.3f', 00H
	ORG $+3
$SG11456 DB	'float##5', 00H
	ORG $+3
$SG11458 DB	'Basic Horizontal Layout', 00H
$SG11460 DB	'Two items: Hello', 00H
	ORG $+3
$SG11459 DB	'(Use ImGui::SameLine() to keep adding items to the right'
	DB	' of the preceding item)', 00H
$SG11461 DB	'Sailor', 00H
	ORG $+1
$SG11462 DB	'More spacing: Hello', 00H
$SG11463 DB	'Sailor', 00H
	ORG $+1
$SG11464 DB	'Normal buttons', 00H
	ORG $+1
$SG11465 DB	'Banana', 00H
	ORG $+1
$SG11466 DB	'Apple', 00H
	ORG $+2
$SG11467 DB	'Corniflower', 00H
$SG11468 DB	'Small buttons', 00H
	ORG $+2
$SG11469 DB	'Like this one', 00H
	ORG $+2
$SG11470 DB	'can fit within a text block.', 00H
	ORG $+3
$SG11471 DB	'Aligned', 00H
$SG11472 DB	'x=150', 00H
	ORG $+2
$SG11473 DB	'x=300', 00H
	ORG $+2
$SG11474 DB	'Aligned', 00H
$SG11475 DB	'x=150', 00H
	ORG $+2
$SG11476 DB	'x=300', 00H
	ORG $+2
$SG11477 DB	'My', 00H
	ORG $+1
$SG11478 DB	'Tailor', 00H
	ORG $+1
$SG11479 DB	'Is', 00H
	ORG $+1
$SG11480 DB	'Rich', 00H
	ORG $+3
$SG11481 DB	'AAAA', 00H
	ORG $+3
$SG11482 DB	'BBBB', 00H
	ORG $+3
$SG11483 DB	'CCCC', 00H
	ORG $+3
$SG11484 DB	'DDDD', 00H
	ORG $+3
$SG11485 DB	'Combo', 00H
	ORG $+2
$SG11486 DB	'%.3f', 00H
	ORG $+3
$SG11487 DB	'X', 00H
	ORG $+2
$SG11488 DB	'%.3f', 00H
	ORG $+3
$SG11489 DB	'Y', 00H
	ORG $+2
$SG11490 DB	'%.3f', 00H
	ORG $+3
$SG11491 DB	'Z', 00H
	ORG $+2
$SG11492 DB	'Lists:', 00H
	ORG $+1
$SG11495 DB	'A', 00H
	ORG $+2
$SG11496 DB	'B', 00H
	ORG $+2
$SG11498 DB	'Groups', 00H
	ORG $+1
$SG11500 DB	'AAA', 00H
$SG11499 DB	'(Using ImGui::BeginGroup()/EndGroup() to layout items. B'
	DB	'eginGroup() basically locks the horizontal position. EndGroup'
	DB	'() bundles the whole group so that you can use functions such'
	DB	' as IsItemHovered() on it.)', 00H
	ORG $+2
$SG11501 DB	'BBB', 00H
$SG11502 DB	'CCC', 00H
$SG11503 DB	'DDD', 00H
$SG11505 DB	'Group hovered', 00H
	ORG $+2
$SG11506 DB	'EEE', 00H
$SG11507 DB	'##values', 00H
	ORG $+3
$SG11508 DB	'ACTION', 00H
	ORG $+1
$SG11509 DB	'REACTION', 00H
	ORG $+3
$SG11510 DB	'LEVERAGE', 0aH, 'BUZZWORD', 00H
	ORG $+2
$SG11511 DB	'List', 00H
	ORG $+3
$SG11512 DB	'Selected', 00H
	ORG $+3
$SG11513 DB	'Not Selected', 00H
	ORG $+3
$SG11515 DB	'Text Baseline Alignment', 00H
$SG11516 DB	'(This is testing the vertical alignment that occurs on t'
	DB	'ext to keep it at the same baseline as widgets. Lines only co'
	DB	'mposed of text or "small" widgets fit in less vertical spaces'
	DB	' than lines with normal widgets)', 00H
	ORG $+1
$SG11517 DB	'One', 0aH, 'Two', 0aH, 'Three', 00H
	ORG $+2
$SG11518 DB	'Hello', 0aH, 'World', 00H
$SG11519 DB	'Banana', 00H
	ORG $+1
$SG11520 DB	'Banana', 00H
	ORG $+1
$SG11521 DB	'Hello', 0aH, 'World', 00H
$SG11522 DB	'One', 0aH, 'Two', 0aH, 'Three', 00H
	ORG $+2
$SG11523 DB	'HOP##1', 00H
	ORG $+1
$SG11524 DB	'Banana', 00H
	ORG $+1
$SG11525 DB	'Hello', 0aH, 'World', 00H
$SG11526 DB	'Banana', 00H
	ORG $+1
$SG11527 DB	'HOP##2', 00H
	ORG $+1
$SG11528 DB	'Hello', 0aH, 'World', 00H
$SG11529 DB	'Banana', 00H
	ORG $+1
$SG11530 DB	'TEST##1', 00H
$SG11531 DB	'TEST', 00H
	ORG $+3
$SG11532 DB	'TEST##2', 00H
$SG11533 DB	'Text aligned to Widget', 00H
	ORG $+1
$SG11534 DB	'Widget##1', 00H
	ORG $+2
$SG11535 DB	'Widget', 00H
	ORG $+1
$SG11536 DB	'Widget##2', 00H
	ORG $+2
$SG11537 DB	'Button##1', 00H
	ORG $+2
$SG11539 DB	'Node##1', 00H
$SG11540 DB	'Item %d..', 00H
	ORG $+2
$SG11541 DB	'Node##2', 00H
$SG11542 DB	'Button##2', 00H
	ORG $+2
$SG11544 DB	'Item %d..', 00H
	ORG $+2
$SG11545 DB	'Button##3', 00H
	ORG $+2
$SG11546 DB	'Bullet text', 00H
$SG11547 DB	'Node', 00H
	ORG $+3
$SG11548 DB	'Button##4', 00H
	ORG $+2
$SG11550 DB	'Scrolling', 00H
	ORG $+2
$SG11553 DB	'Line %.0f', 00H
	ORG $+2
$SG11551 DB	'(Use SetScrollHere() or SetScrollFromPosY() to scroll to'
	DB	' a given position.)', 00H
$SG11552 DB	'Track', 00H
	ORG $+2
$SG11554 DB	'##line', 00H
	ORG $+1
$SG11555 DB	'Scroll To', 00H
	ORG $+2
$SG11556 DB	'y = %.0f px', 00H
$SG11557 DB	'##pos_y', 00H
$SG11560 DB	'Top', 00H
$SG11561 DB	'25%', 00H
$SG11562 DB	'Center', 00H
	ORG $+1
$SG11563 DB	'75%', 00H
$SG11564 DB	'Bottom', 00H
	ORG $+1
$SG11565 DB	'%s', 00H
	ORG $+1
$SG11569 DB	'Line %d', 00H
$SG11570 DB	'Line %d', 00H
$SG11572 DB	'Horizontal Scrolling', 00H
	ORG $+3
$SG11576 DB	'Lines', 00H
	ORG $+2
$SG11577 DB	'scrolling', 00H
	ORG $+2
$SG11573 DB	'Horizontal scrolling for a window has to be enabled expl'
	DB	'icitly via the ImGuiWindowFlags_HorizontalScrollbar flag.', 00H
	ORG $+2
$SG11579 DB	'FizzBuzz', 00H
	ORG $+3
$SG11574 DB	'You may want to explicitly specify content width by call'
	DB	'ing SetNextWindowContentWidth() before Begin().', 00H
$SG11575 DB	'%.0f', 00H
	ORG $+3
$SG11580 DB	'Fizz', 00H
	ORG $+3
$SG11581 DB	'Buzz', 00H
	ORG $+3
$SG11582 DB	'%d', 00H
	ORG $+1
$SG11583 DB	'<<', 00H
	ORG $+1
$SG11585 DB	'Scroll from code', 00H
	ORG $+3
$SG11586 DB	'>>', 00H
	ORG $+1
$SG11589 DB	'scrolling', 00H
	ORG $+2
$SG11591 DB	'Clipping', 00H
	ORG $+3
$SG11592 DB	'On a per-widget basis we are occasionally clipping text '
	DB	'CPU-side if it won''t fit in its frame. Otherwise we are doin'
	DB	'g coarser clipping + passing a scissor rectangle to the rende'
	DB	'rer. The system is designed to try minimizing both execution '
	DB	'and CPU/GPU rendering cost.', 00H
	ORG $+2
$SG11593 DB	'%.0f', 00H
	ORG $+3
$SG11594 DB	'size', 00H
	ORG $+3
$SG11595 DB	'(Click and drag)', 00H
	ORG $+3
$SG11596 DB	'##dummy', 00H
$SG11598 DB	'Line 1 hello', 0aH, 'Line 2 clip me!', 00H
	ORG $+3
$SG11600 DB	'Popups & Modal windows', 00H
	ORG $+1
$SG11602 DB	'Popups', 00H
	ORG $+1
$SG11603 DB	'When a popup is active, it inhibits interacting with win'
	DB	'dows that are behind the popup. Clicking outside the popup cl'
	DB	'oses it.', 00H
	ORG $+2
$SG11604 DB	'Bream', 00H
	ORG $+2
$SG11605 DB	'Haddock', 00H
$SG11606 DB	'Mackerel', 00H
	ORG $+3
$SG11607 DB	'Pollock', 00H
$SG11608 DB	'Tilefish', 00H
	ORG $+3
$SG11610 DB	'Select..', 00H
	ORG $+3
$SG11611 DB	'select', 00H
	ORG $+1
$SG11612 DB	'<None>', 00H
	ORG $+1
$SG11614 DB	'select', 00H
	ORG $+1
$SG11615 DB	'Aquarium', 00H
	ORG $+3
$SG11618 DB	'Toggle..', 00H
	ORG $+3
$SG11619 DB	'toggle', 00H
	ORG $+1
$SG11621 DB	'toggle', 00H
	ORG $+1
$SG11624 DB	'Sub-menu', 00H
	ORG $+3
$SG11625 DB	'Click me', 00H
	ORG $+3
$SG11626 DB	'Tooltip here', 00H
	ORG $+3
$SG11628 DB	'I am a tooltip over a popup', 00H
$SG11630 DB	'Stacked Popup', 00H
	ORG $+2
$SG11631 DB	'another popup', 00H
	ORG $+2
$SG11633 DB	'another popup', 00H
	ORG $+2
$SG11636 DB	'Sub-menu', 00H
	ORG $+3
$SG11637 DB	'Click me', 00H
	ORG $+3
$SG11639 DB	'Popup Menu..', 00H
	ORG $+3
$SG11640 DB	'FilePopup', 00H
	ORG $+2
$SG11642 DB	'FilePopup', 00H
	ORG $+2
$SG11643 DB	'Below we are testing adding menu items to a regular wind'
	DB	'ow. It''s rather unusual but should work!', 00H
	ORG $+3
$SG11644 DB	'foo', 00H
$SG11645 DB	'CTRL+M', 00H
	ORG $+1
$SG11646 DB	'Menu item', 00H
	ORG $+2
$SG11648 DB	'Menu inside a regular window', 00H
	ORG $+3
$SG11650 DB	'Context menus', 00H
	ORG $+2
$SG11651 DB	'Value = %.3f (<-- right-click here)', 00H
$SG11653 DB	'item context menu', 00H
	ORG $+2
$SG11655 DB	'Set to zero', 00H
$SG11657 DB	'Set to PI', 00H
	ORG $+2
$SG11659 DB	'color context menu', 00H
	ORG $+1
$SG11660 DB	'Edit color', 00H
	ORG $+1
$SG11661 DB	'##edit', 00H
	ORG $+1
$SG11663 DB	'Close', 00H
	ORG $+2
$SG11664 DB	'(<-- right-click here)', 00H
	ORG $+1
$SG11666 DB	'Modals', 00H
	ORG $+1
$SG11669 DB	'Delete..', 00H
	ORG $+3
$SG11667 DB	'Modal windows are like popups but the user cannot close '
	DB	'them by clicking outside the window.', 00H
	ORG $+3
$SG11670 DB	'Delete?', 00H
$SG11672 DB	'Delete?', 00H
$SG11673 DB	'All those beautiful files will be deleted.', 0aH, 'This '
	DB	'operation cannot be undone!', 0aH, 0aH, 00H
	ORG $+2
$SG11674 DB	'Don''t ask me next time', 00H
	ORG $+1
$SG11676 DB	'OK', 00H
	ORG $+1
$SG11678 DB	'Cancel', 00H
	ORG $+1
$SG11680 DB	'Stacked modals..', 00H
	ORG $+3
$SG11681 DB	'Stacked 1', 00H
	ORG $+2
$SG11683 DB	'Stacked 1', 00H
	ORG $+2
$SG11684 DB	'Hello from Stacked The First', 0aH, 'Using style.Colors['
	DB	'ImGuiCol_ModalWindowDarkening] for darkening.', 00H
	ORG $+2
$SG11685 DB	'aaaa', 00H, 'bbbb', 00H, 'cccc', 00H, 'dddd', 00H, 'eeee'
	DB	00H, 00H, 00H
	ORG $+1
$SG11686 DB	'Combo', 00H
	ORG $+2
$SG11688 DB	'Add another modal..', 00H
$SG11689 DB	'Stacked 2', 00H
	ORG $+2
$SG11691 DB	'Stacked 2', 00H
	ORG $+2
$SG11692 DB	'Hello from Stacked The Second!', 0aH, 'We are piling a m'
	DB	'odal over another here,', 0aH, 'and also testing if the menu-'
	DB	'bar works.', 00H
$SG11694 DB	'Close', 00H
	ORG $+2
$SG11696 DB	'Close', 00H
	ORG $+2
$SG11698 DB	'Columns', 00H
$SG11700 DB	'Basic', 00H
	ORG $+2
$SG11701 DB	'Without border:', 00H
$SG11702 DB	'mycolumns3', 00H
	ORG $+1
$SG11703 DB	'Item %d', 00H
$SG11705 DB	'With border:', 00H
	ORG $+3
$SG11706 DB	'mycolumns', 00H
	ORG $+2
$SG11707 DB	'ID', 00H
	ORG $+1
$SG11708 DB	'Name', 00H
	ORG $+3
$SG11709 DB	'Path', 00H
	ORG $+3
$SG11710 DB	'Flags', 00H
	ORG $+2
$SG11711 DB	'One', 00H
$SG11712 DB	'Two', 00H
$SG11713 DB	'Three', 00H
	ORG $+2
$SG11714 DB	'/path/one', 00H
	ORG $+2
$SG11715 DB	'/path/two', 00H
	ORG $+2
$SG11716 DB	'/path/three', 00H
$SG11717 DB	'%04d', 00H
	ORG $+3
$SG11719 DB	'....', 00H
	ORG $+3
$SG11721 DB	'Mixed items', 00H
$SG11722 DB	'mixed', 00H
	ORG $+2
$SG11723 DB	'Hello', 00H
	ORG $+2
$SG11724 DB	'Banana', 00H
	ORG $+1
$SG11725 DB	'ImGui', 00H
	ORG $+2
$SG11726 DB	'Apple', 00H
	ORG $+2
$SG11727 DB	'red', 00H
$SG11728 DB	'An extra line here.', 00H
$SG11729 DB	'Sailor', 00H
	ORG $+1
$SG11730 DB	'Corniflower', 00H
$SG11731 DB	'blue', 00H
	ORG $+3
$SG11733 DB	'Category A', 00H
	ORG $+1
$SG11734 DB	'Blah blah blah', 00H
	ORG $+1
$SG11736 DB	'Category B', 00H
	ORG $+1
$SG11737 DB	'Blah blah blah', 00H
	ORG $+1
$SG11739 DB	'Category C', 00H
	ORG $+1
$SG11740 DB	'Blah blah blah', 00H
	ORG $+1
$SG11742 DB	'Word-wrapping', 00H
	ORG $+2
$SG11743 DB	'word-wrapping', 00H
	ORG $+2
$SG11744 DB	'The quick brown fox jumps over the lazy dog.', 00H
	ORG $+3
$SG11745 DB	'Hello Left', 00H
	ORG $+1
$SG11746 DB	'The quick brown fox jumps over the lazy dog.', 00H
	ORG $+3
$SG11747 DB	'Hello Right', 00H
$SG11749 DB	'Borders', 00H
$SG11750 DB	'horizontal', 00H
	ORG $+1
$SG11751 DB	'vertical', 00H
	ORG $+3
$SG11753 DB	'%c%c%c', 00H
	ORG $+1
$SG11755 DB	'Tree within single cell', 00H
$SG11758 DB	'tree items', 00H
	ORG $+1
$SG11756 DB	'NB: Tree node must be poped before ending the cell. Ther'
	DB	'e''s no storage of state per-cell.', 00H
	ORG $+2
$SG11760 DB	'Hello', 00H
	ORG $+2
$SG11761 DB	'Sailor', 00H
	ORG $+1
$SG11763 DB	'Bonjour', 00H
$SG11764 DB	'Marin', 00H
	ORG $+2
$SG12789 DB	'Example: Console', 00H
	ORG $+3
$SG11766 DB	'Filtering', 00H
	ORG $+2
$SG11769 DB	'Filter (inc,-exc)', 00H
	ORG $+2
$SG11768 DB	'Filter usage:', 0aH, '  ""         display all lines', 0aH
	DB	'  "xxx"      display lines containing "xxx"', 0aH, '  "xxx,yy'
	DB	'y"  display lines containing "xxx" or "yyy"', 0aH, '  "-xxx" '
	DB	'    hide lines containing "xxx"', 00H
	ORG $+1
$SG11770 DB	'aaa1.c', 00H
	ORG $+1
$SG11771 DB	'bbb1.c', 00H
	ORG $+1
$SG11772 DB	'ccc1.c', 00H
	ORG $+1
$SG11773 DB	'aaa2.cpp', 00H
	ORG $+3
$SG11774 DB	'bbb2.cpp', 00H
	ORG $+3
$SG11775 DB	'ccc2.cpp', 00H
	ORG $+3
$SG11776 DB	'abc.h', 00H
	ORG $+2
$SG11777 DB	'hello, world', 00H
	ORG $+3
$SG11779 DB	'%s', 00H
	ORG $+1
$SG11781 DB	'Inputs, Navigation & Focus', 00H
	ORG $+1
$SG11782 DB	'io.NavMovesMouse', 00H
	ORG $+3
$SG11783 DB	'Request ImGui to move your move cursor when using gamepa'
	DB	'd/keyboard navigation. NewFrame() will change io.MousePos and'
	DB	' set the io.WantMoveMouse flag, your backend will need to app'
	DB	'ly the new mouse position.', 00H
	ORG $+3
$SG11784 DB	'io.MouseDrawCursor', 00H
	ORG $+1
$SG11787 DB	'WantCaptureKeyboard: %d', 00H
$SG11788 DB	'WantTextInput: %d', 00H
	ORG $+2
$SG11785 DB	'Request ImGui to render a mouse cursor for you in softwa'
	DB	're. Note that a mouse cursor rendered via regular GPU renderi'
	DB	'ng will feel more laggy than hardware cursor, but will be mor'
	DB	'e in sync with your other visuals.', 00H
	ORG $+3
$SG11786 DB	'WantCaptureMouse: %d', 00H
	ORG $+3
$SG11789 DB	'WantMoveMouse: %d', 00H
	ORG $+2
$SG11791 DB	'Keyboard, Mouse & Navigation State', 00H
	ORG $+1
$SG11792 DB	'Mouse pos: (%g, %g)', 00H
$SG11793 DB	'Mouse down:', 00H
$SG11795 DB	'b%d (%.02f secs)', 00H
	ORG $+3
$SG11796 DB	'Mouse clicked:', 00H
	ORG $+1
$SG11798 DB	'b%d', 00H
$SG11799 DB	'Mouse dbl-clicked:', 00H
	ORG $+1
$SG11801 DB	'b%d', 00H
$SG11802 DB	'Mouse released:', 00H
$SG11804 DB	'b%d', 00H
$SG11805 DB	'Mouse wheel: %.1f', 00H
	ORG $+2
$SG11806 DB	'Keys down:', 00H
	ORG $+1
$SG11808 DB	'%d (%.02f secs)', 00H
$SG11809 DB	'Keys pressed:', 00H
	ORG $+2
$SG11811 DB	'%d', 00H
	ORG $+1
$SG11812 DB	'Keys release:', 00H
	ORG $+2
$SG11814 DB	'%d', 00H
	ORG $+1
$SG11815 DB	'SUPER ', 00H
	ORG $+1
$SG11817 DB	'ALT ', 00H
	ORG $+3
$SG11819 DB	'SHIFT ', 00H
	ORG $+1
$SG11821 DB	'CTRL ', 00H
	ORG $+2
$SG11823 DB	'Keys mods: %s%s%s%s', 00H
$SG11824 DB	'NavUsable: %d, NavActive: %d', 00H
	ORG $+3
$SG11825 DB	'NavInputs down:', 00H
$SG11827 DB	'[%d] %.2f', 00H
	ORG $+2
$SG11828 DB	'NavInputs pressed:', 00H
	ORG $+1
$SG11830 DB	'[%d]', 00H
	ORG $+3
$SG11831 DB	'NavInputs duration:', 00H
$SG11833 DB	'[%d] %.2f', 00H
	ORG $+2
$SG11834 DB	'Hovering me sets the', 0aH, 'keyboard capture flag', 00H
	ORG $+1
$SG11836 DB	'Holding me clears the', 0aH, 'the keyboard capture flag', 00H
$SG11839 DB	'Tabbing', 00H
$SG11840 DB	'Use TAB/SHIFT+TAB to cycle through keyboard editable fie'
	DB	'lds.', 00H
	ORG $+3
$SG11841 DB	'1', 00H
	ORG $+2
$SG11842 DB	'2', 00H
	ORG $+2
$SG11843 DB	'3', 00H
	ORG $+2
$SG11844 DB	'4 (tab skip)', 00H
	ORG $+3
$SG11845 DB	'5', 00H
	ORG $+2
$SG11847 DB	'Focus from code', 00H
$SG11848 DB	'Focus on 1', 00H
	ORG $+1
$SG11849 DB	'Focus on 2', 00H
	ORG $+1
$SG11850 DB	'Focus on 3', 00H
	ORG $+1
$SG11852 DB	'1', 00H
	ORG $+2
$SG11855 DB	'2', 00H
	ORG $+2
$SG11858 DB	'3 (tab skip)', 00H
	ORG $+3
$SG11862 DB	'Item with focus: %d', 00H
$SG11863 DB	'Item with focus: <none>', 00H
$SG11866 DB	'Dragging', 00H
	ORG $+3
$SG11864 DB	'Cursor & selection are preserved when refocusing last us'
	DB	'ed item in code.', 00H
	ORG $+3
$SG11868 DB	'Drag Me', 00H
$SG11873 DB	'Hover to see mouse cursors:', 00H
$SG11867 DB	'You can use ImGui::GetMouseDragDelta(0) to query for the'
	DB	' dragged amount on any widget.', 00H
	ORG $+1
$SG11870 DB	'Raw (%.1f, %.1f), WithLockThresold (%.1f, %.1f), MouseDe'
	DB	'lta (%.1f, %.1f)', 00H
	ORG $+3
$SG11872 DB	'Mouse cursors', 00H
	ORG $+2
$SG11875 DB	'Mouse cursor %d', 00H
$SG12932 DB	'log', 00H
$SG11874 DB	'Your application can render a different mouse cursor bas'
	DB	'ed on what ImGui::GetMouseCursor() returns. If software curso'
	DB	'r rendering (io.MouseDrawCursor) is set ImGui will draw the r'
	DB	'ight cursor for you, otherwise your backend needs to handle i'
	DB	't.', 00H
	ORG $+2
$SG12926 DB	'system', 00H
	ORG $+1
$SG12927 DB	'info', 00H
	ORG $+3
$SG12928 DB	'warning', 00H
$SG12929 DB	'error', 00H
	ORG $+2
$SG12930 DB	'fatal', 00H
	ORG $+2
$SG12931 DB	'notice', 00H
	ORG $+1
$SG12933 DB	'[%s] Hello, time is %.1f, rand() %d', 0aH, 00H
	ORG $+3
$SG12934 DB	'Example: Log', 00H
	ORG $+3
$SG12960 DB	'Example: Layout', 00H
$SG12963 DB	'File', 00H
	ORG $+3
$SG12965 DB	'Close', 00H
	ORG $+2
$SG12966 DB	'left pane', 00H
	ORG $+2
$SG12967 DB	'MyObject %d', 00H
$SG12969 DB	'item view', 00H
	ORG $+2
$SG12970 DB	'MyObject: %d', 00H
	ORG $+3
$SG12971 DB	'Lorem ipsum dolor sit amet, consectetur adipiscing elit,'
	DB	' sed do eiusmod tempor incididunt ut labore et dolore magna a'
	DB	'liqua. ', 00H
	ORG $+3
$SG12972 DB	'buttons', 00H
$SG12974 DB	'Revert', 00H
	ORG $+1
$SG12976 DB	'Save', 00H
	ORG $+3
$SG11994 DB	'Revert Style', 00H
	ORG $+3
$SG11997 DB	'Save Style', 00H
	ORG $+1
$SG13023 DB	'Example: Property editor', 00H
	ORG $+3
$SG11999 DB	'Rendering', 00H
	ORG $+2
$SG12000 DB	'Anti-aliased lines', 00H
	ORG $+1
$SG13024 DB	'This example shows how you may implement a property edit'
	DB	'or using two columns.', 0aH, 'All objects/fields data are dum'
	DB	'mies here.', 0aH, 'Remember that in many simple cases, you ca'
	DB	'n use ImGui::SameLine(xxx) to position', 0aH, 'your cursor ho'
	DB	'rizontally instead of using the Columns() API.', 00H
	ORG $+2
$SG13025 DB	'Object', 00H
	ORG $+1
$SG12001 DB	'Anti-aliased shapes', 00H
$SG12002 DB	'Curve Tessellation Tolerance', 00H
	ORG $+3
$SG12004 DB	'%.2f', 00H
	ORG $+3
$SG12005 DB	'Global Alpha', 00H
	ORG $+3
$SG12007 DB	'Settings', 00H
	ORG $+3
$SG12008 DB	'%.0f', 00H
	ORG $+3
$SG12009 DB	'WindowPadding', 00H
	ORG $+2
$SG12010 DB	'%.0f', 00H
	ORG $+3
$SG12011 DB	'WindowRounding', 00H
	ORG $+1
$SG12012 DB	'%.0f', 00H
	ORG $+3
$SG12013 DB	'ChildWindowRounding', 00H
$SG12014 DB	'%.0f', 00H
	ORG $+3
$SG12015 DB	'FramePadding', 00H
	ORG $+3
$SG12016 DB	'%.0f', 00H
	ORG $+3
$SG12017 DB	'FrameRounding', 00H
	ORG $+2
$SG12018 DB	'%.0f', 00H
	ORG $+3
$SG12019 DB	'ItemSpacing', 00H
$SG12020 DB	'%.0f', 00H
	ORG $+3
$SG12021 DB	'ItemInnerSpacing', 00H
	ORG $+3
$SG12022 DB	'%.0f', 00H
	ORG $+3
$SG12023 DB	'TouchExtraPadding', 00H
	ORG $+2
$SG12024 DB	'%.0f', 00H
	ORG $+3
$SG12025 DB	'IndentSpacing', 00H
	ORG $+2
$SG12026 DB	'%.0f', 00H
	ORG $+3
$SG12027 DB	'ScrollbarSize', 00H
	ORG $+2
$SG12028 DB	'%.0f', 00H
	ORG $+3
$SG12029 DB	'ScrollbarRounding', 00H
	ORG $+2
$SG12030 DB	'%.0f', 00H
	ORG $+3
$SG12031 DB	'GrabMinSize', 00H
$SG12032 DB	'%.0f', 00H
	ORG $+3
$SG12033 DB	'GrabRounding', 00H
	ORG $+3
$SG12034 DB	'Alignment', 00H
	ORG $+2
$SG12035 DB	'%.2f', 00H
	ORG $+3
$SG12036 DB	'WindowTitleAlign', 00H
	ORG $+3
$SG12037 DB	'%.2f', 00H
	ORG $+3
$SG12038 DB	'ButtonTextAlign', 00H
$SG12039 DB	'Alignment applies when a button is larger than its text '
	DB	'content.', 00H
	ORG $+3
$SG13064 DB	'Example: Long text display', 00H
	ORG $+1
$SG13065 DB	'Printing unusually long amount of text.', 00H
$SG12041 DB	'Colors', 00H
	ORG $+1
$SG13066 DB	'Single call to TextUnformatted()', 00H, 'Multiple calls '
	DB	'to Text(), clipped manually', 00H, 'Multiple calls to Text(),'
	DB	' not clipped', 00H, 00H
	ORG $+1
$SG13067 DB	'Test type', 00H
	ORG $+2
$SG12043 DB	'Copy Colors', 00H
$SG13068 DB	'Buffer contents: %d lines, %d bytes', 00H
$SG13070 DB	'Clear', 00H
	ORG $+2
$SG12046 DB	'ImGuiStyle& style = ImGui::GetStyle();', 0dH, 0aH, 00H
	ORG $+3
$SG13072 DB	'Add 1000 lines', 00H
	ORG $+1
$SG13073 DB	'%i The quick brown fox jumps over the lazy dog', 0aH, 00H
$SG13074 DB	'Log', 00H
$SG12050 DB	'style.Colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff'
	DB	', %.2ff);', 0dH, 0aH, 00H
$SG12051 DB	'To Clipboard', 00H, 'To TTY', 00H, 00H
	ORG $+3
$SG12052 DB	'##output_type', 00H
	ORG $+2
$SG13077 DB	'%i The quick brown fox jumps over the lazy dog', 00H
	ORG $+1
$SG12053 DB	'Only Modified Fields', 00H
	ORG $+3
$SG12054 DB	'RGB', 00H
$SG13079 DB	'%i The quick brown fox jumps over the lazy dog', 00H
	ORG $+1
$SG12055 DB	'HSV', 00H
$SG12056 DB	'HEX', 00H
$SG12058 DB	'Filter colors', 00H
	ORG $+2
$SG12059 DB	'#colors', 00H
$SG12063 DB	'Revert', 00H
	ORG $+1
$SG12066 DB	'Save', 00H
	ORG $+3
$SG12068 DB	'Fonts (%d)', 00H
	ORG $+1
$SG12069 DB	'Fonts', 00H
	ORG $+2
$SG12075 DB	'Font %d: ''%s'', %.2f px, %d glyphs', 00H
	ORG $+2
$SG12070 DB	'Tip: Load fonts with io.Fonts->AddFontFromFileTTF()', 0aH
	DB	'before calling io.Fonts->GetTex* functions.', 00H
$SG12072 DB	'Atlas texture (%dx%d pixels)', 00H
	ORG $+3
$SG12073 DB	'Atlas texture', 00H
	ORG $+2
$SG12077 DB	'Set as default', 00H
	ORG $+1
$SG12078 DB	'The quick brown fox jumps over the lazy dog', 00H
$SG12080 DB	'Details', 00H
$SG12081 DB	'%.1f', 00H
	ORG $+3
$SG12082 DB	'Font scale', 00H
	ORG $+1
$SG12083 DB	'Note than the default embedded font is NOT meant to be s'
	DB	'caled.', 0aH, 0aH, 'Font are currently rendered into bitmaps '
	DB	'at a given size at the time of building the atlas. You may ov'
	DB	'ersample them to get some flexibility with scaling. You can a'
	DB	'lso render at multiple sizes and select which one to use at r'
	DB	'untime.', 0aH, 0aH, '(Glimmer of hope: the atlas system shoul'
	DB	'd hopefully be rewritten in the future to make scaling more n'
	DB	'atural and automatic.)', 00H
	ORG $+3
$SG12084 DB	'Ascent: %f, Descent: %f, Height: %f', 00H
$SG12085 DB	'Fallback character: ''%c'' (%d)', 00H
	ORG $+2
$SG12086 DB	'Texture surface: %d pixels (approx)', 00H
$SG12087 DB	'Input %d: ''%s'', Oversample: (%d,%d), PixelSnapH: %d', 00H
$SG12089 DB	'Glyphs (%d)', 00H
$SG12090 DB	'Glyphs', 00H
	ORG $+1
$SG12092 DB	'glyphs', 00H
	ORG $+1
$SG12093 DB	'glyph', 00H
	ORG $+2
$SG12094 DB	'U+%04X..U+%04X (%d %s)', 00H
	ORG $+1
$SG12096 DB	'Codepoint: U+%04X', 00H
	ORG $+2
$SG12097 DB	'XAdvance+1: %.1f', 00H
	ORG $+3
$SG12098 DB	'Pos: (%.2f,%.2f)->(%.2f,%.2f)', 00H
	ORG $+2
$SG12099 DB	'UV: (%.3f,%.3f)->(%.3f,%.3f)', 00H
	ORG $+3
$SG12100 DB	'%.1f', 00H
	ORG $+3
$SG12101 DB	'this window scale', 00H
	ORG $+2
$SG12102 DB	'%.1f', 00H
	ORG $+3
$SG12103 DB	'global scale', 00H
	ORG $+3
$SG11082 DB	'Style Editor', 00H
	ORG $+3
$SG11084 DB	'About ImGui', 00H
$SG12109 DB	'File', 00H
	ORG $+3
$SG11085 DB	'dear imgui, %s', 00H
	ORG $+1
$SG11086 DB	'By Omar Cornut and all github contributors.', 00H
$SG12111 DB	'Edit', 00H
	ORG $+3
$SG12113 DB	'CTRL+Z', 00H
	ORG $+1
$SG12120 DB	'Cut', 00H
$SG11087 DB	'ImGui is licensed under the MIT License, see LICENSE for'
	DB	' more information.', 00H
	ORG $+1
$SG12114 DB	'Undo', 00H
	ORG $+3
$SG12116 DB	'CTRL+Y', 00H
	ORG $+1
$SG12117 DB	'Redo', 00H
	ORG $+3
$SG12119 DB	'CTRL+X', 00H
	ORG $+1
$SG11097 DB	'ImGui Demo', 00H
	ORG $+1
$SG12122 DB	'CTRL+C', 00H
	ORG $+1
$SG11098 DB	'Dear ImGui says hello.', 00H
	ORG $+1
$SG12123 DB	'Copy', 00H
	ORG $+3
$SG12125 DB	'CTRL+V', 00H
	ORG $+1
$SG11101 DB	'Menu', 00H
	ORG $+3
$SG12126 DB	'Paste', 00H
	ORG $+2
$SG11103 DB	'Examples', 00H
	ORG $+3
$SG11104 DB	'Main menu bar', 00H
	ORG $+2
$SG11105 DB	'Console', 00H
$SG11106 DB	'Log', 00H
$SG11107 DB	'Simple layout', 00H
	ORG $+2
$SG11108 DB	'Property editor', 00H
$SG11109 DB	'Long text display', 00H
	ORG $+2
$SG11110 DB	'Auto-resizing window', 00H
	ORG $+3
$SG11111 DB	'Constrained-resizing window', 00H
$SG11112 DB	'Simple overlay', 00H
	ORG $+1
$SG11113 DB	'Manipulating window title', 00H
	ORG $+2
$SG11114 DB	'Custom rendering', 00H
	ORG $+3
$SG11116 DB	'Help', 00H
	ORG $+3
$SG11117 DB	'Metrics', 00H
$SG11118 DB	'Style Editor', 00H
	ORG $+3
$SG11119 DB	'About ImGui', 00H
$SG11121 DB	'Help', 00H
	ORG $+3
$SG11124 DB	'Window options', 00H
	ORG $+1
$SG11125 DB	'No titlebar', 00H
$SG11122 DB	'This window is being created by the ShowTestWindow() fun'
	DB	'ction. Please refer to the code for programming reference.', 0aH
	DB	0aH, 'User Guide:', 00H
$SG12148 DB	'(dummy menu)', 00H
	ORG $+3
$SG12150 DB	'New', 00H
$SG11126 DB	'No border', 00H
	ORG $+2
$SG11127 DB	'No resize', 00H
	ORG $+2
$SG12152 DB	'Ctrl+O', 00H
	ORG $+1
$SG11128 DB	'No move', 00H
$SG12153 DB	'Open', 00H
	ORG $+3
$SG11129 DB	'No scrollbar', 00H
	ORG $+3
$SG11130 DB	'No collapse', 00H
$SG12155 DB	'Open Recent', 00H
$SG11131 DB	'No menu', 00H
$SG12156 DB	'fish_hat.c', 00H
	ORG $+1
$SG11132 DB	'No nav', 00H
	ORG $+1
$SG12157 DB	'fish_hat.inl', 00H
	ORG $+3
$SG12158 DB	'fish_hat.h', 00H
	ORG $+1
$SG11134 DB	'Style', 00H
	ORG $+2
$SG12160 DB	'More..', 00H
	ORG $+1
$SG11136 DB	'Logging', 00H
$SG12161 DB	'Hello', 00H
	ORG $+2
$SG12162 DB	'Sailor', 00H
	ORG $+1
$SG11139 DB	'Widgets', 00H
$SG12164 DB	'Recurse..', 00H
	ORG $+2
$SG11137 DB	'The logging API redirects all text output so you can eas'
	DB	'ily capture the content of a window or a block. Tree nodes ca'
	DB	'n be automatically expanded. You can also call ImGui::LogText'
	DB	'() to output directly to the log without a visual output.', 00H
$SG11141 DB	'Trees', 00H
	ORG $+2
$SG12166 DB	'Ctrl+S', 00H
	ORG $+1
$SG12167 DB	'Save', 00H
	ORG $+3
$SG11143 DB	'Basic trees', 00H
$SG12169 DB	'Save As..', 00H
	ORG $+2
$SG11145 DB	'Child %d', 00H
	ORG $+3
$SG11146 DB	'blah blah', 00H
	ORG $+2
$SG12171 DB	'Options', 00H
$SG11148 DB	'print', 00H
	ORG $+2
$SG12173 DB	'Enabled', 00H
$SG11149 DB	'Child %d pressed', 00H
	ORG $+3
$SG12174 DB	'child', 00H
	ORG $+2
$SG12175 DB	'Scrolling Text %d', 00H
	ORG $+2
$SG11151 DB	'Advanced, with Selectable nodes', 00H
$SG12176 DB	'%.3f', 00H
	ORG $+3
$SG12177 DB	'Value', 00H
	ORG $+2
$SG11154 DB	'Hello!', 00H
	ORG $+1
$SG11158 DB	'Selectable Node %d', 00H
	ORG $+1
$SG11152 DB	'This is a more standard looking tree with selectable nod'
	DB	'es.', 0aH, 'Click to select, CTRL+Click to toggle, click on a'
	DB	'rrows or double-click to open.', 00H
$SG11153 DB	'Align label with current X position)', 00H
	ORG $+3
$SG12178 DB	'Input', 00H
	ORG $+2
$SG12179 DB	'Yes', 00H, 'No', 00H, 'Maybe', 00H, 00H, 00H
	ORG $+1
$SG12180 DB	'Combo', 00H
	ORG $+2
$SG12181 DB	'Check', 00H
	ORG $+2
$SG12183 DB	'Colors', 00H
	ORG $+1
$SG12185 DB	'Disabled', 00H
	ORG $+3
$SG11161 DB	'Blah blah', 0aH, 'Blah Blah', 00H
$SG11162 DB	'Selectable Leaf %d', 00H
	ORG $+1
$SG12187 DB	'Checked', 00H
$SG12189 DB	'Alt+F4', 00H
	ORG $+1
$SG12190 DB	'Quit', 00H
	ORG $+3
$SG11169 DB	'Collapsing Headers', 00H
	ORG $+1
$SG11171 DB	'Header', 00H
	ORG $+1
$SG11172 DB	'Enable extra group', 00H
	ORG $+1
$SG11173 DB	'Some content %d', 00H
$SG11175 DB	'Header with a close button', 00H
	ORG $+1
$SG11176 DB	'More content %d', 00H
$SG12201 DB	'Example: Auto-resizing window', 00H
	ORG $+2
$SG11178 DB	'Bullets', 00H
$SG11180 DB	'Bullet point 2', 0aH, 'On multiple lines', 00H
	ORG $+3
$SG12202 DB	'Window will resize every-frame to the size of its conten'
	DB	't.', 0aH, 'Note that you probably don''t want to query the wi'
	DB	'ndow size to', 0aH, 'output your content because that would c'
	DB	'reate a feedback loop.', 00H
$SG12203 DB	'%.0f', 00H
	ORG $+3
$SG11179 DB	'Bullet point 1', 00H
	ORG $+1
$SG12204 DB	'Number of lines', 00H
$SG11181 DB	'Bullet point 3 (two calls)', 00H
	ORG $+1
$SG12206 DB	'%*sThis is line %d', 00H
	ORG $+1
$SG11182 DB	'Button', 00H
	ORG $+1
$SG11184 DB	'Colored Text', 00H
	ORG $+3
$SG11185 DB	'Pink', 00H
	ORG $+3
$SG11186 DB	'Yellow', 00H
	ORG $+1
$SG11187 DB	'Disabled', 00H
	ORG $+3
$SG11189 DB	'Word Wrapping', 00H
	ORG $+2
$SG11192 DB	'Wrap width', 00H
	ORG $+1
$SG11190 DB	'This text should automatically wrap on the edge of the w'
	DB	'indow. The current implementation for text wrapping follows s'
	DB	'imple rules suitable for English and possibly other languages'
	DB	'.', 00H
$SG11191 DB	'%.0f', 00H
	ORG $+3
$SG11193 DB	'Test paragraph 1:', 00H
	ORG $+2
$SG11194 DB	'The lazy dog is a good dog. This paragraph is made to fi'
	DB	't within %.0f pixels. Testing a 1 character word. The quick b'
	DB	'rown fox jumps over the lazy dog.', 00H
	ORG $+1
$SG11195 DB	'Test paragraph 2:', 00H
	ORG $+2
$SG11198 DB	'UTF-8 Text', 00H
	ORG $+1
$SG11196 DB	'aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   fff'
	DB	'fffff. gggggggg!hhhhhhhh', 00H
	ORG $+3
$SG11200 DB	'Hiragana: ', 0e3H, 081H, 08bH, 0e3H, 081H, 08dH, 0e3H, 081H
	DB	08fH, 0e3H, 081H, 091H, 0e3H, 081H, 093H, ' (kakikukeko)', 00H
	ORG $+1
$SG11201 DB	'Kanjis: ', 0e6H, 097H, 0a5H, 0e6H, 09cH, 0acH, 0e8H, 0aaH
	DB	09eH, ' (nihongo)', 00H
$SG11199 DB	'CJK text will only appears if the font was loaded with t'
	DB	'he appropriate CJK character ranges. Call io.Font->LoadFromFi'
	DB	'leTTF() manually to load extra character ranges.', 00H
	ORG $+2
$SG11202 DB	'UTF-8 input', 00H
$SG11204 DB	'Images', 00H
	ORG $+1
$SG11206 DB	'%.0fx%.0f', 00H
	ORG $+2
$SG11205 DB	'Below we are displaying the font texture (which is the o'
	DB	'nly texture we have access to in this demo). Use the ''ImText'
	DB	'ureID'' type as storage to pass pointers or identifier to you'
	DB	'r own texture data. Hover the texture for a zoomed view!', 00H
	ORG $+3
$SG11214 DB	'Min: (%.2f, %.2f)', 00H
	ORG $+2
$SG11215 DB	'Max: (%.2f, %.2f)', 00H
	ORG $+2
$SG11216 DB	'And now some textured buttons..', 00H
$SG11218 DB	'Pressed %d times.', 00H
	ORG $+2
$SG11220 DB	'Selectables', 00H
$SG11222 DB	'Basic', 00H
	ORG $+2
$SG11223 DB	'1. I am selectable', 00H
	ORG $+1
$SG11224 DB	'2. I am selectable', 00H
	ORG $+1
$SG11225 DB	'3. I am not selectable', 00H
	ORG $+1
$SG11226 DB	'4. I am selectable', 00H
	ORG $+1
$SG11228 DB	'5. I am double clickable', 00H
	ORG $+3
$SG11231 DB	'Rendering more text into the same block', 00H
$SG11232 DB	'main.c', 00H
	ORG $+1
$SG11233 DB	' 2,345 bytes', 00H
	ORG $+3
$SG11234 DB	'Hello.cpp', 00H
	ORG $+2
$SG11235 DB	'12,345 bytes', 00H
	ORG $+3
$SG11236 DB	'Hello.h', 00H
$SG11237 DB	' 2,345 bytes', 00H
	ORG $+3
$SG11239 DB	'In columns', 00H
	ORG $+1
$SG11240 DB	'Item %d', 00H
$SG11243 DB	'Grid', 00H
	ORG $+3
$SG12269 DB	'Example: Constrained Resize', 00H
$SG11245 DB	'Sailor', 00H
	ORG $+1
$SG12270 DB	'Resize vertical only', 00H
	ORG $+3
$SG12271 DB	'Resize horizontal only', 00H
	ORG $+1
$SG12272 DB	'Width > 100, Height > 100', 00H
	ORG $+2
$SG12273 DB	'Width 300-400', 00H
	ORG $+2
$SG12274 DB	'Custom: Always Square', 00H
	ORG $+2
$SG12275 DB	'Custom: Fixed Steps (100)', 00H
	ORG $+2
$SG12276 DB	'Constraint', 00H
	ORG $+1
$SG11252 DB	'Filtered Text Input', 00H
$SG11253 DB	'default', 00H
$SG12278 DB	'200x200', 00H
$SG11254 DB	'decimal', 00H
$SG11255 DB	'hexadecimal', 00H
$SG12280 DB	'500x500', 00H
$SG11256 DB	'uppercase', 00H
	ORG $+2
$SG11257 DB	'no blank', 00H
	ORG $+3
$SG12282 DB	'800x200', 00H
$SG11258 DB	'"imgui" letters', 00H
$SG12283 DB	'Hello, sailor! Making this line long enough for the exam'
	DB	'ple.', 00H
	ORG $+3
$SG11259 DB	'Password input', 00H
	ORG $+1
$SG11260 DB	'password', 00H
	ORG $+3
$SG11261 DB	'Display all characters as ''*''.', 0aH, 'Disable clipboa'
	DB	'rd cut and copy.', 0aH, 'Disable logging.', 0aH, 00H
	ORG $+3
$SG11262 DB	'password (clear)', 00H
CONST	ENDS
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QAE@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QAE@MMMM@Z				; ImVec4::ImVec4
PUBLIC	?ShowUserGuide@ImGui@@YAXXZ			; ImGui::ShowUserGuide
PUBLIC	?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z	; ImGui::ShowStyleEditor
PUBLIC	?ShowTestWindow@ImGui@@YAXPA_N@Z		; ImGui::ShowTestWindow
PUBLIC	??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ ; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>
PUBLIC	?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QBE_NXZ ; ImVector<ImGuiTextFilter::TextRange>::empty
PUBLIC	??1ImGuiTextFilter@@QAE@XZ			; ImGuiTextFilter::~ImGuiTextFilter
PUBLIC	?IsActive@ImGuiTextFilter@@QBE_NXZ		; ImGuiTextFilter::IsActive
PUBLIC	??0?$ImVector@D@@QAE@XZ				; ImVector<char>::ImVector<char>
PUBLIC	??1?$ImVector@D@@QAE@XZ				; ImVector<char>::~ImVector<char>
PUBLIC	?clear@?$ImVector@D@@QAEXXZ			; ImVector<char>::clear
PUBLIC	?front@?$ImVector@D@@QBEABDXZ			; ImVector<char>::front
PUBLIC	?back@?$ImVector@D@@QBEABDXZ			; ImVector<char>::back
PUBLIC	?_grow_capacity@?$ImVector@D@@QAEHH@Z		; ImVector<char>::_grow_capacity
PUBLIC	?reserve@?$ImVector@D@@QAEXH@Z			; ImVector<char>::reserve
PUBLIC	?push_back@?$ImVector@D@@QAEXABD@Z		; ImVector<char>::push_back
PUBLIC	??0ImGuiTextBuffer@@QAE@XZ			; ImGuiTextBuffer::ImGuiTextBuffer
PUBLIC	??AImGuiTextBuffer@@QAEDH@Z			; ImGuiTextBuffer::operator[]
PUBLIC	?begin@ImGuiTextBuffer@@QBEPBDXZ		; ImGuiTextBuffer::begin
PUBLIC	?end@ImGuiTextBuffer@@QBEPBDXZ			; ImGuiTextBuffer::end
PUBLIC	?size@ImGuiTextBuffer@@QBEHXZ			; ImGuiTextBuffer::size
PUBLIC	?clear@ImGuiTextBuffer@@QAEXXZ			; ImGuiTextBuffer::clear
PUBLIC	??1ImGuiTextBuffer@@QAE@XZ			; ImGuiTextBuffer::~ImGuiTextBuffer
PUBLIC	??0ImColor@@QAE@HHHH@Z				; ImColor::ImColor
PUBLIC	??0ImColor@@QAE@MMMM@Z				; ImColor::ImColor
PUBLIC	??0ImColor@@QAE@ABUImVec4@@@Z			; ImColor::ImColor
PUBLIC	??BImColor@@QBEIXZ				; ImColor::operator unsigned int
PUBLIC	??BImColor@@QBE?AUImVec4@@XZ			; ImColor::operator ImVec4
PUBLIC	?HSV@ImColor@@SA?AU1@MMMM@Z			; ImColor::HSV
PUBLIC	??0ImGuiListClipper@@QAE@HM@Z			; ImGuiListClipper::ImGuiListClipper
PUBLIC	??1ImGuiListClipper@@QAE@XZ			; ImGuiListClipper::~ImGuiListClipper
PUBLIC	??0?$ImVector@UImVec2@@@@QAE@XZ			; ImVector<ImVec2>::ImVector<ImVec2>
PUBLIC	??1?$ImVector@UImVec2@@@@QAE@XZ			; ImVector<ImVec2>::~ImVector<ImVec2>
PUBLIC	?empty@?$ImVector@UImVec2@@@@QBE_NXZ		; ImVector<ImVec2>::empty
PUBLIC	??A?$ImVector@UImVec2@@@@QAEAAUImVec2@@H@Z	; ImVector<ImVec2>::operator[]
PUBLIC	?clear@?$ImVector@UImVec2@@@@QAEXXZ		; ImVector<ImVec2>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QAEXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	?pop_back@?$ImVector@UImVec2@@@@QAEXXZ		; ImVector<ImVec2>::pop_back
PUBLIC	??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z	; ImVector<ImFont *>::operator[]
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	??0?$ImVector@PAD@@QAE@XZ			; ImVector<char *>::ImVector<char *>
PUBLIC	??1?$ImVector@PAD@@QAE@XZ			; ImVector<char *>::~ImVector<char *>
PUBLIC	??A?$ImVector@PAD@@QAEAAPADH@Z			; ImVector<char *>::operator[]
PUBLIC	?clear@?$ImVector@PAD@@QAEXXZ			; ImVector<char *>::clear
PUBLIC	?begin@?$ImVector@PAD@@QAEPAPADXZ		; ImVector<char *>::begin
PUBLIC	?_grow_capacity@?$ImVector@PAD@@QAEHH@Z		; ImVector<char *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PAD@@QAEXH@Z		; ImVector<char *>::reserve
PUBLIC	?push_back@?$ImVector@PAD@@QAEXABQAD@Z		; ImVector<char *>::push_back
PUBLIC	?erase@?$ImVector@PAD@@QAEPAPADPBQAD@Z		; ImVector<char *>::erase
PUBLIC	??0?$ImVector@PBD@@QAE@XZ			; ImVector<char const *>::ImVector<char const *>
PUBLIC	??1?$ImVector@PBD@@QAE@XZ			; ImVector<char const *>::~ImVector<char const *>
PUBLIC	??A?$ImVector@PBD@@QAEAAPBDH@Z			; ImVector<char const *>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@PBD@@QAEHH@Z		; ImVector<char const *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PBD@@QAEXH@Z		; ImVector<char const *>::reserve
PUBLIC	?push_back@?$ImVector@PBD@@QAEXABQBD@Z		; ImVector<char const *>::push_back
PUBLIC	??0ExampleAppConsole@@QAE@XZ			; ExampleAppConsole::ExampleAppConsole
PUBLIC	??1ExampleAppConsole@@QAE@XZ			; ExampleAppConsole::~ExampleAppConsole
PUBLIC	?Stricmp@ExampleAppConsole@@SAHPBD0@Z		; ExampleAppConsole::Stricmp
PUBLIC	?Strnicmp@ExampleAppConsole@@SAHPBD0H@Z		; ExampleAppConsole::Strnicmp
PUBLIC	?Strdup@ExampleAppConsole@@SAPADPBD@Z		; ExampleAppConsole::Strdup
PUBLIC	?ClearLog@ExampleAppConsole@@QAEXXZ		; ExampleAppConsole::ClearLog
PUBLIC	?AddLog@ExampleAppConsole@@QAAXPBDZZ		; ExampleAppConsole::AddLog
PUBLIC	?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z		; ExampleAppConsole::Draw
PUBLIC	?ExecCommand@ExampleAppConsole@@QAEXPBD@Z	; ExampleAppConsole::ExecCommand
PUBLIC	?TextEditCallbackStub@ExampleAppConsole@@SAHPAUImGuiTextEditCallbackData@@@Z ; ExampleAppConsole::TextEditCallbackStub
PUBLIC	?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z ; ExampleAppConsole::TextEditCallback
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ ; `ExampleAppConsole::Draw'::`2'::`dynamic atexit destructor for 'filter''
PUBLIC	??0?$ImVector@H@@QAE@XZ				; ImVector<int>::ImVector<int>
PUBLIC	??1?$ImVector@H@@QAE@XZ				; ImVector<int>::~ImVector<int>
PUBLIC	??A?$ImVector@H@@QAEAAHH@Z			; ImVector<int>::operator[]
PUBLIC	?clear@?$ImVector@H@@QAEXXZ			; ImVector<int>::clear
PUBLIC	?_grow_capacity@?$ImVector@H@@QAEHH@Z		; ImVector<int>::_grow_capacity
PUBLIC	?reserve@?$ImVector@H@@QAEXH@Z			; ImVector<int>::reserve
PUBLIC	?push_back@?$ImVector@H@@QAEXABH@Z		; ImVector<int>::push_back
PUBLIC	?Clear@ExampleAppLog@@QAEXXZ			; ExampleAppLog::Clear
PUBLIC	?AddLog@ExampleAppLog@@QAAXPBDZZ		; ExampleAppLog::AddLog
PUBLIC	?Draw@ExampleAppLog@@QAEXPBDPA_N@Z		; ExampleAppLog::Draw
PUBLIC	??0ExampleAppLog@@QAE@XZ			; ExampleAppLog::ExampleAppLog
PUBLIC	??1ExampleAppLog@@QAE@XZ			; ExampleAppLog::~ExampleAppLog
PUBLIC	??_C@_05EAJAAGNN@imgui?$AA@			; `string'
PUBLIC	??_C@_04DOKPJKJF@HELP?$AA@			; `string'
PUBLIC	??_C@_07DBIJIOJO@HISTORY?$AA@			; `string'
PUBLIC	??_C@_05PONODPI@CLEAR?$AA@			; `string'
PUBLIC	??_C@_08GOHMLCGG@CLASSIFY?$AA@			; `string'
PUBLIC	??_C@_0BC@JPCINNJN@Welcome?5to?5ImGui?$CB?$AA@	; `string'
PUBLIC	?filter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4UImGuiTextFilter@@A ; `ExampleAppConsole::Draw'::`2'::filter
PUBLIC	?$TSS0@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4HA ; TSS0<`template-parameter-2',ExampleAppConsole::aw,unsigned char * const,void,char const *,bool *>
PUBLIC	??_C@_0MA@ICGIOBFG@This?5example?5implements?5a?5consol@ ; `string'
PUBLIC	??_C@_0DJ@NBHLDCP@Enter?5?8HELP?8?5for?5help?0?5press?5TAB@ ; `string'
PUBLIC	??_C@_0P@CGJDLLEJ@Add?5Dummy?5Text?$AA@		; `string'
PUBLIC	??_C@_0N@OJGBPOOP@?$CFd?5some?5text?$AA@	; `string'
PUBLIC	??_C@_0P@BMHJKMPF@some?5more?5text?$AA@		; `string'
PUBLIC	??_C@_0CF@PEIDNPCH@display?5very?5important?5message?5h@ ; `string'
PUBLIC	??_C@_0BA@HHKLEHKC@Add?5Dummy?5Error?$AA@	; `string'
PUBLIC	??_C@_0BN@KNPJMMPE@?$FLerror?$FN?5something?5went?5wrong?$AA@ ; `string'
PUBLIC	??_C@_05MDNHABIA@Clear?$AA@			; `string'
PUBLIC	??_C@_0BB@GPFIAMJC@Scroll?5to?5bottom?$AA@	; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0CA@HIABFBKB@Filter?5?$CI?$CCincl?0?9excl?$CC?$CJ?5?$CI?$CCerror?$CC?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BA@KOEFNJOK@ScrollingRegion?$AA@		; `string'
PUBLIC	??_C@_07LFMCMLFD@?$FLerror?$FN?$AA@		; `string'
PUBLIC	??_C@_02KPDBPKPG@?$CD?5?$AA@			; `string'
PUBLIC	??_C@_05DCDOHKAB@Input?$AA@			; `string'
PUBLIC	??_C@_05DFHAGHEP@?$CD?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_09GJFNIAOH@Commands?3?$AA@		; `string'
PUBLIC	??_C@_04JKCKOCFH@?9?5?$CFs?$AA@			; `string'
PUBLIC	??_C@_08PKLPHKJF@?$CF3d?3?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0BH@OKLFOGKH@Unknown?5command?3?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@DOPMHGPK@No?5match?5for?5?$CC?$CF?4?$CKs?$CC?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_0BD@LCPLNAHF@Possible?5matches?3?6?$AA@	; `string'
PUBLIC	??_C@_05PHKAGDP@?9?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_04OPMHGHMB@Copy?$AA@			; `string'
PUBLIC	??_C@_06IBDJIBGI@Filter?$AA@			; `string'
PUBLIC	??_C@_09PKEBEIDM@scrolling?$AA@			; `string'
PUBLIC	?dummy_members@?4??ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z@4PAMA ; ``ShowExampleAppPropertyEditor'::`2'::funcs::ShowDummyObject'::`5'::dummy_members
PUBLIC	??_C@_05FIIOEGIK@?$CFs_?$CFu?$AA@		; `string'
PUBLIC	??_C@_06ELFECKBG@Object?$AA@			; `string'
PUBLIC	??_C@_0BC@LIBEHHHH@my?5sailor?5is?5rich?$AA@	; `string'
PUBLIC	??_C@_05GIMBDOHM@Child?$AA@			; `string'
PUBLIC	??_C@_08BNKJGCPO@Field_?$CFd?$AA@		; `string'
PUBLIC	??_C@_07FBBIKLOB@?$CD?$CDvalue?$AA@		; `string'
PUBLIC	??_C@_04GFJLOHHD@?$CF?43f?$AA@			; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3b808081
PUBLIC	__real@3c888889
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e124925
PUBLIC	__real@3e2e147b
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3f8ccccd
PUBLIC	__real@3fa66666
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41800000
PUBLIC	__real@41a00000
PUBLIC	__real@41c00000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@42200000
PUBLIC	__real@42480000
PUBLIC	__real@42800000
PUBLIC	__real@447a0000
PUBLIC	__real@44db2000
PUBLIC	__real@bdcccccd
PUBLIC	__real@bf800000
PUBLIC	__real@c47a0000
PUBLIC	__xmm@3f0080813f8000003f8000003f800000
PUBLIC	__xmm@3f19999a3f4ccccd3e4ccccd3f000000
PUBLIC	__xmm@3f800000000000000000000000000000
PUBLIC	__xmm@3f80000000000000000000003f800000
PUBLIC	__xmm@3f800000000000003f80000000000000
PUBLIC	__xmm@3f800000000000003f8000003f800000
PUBLIC	__xmm@3f8000003e48c8ca3e48c8ca3e48c8ca
PUBLIC	__xmm@3f8000003e70f0f23e48c8ca3e48c8ca
PUBLIC	__xmm@3f8000003e8c8c8d3e70f0f23e70f0f2
PUBLIC	__xmm@3f8000003ecccccd3ecccccd3f800000
PUBLIC	__xmm@3f8000003ef0f0f23eb4b4b53eb4b4b5
PUBLIC	__xmm@3f8000003f147ae13f47ae143f800000
PUBLIC	__xmm@3f8000003f800000000000003f800000
PUBLIC	__xmm@3f8000003f8000003f0000003f4ccccd
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__strstr:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ:PROC	; ImGui::GetStyle
EXTRN	?ShowMetricsWindow@ImGui@@YAXPA_N@Z:PROC	; ImGui::ShowMetricsWindow
EXTRN	?Begin@ImGui@@YA_NPBDPA_NH@Z:PROC		; ImGui::Begin
EXTRN	?Begin@ImGui@@YA_NPBDPA_NABUImVec2@@MH@Z:PROC	; ImGui::Begin
EXTRN	?End@ImGui@@YAXXZ:PROC				; ImGui::End
EXTRN	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z:PROC	; ImGui::BeginChild
EXTRN	?BeginChild@ImGui@@YA_NIABUImVec2@@_NH@Z:PROC	; ImGui::BeginChild
EXTRN	?EndChild@ImGui@@YAXXZ:PROC			; ImGui::EndChild
EXTRN	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetContentRegionAvail
EXTRN	?GetContentRegionAvailWidth@ImGui@@YAMXZ:PROC	; ImGui::GetContentRegionAvailWidth
EXTRN	?GetWindowContentRegionWidth@ImGui@@YAMXZ:PROC	; ImGui::GetWindowContentRegionWidth
EXTRN	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ:PROC ; ImGui::GetWindowDrawList
EXTRN	?GetWindowWidth@ImGui@@YAMXZ:PROC		; ImGui::GetWindowWidth
EXTRN	?SetWindowFontScale@ImGui@@YAXM@Z:PROC		; ImGui::SetWindowFontScale
EXTRN	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z:PROC	; ImGui::SetNextWindowPos
EXTRN	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z:PROC ; ImGui::SetNextWindowSize
EXTRN	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z:PROC ; ImGui::SetNextWindowSizeConstraints
EXTRN	?SetWindowSize@ImGui@@YAXABUImVec2@@H@Z:PROC	; ImGui::SetWindowSize
EXTRN	?GetScrollX@ImGui@@YAMXZ:PROC			; ImGui::GetScrollX
EXTRN	?SetScrollX@ImGui@@YAXM@Z:PROC			; ImGui::SetScrollX
EXTRN	?SetScrollHere@ImGui@@YAXM@Z:PROC		; ImGui::SetScrollHere
EXTRN	?SetScrollFromPosY@ImGui@@YAXMM@Z:PROC		; ImGui::SetScrollFromPosY
EXTRN	?SetKeyboardFocusHere@ImGui@@YAXH@Z:PROC	; ImGui::SetKeyboardFocusHere
EXTRN	?PushFont@ImGui@@YAXPAUImFont@@@Z:PROC		; ImGui::PushFont
EXTRN	?PopFont@ImGui@@YAXXZ:PROC			; ImGui::PopFont
EXTRN	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z:PROC	; ImGui::PushStyleColor
EXTRN	?PopStyleColor@ImGui@@YAXH@Z:PROC		; ImGui::PopStyleColor
EXTRN	?PushStyleVar@ImGui@@YAXHM@Z:PROC		; ImGui::PushStyleVar
EXTRN	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z:PROC	; ImGui::PushStyleVar
EXTRN	?PopStyleVar@ImGui@@YAXH@Z:PROC			; ImGui::PopStyleVar
EXTRN	?GetFont@ImGui@@YAPAUImFont@@XZ:PROC		; ImGui::GetFont
EXTRN	?GetFontSize@ImGui@@YAMXZ:PROC			; ImGui::GetFontSize
EXTRN	?GetColorU32@ImGui@@YAIHM@Z:PROC		; ImGui::GetColorU32
EXTRN	?PushItemWidth@ImGui@@YAXM@Z:PROC		; ImGui::PushItemWidth
EXTRN	?PopItemWidth@ImGui@@YAXXZ:PROC			; ImGui::PopItemWidth
EXTRN	?PushTextWrapPos@ImGui@@YAXM@Z:PROC		; ImGui::PushTextWrapPos
EXTRN	?PopTextWrapPos@ImGui@@YAXXZ:PROC		; ImGui::PopTextWrapPos
EXTRN	?PushAllowKeyboardFocus@ImGui@@YAX_N@Z:PROC	; ImGui::PushAllowKeyboardFocus
EXTRN	?PopAllowKeyboardFocus@ImGui@@YAXXZ:PROC	; ImGui::PopAllowKeyboardFocus
EXTRN	?Separator@ImGui@@YAXXZ:PROC			; ImGui::Separator
EXTRN	?SameLine@ImGui@@YAXMM@Z:PROC			; ImGui::SameLine
EXTRN	?NewLine@ImGui@@YAXXZ:PROC			; ImGui::NewLine
EXTRN	?Spacing@ImGui@@YAXXZ:PROC			; ImGui::Spacing
EXTRN	?Dummy@ImGui@@YAXABUImVec2@@@Z:PROC		; ImGui::Dummy
EXTRN	?Indent@ImGui@@YAXM@Z:PROC			; ImGui::Indent
EXTRN	?Unindent@ImGui@@YAXM@Z:PROC			; ImGui::Unindent
EXTRN	?BeginGroup@ImGui@@YAXXZ:PROC			; ImGui::BeginGroup
EXTRN	?EndGroup@ImGui@@YAXXZ:PROC			; ImGui::EndGroup
EXTRN	?GetCursorPos@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetCursorPos
EXTRN	?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetCursorStartPos
EXTRN	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetCursorScreenPos
EXTRN	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ:PROC ; ImGui::AlignFirstTextHeightToWidgets
EXTRN	?GetTextLineHeight@ImGui@@YAMXZ:PROC		; ImGui::GetTextLineHeight
EXTRN	?GetItemsLineHeightWithSpacing@ImGui@@YAMXZ:PROC ; ImGui::GetItemsLineHeightWithSpacing
EXTRN	?Columns@ImGui@@YAXHPBD_N@Z:PROC		; ImGui::Columns
EXTRN	?NextColumn@ImGui@@YAXXZ:PROC			; ImGui::NextColumn
EXTRN	?PushID@ImGui@@YAXPBD@Z:PROC			; ImGui::PushID
EXTRN	?PushID@ImGui@@YAXH@Z:PROC			; ImGui::PushID
EXTRN	?PopID@ImGui@@YAXXZ:PROC			; ImGui::PopID
EXTRN	?GetID@ImGui@@YAIPBX@Z:PROC			; ImGui::GetID
EXTRN	?Text@ImGui@@YAXPBDZZ:PROC			; ImGui::Text
EXTRN	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ:PROC	; ImGui::TextColored
EXTRN	?TextDisabled@ImGui@@YAXPBDZZ:PROC		; ImGui::TextDisabled
EXTRN	?TextWrapped@ImGui@@YAXPBDZZ:PROC		; ImGui::TextWrapped
EXTRN	?TextUnformatted@ImGui@@YAXPBD0@Z:PROC		; ImGui::TextUnformatted
EXTRN	?LabelText@ImGui@@YAXPBD0ZZ:PROC		; ImGui::LabelText
EXTRN	?Bullet@ImGui@@YAXXZ:PROC			; ImGui::Bullet
EXTRN	?BulletText@ImGui@@YAXPBDZZ:PROC		; ImGui::BulletText
EXTRN	?Button@ImGui@@YA_NPBDABUImVec2@@@Z:PROC	; ImGui::Button
EXTRN	?SmallButton@ImGui@@YA_NPBD@Z:PROC		; ImGui::SmallButton
EXTRN	?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z:PROC ; ImGui::InvisibleButton
EXTRN	?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z:PROC ; ImGui::Image
EXTRN	?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z:PROC ; ImGui::ImageButton
EXTRN	?Checkbox@ImGui@@YA_NPBDPA_N@Z:PROC		; ImGui::Checkbox
EXTRN	?RadioButton@ImGui@@YA_NPBDPAHH@Z:PROC		; ImGui::RadioButton
EXTRN	?Combo@ImGui@@YA_NPBDPAHPBQBDHH@Z:PROC		; ImGui::Combo
EXTRN	?Combo@ImGui@@YA_NPBDPAH0H@Z:PROC		; ImGui::Combo
EXTRN	?ColorButton@ImGui@@YA_NABUImVec4@@_N1@Z:PROC	; ImGui::ColorButton
EXTRN	?ColorEdit3@ImGui@@YA_NPBDQAM@Z:PROC		; ImGui::ColorEdit3
EXTRN	?ColorEdit4@ImGui@@YA_NPBDQAM_N@Z:PROC		; ImGui::ColorEdit4
EXTRN	?ColorEditMode@ImGui@@YAXH@Z:PROC		; ImGui::ColorEditMode
EXTRN	?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z:PROC ; ImGui::PlotLines
EXTRN	?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z:PROC ; ImGui::PlotLines
EXTRN	?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z:PROC ; ImGui::PlotHistogram
EXTRN	?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z:PROC ; ImGui::PlotHistogram
EXTRN	?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z:PROC	; ImGui::ProgressBar
EXTRN	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z:PROC	; ImGui::DragFloat
EXTRN	?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z:PROC	; ImGui::DragFloat2
EXTRN	?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z:PROC	; ImGui::DragFloat3
EXTRN	?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z:PROC	; ImGui::DragFloat4
EXTRN	?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z:PROC ; ImGui::DragFloatRange2
EXTRN	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z:PROC		; ImGui::DragInt
EXTRN	?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z:PROC		; ImGui::DragInt2
EXTRN	?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z:PROC		; ImGui::DragInt3
EXTRN	?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z:PROC		; ImGui::DragInt4
EXTRN	?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z:PROC	; ImGui::DragIntRange2
EXTRN	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z:PROC ; ImGui::InputText
EXTRN	?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z:PROC ; ImGui::InputTextMultiline
EXTRN	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z:PROC	; ImGui::InputFloat
EXTRN	?InputFloat2@ImGui@@YA_NPBDQAMHH@Z:PROC		; ImGui::InputFloat2
EXTRN	?InputFloat3@ImGui@@YA_NPBDQAMHH@Z:PROC		; ImGui::InputFloat3
EXTRN	?InputFloat4@ImGui@@YA_NPBDQAMHH@Z:PROC		; ImGui::InputFloat4
EXTRN	?InputInt@ImGui@@YA_NPBDPAHHHH@Z:PROC		; ImGui::InputInt
EXTRN	?InputInt2@ImGui@@YA_NPBDQAHH@Z:PROC		; ImGui::InputInt2
EXTRN	?InputInt3@ImGui@@YA_NPBDQAHH@Z:PROC		; ImGui::InputInt3
EXTRN	?InputInt4@ImGui@@YA_NPBDQAHH@Z:PROC		; ImGui::InputInt4
EXTRN	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z:PROC	; ImGui::SliderFloat
EXTRN	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z:PROC	; ImGui::SliderFloat2
EXTRN	?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z:PROC	; ImGui::SliderFloat3
EXTRN	?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z:PROC	; ImGui::SliderFloat4
EXTRN	?SliderAngle@ImGui@@YA_NPBDPAMMM@Z:PROC		; ImGui::SliderAngle
EXTRN	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z:PROC		; ImGui::SliderInt
EXTRN	?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z:PROC		; ImGui::SliderInt2
EXTRN	?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z:PROC		; ImGui::SliderInt3
EXTRN	?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z:PROC		; ImGui::SliderInt4
EXTRN	?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z:PROC ; ImGui::VSliderFloat
EXTRN	?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z:PROC ; ImGui::VSliderInt
EXTRN	?TreeNode@ImGui@@YA_NPBD@Z:PROC			; ImGui::TreeNode
EXTRN	?TreeNode@ImGui@@YA_NPBD0ZZ:PROC		; ImGui::TreeNode
EXTRN	?TreeNode@ImGui@@YA_NPBXPBDZZ:PROC		; ImGui::TreeNode
EXTRN	?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ:PROC		; ImGui::TreeNodeEx
EXTRN	?TreePush@ImGui@@YAXPBX@Z:PROC			; ImGui::TreePush
EXTRN	?TreePop@ImGui@@YAXXZ:PROC			; ImGui::TreePop
EXTRN	?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ:PROC	; ImGui::GetTreeNodeToLabelSpacing
EXTRN	?CollapsingHeader@ImGui@@YA_NPBDH@Z:PROC	; ImGui::CollapsingHeader
EXTRN	?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z:PROC	; ImGui::CollapsingHeader
EXTRN	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z:PROC	; ImGui::Selectable
EXTRN	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z:PROC ; ImGui::Selectable
EXTRN	?ListBox@ImGui@@YA_NPBDPAHPBQBDHH@Z:PROC	; ImGui::ListBox
EXTRN	?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z:PROC	; ImGui::ListBoxHeader
EXTRN	?ListBoxFooter@ImGui@@YAXXZ:PROC		; ImGui::ListBoxFooter
EXTRN	?SetTooltip@ImGui@@YAXPBDZZ:PROC		; ImGui::SetTooltip
EXTRN	?BeginTooltip@ImGui@@YAXXZ:PROC			; ImGui::BeginTooltip
EXTRN	?EndTooltip@ImGui@@YAXXZ:PROC			; ImGui::EndTooltip
EXTRN	?BeginMainMenuBar@ImGui@@YA_NXZ:PROC		; ImGui::BeginMainMenuBar
EXTRN	?EndMainMenuBar@ImGui@@YAXXZ:PROC		; ImGui::EndMainMenuBar
EXTRN	?BeginMenuBar@ImGui@@YA_NXZ:PROC		; ImGui::BeginMenuBar
EXTRN	?EndMenuBar@ImGui@@YAXXZ:PROC			; ImGui::EndMenuBar
EXTRN	?BeginMenu@ImGui@@YA_NPBD_N@Z:PROC		; ImGui::BeginMenu
EXTRN	?EndMenu@ImGui@@YAXXZ:PROC			; ImGui::EndMenu
EXTRN	?MenuItem@ImGui@@YA_NPBD0_N1@Z:PROC		; ImGui::MenuItem
EXTRN	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z:PROC		; ImGui::MenuItem
EXTRN	?OpenPopup@ImGui@@YAXPBD@Z:PROC			; ImGui::OpenPopup
EXTRN	?BeginPopup@ImGui@@YA_NPBD@Z:PROC		; ImGui::BeginPopup
EXTRN	?BeginPopupModal@ImGui@@YA_NPBDPA_NH@Z:PROC	; ImGui::BeginPopupModal
EXTRN	?BeginPopupContextItem@ImGui@@YA_NPBDH@Z:PROC	; ImGui::BeginPopupContextItem
EXTRN	?BeginPopupContextWindow@ImGui@@YA_N_NPBDH@Z:PROC ; ImGui::BeginPopupContextWindow
EXTRN	?EndPopup@ImGui@@YAXXZ:PROC			; ImGui::EndPopup
EXTRN	?CloseCurrentPopup@ImGui@@YAXXZ:PROC		; ImGui::CloseCurrentPopup
EXTRN	?LogToTTY@ImGui@@YAXH@Z:PROC			; ImGui::LogToTTY
EXTRN	?LogToClipboard@ImGui@@YAXH@Z:PROC		; ImGui::LogToClipboard
EXTRN	?LogFinish@ImGui@@YAXXZ:PROC			; ImGui::LogFinish
EXTRN	?LogButtons@ImGui@@YAXXZ:PROC			; ImGui::LogButtons
EXTRN	?LogText@ImGui@@YAXPBDZZ:PROC			; ImGui::LogText
EXTRN	?IsItemHovered@ImGui@@YA_NXZ:PROC		; ImGui::IsItemHovered
EXTRN	?IsItemActive@ImGui@@YA_NXZ:PROC		; ImGui::IsItemActive
EXTRN	?IsItemFocused@ImGui@@YA_NXZ:PROC		; ImGui::IsItemFocused
EXTRN	?IsItemClicked@ImGui@@YA_NH@Z:PROC		; ImGui::IsItemClicked
EXTRN	?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetItemRectMin
EXTRN	?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetItemRectMax
EXTRN	?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetItemRectSize
EXTRN	?SetItemDefaultFocus@ImGui@@YAXXZ:PROC		; ImGui::SetItemDefaultFocus
EXTRN	?GetTime@ImGui@@YAMXZ:PROC			; ImGui::GetTime
EXTRN	?GetStyleColName@ImGui@@YAPBDH@Z:PROC		; ImGui::GetStyleColName
EXTRN	?CalcItemRectClosestPoint@ImGui@@YA?AUImVec2@@ABU2@_NM@Z:PROC ; ImGui::CalcItemRectClosestPoint
EXTRN	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z:PROC ; ImGui::ColorConvertFloat4ToU32
EXTRN	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z:PROC	; ImGui::ColorConvertHSVtoRGB
EXTRN	?IsKeyPressed@ImGui@@YA_NH_N@Z:PROC		; ImGui::IsKeyPressed
EXTRN	?IsKeyReleased@ImGui@@YA_NH@Z:PROC		; ImGui::IsKeyReleased
EXTRN	?IsMouseClicked@ImGui@@YA_NH_N@Z:PROC		; ImGui::IsMouseClicked
EXTRN	?IsMouseDoubleClicked@ImGui@@YA_NH@Z:PROC	; ImGui::IsMouseDoubleClicked
EXTRN	?IsMouseReleased@ImGui@@YA_NH@Z:PROC		; ImGui::IsMouseReleased
EXTRN	?IsMouseDragging@ImGui@@YA_NHM@Z:PROC		; ImGui::IsMouseDragging
EXTRN	?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z:PROC ; ImGui::IsMouseHoveringRect
EXTRN	?GetMousePos@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetMousePos
EXTRN	?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z:PROC ; ImGui::GetMouseDragDelta
EXTRN	?SetMouseCursor@ImGui@@YAXH@Z:PROC		; ImGui::SetMouseCursor
EXTRN	?CaptureKeyboardFromApp@ImGui@@YAX_N@Z:PROC	; ImGui::CaptureKeyboardFromApp
EXTRN	?MemAlloc@ImGui@@YAPAXI@Z:PROC			; ImGui::MemAlloc
EXTRN	?MemFree@ImGui@@YAXPAX@Z:PROC			; ImGui::MemFree
EXTRN	?GetVersion@ImGui@@YAPBDXZ:PROC			; ImGui::GetVersion
EXTRN	??0ImGuiStyle@@QAE@XZ:PROC			; ImGuiStyle::ImGuiStyle
EXTRN	??0ImGuiTextFilter@@QAE@PBD@Z:PROC		; ImGuiTextFilter::ImGuiTextFilter
EXTRN	?Draw@ImGuiTextFilter@@QAE_NPBDM@Z:PROC		; ImGuiTextFilter::Draw
EXTRN	?PassFilter@ImGuiTextFilter@@QBE_NPBD0@Z:PROC	; ImGuiTextFilter::PassFilter
EXTRN	?append@ImGuiTextBuffer@@QAAXPBDZZ:PROC		; ImGuiTextBuffer::append
EXTRN	?appendv@ImGuiTextBuffer@@QAEXPBDPAD@Z:PROC	; ImGuiTextBuffer::appendv
EXTRN	?DeleteChars@ImGuiTextEditCallbackData@@QAEXHH@Z:PROC ; ImGuiTextEditCallbackData::DeleteChars
EXTRN	?InsertChars@ImGuiTextEditCallbackData@@QAEXHPBD0@Z:PROC ; ImGuiTextEditCallbackData::InsertChars
EXTRN	?Step@ImGuiListClipper@@QAE_NXZ:PROC		; ImGuiListClipper::Step
EXTRN	?Begin@ImGuiListClipper@@QAEXHM@Z:PROC		; ImGuiListClipper::Begin
EXTRN	?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z:PROC ; ImDrawList::PushClipRect
EXTRN	?PushClipRectFullScreen@ImDrawList@@QAEXXZ:PROC	; ImDrawList::PushClipRectFullScreen
EXTRN	?PopClipRect@ImDrawList@@QAEXXZ:PROC		; ImDrawList::PopClipRect
EXTRN	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z:PROC	; ImDrawList::AddLine
EXTRN	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z:PROC ; ImDrawList::AddRect
EXTRN	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z:PROC ; ImDrawList::AddRectFilled
EXTRN	?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z:PROC ; ImDrawList::AddRectFilledMultiColor
EXTRN	?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z:PROC ; ImDrawList::AddTriangle
EXTRN	?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z:PROC ; ImDrawList::AddTriangleFilled
EXTRN	?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z:PROC ; ImDrawList::AddCircle
EXTRN	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z:PROC ; ImDrawList::AddCircleFilled
EXTRN	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z:PROC ; ImDrawList::AddText
EXTRN	?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z:PROC ; ImDrawList::AddBezierCurve
EXTRN	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z:PROC	; ImFont::FindGlyph
EXTRN	?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z:PROC ; ImFont::RenderChar
EXTRN	__imp__toupper:PROC
EXTRN	_printf:PROC
EXTRN	_vsnprintf:PROC
EXTRN	_sprintf:PROC
EXTRN	__snprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__rand:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___libm_sse2_cosf:PROC
EXTRN	___libm_sse2_sinf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?show_app_main_menu_bar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_main_menu_bar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_main_menu_bar
_BSS	ENDS
;	COMDAT ?show_app_console@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_console@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_console
_BSS	ENDS
;	COMDAT ?show_app_log@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_log@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_log
_BSS	ENDS
;	COMDAT ?show_app_layout@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_layout@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_layout
_BSS	ENDS
;	COMDAT ?show_app_property_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_property_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_property_editor
_BSS	ENDS
;	COMDAT ?show_app_long_text@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_long_text@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_long_text
_BSS	ENDS
;	COMDAT ?show_app_auto_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_auto_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_auto_resize
_BSS	ENDS
;	COMDAT ?show_app_constrained_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_constrained_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_constrained_resize
_BSS	ENDS
;	COMDAT ?show_app_fixed_overlay@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_fixed_overlay@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_fixed_overlay
_BSS	ENDS
;	COMDAT ?show_app_manipulating_window_title@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_manipulating_window_title@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_manipulating_window_title
_BSS	ENDS
;	COMDAT ?show_app_custom_rendering@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_custom_rendering@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_custom_rendering
_BSS	ENDS
;	COMDAT ?show_app_style_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_style_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_style_editor
_BSS	ENDS
;	COMDAT ?show_app_metrics@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_metrics@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_metrics
_BSS	ENDS
;	COMDAT ?show_app_about@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?show_app_about@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::show_app_about
_BSS	ENDS
;	COMDAT ?no_titlebar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?no_titlebar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::no_titlebar
_BSS	ENDS
;	COMDAT ?no_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?no_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::no_resize
_BSS	ENDS
;	COMDAT ?no_move@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?no_move@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::no_move
_BSS	ENDS
;	COMDAT ?no_scrollbar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?no_scrollbar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::no_scrollbar
_BSS	ENDS
;	COMDAT ?no_collapse@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?no_collapse@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::no_collapse
_BSS	ENDS
;	COMDAT ?no_menu@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?no_menu@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::no_menu
_BSS	ENDS
;	COMDAT ?no_nav@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?no_nav@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`2'::no_nav
_BSS	ENDS
;	COMDAT ?align_label_with_current_x_position@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?align_label_with_current_x_position@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`93'::align_label_with_current_x_position
_BSS	ENDS
;	COMDAT ?pressed_count@?IP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?pressed_count@?IP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ImGui::ShowTestWindow'[::P]::pressed_count
_BSS	ENDS
;	COMDAT ?selected@?KN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA
_BSS	SEGMENT
?selected@?KN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA DB 03H DUP (?) ; `ImGui::ShowTestWindow'::`173'::selected
_BSS	ENDS
;	COMDAT ?selected@?LA@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA
_BSS	SEGMENT
?selected@?LA@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA DB 010H DUP (?) ; `ImGui::ShowTestWindow'::`176'::selected
_BSS	ENDS
;	COMDAT ?buf1@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_BSS	SEGMENT
?buf1@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 040H DUP (?) ; `ImGui::ShowTestWindow'::`202'::buf1
_BSS	ENDS
;	COMDAT ?buf2@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_BSS	SEGMENT
?buf2@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 040H DUP (?) ; `ImGui::ShowTestWindow'::`202'::buf2
_BSS	ENDS
;	COMDAT ?buf3@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_BSS	SEGMENT
?buf3@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 040H DUP (?) ; `ImGui::ShowTestWindow'::`202'::buf3
_BSS	ENDS
;	COMDAT ?buf4@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_BSS	SEGMENT
?buf4@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 040H DUP (?) ; `ImGui::ShowTestWindow'::`202'::buf4
_BSS	ENDS
;	COMDAT ?buf5@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_BSS	SEGMENT
?buf5@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 040H DUP (?) ; `ImGui::ShowTestWindow'::`202'::buf5
_BSS	ENDS
;	COMDAT ?buf6@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_BSS	SEGMENT
?buf6@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 040H DUP (?) ; `ImGui::ShowTestWindow'::`202'::buf6
_BSS	ENDS
;	COMDAT ?read_only@?MN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?read_only@?MN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`205'::read_only
_BSS	ENDS
;	COMDAT ?clicked@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?clicked@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`78'::clicked
_BSS	ENDS
;	COMDAT ?e@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?e@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`78'::e
_BSS	ENDS
;	COMDAT ?i1@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?i1@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`222'::i1
_BSS	ENDS
;	COMDAT ?f2@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_BSS	SEGMENT
?f2@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`222'::f2
_BSS	ENDS
;	COMDAT ?angle@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_BSS	SEGMENT
?angle@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`222'::angle
_BSS	ENDS
;	COMDAT ?int_value@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?int_value@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`231'::int_value
_BSS	ENDS
;	COMDAT ?values@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_BSS	SEGMENT
?values@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 05aH DUP (?) ; `ImGui::ShowTestWindow'::`252'::values
_BSS	ENDS
;	COMDAT ?values_offset@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?values_offset@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`252'::values_offset
_BSS	ENDS
;	COMDAT ?refresh_time@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_BSS	SEGMENT
?refresh_time@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`252'::refresh_time
_BSS	ENDS
;	COMDAT ?phase@?BAA@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_BSS	SEGMENT
?phase@?BAA@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`256'::phase
_BSS	ENDS
;	COMDAT ?func_type@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?func_type@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`252'::func_type
_BSS	ENDS
;	COMDAT ?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_BSS	SEGMENT
?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`252'::progress
_BSS	ENDS
;	COMDAT ?f@?BBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_BSS	SEGMENT
?f@?BBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 01H DUP (?) ; `ImGui::ShowTestWindow'::`286'::f
_BSS	ENDS
;	COMDAT ?c1@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?c1@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`289'::c1
_BSS	ENDS
;	COMDAT ?c2@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?c2@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`289'::c2
_BSS	ENDS
;	COMDAT ?c3@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?c3@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`289'::c3
_BSS	ENDS
;	COMDAT ?c4@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?c4@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`289'::c4
_BSS	ENDS
;	COMDAT ?color@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec4@@A
_BSS	SEGMENT
?color@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec4@@A DB 010H DUP (?) ; `ImGui::ShowTestWindow'::`395'::color
_BSS	ENDS
;	COMDAT ?$TSS2@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?$TSS2@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; TSS2<`template-parameter-395',ImGui::wTestWindow, ?? :: ?? ::HA::Z::Z::AXPA_N>
_BSS	ENDS
;	COMDAT ?dont_ask_me_next_time@?BJP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?dont_ask_me_next_time@?BJP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowTestWindow'::`415'::dont_ask_me_next_time
_BSS	ENDS
;	COMDAT ?filter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImGuiTextFilter@@A
_BSS	SEGMENT
?filter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImGuiTextFilter@@A DB 0110H DUP (?) ; `ImGui::ShowTestWindow'::`483'::filter
_BSS	ENDS
;	COMDAT ?$TSS3@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?$TSS3@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H DUP (?) ; TSS3<`template-parameter-483',ImGui::wTestWindow, ?? :: ?? ::HA::Z::Z::AXPA_N>
_BSS	ENDS
;	COMDAT ?output_dest@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
_BSS	SEGMENT
?output_dest@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA DD 01H DUP (?) ; `ImGui::ShowStyleEditor'::`20'::output_dest
_BSS	ENDS
;	COMDAT ?output_only_modified@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4_NA
_BSS	SEGMENT
?output_only_modified@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4_NA DB 01H DUP (?) ; `ImGui::ShowStyleEditor'::`20'::output_only_modified
_BSS	ENDS
;	COMDAT ?edit_mode@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
_BSS	SEGMENT
?edit_mode@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA DD 01H DUP (?) ; `ImGui::ShowStyleEditor'::`20'::edit_mode
_BSS	ENDS
;	COMDAT ?filter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4UImGuiTextFilter@@A
_BSS	SEGMENT
?filter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4UImGuiTextFilter@@A DB 0110H DUP (?) ; `ImGui::ShowStyleEditor'::`20'::filter
_BSS	ENDS
;	COMDAT ?$TSS0@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-20',ImGui::wStyleEditor,AXPAUImGuiStyle>
_BSS	ENDS
;	COMDAT ?n@?BK@??ShowExampleMenuFile@@YAXXZ@4HA
_BSS	SEGMENT
?n@?BK@??ShowExampleMenuFile@@YAXXZ@4HA DD 01H DUP (?)	; `ShowExampleMenuFile'::`26'::n
_BSS	ENDS
;	COMDAT ?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ShowExampleAppConstrainedResize'::`2'::type
_BSS	ENDS
;	COMDAT ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A
_BSS	SEGMENT
?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A DB 0cH DUP (?) ; `ShowExampleAppCustomRendering'::`9'::points
_BSS	ENDS
;	COMDAT ?$TSS1@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?$TSS1@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4HA DD 01H DUP (?) ; TSS1<`template-parameter-9',wExampleAppCustomRendering,int, ?? &>
_BSS	ENDS
;	COMDAT ?adding_line@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4_NA
_BSS	SEGMENT
?adding_line@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4_NA DB 01H DUP (?) ; `ShowExampleAppCustomRendering'::`9'::adding_line
_BSS	ENDS
;	COMDAT ?filter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4UImGuiTextFilter@@A
_BSS	SEGMENT
?filter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4UImGuiTextFilter@@A DB 0110H DUP (?) ; `ExampleAppConsole::Draw'::`2'::filter
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ExampleAppConsole::aw,unsigned char * const,void,char const *,bool *>
_BSS	ENDS
;	COMDAT ?console@?1??ShowExampleAppConsole@@YAXPA_N@Z@4UExampleAppConsole@@A
_BSS	SEGMENT
?console@?1??ShowExampleAppConsole@@YAXPA_N@Z@4UExampleAppConsole@@A DB 012cH DUP (?) ; `ShowExampleAppConsole'::`2'::console
_BSS	ENDS
;	COMDAT ?$TSS0@?1??ShowExampleAppConsole@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??ShowExampleAppConsole@@YAXPA_N@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',wExampleAppConsole,int, ?? &>
_BSS	ENDS
;	COMDAT ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A
_BSS	SEGMENT
?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A DB 012cH DUP (?) ; `ShowExampleAppLog'::`2'::log
_BSS	ENDS
;	COMDAT ?$TSS0@?1??ShowExampleAppLog@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??ShowExampleAppLog@@YAXPA_N@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',wExampleAppLog,int, ?? &>
_BSS	ENDS
;	COMDAT ?selected@?4??ShowExampleAppLayout@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?selected@?4??ShowExampleAppLayout@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ShowExampleAppLayout'::`5'::selected
_BSS	ENDS
;	COMDAT ?test_type@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?test_type@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ShowExampleAppLongText'::`2'::test_type
_BSS	ENDS
;	COMDAT ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A
_BSS	SEGMENT
?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A DB 0cH DUP (?) ; `ShowExampleAppLongText'::`2'::log
_BSS	ENDS
;	COMDAT ?$TSS0@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',wExampleAppLongText,int, ?? &>
_BSS	ENDS
;	COMDAT ?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
_BSS	SEGMENT
?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA DD 01H DUP (?) ; `ShowExampleAppLongText'::`2'::lines
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f8000003f0000003f4ccccd
CONST	SEGMENT
__xmm@3f8000003f8000003f0000003f4ccccd DB 0cdH, 0ccH, 'L?', 00H, 00H, 00H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f800000000000003f800000
CONST	SEGMENT
__xmm@3f8000003f800000000000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	00H, 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f147ae13f47ae143f800000
CONST	SEGMENT
__xmm@3f8000003f147ae13f47ae143f800000 DB 00H, 00H, 080H, '?', 014H, 0aeH
	DB	'G?', 0e1H, 'z', 014H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003ef0f0f23eb4b4b53eb4b4b5
CONST	SEGMENT
__xmm@3f8000003ef0f0f23eb4b4b53eb4b4b5 DB 0b5H, 0b4H, 0b4H, '>', 0b5H, 0b4H
	DB	0b4H, '>', 0f2H, 0f0H, 0f0H, '>', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003ecccccd3ecccccd3f800000
CONST	SEGMENT
__xmm@3f8000003ecccccd3ecccccd3f800000 DB 00H, 00H, 080H, '?', 0cdH, 0ccH
	DB	0ccH, '>', 0cdH, 0ccH, 0ccH, '>', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003e8c8c8d3e70f0f23e70f0f2
CONST	SEGMENT
__xmm@3f8000003e8c8c8d3e70f0f23e70f0f2 DB 0f2H, 0f0H, 'p>', 0f2H, 0f0H, 'p'
	DB	'>', 08dH, 08cH, 08cH, '>', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003e70f0f23e48c8ca3e48c8ca
CONST	SEGMENT
__xmm@3f8000003e70f0f23e48c8ca3e48c8ca DB 0caH, 0c8H, 'H>', 0caH, 0c8H, 'H'
	DB	'>', 0f2H, 0f0H, 'p>', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003e48c8ca3e48c8ca3e48c8ca
CONST	SEGMENT
__xmm@3f8000003e48c8ca3e48c8ca3e48c8ca DB 0caH, 0c8H, 'H>', 0caH, 0c8H, 'H'
	DB	'>', 0caH, 0c8H, 'H>', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000003f8000003f800000
CONST	SEGMENT
__xmm@3f800000000000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000003f80000000000000
CONST	SEGMENT
__xmm@3f800000000000003f80000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 080H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f80000000000000000000003f800000
CONST	SEGMENT
__xmm@3f80000000000000000000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000000000000000000000
CONST	SEGMENT
__xmm@3f800000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f19999a3f4ccccd3e4ccccd3f000000
CONST	SEGMENT
__xmm@3f19999a3f4ccccd3e4ccccd3f000000 DB 00H, 00H, 00H, '?', 0cdH, 0ccH, 'L'
	DB	'>', 0cdH, 0ccH, 'L?', 09aH, 099H, 019H, '?'
CONST	ENDS
;	COMDAT __xmm@3f0080813f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f0080813f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 081H, 080H, 00H, '?'
CONST	ENDS
;	COMDAT __real@c47a0000
CONST	SEGMENT
__real@c47a0000 DD 0c47a0000r			; -1000
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@44db2000
CONST	SEGMENT
__real@44db2000 DD 044db2000r			; 1753
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3fa66666
CONST	SEGMENT
__real@3fa66666 DD 03fa66666r			; 1.3
CONST	ENDS
;	COMDAT __real@3f8ccccd
CONST	SEGMENT
__real@3f8ccccd DD 03f8ccccdr			; 1.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e2e147b
CONST	SEGMENT
__real@3e2e147b DD 03e2e147br			; 0.17
CONST	ENDS
;	COMDAT __real@3e124925
CONST	SEGMENT
__real@3e124925 DD 03e124925r			; 0.142857
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3c888889
CONST	SEGMENT
__real@3c888889 DD 03c888889r			; 0.0166667
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_04GFJLOHHD@?$CF?43f?$AA@
CONST	SEGMENT
??_C@_04GFJLOHHD@?$CF?43f?$AA@ DB '%.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBBIKLOB@?$CD?$CDvalue?$AA@
CONST	SEGMENT
??_C@_07FBBIKLOB@?$CD?$CDvalue?$AA@ DB '##value', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNKJGCPO@Field_?$CFd?$AA@
CONST	SEGMENT
??_C@_08BNKJGCPO@Field_?$CFd?$AA@ DB 'Field_%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GIMBDOHM@Child?$AA@
CONST	SEGMENT
??_C@_05GIMBDOHM@Child?$AA@ DB 'Child', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LIBEHHHH@my?5sailor?5is?5rich?$AA@
CONST	SEGMENT
??_C@_0BC@LIBEHHHH@my?5sailor?5is?5rich?$AA@ DB 'my sailor is rich', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ELFECKBG@Object?$AA@
CONST	SEGMENT
??_C@_06ELFECKBG@Object?$AA@ DB 'Object', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FIIOEGIK@?$CFs_?$CFu?$AA@
CONST	SEGMENT
??_C@_05FIIOEGIK@?$CFs_?$CFu?$AA@ DB '%s_%u', 00H	; `string'
CONST	ENDS
;	COMDAT ?dummy_members@?4??ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z@4PAMA
_DATA	SEGMENT
?dummy_members@?4??ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z@4PAMA DD 000000000r ; 0 ; ``ShowExampleAppPropertyEditor'::`2'::funcs::ShowDummyObject'::`5'::dummy_members
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	040490ff9r			; 3.1416
	DD	042c80000r			; 100
	DD	04479c000r			; 999
	ORG $+8
_DATA	ENDS
;	COMDAT ?last_time@?1??ShowExampleAppLog@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?last_time@?1??ShowExampleAppLog@@YAXPA_N@Z@4MA DD 0bf800000r ; -1 ; `ShowExampleAppLog'::`2'::last_time
_DATA	ENDS
;	COMDAT ??_C@_09PKEBEIDM@scrolling?$AA@
CONST	SEGMENT
??_C@_09PKEBEIDM@scrolling?$AA@ DB 'scrolling', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBDJIBGI@Filter?$AA@
CONST	SEGMENT
??_C@_06IBDJIBGI@Filter?$AA@ DB 'Filter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OPMHGHMB@Copy?$AA@
CONST	SEGMENT
??_C@_04OPMHGHMB@Copy?$AA@ DB 'Copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHKAGDP@?9?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_05PHKAGDP@?9?5?$CFs?6?$AA@ DB '- %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LCPLNAHF@Possible?5matches?3?6?$AA@
CONST	SEGMENT
??_C@_0BD@LCPLNAHF@Possible?5matches?3?6?$AA@ DB 'Possible matches:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DOPMHGPK@No?5match?5for?5?$CC?$CF?4?$CKs?$CC?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BG@DOPMHGPK@No?5match?5for?5?$CC?$CF?4?$CKs?$CC?$CB?6?$AA@ DB 'No '
	DB	'match for "%.*s"!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OKLFOGKH@Unknown?5command?3?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BH@OKLFOGKH@Unknown?5command?3?5?8?$CFs?8?6?$AA@ DB 'Unknown comma'
	DB	'nd: ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PKLPHKJF@?$CF3d?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_08PKLPHKJF@?$CF3d?3?5?$CFs?6?$AA@ DB '%3d: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JKCKOCFH@?9?5?$CFs?$AA@
CONST	SEGMENT
??_C@_04JKCKOCFH@?9?5?$CFs?$AA@ DB '- %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GJFNIAOH@Commands?3?$AA@
CONST	SEGMENT
??_C@_09GJFNIAOH@Commands?3?$AA@ DB 'Commands:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFHAGHEP@?$CD?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_05DFHAGHEP@?$CD?5?$CFs?6?$AA@ DB '# %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DCDOHKAB@Input?$AA@
CONST	SEGMENT
??_C@_05DCDOHKAB@Input?$AA@ DB 'Input', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPDBPKPG@?$CD?5?$AA@
CONST	SEGMENT
??_C@_02KPDBPKPG@?$CD?5?$AA@ DB '# ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LFMCMLFD@?$FLerror?$FN?$AA@
CONST	SEGMENT
??_C@_07LFMCMLFD@?$FLerror?$FN?$AA@ DB '[error]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KOEFNJOK@ScrollingRegion?$AA@
CONST	SEGMENT
??_C@_0BA@KOEFNJOK@ScrollingRegion?$AA@ DB 'ScrollingRegion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HIABFBKB@Filter?5?$CI?$CCincl?0?9excl?$CC?$CJ?5?$CI?$CCerror?$CC?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@HIABFBKB@Filter?5?$CI?$CCincl?0?9excl?$CC?$CJ?5?$CI?$CCerror?$CC?$CJ?$AA@ DB 'F'
	DB	'ilter ("incl,-excl") ("error")', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GPFIAMJC@Scroll?5to?5bottom?$AA@
CONST	SEGMENT
??_C@_0BB@GPFIAMJC@Scroll?5to?5bottom?$AA@ DB 'Scroll to bottom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MDNHABIA@Clear?$AA@
CONST	SEGMENT
??_C@_05MDNHABIA@Clear?$AA@ DB 'Clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KNPJMMPE@?$FLerror?$FN?5something?5went?5wrong?$AA@
CONST	SEGMENT
??_C@_0BN@KNPJMMPE@?$FLerror?$FN?5something?5went?5wrong?$AA@ DB '[error]'
	DB	' something went wrong', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HHKLEHKC@Add?5Dummy?5Error?$AA@
CONST	SEGMENT
??_C@_0BA@HHKLEHKC@Add?5Dummy?5Error?$AA@ DB 'Add Dummy Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PEIDNPCH@display?5very?5important?5message?5h@
CONST	SEGMENT
??_C@_0CF@PEIDNPCH@display?5very?5important?5message?5h@ DB 'display very'
	DB	' important message here!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BMHJKMPF@some?5more?5text?$AA@
CONST	SEGMENT
??_C@_0P@BMHJKMPF@some?5more?5text?$AA@ DB 'some more text', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OJGBPOOP@?$CFd?5some?5text?$AA@
CONST	SEGMENT
??_C@_0N@OJGBPOOP@?$CFd?5some?5text?$AA@ DB '%d some text', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CGJDLLEJ@Add?5Dummy?5Text?$AA@
CONST	SEGMENT
??_C@_0P@CGJDLLEJ@Add?5Dummy?5Text?$AA@ DB 'Add Dummy Text', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NBHLDCP@Enter?5?8HELP?8?5for?5help?0?5press?5TAB@
CONST	SEGMENT
??_C@_0DJ@NBHLDCP@Enter?5?8HELP?8?5for?5help?0?5press?5TAB@ DB 'Enter ''H'
	DB	'ELP'' for help, press TAB to use text completion.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MA@ICGIOBFG@This?5example?5implements?5a?5consol@
CONST	SEGMENT
??_C@_0MA@ICGIOBFG@This?5example?5implements?5a?5consol@ DB 'This example'
	DB	' implements a console with basic coloring, completion and his'
	DB	'tory. A more elaborate implementation may want to store entri'
	DB	'es along with extra data such as timestamp, emitter, etc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JPCINNJN@Welcome?5to?5ImGui?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@JPCINNJN@Welcome?5to?5ImGui?$CB?$AA@ DB 'Welcome to ImGui!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GOHMLCGG@CLASSIFY?$AA@
CONST	SEGMENT
??_C@_08GOHMLCGG@CLASSIFY?$AA@ DB 'CLASSIFY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PONODPI@CLEAR?$AA@
CONST	SEGMENT
??_C@_05PONODPI@CLEAR?$AA@ DB 'CLEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBIJIOJO@HISTORY?$AA@
CONST	SEGMENT
??_C@_07DBIJIOJO@HISTORY?$AA@ DB 'HISTORY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DOKPJKJF@HELP?$AA@
CONST	SEGMENT
??_C@_04DOKPJKJF@HELP?$AA@ DB 'HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ?col@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4UImVec4@@A
_DATA	SEGMENT
?col@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4UImVec4@@A DD 03f800000r ; 1 ; `ShowExampleAppCustomRendering'::`2'::col
	DD	03f800000r			; 1
	DD	03ecccccdr			; 0.4
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA DD 042100000r ; 36 ; `ShowExampleAppCustomRendering'::`2'::sz
_DATA	ENDS
;	COMDAT ?lines@?1??ShowExampleAppAutoResize@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?lines@?1??ShowExampleAppAutoResize@@YAXPA_N@Z@4HA DD 0aH ; `ShowExampleAppAutoResize'::`2'::lines
_DATA	ENDS
;	COMDAT ?b@?BK@??ShowExampleMenuFile@@YAXXZ@4_NA
_DATA	SEGMENT
?b@?BK@??ShowExampleMenuFile@@YAXXZ@4_NA DB 01H		; `ShowExampleMenuFile'::`26'::b
_DATA	ENDS
;	COMDAT ?f@?BK@??ShowExampleMenuFile@@YAXXZ@4MA
_DATA	SEGMENT
?f@?BK@??ShowExampleMenuFile@@YAXXZ@4MA DD 03f000000r ; 0.5 ; `ShowExampleMenuFile'::`26'::f
_DATA	ENDS
;	COMDAT ?enabled@?BK@??ShowExampleMenuFile@@YAXXZ@4_NA
_DATA	SEGMENT
?enabled@?BK@??ShowExampleMenuFile@@YAXXZ@4_NA DB 01H	; `ShowExampleMenuFile'::`26'::enabled
_DATA	ENDS
;	COMDAT ?window_scale@?CP@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4MA
_DATA	SEGMENT
?window_scale@?CP@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4MA DD 03f800000r ; 1 ; `ImGui::ShowStyleEditor'::`47'::window_scale
_DATA	ENDS
;	COMDAT ?buf@?CBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_DATA	SEGMENT
?buf@?CBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 'click on a button t'
	DB	'o set focus', 00H				; `ImGui::ShowTestWindow'::`542'::buf
	ORG $+97
_DATA	ENDS
;	COMDAT ?buf@?CBL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_DATA	SEGMENT
?buf@?CBL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 'dummy', 00H ; `ImGui::ShowTestWindow'::`539'::buf
	ORG $+26
_DATA	ENDS
;	COMDAT ?v_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_DATA	SEGMENT
?v_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H ; `ImGui::ShowTestWindow'::`465'::v_borders
_DATA	ENDS
;	COMDAT ?h_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_DATA	SEGMENT
?h_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H ; `ImGui::ShowTestWindow'::`465'::h_borders
_DATA	ENDS
;	COMDAT ?bar@?BMF@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?bar@?BMF@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03f800000r ; 1 ; `ImGui::ShowTestWindow'::`453'::bar
_DATA	ENDS
;	COMDAT ?foo@?BMF@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?foo@?BMF@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03f800000r ; 1 ; `ImGui::ShowTestWindow'::`453'::foo
_DATA	ENDS
;	COMDAT ?selected@?BLJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?selected@?BLJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 0ffffffffH ; `ImGui::ShowTestWindow'::`441'::selected
_DATA	ENDS
;	COMDAT ?item@?BKK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?item@?BKK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H	; `ImGui::ShowTestWindow'::`426'::item
_DATA	ENDS
;	COMDAT ?value@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?value@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03f000000r ; 0.5 ; `ImGui::ShowTestWindow'::`395'::value
_DATA	ENDS
;	COMDAT ?toggles@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA
_DATA	SEGMENT
?toggles@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA DB 01H ; `ImGui::ShowTestWindow'::`356'::toggles
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
;	COMDAT ?selected_fish@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?selected_fish@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 0ffffffffH ; `ImGui::ShowTestWindow'::`356'::selected_fish
_DATA	ENDS
;	COMDAT ?offset@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A
_DATA	SEGMENT
?offset@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A DD 042480000r ; 50 ; `ImGui::ShowTestWindow'::`347'::offset
	DD	041a00000r			; 20
_DATA	ENDS
;	COMDAT ?size@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A
_DATA	SEGMENT
?size@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A DD 042c80000r ; 100 ; `ImGui::ShowTestWindow'::`347'::size
	DD	042c80000r			; 100
_DATA	ENDS
;	COMDAT ?lines@?BEL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?lines@?BEL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 07H ; `ImGui::ShowTestWindow'::`331'::lines
_DATA	ENDS
;	COMDAT ?scroll_to_px@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?scroll_to_px@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 0c8H ; `ImGui::ShowTestWindow'::`313'::scroll_to_px
_DATA	ENDS
;	COMDAT ?track_line@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?track_line@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 032H ; `ImGui::ShowTestWindow'::`313'::track_line
_DATA	ENDS
;	COMDAT ?track@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_DATA	SEGMENT
?track@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H ; `ImGui::ShowTestWindow'::`313'::track
_DATA	ENDS
;	COMDAT ?selection@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
_DATA	SEGMENT
?selection@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA DD 00H ; `ImGui::ShowTestWindow'::`289'::selection
	DD	01H
	DD	02H
	DD	03H
_DATA	ENDS
;	COMDAT ?item@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?item@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 0ffffffffH ; `ImGui::ShowTestWindow'::`289'::item
_DATA	ENDS
;	COMDAT ?f2@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?f2@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 040400000r ; 3 ; `ImGui::ShowTestWindow'::`289'::f2
_DATA	ENDS
;	COMDAT ?f1@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?f1@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 040000000r ; 2 ; `ImGui::ShowTestWindow'::`289'::f1
_DATA	ENDS
;	COMDAT ?f0@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?f0@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03f800000r ; 1 ; `ImGui::ShowTestWindow'::`289'::f0
_DATA	ENDS
;	COMDAT ?line@?BAP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?line@?BAP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 032H ; `ImGui::ShowTestWindow'::`271'::line
_DATA	ENDS
;	COMDAT ?progress_dir@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?progress_dir@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03f800000r ; 1 ; `ImGui::ShowTestWindow'::`252'::progress_dir
_DATA	ENDS
;	COMDAT ?display_count@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?display_count@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 046H ; `ImGui::ShowTestWindow'::`252'::display_count
_DATA	ENDS
;	COMDAT ?arr@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_DATA	SEGMENT
?arr@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 03f19999ar ; 0.6 ; `ImGui::ShowTestWindow'::`252'::arr
	DD	03dcccccdr			; 0.1
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	03f6b851fr			; 0.92
	DD	03dcccccdr			; 0.1
	DD	03e4ccccdr			; 0.2
_DATA	ENDS
;	COMDAT ?animate@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_DATA	SEGMENT
?animate@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H ; `ImGui::ShowTestWindow'::`252'::animate
_DATA	ENDS
;	COMDAT ?values2@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_DATA	SEGMENT
?values2@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 03e4ccccdr ; 0.2 ; `ImGui::ShowTestWindow'::`231'::values2
	DD	03f4ccccdr			; 0.8
	DD	03ecccccdr			; 0.4
	DD	03e800000r			; 0.25
_DATA	ENDS
;	COMDAT ?values@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_DATA	SEGMENT
?values@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 000000000r ; 0 ; `ImGui::ShowTestWindow'::`231'::values
	DD	03f19999ar			; 0.6
	DD	03eb33333r			; 0.35
	DD	03f666666r			; 0.9
	DD	03f333333r			; 0.7
	DD	03e4ccccdr			; 0.2
	DD	000000000r			; 0
_DATA	ENDS
;	COMDAT ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
_DATA	SEGMENT
?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA DD 01H ; `ImGui::ShowTestWindow'::`228'::vec4i
	DD	05H
	DD	064H
	DD	0ffH
_DATA	ENDS
;	COMDAT ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_DATA	SEGMENT
?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 03dcccccdr ; 0.1 ; `ImGui::ShowTestWindow'::`228'::vec4f
	DD	03e4ccccdr			; 0.2
	DD	03e99999ar			; 0.3
	DD	03ee147aer			; 0.44
_DATA	ENDS
;	COMDAT ?end_i@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?end_i@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 03e8H ; `ImGui::ShowTestWindow'::`225'::end_i
_DATA	ENDS
;	COMDAT ?begin_i@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?begin_i@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 064H ; `ImGui::ShowTestWindow'::`225'::begin_i
_DATA	ENDS
;	COMDAT ?end@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?end@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 042b40000r ; 90 ; `ImGui::ShowTestWindow'::`225'::end
_DATA	ENDS
;	COMDAT ?begin@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?begin@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 041200000r ; 10 ; `ImGui::ShowTestWindow'::`225'::begin
_DATA	ENDS
;	COMDAT ?listbox_item_current@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?listbox_item_current@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H ; `ImGui::ShowTestWindow'::`78'::listbox_item_current
_DATA	ENDS
;	COMDAT ?col2@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_DATA	SEGMENT
?col2@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 03ecccccdr ; 0.4 ; `ImGui::ShowTestWindow'::`78'::col2
	DD	03f333333r			; 0.7
	DD	000000000r			; 0
	DD	03f000000r			; 0.5
_DATA	ENDS
;	COMDAT ?col1@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_DATA	SEGMENT
?col1@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 03f800000r ; 1 ; `ImGui::ShowTestWindow'::`78'::col1
	DD	000000000r			; 0
	DD	03e4ccccdr			; 0.2
_DATA	ENDS
;	COMDAT ?f1@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?f1@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03dfbe76dr ; 0.123 ; `ImGui::ShowTestWindow'::`222'::f1
_DATA	ENDS
;	COMDAT ?f2@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?f2@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03bdb8bacr ; 0.0067 ; `ImGui::ShowTestWindow'::`221'::f2
_DATA	ENDS
;	COMDAT ?f1@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?f1@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03f800000r ; 1 ; `ImGui::ShowTestWindow'::`221'::f1
_DATA	ENDS
;	COMDAT ?i2@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?i2@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 02aH	; `ImGui::ShowTestWindow'::`221'::i2
_DATA	ENDS
;	COMDAT ?i1@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?i1@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 032H	; `ImGui::ShowTestWindow'::`221'::i1
_DATA	ENDS
;	COMDAT ?vec4a@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_DATA	SEGMENT
?vec4a@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 03dcccccdr ; 0.1 ; `ImGui::ShowTestWindow'::`220'::vec4a
	DD	03e4ccccdr			; 0.2
	DD	03e99999ar			; 0.3
	DD	03ee147aer			; 0.44
_DATA	ENDS
;	COMDAT ?f0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?f0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 03a83126fr ; 0.001 ; `ImGui::ShowTestWindow'::`220'::f0
_DATA	ENDS
;	COMDAT ?i0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?i0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 07bH	; `ImGui::ShowTestWindow'::`220'::i0
_DATA	ENDS
;	COMDAT ?str0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_DATA	SEGMENT
?str0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 'Hello, world!', 00H ; `ImGui::ShowTestWindow'::`220'::str0
	ORG $+114
_DATA	ENDS
;	COMDAT ?item2@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?item2@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 0ffffffffH ; `ImGui::ShowTestWindow'::`78'::item2
_DATA	ENDS
;	COMDAT ?item@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?item@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 01H	; `ImGui::ShowTestWindow'::`78'::item
_DATA	ENDS
;	COMDAT ?arr@?NL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
_DATA	SEGMENT
?arr@?NL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA DD 03f19999ar ; 0.6 ; `ImGui::ShowTestWindow'::`219'::arr
	DD	03dcccccdr			; 0.1
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	03f6b851fr			; 0.92
	DD	03dcccccdr			; 0.1
	DD	03e4ccccdr			; 0.2
_DATA	ENDS
;	COMDAT ?check@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_DATA	SEGMENT
?check@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H ; `ImGui::ShowTestWindow'::`78'::check
_DATA	ENDS
;	COMDAT ?text@?MN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_DATA	SEGMENT
?text@?MN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB '/*', 0aH, ' The Pen'
	DB	'tium F00F bug, shorthand for F0 0F C7 C8,', 0aH, ' the hexade'
	DB	'cimal encoding of one offending instruction,', 0aH, ' more fo'
	DB	'rmally, the invalid operand with locked CMPXCHG8B', 0aH, ' in'
	DB	'struction bug, is a design flaw in the majority of', 0aH, ' I'
	DB	'ntel Pentium, Pentium MMX, and Pentium OverDrive', 0aH, ' pro'
	DB	'cessors (all in the P5 microarchitecture).', 0aH, '*/', 0aH, 0aH
	DB	'label:', 0aH, 09H, 'lock cmpxchg8b eax', 0aH, 00H ; `ImGui::ShowTestWindow'::`205'::text
	ORG $+16033
_DATA	ENDS
;	COMDAT ?bufpass@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_DATA	SEGMENT
?bufpass@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 'password123', 00H ; `ImGui::ShowTestWindow'::`202'::bufpass
	ORG $+52
_DATA	ENDS
;	COMDAT ??_C@_05EAJAAGNN@imgui?$AA@
CONST	SEGMENT
??_C@_05EAJAAGNN@imgui?$AA@ DB 'imgui', 00H		; `string'
CONST	ENDS
;	COMDAT ?selected@?LI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA
_DATA	SEGMENT
?selected@?LI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA DB 01H ; `ImGui::ShowTestWindow'::`184'::selected
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
_DATA	ENDS
;	COMDAT ?selected@?KG@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA
_DATA	SEGMENT
?selected@?KG@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA DB 00H ; `ImGui::ShowTestWindow'::`166'::selected
	DB	01H
	DB	00H
	DB	00H
_DATA	ENDS
;	COMDAT ?buf@?IM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
_DATA	SEGMENT
?buf@?IM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA DB 0e6H, 097H, 0a5H, 0e6H
	DB	09cH, 0acH, 0e8H, 0aaH, 09eH, 00H		; `ImGui::ShowTestWindow'[::M]::buf
	ORG $+22
_DATA	ENDS
;	COMDAT ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
_DATA	SEGMENT
?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA DD 043480000r ; 200 ; `ImGui::ShowTestWindow'[::J]::wrap_width
_DATA	ENDS
;	COMDAT ?closable_group@?HI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_DATA	SEGMENT
?closable_group@?HI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H ; `ImGui::ShowTestWindow'::`120'::closable_group
_DATA	ENDS
;	COMDAT ?selection_mask@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
_DATA	SEGMENT
?selection_mask@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA DD 04H ; `ImGui::ShowTestWindow'::`93'::selection_mask
_DATA	ENDS
;	COMDAT ?no_border@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
_DATA	SEGMENT
?no_border@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H ; `ImGui::ShowTestWindow'::`2'::no_border
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ExampleAppLog@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ExampleAppLog@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1ExampleAppLog@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ExampleAppLog@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ExampleAppLog@@QAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0ExampleAppLog@@QAE@XZ$0
__ehfuncinfo$??0ExampleAppLog@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ExampleAppLog@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@H@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z$0
__ehfuncinfo$?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ExampleAppConsole@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ExampleAppConsole@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1ExampleAppConsole@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ExampleAppConsole@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ExampleAppConsole@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ExampleAppConsole@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ExampleAppConsole@@QAE@XZ$2
__ehfuncinfo$??0ExampleAppConsole@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0ExampleAppConsole@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PBD@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAD@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImVec2@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ImGuiTextBuffer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ImGuiTextBuffer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ImGuiTextBuffer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ImGuiTextBuffer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImGuiTextBuffer@@QAE@XZ$0
__ehfuncinfo$??0ImGuiTextBuffer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImGuiTextBuffer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@D@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ImGuiTextFilter@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ImGuiTextFilter@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ImGuiTextFilter@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?ShowExampleAppConsole@@YAXPA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShowExampleAppConsole@@YAXPA_N@Z$0
__unwindtable$?ShowTestWindow@ImGui@@YAXPA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShowTestWindow@ImGui@@YAXPA_N@Z$3
__unwindtable$?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z$0
__unwindtable$?ShowExampleAppLongText@@YAXPA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShowExampleAppLongText@@YAXPA_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ShowExampleAppLongText@@YAXPA_N@Z$1
__unwindtable$?ShowExampleAppLog@@YAXPA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShowExampleAppLog@@YAXPA_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ShowExampleAppLog@@YAXPA_N@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ShowExampleAppLog@@YAXPA_N@Z$1
__ehfuncinfo$?ShowExampleAppLongText@@YAXPA_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ShowExampleAppLongText@@YAXPA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ShowExampleAppLog@@YAXPA_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ShowExampleAppLog@@YAXPA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ShowExampleAppConsole@@YAXPA_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShowExampleAppConsole@@YAXPA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ShowTestWindow@ImGui@@YAXPA_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShowTestWindow@ImGui@@YAXPA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ PROC ; `ShowExampleAppLongText'::`2'::`dynamic atexit destructor for 'log'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A+8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN7@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN7@dynamic:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ ENDP ; `ShowExampleAppLongText'::`2'::`dynamic atexit destructor for 'log''
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z
_TEXT	SEGMENT
_label$1 = -40						; size = 32
$T2 = -8						; size = 8
_prefix$ = 8						; size = 4
_uid$ = 12						; size = 4
?ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z PROC ; `ShowExampleAppPropertyEditor'::`2'::funcs::ShowDummyObject, COMDAT

; 2547 :         {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi

; 2548 :             ImGui::PushID(uid);                      // Use object uid as identifier. Most commonly you could also use the object pointer as a base ID.

	mov	esi, DWORD PTR _uid$[ebp]
	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 2549 :             ImGui::AlignFirstTextHeightToWidgets();  // Text and Tree nodes are less high than regular widgets, here we add vertical spacing to make the tree lines equal high.

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 2550 :             bool node_open = ImGui::TreeNode("Object", "%s_%u", prefix, uid);

	push	esi
	push	DWORD PTR _prefix$[ebp]
	push	OFFSET ??_C@_05FIIOEGIK@?$CFs_?$CFu?$AA@
	push	OFFSET ??_C@_06ELFECKBG@Object?$AA@
	call	?TreeNode@ImGui@@YA_NPBD0ZZ		; ImGui::TreeNode
	mov	bl, al

; 2551 :             ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 2552 :             ImGui::AlignFirstTextHeightToWidgets();

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 2553 :             ImGui::Text("my sailor is rich");

	push	OFFSET ??_C@_0BC@LIBEHHHH@my?5sailor?5is?5rich?$AA@
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 24					; 00000018H

; 2554 :             ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 2555 :             if (node_open)

	test	bl, bl
	je	$LN5@ShowDummyO

; 2556 :             {
; 2557 :                 static float dummy_members[8] = { 0.0f,0.0f,1.0f,3.1416f,100.0f,999.0f };
; 2558 :                 for (int i = 0; i < 8; i++)

	push	edi
	xor	esi, esi
	mov	edi, OFFSET ?dummy_members@?4??ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z@4PAMA ; ``ShowExampleAppPropertyEditor'::`2'::funcs::ShowDummyObject'::`5'::dummy_members
	npad	7
$LL4@ShowDummyO:

; 2559 :                 {
; 2560 :                     ImGui::PushID(i); // Use field index as identifier.

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
	add	esp, 4

; 2561 :                     if (i < 2)

	cmp	esi, 2
	jge	SHORT $LN6@ShowDummyO

; 2562 :                     {
; 2563 :                         ShowDummyObject("Child", 424242);

	push	424242					; 00067932H
	push	OFFSET ??_C@_05GIMBDOHM@Child?$AA@
	call	?ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z ; `ShowExampleAppPropertyEditor'::`2'::funcs::ShowDummyObject
	add	esp, 8

; 2564 :                     }
; 2565 :                     else

	jmp	$LN7@ShowDummyO
$LN6@ShowDummyO:

; 2566 :                     {
; 2567 :                         ImGui::AlignFirstTextHeightToWidgets();

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 2568 :                         // Here we use a Selectable (instead of Text) to highlight on hover
; 2569 :                         //ImGui::Text("Field_%d", i);
; 2570 :                         char label[32];
; 2571 :                         sprintf(label, "Field_%d", i);

	push	esi
	lea	eax, DWORD PTR _label$1[ebp]
	push	OFFSET ??_C@_08BNKJGCPO@Field_?$CFd?$AA@
	push	eax
	call	_sprintf

; 2572 :                         ImGui::Bullet();

	call	?Bullet@ImGui@@YAXXZ			; ImGui::Bullet

; 2573 :                         ImGui::Selectable(label);

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2573 :                         ImGui::Selectable(label);

	push	eax
	push	0
	lea	eax, DWORD PTR _label$1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2573 :                         ImGui::Selectable(label);

	push	0
	push	eax
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable

; 2574 :                         ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 2575 :                         ImGui::PushItemWidth(-1);

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	add	esp, 4

; 2576 :                         if (i >= 5)

	cmp	esi, 5
	jl	SHORT $LN8@ShowDummyO

; 2577 :                             ImGui::InputFloat("##value", &dummy_members[i], 1.0f);

	push	0
	push	-1
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	edi
	push	OFFSET ??_C@_07FBBIKLOB@?$CD?$CDvalue?$AA@
	call	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z	; ImGui::InputFloat
	add	esp, 24					; 00000018H

; 2578 :                         else

	jmp	SHORT $LN9@ShowDummyO
$LN8@ShowDummyO:

; 2579 :                             ImGui::DragFloat("##value", &dummy_members[i], 0.01f);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ??_C@_04GFJLOHHD@?$CF?43f?$AA@
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	push	edi
	push	OFFSET ??_C@_07FBBIKLOB@?$CD?$CDvalue?$AA@
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat
	add	esp, 28					; 0000001cH
$LN9@ShowDummyO:

; 2580 :                         ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 2581 :                         ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
$LN7@ShowDummyO:

; 2582 :                     }
; 2583 :                     ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	add	edi, 4
	inc	esi
	cmp	edi, OFFSET ?dummy_members@?4??ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z@4PAMA+32
	jl	$LL4@ShowDummyO

; 2584 :                 }
; 2585 :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	pop	edi
$LN5@ShowDummyO:

; 2586 :             }
; 2587 :             ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	pop	esi
	pop	ebx

; 2588 :         }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z ENDP ; `ShowExampleAppPropertyEditor'::`2'::funcs::ShowDummyObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ PROC	; `ShowExampleAppLog'::`2'::`dynamic atexit destructor for 'log'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A+292
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN7@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN7@dynamic:
	mov	eax, DWORD PTR ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A+276
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN14@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN14@dynamic:
	mov	eax, DWORD PTR ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A+8
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN21@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN21@dynamic:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ ENDP	; `ShowExampleAppLog'::`2'::`dynamic atexit destructor for 'log''
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ExampleAppLog@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ExampleAppLog@@QAE@XZ PROC				; ExampleAppLog::~ExampleAppLog, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ExampleAppLog@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+292]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ExampleApp
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ExampleApp:
	mov	eax, DWORD PTR [esi+276]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN11@ExampleApp
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN11@ExampleApp:
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN18@ExampleApp
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN18@ExampleApp:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ExampleAppLog@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ExampleAppLog@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ExampleAppLog@@QAE@XZ ENDP				; ExampleAppLog::~ExampleAppLog
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ExampleAppLog@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0ExampleAppLog@@QAE@XZ PROC				; ExampleAppLog::ExampleAppLog, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ExampleAppLog@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR _this$[ebp], esi

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0

; 1000 :     ImGuiTextBuffer()   { Buf.push_back(0); }

	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	mov	BYTE PTR $T2[ebp], 0
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	call	??0ImGuiTextFilter@@QAE@PBD@Z		; ImGuiTextFilter::ImGuiTextFilter
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+284], 0
	mov	DWORD PTR [esi+292], 0
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ExampleAppLog@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$ImVector@D@@QAE@XZ			; ImVector<char>::~ImVector<char>
__unwindfunclet$??0ExampleAppLog@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ImGuiTextBuffer@@QAE@XZ
__ehhandler$??0ExampleAppLog@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0ExampleAppLog@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ExampleAppLog@@QAE@XZ ENDP				; ExampleAppLog::ExampleAppLog
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Draw@ExampleAppLog@@QAEXPBDPA_N@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
$T2 = -12						; size = 8
$T3 = -12						; size = 8
$T4 = -12						; size = 8
_this$1$ = -4						; size = 4
_buf_begin$1$ = 8					; size = 4
_title$ = 8						; size = 4
tv274 = 12						; size = 4
_p_open$ = 12						; size = 4
?Draw@ExampleAppLog@@QAEXPBDPA_N@Z PROC			; ExampleAppLog::Draw, COMDAT
; _this$ = ecx

; 2427 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 2428 :         ImGui::SetNextWindowSize(ImVec2(500,400), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 1140457472		; 43fa0000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2427 :     {

	mov	esi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 1137180672	; 43c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2428 :         ImGui::SetNextWindowSize(ImVec2(500,400), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
	mov	DWORD PTR _this$1$[ebp], esi
	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 2429 :         ImGui::Begin(title, p_open);

	push	0
	push	DWORD PTR _p_open$[ebp]
	push	DWORD PTR _title$[ebp]
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin

; 2430 :         if (ImGui::Button("Clear")) Clear();

	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2430 :         if (ImGui::Button("Clear")) Clear();

	push	eax
	push	OFFSET ??_C@_05MDNHABIA@Clear?$AA@
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2430 :         if (ImGui::Button("Clear")) Clear();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 28					; 0000001cH
	test	al, al
	je	SHORT $LN5@Draw
	mov	ecx, esi
	call	?Clear@ExampleAppLog@@QAEXXZ		; ExampleAppLog::Clear
$LN5@Draw:

; 2431 :         ImGui::SameLine();

	push	ebx
	push	edi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 2432 :         bool copy = ImGui::Button("Copy");

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2432 :         bool copy = ImGui::Button("Copy");

	push	eax
	push	OFFSET ??_C@_04OPMHGHMB@Copy?$AA@
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2432 :         bool copy = ImGui::Button("Copy");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 2433 :         ImGui::SameLine();

	add	esp, 8
	mov	bl, al
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 2434 :         Filter.Draw("Filter", -100.0f);

	add	esp, 4
	lea	eax, DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR tv274[ebp], eax
	mov	DWORD PTR [esp], -1027080192		; c2c80000H
	push	OFFSET ??_C@_06IBDJIBGI@Filter?$AA@
	call	?Draw@ImGuiTextFilter@@QAE_NPBDM@Z	; ImGuiTextFilter::Draw

; 2435 :         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 2436 :         ImGui::BeginChild("scrolling", ImVec2(0,0), false, ImGuiWindowFlags_HorizontalScrollbar);

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2436 :         ImGui::BeginChild("scrolling", ImVec2(0,0), false, ImGuiWindowFlags_HorizontalScrollbar);

	push	eax
	push	OFFSET ??_C@_09PKEBEIDM@scrolling?$AA@
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2436 :         ImGui::BeginChild("scrolling", ImVec2(0,0), false, ImGuiWindowFlags_HorizontalScrollbar);

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild
	add	esp, 16					; 00000010H

; 2437 :         if (copy) ImGui::LogToClipboard();

	test	bl, bl
	je	SHORT $LN6@Draw
	push	-1
	call	?LogToClipboard@ImGui@@YAXH@Z		; ImGui::LogToClipboard
	add	esp, 4
$LN6@Draw:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+268], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2439 :         if (Filter.IsActive())

	je	SHORT $LN7@Draw

; 2440 :         {
; 2441 :             const char* buf_begin = Buf.begin();

	mov	ecx, DWORD PTR [esi+8]

; 2442 :             const char* line = buf_begin;
; 2443 :             for (int line_no = 0; line != NULL; line_no++)

	xor	ebx, ebx
	mov	DWORD PTR _buf_begin$1$[ebp], ecx
	mov	edi, ecx
	test	ecx, ecx
	je	SHORT $LN8@Draw
$LL4@Draw:

; 2444 :             {
; 2445 :                 const char* line_end = (line_no < LineOffsets.Size) ? buf_begin + LineOffsets[line_no] : NULL;

	cmp	ebx, DWORD PTR [esi+284]
	jge	SHORT $LN12@Draw
	mov	eax, DWORD PTR [esi+292]
	mov	esi, DWORD PTR [eax+ebx*4]
	add	esi, ecx
	jmp	SHORT $LN13@Draw
$LN12@Draw:
	xor	esi, esi
$LN13@Draw:

; 2446 :                 if (Filter.PassFilter(line, line_end))

	mov	ecx, DWORD PTR tv274[ebp]
	push	esi
	push	edi
	call	?PassFilter@ImGuiTextFilter@@QBE_NPBD0@Z ; ImGuiTextFilter::PassFilter
	test	al, al
	je	SHORT $LN9@Draw

; 2447 :                     ImGui::TextUnformatted(line, line_end);

	push	esi
	push	edi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 8
$LN9@Draw:

; 2448 :                 line = line_end && line_end[1] ? line_end + 1 : NULL;

	test	esi, esi
	je	SHORT $LN14@Draw
	cmp	BYTE PTR [esi+1], 0
	lea	edi, DWORD PTR [esi+1]
	jne	SHORT $LN15@Draw
$LN14@Draw:
	xor	edi, edi
$LN15@Draw:

; 2442 :             const char* line = buf_begin;
; 2443 :             for (int line_no = 0; line != NULL; line_no++)

	mov	esi, DWORD PTR _this$1$[ebp]
	inc	ebx
	mov	ecx, DWORD PTR _buf_begin$1$[ebp]
	test	edi, edi
	jne	SHORT $LL4@Draw

; 2449 :             }
; 2450 :         }
; 2451 :         else

	jmp	SHORT $LN8@Draw
$LN7@Draw:

; 2452 :         {
; 2453 :             ImGui::TextUnformatted(Buf.begin());

	push	0
	push	DWORD PTR [esi+8]
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 8
$LN8@Draw:

; 2454 :         }
; 2455 : 
; 2456 :         if (ScrollToBottom)

	cmp	BYTE PTR [esi+296], 0
	pop	edi
	pop	ebx
	je	SHORT $LN10@Draw

; 2457 :             ImGui::SetScrollHere(1.0f);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	call	?SetScrollHere@ImGui@@YAXM@Z		; ImGui::SetScrollHere
	add	esp, 4
$LN10@Draw:

; 2458 :         ScrollToBottom = false;

	mov	BYTE PTR [esi+296], 0

; 2459 :         ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 2460 :         ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	pop	esi

; 2461 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?Draw@ExampleAppLog@@QAEXPBDPA_N@Z ENDP			; ExampleAppLog::Draw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?AddLog@ExampleAppLog@@QAAXPBDZZ
_TEXT	SEGMENT
_new_size$1$ = -4					; size = 4
_new_data$1$ = 8					; size = 4
_this$ = 8						; size = 4
_fmt$ = 12						; size = 4
?AddLog@ExampleAppLog@@QAAXPBDZZ PROC			; ExampleAppLog::AddLog, COMDAT

; 2414 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1004 :     int                 size() const { return Buf.Size - 1; }

	mov	esi, DWORD PTR _this$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2418 :         Buf.appendv(fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	edi
	push	eax
	push	DWORD PTR _fmt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1004 :     int                 size() const { return Buf.Size - 1; }

	mov	edi, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2418 :         Buf.appendv(fmt, args);

	mov	ecx, esi
	call	?appendv@ImGuiTextBuffer@@QAEXPBDPAD@Z	; ImGuiTextBuffer::appendv
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1004 :     int                 size() const { return Buf.Size - 1; }

	mov	eax, DWORD PTR [esi]
	dec	edi
	dec	eax
	mov	DWORD PTR _new_size$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2420 :         for (int new_size = Buf.size(); old_size < new_size; old_size++)

	cmp	edi, eax
	jge	$LN28@AddLog
	push	ebx
	npad	5
$LL4@AddLog:

; 2421 :             if (Buf[old_size] == '\n')

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [edi+eax], 10			; 0000000aH
	jne	$LN2@AddLog
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ebx, DWORD PTR [esi+284]
	mov	ecx, DWORD PTR [esi+288]
	cmp	ebx, ecx
	jne	SHORT $LN20@AddLog
	inc	ebx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN18@AddLog
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN19@AddLog
$LN18@AddLog:
	mov	eax, 8
$LN19@AddLog:
	cmp	eax, ebx
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN20@AddLog

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+292]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN22@AddLog

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi+284]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN22@AddLog:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+292]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+292], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+288], ebx
$LN20@AddLog:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi+284]
	mov	eax, DWORD PTR [esi+292]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	DWORD PTR [esi+284]
$LN2@AddLog:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2420 :         for (int new_size = Buf.size(); old_size < new_size; old_size++)

	inc	edi
	cmp	edi, DWORD PTR _new_size$1$[ebp]
	jl	$LL4@AddLog
	pop	ebx
$LN28@AddLog:
	pop	edi

; 2422 :                 LineOffsets.push_back(old_size);
; 2423 :         ScrollToBottom = true;

	mov	BYTE PTR [esi+296], 1
	pop	esi

; 2424 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddLog@ExampleAppLog@@QAAXPBDZZ ENDP			; ExampleAppLog::AddLog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Clear@ExampleAppLog@@QAEXXZ
_TEXT	SEGMENT
$T1 = -1						; size = 1
?Clear@ExampleAppLog@@QAEXXZ PROC			; ExampleAppLog::Clear, COMDAT
; _this$ = ecx

; 2411 :     void    Clear()     { Buf.clear(); LineOffsets.clear(); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN6@Clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN6@Clear:

; 1006 :     void                clear() { Buf.clear(); Buf.push_back(0); }

	lea	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR $T1[ebp], 0
	push	eax
	mov	ecx, esi
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+292]
	test	eax, eax
	je	SHORT $LN9@Clear
	push	eax
	mov	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+284], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+292], 0
$LN9@Clear:
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2411 :     void    Clear()     { Buf.clear(); LineOffsets.clear(); }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@ExampleAppLog@@QAEXXZ ENDP			; ExampleAppLog::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@H@@QAEXABH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@H@@QAEXABH@Z PROC			; ImVector<int>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@H@@QAEXABH@Z ENDP			; ImVector<int>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@H@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@H@@QAEXH@Z PROC			; ImVector<int>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@H@@QAEXH@Z ENDP			; ImVector<int>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@H@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@H@@QAEHH@Z PROC		; ImVector<int>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@H@@QAEHH@Z ENDP		; ImVector<int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@H@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@H@@QAEXXZ PROC			; ImVector<int>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@H@@QAEXXZ ENDP			; ImVector<int>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@H@@QAEAAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@H@@QAEAAHH@Z PROC				; ImVector<int>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@H@@QAEAAHH@Z ENDP				; ImVector<int>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@H@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@H@@QAE@XZ PROC				; ImVector<int>::~ImVector<int>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@H@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@H@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@H@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@H@@QAE@XZ ENDP				; ImVector<int>::~ImVector<int>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@H@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@H@@QAE@XZ PROC				; ImVector<int>::ImVector<int>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@H@@QAE@XZ ENDP				; ImVector<int>::ImVector<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fconsole@?1??ShowExampleAppConsole@@YAXPA_N@Z@YAXXZ
text$yd	SEGMENT
??__Fconsole@?1??ShowExampleAppConsole@@YAXPA_N@Z@YAXXZ PROC ; `ShowExampleAppConsole'::`2'::`dynamic atexit destructor for 'console'', COMDAT
	mov	ecx, OFFSET ?console@?1??ShowExampleAppConsole@@YAXPA_N@Z@4UExampleAppConsole@@A
	jmp	??1ExampleAppConsole@@QAE@XZ		; ExampleAppConsole::~ExampleAppConsole
??__Fconsole@?1??ShowExampleAppConsole@@YAXPA_N@Z@YAXXZ ENDP ; `ShowExampleAppConsole'::`2'::`dynamic atexit destructor for 'console''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ PROC ; `ExampleAppConsole::Draw'::`2'::`dynamic atexit destructor for 'filter'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR ?filter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4UImGuiTextFilter@@A+264
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN7@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN7@dynamic:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ ENDP ; `ExampleAppConsole::Draw'::`2'::`dynamic atexit destructor for 'filter''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z
_TEXT	SEGMENT
_candidates$2 = -40					; size = 12
_this$1$ = -28						; size = 4
tv530 = -24						; size = 4
_match_len$1$ = -20					; size = 4
_word_end$1$ = -20					; size = 4
_word_start$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z PROC ; ExampleAppConsole::TextEditCallback, COMDAT
; _this$ = ecx

; 2295 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 2296 :         //AddLog("cursor: %d, selection: %d-%d", data->CursorPos, data->SelectionStart, data->SelectionEnd);
; 2297 :         switch (data->EventFlag)

	mov	esi, DWORD PTR _data$[ebp]
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	eax, DWORD PTR [esi]
	sub	eax, 64					; 00000040H
	je	$LN18@TextEditCa
	sub	eax, 64					; 00000040H
	jne	$LN98@TextEditCa

; 2360 :                 }
; 2361 : 
; 2362 :                 break;
; 2363 :             }
; 2364 :         case ImGuiInputTextFlags_CallbackHistory:
; 2365 :             {
; 2366 :                 // Example of HISTORY
; 2367 :                 const int prev_history_pos = HistoryPos;
; 2368 :                 if (data->EventKey == ImGuiKey_UpArrow)

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [ebx+284]
	cmp	eax, 1
	jne	SHORT $LN33@TextEditCa

; 2369 :                 {
; 2370 :                     if (HistoryPos == -1)

	cmp	ecx, -1
	jne	SHORT $LN35@TextEditCa

; 2371 :                         HistoryPos = History.Size - 1;

	mov	eax, DWORD PTR [ebx+272]
	dec	eax
	jmp	SHORT $LN107@TextEditCa
$LN35@TextEditCa:

; 2372 :                     else if (HistoryPos > 0)

	test	ecx, ecx
	jle	SHORT $LN40@TextEditCa

; 2373 :                         HistoryPos--;

	lea	eax, DWORD PTR [ecx-1]

; 2374 :                 }

	jmp	SHORT $LN107@TextEditCa
$LN33@TextEditCa:

; 2375 :                 else if (data->EventKey == ImGuiKey_DownArrow)

	cmp	eax, 2
	jne	SHORT $LN40@TextEditCa

; 2376 :                 {
; 2377 :                     if (HistoryPos != -1)

	cmp	ecx, -1
	je	SHORT $LN40@TextEditCa

; 2378 :                         if (++HistoryPos >= History.Size)

	lea	eax, DWORD PTR [ecx+1]
	or	edx, -1
	cmp	eax, DWORD PTR [ebx+272]
	cmovge	eax, edx
$LN107@TextEditCa:
	mov	DWORD PTR [ebx+284], eax
$LN40@TextEditCa:

; 2379 :                             HistoryPos = -1;
; 2380 :                 }
; 2381 : 
; 2382 :                 // A better implementation would preserve the data on the current input line along with cursor position.
; 2383 :                 if (prev_history_pos != HistoryPos)

	mov	edx, DWORD PTR [ebx+284]
	cmp	ecx, edx
	je	$LN98@TextEditCa

; 2384 :                 {
; 2385 :                     data->CursorPos = data->SelectionStart = data->SelectionEnd = data->BufTextLen = (int)snprintf(data->Buf, (size_t)data->BufSize, "%s", (HistoryPos >= 0) ? History[HistoryPos] : "");

	test	edx, edx
	js	SHORT $LN43@TextEditCa
	mov	eax, DWORD PTR [ebx+280]
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN44@TextEditCa
$LN43@TextEditCa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN44@TextEditCa:
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	push	DWORD PTR [esi+28]
	push	DWORD PTR [esi+20]
	call	__snprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+36], eax

; 2386 :                     data->BufDirty = true;
; 2387 :                 }
; 2388 :             }
; 2389 :         }
; 2390 :         return 0;

	xor	eax, eax
	mov	BYTE PTR [esi+32], 1
	pop	esi
	pop	ebx

; 2391 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN18@TextEditCa:

; 2298 :         {
; 2299 :         case ImGuiInputTextFlags_CallbackCompletion:
; 2300 :             {
; 2301 :                 // Example of TEXT COMPLETION
; 2302 : 
; 2303 :                 // Locate beginning of current word
; 2304 :                 const char* word_end = data->Buf + data->CursorPos;

	mov	edx, DWORD PTR [esi+20]
	push	edi
	mov	edi, DWORD PTR [esi+36]
	add	edi, edx
	mov	DWORD PTR _word_end$1$[ebp], edi

; 2305 :                 const char* word_start = word_end;

	mov	ecx, edi
	mov	DWORD PTR _word_start$1$[ebp], ecx

; 2306 :                 while (word_start > data->Buf)

	cmp	edi, edx
	jbe	SHORT $LN80@TextEditCa
	mov	ebx, ecx
$LL4@TextEditCa:

; 2307 :                 {
; 2308 :                     const char c = word_start[-1];

	mov	al, BYTE PTR [ebx-1]

; 2309 :                     if (c == ' ' || c == '\t' || c == ',' || c == ';')

	cmp	al, 32					; 00000020H
	je	SHORT $LN102@TextEditCa
	cmp	al, 9
	je	SHORT $LN102@TextEditCa
	cmp	al, 44					; 0000002cH
	je	SHORT $LN102@TextEditCa
	cmp	al, 59					; 0000003bH
	je	SHORT $LN102@TextEditCa

; 2310 :                         break;
; 2311 :                     word_start--;

	dec	ebx
	mov	DWORD PTR _word_start$1$[ebp], ebx
	cmp	ebx, edx
	ja	SHORT $LL4@TextEditCa
$LN102@TextEditCa:
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR _word_start$1$[ebp]
$LN80@TextEditCa:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR _candidates$2[ebp+4], 0
	mov	DWORD PTR _candidates$2[ebp], 0
	mov	DWORD PTR _candidates$2[ebp+8], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2316 :                 for (int i = 0; i < Commands.Size; i++)

	xor	esi, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR [ebx+288], esi
	jle	$LN96@TextEditCa
	mov	edx, edi
	mov	edi, DWORD PTR _this$1$[ebp]
	sub	edx, ecx
	mov	DWORD PTR tv530[ebp], edx
	npad	11
$LL8@TextEditCa:
	mov	eax, DWORD PTR [edi+296]
	lea	ebx, DWORD PTR [esi*4]

; 2317 :                     if (Strnicmp(Commands[i], word_start, (int)(word_end-word_start)) == 0)

	push	edx
	push	ecx
	push	DWORD PTR [eax+ebx]
	call	?Strnicmp@ExampleAppConsole@@SAHPBD0H@Z	; ExampleAppConsole::Strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@TextEditCa

; 2318 :                         candidates.push_back(Commands[i]);

	mov	eax, DWORD PTR [edi+296]
	lea	ecx, DWORD PTR _candidates$2[ebp]
	add	eax, ebx
	push	eax
	call	?push_back@?$ImVector@PBD@@QAEXABQBD@Z	; ImVector<char const *>::push_back
$LN6@TextEditCa:

; 2316 :                 for (int i = 0; i < Commands.Size; i++)

	mov	ecx, DWORD PTR _word_start$1$[ebp]
	inc	esi
	mov	edx, DWORD PTR tv530[ebp]
	cmp	esi, DWORD PTR [edi+288]
	jl	SHORT $LL8@TextEditCa

; 2319 : 
; 2320 :                 if (candidates.Size == 0)

	mov	eax, DWORD PTR _candidates$2[ebp]
	mov	edi, DWORD PTR _word_end$1$[ebp]
	test	eax, eax
	je	$LN101@TextEditCa

; 2324 :                 }
; 2325 :                 else if (candidates.Size == 1)

	cmp	eax, 1
	jne	SHORT $LN24@TextEditCa

; 2326 :                 {
; 2327 :                     // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing
; 2328 :                     data->DeleteChars((int)(word_start-data->Buf), (int)(word_end-word_start));

	mov	esi, DWORD PTR _data$[ebp]
	mov	eax, ecx
	push	edx
	mov	ecx, esi
	sub	eax, DWORD PTR [esi+20]
	push	eax
	call	?DeleteChars@ImGuiTextEditCallbackData@@QAEXHH@Z ; ImGuiTextEditCallbackData::DeleteChars

; 2329 :                     data->InsertChars(data->CursorPos, candidates[0]);

	mov	ebx, DWORD PTR _candidates$2[ebp+8]
	mov	ecx, esi
	push	0
	push	DWORD PTR [ebx]
	push	DWORD PTR [esi+36]
	call	?InsertChars@ImGuiTextEditCallbackData@@QAEXHPBD0@Z ; ImGuiTextEditCallbackData::InsertChars

; 2330 :                     data->InsertChars(data->CursorPos, " ");

	push	0
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	DWORD PTR [esi+36]
	mov	ecx, esi
	call	?InsertChars@ImGuiTextEditCallbackData@@QAEXHPBD0@Z ; ImGuiTextEditCallbackData::InsertChars

; 2331 :                 }
; 2332 :                 else

	jmp	$LN16@TextEditCa
$LN24@TextEditCa:

; 2333 :                 {
; 2334 :                     // Multiple matches. Complete as much as we can, so inputing "C" will complete to "CL" and display "CLEAR" and "CLASSIFY"
; 2335 :                     int match_len = (int)(word_end - word_start);

	mov	ecx, DWORD PTR tv530[ebp]
	mov	edx, DWORD PTR __imp__toupper
$LN108@TextEditCa:

; 2336 :                     for (;;)
; 2337 :                     {
; 2338 :                         int c = 0;

	xor	edi, edi
	mov	DWORD PTR _match_len$1$[ebp], ecx

; 2339 :                         bool all_candidates_matches = true;
; 2340 :                         for (int i = 0; i < candidates.Size && all_candidates_matches; i++)

	xor	esi, esi
	mov	bl, 1
	test	eax, eax
	jle	SHORT $LN97@TextEditCa
	npad	1
$LL14@TextEditCa:
	test	bl, bl
	je	SHORT $LN81@TextEditCa

; 2341 :                             if (i == 0)

	test	esi, esi
	jne	SHORT $LN26@TextEditCa

; 2342 :                                 c = toupper(candidates[i][match_len]);

	mov	eax, DWORD PTR _candidates$2[ebp+8]
	mov	eax, DWORD PTR [eax]
	movsx	eax, BYTE PTR [eax+ecx]
	push	eax
	call	edx
	add	esp, 4
	mov	edi, eax
$LN105@TextEditCa:
	mov	eax, DWORD PTR _candidates$2[ebp]
$LN12@TextEditCa:

; 2339 :                         bool all_candidates_matches = true;
; 2340 :                         for (int i = 0; i < candidates.Size && all_candidates_matches; i++)

	mov	ecx, DWORD PTR _match_len$1$[ebp]
	inc	esi
	mov	edx, DWORD PTR __imp__toupper
	cmp	esi, eax
	jl	SHORT $LL14@TextEditCa

; 2345 :                         if (!all_candidates_matches)

	test	bl, bl
	je	SHORT $LN81@TextEditCa
$LN97@TextEditCa:

; 2346 :                             break;
; 2347 :                         match_len++;

	inc	ecx

; 2348 :                     }

	jmp	SHORT $LN108@TextEditCa
$LN26@TextEditCa:

; 2343 :                             else if (c == 0 || c != toupper(candidates[i][match_len]))

	test	edi, edi
	je	SHORT $LN29@TextEditCa
	mov	eax, DWORD PTR _candidates$2[ebp+8]
	mov	eax, DWORD PTR [eax+esi*4]
	movsx	eax, BYTE PTR [eax+ecx]
	push	eax
	call	edx
	add	esp, 4
	cmp	edi, eax
	je	SHORT $LN105@TextEditCa
	mov	eax, DWORD PTR _candidates$2[ebp]
$LN29@TextEditCa:

; 2344 :                                 all_candidates_matches = false;

	xor	bl, bl
	jmp	SHORT $LN12@TextEditCa
$LN81@TextEditCa:

; 2349 : 
; 2350 :                     if (match_len > 0)

	test	ecx, ecx
	jle	SHORT $LN103@TextEditCa

; 2351 :                     {
; 2352 :                         data->DeleteChars((int)(word_start - data->Buf), (int)(word_end-word_start));

	mov	esi, DWORD PTR _data$[ebp]
	mov	ecx, esi
	push	DWORD PTR tv530[ebp]
	mov	eax, DWORD PTR _word_start$1$[ebp]
	sub	eax, DWORD PTR [esi+20]
	push	eax
	call	?DeleteChars@ImGuiTextEditCallbackData@@QAEXHH@Z ; ImGuiTextEditCallbackData::DeleteChars

; 2353 :                         data->InsertChars(data->CursorPos, candidates[0], candidates[0] + match_len);

	mov	ebx, DWORD PTR _candidates$2[ebp+8]
	mov	eax, DWORD PTR _match_len$1$[ebp]
	mov	ecx, DWORD PTR [ebx]
	add	eax, ecx
	push	eax
	push	ecx
	push	DWORD PTR [esi+36]
	mov	ecx, esi
	call	?InsertChars@ImGuiTextEditCallbackData@@QAEXHPBD0@Z ; ImGuiTextEditCallbackData::InsertChars
	jmp	SHORT $LN31@TextEditCa
$LN103@TextEditCa:
	mov	ebx, DWORD PTR _candidates$2[ebp+8]
$LN31@TextEditCa:

; 2354 :                     }
; 2355 : 
; 2356 :                     // List matches
; 2357 :                     AddLog("Possible matches:\n");

	mov	edi, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BD@LCPLNAHF@Possible?5matches?3?6?$AA@
	push	edi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	add	esp, 8

; 2358 :                     for (int i = 0; i < candidates.Size; i++)

	xor	esi, esi
$LL17@TextEditCa:

; 2359 :                         AddLog("- %s\n", candidates[i]);

	push	DWORD PTR [ebx+esi*4]
	push	OFFSET ??_C@_05PHKAGDP@?9?5?$CFs?6?$AA@
	push	edi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR _candidates$2[ebp]
	jl	SHORT $LL17@TextEditCa

; 2358 :                     for (int i = 0; i < candidates.Size; i++)

	jmp	SHORT $LN16@TextEditCa
$LN101@TextEditCa:
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN96@TextEditCa:

; 2321 :                 {
; 2322 :                     // No match
; 2323 :                     AddLog("No match for \"%.*s\"!\n", (int)(word_end-word_start), word_start);

	mov	eax, DWORD PTR _word_start$1$[ebp]
	sub	edi, eax
	push	eax
	push	edi
	push	OFFSET ??_C@_0BG@DOPMHGPK@No?5match?5for?5?$CC?$CF?4?$CKs?$CC?$CB?6?$AA@
	push	ebx
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	mov	ebx, DWORD PTR _candidates$2[ebp+8]
	add	esp, 16					; 00000010H
$LN16@TextEditCa:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	pop	edi
	test	ebx, ebx
	je	SHORT $LN98@TextEditCa
	push	ebx
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN98@TextEditCa:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2391 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z$0:
	lea	ecx, DWORD PTR _candidates$2[ebp]
	jmp	??1?$ImVector@PBD@@QAE@XZ		; ImVector<char const *>::~ImVector<char const *>
__ehhandler$?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z ENDP ; ExampleAppConsole::TextEditCallback
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?TextEditCallbackStub@ExampleAppConsole@@SAHPAUImGuiTextEditCallbackData@@@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?TextEditCallbackStub@ExampleAppConsole@@SAHPAUImGuiTextEditCallbackData@@@Z PROC ; ExampleAppConsole::TextEditCallbackStub, COMDAT

; 2289 :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 2290 :         ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;

	mov	eax, DWORD PTR _data$[ebp]

; 2291 :         return console->TextEditCallback(data);

	push	eax
	mov	ecx, DWORD PTR [eax+8]
	call	?TextEditCallback@ExampleAppConsole@@QAEHPAUImGuiTextEditCallbackData@@@Z ; ExampleAppConsole::TextEditCallback

; 2292 :     }

	pop	ebp
	ret	0
?TextEditCallbackStub@ExampleAppConsole@@SAHPAUImGuiTextEditCallbackData@@@Z ENDP ; ExampleAppConsole::TextEditCallbackStub
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?ExecCommand@ExampleAppConsole@@QAEXPBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_new_data$1$ = 8					; size = 4
_command_line$ = 8					; size = 4
?ExecCommand@ExampleAppConsole@@QAEXPBD@Z PROC		; ExampleAppConsole::ExecCommand, COMDAT
; _this$ = ecx

; 2252 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2253 :         AddLog("# %s\n", command_line);

	mov	ebx, DWORD PTR _command_line$[ebp]
	push	esi
	push	edi
	push	ebx
	mov	esi, ecx
	push	OFFSET ??_C@_05DFHAGHEP@?$CD?5?$CFs?6?$AA@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog

; 2254 : 
; 2255 :         // Insert into history. First find match and delete it so it can be pushed to the back. This isn't trying to be smart or optimal.
; 2256 :         HistoryPos = -1;
; 2257 :         for (int i = History.Size-1; i >= 0; i--)

	mov	edi, DWORD PTR [esi+272]
	add	esp, 12					; 0000000cH
	sub	edi, 1
	mov	DWORD PTR [esi+284], -1
	js	SHORT $LN3@ExecComman
$LL4@ExecComman:
	mov	eax, DWORD PTR [esi+280]

; 2258 :             if (Stricmp(History[i], command_line) == 0)

	push	ebx
	push	DWORD PTR [eax+edi*4]
	call	?Stricmp@ExampleAppConsole@@SAHPBD0@Z	; ExampleAppConsole::Stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@ExecComman

; 2254 : 
; 2255 :         // Insert into history. First find match and delete it so it can be pushed to the back. This isn't trying to be smart or optimal.
; 2256 :         HistoryPos = -1;
; 2257 :         for (int i = History.Size-1; i >= 0; i--)

	sub	edi, 1
	jns	SHORT $LL4@ExecComman

; 2258 :             if (Stricmp(History[i], command_line) == 0)

	jmp	SHORT $LN3@ExecComman
$LN49@ExecComman:

; 2260 :                 free(History[i]);

	mov	eax, DWORD PTR [esi+280]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	shl	edi, 2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2260 :                 free(History[i]);

	push	DWORD PTR [eax+edi]
	call	DWORD PTR __imp__free
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 943  :     inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }

	mov	eax, DWORD PTR [esi+280]
	mov	ecx, eax
	sub	ecx, eax
	add	ecx, edi
	sar	ecx, 2
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [esi+272]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4-4]
	push	eax
	lea	eax, DWORD PTR [edx+4]
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 16					; 00000010H
	dec	DWORD PTR [esi+272]
$LN3@ExecComman:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2143 :     static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }

	mov	edi, ebx
	lea	ecx, DWORD PTR [edi+1]
	npad	4
$LL59@ExecComman:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL59@ExecComman
	sub	edi, ecx
	inc	edi
	push	edi
	call	DWORD PTR __imp__malloc
	push	edi
	push	ebx
	push	eax
	call	_memcpy
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edi, DWORD PTR [esi+272]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2143 :     static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }

	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi+276]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2264 :         History.push_back(Strdup(command_line));

	mov	DWORD PTR $T1[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	cmp	edi, ecx
	jne	SHORT $LN38@ExecComman
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN36@ExecComman
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN37@ExecComman
$LN36@ExecComman:
	mov	eax, 8
$LN37@ExecComman:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN38@ExecComman

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+280]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN40@ExecComman

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi+272]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN40@ExecComman:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+280]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+280], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+276], edi
$LN38@ExecComman:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi+272]
	mov	eax, DWORD PTR [esi+280]
	mov	edx, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2267 :         if (Stricmp(command_line, "CLEAR") == 0)

	push	OFFSET ??_C@_05PONODPI@CLEAR?$AA@
	push	ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	DWORD PTR [eax+ecx*4], edx
	inc	DWORD PTR [esi+272]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2267 :         if (Stricmp(command_line, "CLEAR") == 0)

	call	?Stricmp@ExampleAppConsole@@SAHPBD0@Z	; ExampleAppConsole::Stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@ExecComman

; 2268 :         {
; 2269 :             ClearLog();

	mov	ecx, esi
	call	?ClearLog@ExampleAppConsole@@QAEXXZ	; ExampleAppConsole::ClearLog
	pop	edi
	pop	esi
	pop	ebx

; 2285 :         }
; 2286 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@ExecComman:

; 2270 :         }
; 2271 :         else if (Stricmp(command_line, "HELP") == 0)

	push	OFFSET ??_C@_04DOKPJKJF@HELP?$AA@
	push	ebx
	call	?Stricmp@ExampleAppConsole@@SAHPBD0@Z	; ExampleAppConsole::Stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@ExecComman

; 2272 :         {
; 2273 :             AddLog("Commands:");

	push	OFFSET ??_C@_09GJFNIAOH@Commands?3?$AA@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog

; 2274 :             for (int i = 0; i < Commands.Size; i++)

	xor	edi, edi
	add	esp, 8
	cmp	DWORD PTR [esi+288], edi
	jle	$LN17@ExecComman
	npad	13
$LL7@ExecComman:

; 2275 :                 AddLog("- %s", Commands[i]);

	mov	eax, DWORD PTR [esi+296]
	push	DWORD PTR [eax+edi*4]
	push	OFFSET ??_C@_04JKCKOCFH@?9?5?$CFs?$AA@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+288]
	jl	SHORT $LL7@ExecComman
	pop	edi
	pop	esi
	pop	ebx

; 2285 :         }
; 2286 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN14@ExecComman:

; 2276 :         }
; 2277 :         else if (Stricmp(command_line, "HISTORY") == 0)

	push	OFFSET ??_C@_07DBIJIOJO@HISTORY?$AA@
	push	ebx
	call	?Stricmp@ExampleAppConsole@@SAHPBD0@Z	; ExampleAppConsole::Stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@ExecComman

; 2278 :         {
; 2279 :             for (int i = History.Size >= 10 ? History.Size - 10 : 0; i < History.Size; i++)

	mov	eax, DWORD PTR [esi+272]
	cmp	eax, 10					; 0000000aH
	jl	SHORT $LN19@ExecComman
	lea	edi, DWORD PTR [eax-10]
	jmp	SHORT $LN20@ExecComman
$LN19@ExecComman:
	xor	edi, edi
$LN20@ExecComman:
	cmp	edi, eax
	jge	SHORT $LN17@ExecComman
$LL10@ExecComman:

; 2280 :                 AddLog("%3d: %s\n", i, History[i]);

	mov	eax, DWORD PTR [esi+280]
	push	DWORD PTR [eax+edi*4]
	push	edi
	push	OFFSET ??_C@_08PKLPHKJF@?$CF3d?3?5?$CFs?6?$AA@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	inc	edi
	add	esp, 16					; 00000010H
	cmp	edi, DWORD PTR [esi+272]
	jl	SHORT $LL10@ExecComman
	pop	edi
	pop	esi
	pop	ebx

; 2285 :         }
; 2286 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN16@ExecComman:

; 2281 :         }
; 2282 :         else
; 2283 :         {
; 2284 :             AddLog("Unknown command: '%s'\n", command_line);

	push	ebx
	push	OFFSET ??_C@_0BH@OKLFOGKH@Unknown?5command?3?5?8?$CFs?8?6?$AA@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	add	esp, 12					; 0000000cH
$LN17@ExecComman:
	pop	edi
	pop	esi
	pop	ebx

; 2285 :         }
; 2286 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?ExecCommand@ExampleAppConsole@@QAEXPBD@Z ENDP		; ExampleAppConsole::ExecCommand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z
_TEXT	SEGMENT
_col$2 = -36						; size = 16
$T3 = -20						; size = 8
$T4 = -20						; size = 8
$T5 = -20						; size = 8
$T6 = -20						; size = 8
$T7 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_title$ = 8						; size = 4
_item$1$ = 12						; size = 4
tv728 = 12						; size = 4
_p_open$ = 12						; size = 4
_reclaim_focus$1$ = 15					; size = 1
?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z PROC		; ExampleAppConsole::Draw, COMDAT
; _this$ = ecx

; 2166 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	esi

; 2167 :         ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], 1140981760		; 44020000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2167 :         ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
	mov	esi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 1142292480	; 44160000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2167 :         ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 2168 :         if (!ImGui::Begin(title, p_open))

	push	0
	push	DWORD PTR _p_open$[ebp]
	push	DWORD PTR _title$[ebp]
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN22@Draw

; 2169 :         {
; 2170 :             ImGui::End();
; 2171 :             return;
; 2172 :         }
; 2173 : 
; 2174 :         ImGui::TextWrapped("This example implements a console with basic coloring, completion and history. A more elaborate implementation may want to store entries along with extra data such as timestamp, emitter, etc.");

	push	OFFSET ??_C@_0MA@ICGIOBFG@This?5example?5implements?5a?5consol@
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 2175 :         ImGui::TextWrapped("Enter 'HELP' for help, press TAB to use text completion.");

	push	OFFSET ??_C@_0DJ@NBHLDCP@Enter?5?8HELP?8?5for?5help?0?5press?5TAB@
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 2176 : 
; 2177 :         // TODO: display items starting from the bottom
; 2178 : 
; 2179 :         if (ImGui::SmallButton("Add Dummy Text")) { AddLog("%d some text", Items.Size); AddLog("some more text"); AddLog("display very important message here!"); } ImGui::SameLine();

	push	OFFSET ??_C@_0P@CGJDLLEJ@Add?5Dummy?5Text?$AA@
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN9@Draw
	push	DWORD PTR [esi+256]
	push	OFFSET ??_C@_0N@OJGBPOOP@?$CFd?5some?5text?$AA@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	push	OFFSET ??_C@_0P@BMHJKMPF@some?5more?5text?$AA@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	push	OFFSET ??_C@_0CF@PEIDNPCH@display?5very?5important?5message?5h@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	add	esp, 28					; 0000001cH
$LN9@Draw:
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 2180 :         if (ImGui::SmallButton("Add Dummy Error")) AddLog("[error] something went wrong"); ImGui::SameLine();

	push	OFFSET ??_C@_0BA@HHKLEHKC@Add?5Dummy?5Error?$AA@
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN10@Draw
	push	OFFSET ??_C@_0BN@KNPJMMPE@?$FLerror?$FN?5something?5went?5wrong?$AA@
	push	esi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog
	add	esp, 8
$LN10@Draw:
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 2181 :         if (ImGui::SmallButton("Clear")) ClearLog(); ImGui::SameLine();

	push	OFFSET ??_C@_05MDNHABIA@Clear?$AA@
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN11@Draw
	mov	ecx, esi
	call	?ClearLog@ExampleAppConsole@@QAEXXZ	; ExampleAppConsole::ClearLog
$LN11@Draw:
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 2182 :         if (ImGui::SmallButton("Scroll to bottom")) ScrollToBottom = true;

	push	OFFSET ??_C@_0BB@GPFIAMJC@Scroll?5to?5bottom?$AA@
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN12@Draw
	mov	BYTE PTR [esi+268], 1
$LN12@Draw:

; 2183 :         //static float t = 0.0f; if (ImGui::GetTime() - t > 0.02f) { t = ImGui::GetTime(); AddLog("Spam %f", t); }
; 2184 : 
; 2185 :         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 2187 :         ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2187 :         ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	push	eax
	push	5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2187 :         ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 2188 :         static ImGuiTextFilter filter;

	mov	eax, DWORD PTR fs:__tls_array
	add	esp, 8
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4HA ; TSS0<`template-parameter-2',ExampleAppConsole::aw,unsigned char * const,void,char const *,bool *>
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	SHORT $LN2@Draw
	push	OFFSET ?$TSS0@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4HA ; TSS0<`template-parameter-2',ExampleAppConsole::aw,unsigned char * const,void,char const *,bool *>
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4HA, -1 ; TSS0<`template-parameter-2',ExampleAppConsole::aw,unsigned char * const,void,char const *,bool *>
	jne	SHORT $LN2@Draw
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, OFFSET ?filter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4UImGuiTextFilter@@A ; `ExampleAppConsole::Draw'::`2'::filter
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0ImGuiTextFilter@@QAE@PBD@Z		; ImGuiTextFilter::ImGuiTextFilter
	push	OFFSET ??__Ffilter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@YAXXZ ; `ExampleAppConsole::Draw'::`2'::`dynamic atexit destructor for 'filter''
	call	_atexit
	push	OFFSET ?$TSS0@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4HA ; TSS0<`template-parameter-2',ExampleAppConsole::aw,unsigned char * const,void,char const *,bool *>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 8
$LN2@Draw:

; 2189 :         filter.Draw("Filter (\"incl,-excl\") (\"error\")", 180);

	push	ecx
	mov	DWORD PTR [esp], 1127481344		; 43340000H
	mov	ecx, OFFSET ?filter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4UImGuiTextFilter@@A ; `ExampleAppConsole::Draw'::`2'::filter
	push	OFFSET ??_C@_0CA@HIABFBKB@Filter?5?$CI?$CCincl?0?9excl?$CC?$CJ?5?$CI?$CCerror?$CC?$CJ?$AA@
	call	?Draw@ImGuiTextFilter@@QAE_NPBDM@Z	; ImGuiTextFilter::Draw

; 2190 :         ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 2191 :         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 2193 :         ImGui::BeginChild("ScrollingRegion", ImVec2(0,-ImGui::GetItemsLineHeightWithSpacing()), false, ImGuiWindowFlags_HorizontalScrollbar);

	call	?GetItemsLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetItemsLineHeightWithSpacing
	push	2048					; 00000800H
	fstp	DWORD PTR tv728[ebp]
	movss	xmm0, DWORD PTR tv728[ebp]
	lea	eax, DWORD PTR $T5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	0
	push	eax
	push	OFFSET ??_C@_0BA@KOEFNJOK@ScrollingRegion?$AA@
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2193 :         ImGui::BeginChild("ScrollingRegion", ImVec2(0,-ImGui::GetItemsLineHeightWithSpacing()), false, ImGuiWindowFlags_HorizontalScrollbar);

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild

; 2194 :         if (ImGui::BeginPopupContextWindow())

	push	1
	push	0
	push	1
	call	?BeginPopupContextWindow@ImGui@@YA_N_NPBDH@Z ; ImGui::BeginPopupContextWindow
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN13@Draw

; 2196 :             if (ImGui::Selectable("Clear")) ClearLog();

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2196 :             if (ImGui::Selectable("Clear")) ClearLog();

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05MDNHABIA@Clear?$AA@
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2196 :             if (ImGui::Selectable("Clear")) ClearLog();

	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN14@Draw
	mov	ecx, esi
	call	?ClearLog@ExampleAppConsole@@QAEXXZ	; ExampleAppConsole::ClearLog
$LN14@Draw:

; 2197 :             ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN13@Draw:
	push	edi

; 2211 :         ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4,1)); // Tighten spacing

	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 1082130432		; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2211 :         ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4,1)); // Tighten spacing

	push	eax
	push	7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2211 :         ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4,1)); // Tighten spacing

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 2212 :         for (int i = 0; i < Items.Size; i++)

	xor	edi, edi
	add	esp, 8
	cmp	DWORD PTR [esi+256], edi
	jle	$LN4@Draw
$LL5@Draw:

; 2213 :         {
; 2214 :             const char* item = Items[i];

	mov	eax, DWORD PTR [esi+264]

; 2215 :             if (!filter.PassFilter(item))

	mov	ecx, OFFSET ?filter@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4UImGuiTextFilter@@A ; `ExampleAppConsole::Draw'::`2'::filter
	push	0
	mov	eax, DWORD PTR [eax+edi*4]
	push	eax
	mov	DWORD PTR _item$1$[ebp], eax
	call	?PassFilter@ImGuiTextFilter@@QBE_NPBD0@Z ; ImGuiTextFilter::PassFilter
	test	al, al
	je	SHORT $LN3@Draw

; 2216 :                 continue;
; 2217 :             ImVec4 col = ImVec4(1.0f,1.0f,1.0f,1.0f); // A better implementation may store a type per-item. For the sample let's just parse the text.
; 2218 :             if (strstr(item, "[error]")) col = ImColor(1.0f,0.4f,0.4f,1.0f);

	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	push	OFFSET ??_C@_07LFMCMLFD@?$FLerror?$FN?$AA@
	push	DWORD PTR _item$1$[ebp]
	movups	XMMWORD PTR _col$2[ebp], xmm0
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@Draw
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003ecccccd3ecccccd3f800000
	jmp	SHORT $LN98@Draw
$LN16@Draw:

; 2219 :             else if (strncmp(item, "# ", 2) == 0) col = ImColor(1.0f,0.78f,0.58f,1.0f);

	push	2
	push	OFFSET ??_C@_02KPDBPKPG@?$CD?5?$AA@
	push	DWORD PTR _item$1$[ebp]
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN88@Draw
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f147ae13f47ae143f800000
$LN98@Draw:
	movups	XMMWORD PTR _col$2[ebp], xmm0
$LN88@Draw:

; 2220 :             ImGui::PushStyleColor(ImGuiCol_Text, col);

	lea	eax, DWORD PTR _col$2[ebp]
	push	eax
	push	0
	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor

; 2221 :             ImGui::TextUnformatted(item);

	push	0
	push	DWORD PTR _item$1$[ebp]
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted

; 2222 :             ImGui::PopStyleColor();

	push	1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 20					; 00000014H
$LN3@Draw:

; 2212 :         for (int i = 0; i < Items.Size; i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+256]
	jl	$LL5@Draw
$LN4@Draw:

; 2223 :         }
; 2224 :         if (ScrollToBottom)

	cmp	BYTE PTR [esi+268], 0
	pop	edi
	je	SHORT $LN19@Draw

; 2225 :             ImGui::SetScrollHere();

	push	ecx
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	call	?SetScrollHere@ImGui@@YAXM@Z		; ImGui::SetScrollHere
	add	esp, 4
$LN19@Draw:

; 2226 :         ScrollToBottom = false;
; 2227 :         ImGui::PopStyleVar();

	push	1
	mov	BYTE PTR [esi+268], 0
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 2228 :         ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 2229 :         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 2230 : 
; 2231 :         // Command-line
; 2232 :         bool reclaim_focus = false;
; 2233 :         if (ImGui::InputText("Input", InputBuf, IM_ARRAYSIZE(InputBuf), ImGuiInputTextFlags_EnterReturnsTrue|ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_CallbackHistory, &TextEditCallbackStub, (void*)this))

	push	esi
	push	OFFSET ?TextEditCallbackStub@ExampleAppConsole@@SAHPAUImGuiTextEditCallbackData@@@Z ; ExampleAppConsole::TextEditCallbackStub
	push	224					; 000000e0H
	push	256					; 00000100H
	push	esi
	push	OFFSET ??_C@_05DCDOHKAB@Input?$AA@
	mov	BYTE PTR _reclaim_focus$1$[ebp], 0
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 28					; 0000001cH
	test	al, al
	je	SHORT $LN20@Draw

; 2234 :         {
; 2235 :             char* input_end = InputBuf+strlen(InputBuf);

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL95@Draw:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL95@Draw
	sub	ecx, edx
	lea	eax, DWORD PTR [ecx+esi]

; 2236 :             while (input_end > InputBuf && input_end[-1] == ' ') input_end--; *input_end = 0;

	cmp	eax, esi
	jbe	SHORT $LN96@Draw
$LL6@Draw:
	cmp	BYTE PTR [eax-1], 32			; 00000020H
	jne	SHORT $LN96@Draw
	dec	eax
	cmp	eax, esi
	ja	SHORT $LL6@Draw
$LN96@Draw:
	mov	BYTE PTR [eax], 0

; 2237 :             if (InputBuf[0])

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN21@Draw

; 2238 :                 ExecCommand(InputBuf);

	push	esi
	mov	ecx, esi
	call	?ExecCommand@ExampleAppConsole@@QAEXPBD@Z ; ExampleAppConsole::ExecCommand
$LN21@Draw:

; 2239 :             strcpy(InputBuf, "");

	mov	BYTE PTR [esi], 0

; 2240 :             reclaim_focus = true;

	mov	BYTE PTR _reclaim_focus$1$[ebp], 1
$LN20@Draw:

; 2241 :         }
; 2242 : 
; 2243 :         // Demonstrate keeping focus on the input box
; 2244 :         ImGui::SetItemDefaultFocus();

	call	?SetItemDefaultFocus@ImGui@@YAXXZ	; ImGui::SetItemDefaultFocus

; 2245 :         if (ImGui::IsItemHovered() || reclaim_focus)

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	jne	SHORT $LN23@Draw
	cmp	BYTE PTR _reclaim_focus$1$[ebp], al
	je	SHORT $LN22@Draw
$LN23@Draw:

; 2246 :             ImGui::SetKeyboardFocusHere(-1); // Auto focus previous widget

	push	-1
	call	?SetKeyboardFocusHere@ImGui@@YAXH@Z	; ImGui::SetKeyboardFocusHere
	add	esp, 4
$LN22@Draw:

; 2247 : 
; 2248 :         ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 2249 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z$0:
	push	OFFSET ?$TSS0@?1??Draw@ExampleAppConsole@@QAEXPBDPA_N@Z@4HA ; TSS0<`template-parameter-2',ExampleAppConsole::aw,unsigned char * const,void,char const *,bool *>
	call	__Init_thread_abort
	pop	ecx
	ret	0
__ehhandler$?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z ENDP		; ExampleAppConsole::Draw
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?AddLog@ExampleAppConsole@@QAAXPBDZZ
_TEXT	SEGMENT
_buf$ = -1028						; size = 1024
$T1 = -4						; size = 4
_this$ = 8						; size = 4
_fmt$ = 12						; size = 4
?AddLog@ExampleAppConsole@@QAAXPBDZZ PROC		; ExampleAppConsole::AddLog, COMDAT

; 2154 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 1028				; 00000404H

; 2155 :         char buf[1024];
; 2156 :         va_list args;
; 2157 :         va_start(args, fmt);
; 2158 :         vsnprintf(buf, IM_ARRAYSIZE(buf), fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	lea	eax, DWORD PTR _buf$[ebp]
	push	1024					; 00000400H
	push	eax
	call	_vsnprintf

; 2143 :     static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }

	lea	eax, DWORD PTR _buf$[ebp]

; 2159 :         buf[IM_ARRAYSIZE(buf)-1] = 0;

	mov	BYTE PTR _buf$[ebp+1023], 0
	add	esp, 16					; 00000010H

; 2143 :     static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }

	lea	edx, DWORD PTR [eax+1]
$LL5@AddLog:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@AddLog
	sub	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	DWORD PTR __imp__malloc
	push	esi
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	call	_memcpy

; 2160 :         va_end(args);
; 2161 :         Items.push_back(Strdup(buf));

	mov	esi, DWORD PTR _this$[ebp]

; 2143 :     static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }

	add	esp, 16					; 00000010H

; 2160 :         va_end(args);
; 2161 :         Items.push_back(Strdup(buf));

	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR [esi+256]
	call	?push_back@?$ImVector@PAD@@QAEXABQAD@Z	; ImVector<char *>::push_back

; 2162 :         ScrollToBottom = true;

	mov	BYTE PTR [esi+268], 1
	pop	esi

; 2163 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddLog@ExampleAppConsole@@QAAXPBDZZ ENDP		; ExampleAppConsole::AddLog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?ClearLog@ExampleAppConsole@@QAEXXZ
_TEXT	SEGMENT
?ClearLog@ExampleAppConsole@@QAEXXZ PROC		; ExampleAppConsole::ClearLog, COMDAT
; _this$ = ecx

; 2146 :     {

	npad	2
	push	esi
	mov	esi, ecx
	push	edi

; 2147 :         for (int i = 0; i < Items.Size; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+256], edi
	jle	SHORT $LN3@ClearLog
	push	ebx
	mov	ebx, DWORD PTR __imp__free
	npad	9
$LL4@ClearLog:

; 2148 :             free(Items[i]);

	mov	eax, DWORD PTR [esi+264]
	push	DWORD PTR [eax+edi*4]
	call	ebx
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+256]
	jl	SHORT $LL4@ClearLog
	pop	ebx
$LN3@ClearLog:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+264]
	test	eax, eax
	je	SHORT $LN15@ClearLog
	push	eax
	mov	DWORD PTR [esi+260], 0
	mov	DWORD PTR [esi+256], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+264], 0
$LN15@ClearLog:
	pop	edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2150 :         ScrollToBottom = true;

	mov	BYTE PTR [esi+268], 1
	pop	esi

; 2151 :     }

	ret	0
?ClearLog@ExampleAppConsole@@QAEXXZ ENDP		; ExampleAppConsole::ClearLog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Strdup@ExampleAppConsole@@SAPADPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?Strdup@ExampleAppConsole@@SAPADPBD@Z PROC		; ExampleAppConsole::Strdup, COMDAT

; 2143 :     static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _str$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL3@Strdup:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@Strdup
	sub	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	DWORD PTR __imp__malloc
	push	esi
	push	DWORD PTR _str$[ebp]
	push	eax
	call	_memcpy
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	ret	0
?Strdup@ExampleAppConsole@@SAPADPBD@Z ENDP		; ExampleAppConsole::Strdup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Strnicmp@ExampleAppConsole@@SAHPBD0H@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_n$ = 16						; size = 4
?Strnicmp@ExampleAppConsole@@SAHPBD0H@Z PROC		; ExampleAppConsole::Strnicmp, COMDAT

; 2142 :     static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, DWORD PTR _n$[ebp]
	test	edi, edi
	jle	SHORT $LN9@Strnicmp
	mov	eax, DWORD PTR _str2$[ebp]
	push	esi
	mov	esi, DWORD PTR _str1$[ebp]
	sub	eax, esi
	mov	DWORD PTR _str2$[ebp], eax
	push	ebx
	npad	6
$LL2@Strnicmp:
	movsx	eax, BYTE PTR [eax+esi]
	push	eax
	call	DWORD PTR __imp__toupper
	mov	ebx, eax
	movsx	eax, BYTE PTR [esi]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 8
	sub	ebx, eax
	jne	SHORT $LN10@Strnicmp
	cmp	BYTE PTR [esi], bl
	je	SHORT $LN10@Strnicmp
	mov	eax, DWORD PTR _str2$[ebp]
	dec	edi
	inc	esi
	test	edi, edi
	jg	SHORT $LL2@Strnicmp
$LN10@Strnicmp:
	mov	eax, ebx
	pop	ebx
	pop	esi
	pop	edi
	pop	ebp
	ret	0
$LN9@Strnicmp:
	xor	eax, eax
	pop	edi
	pop	ebp
	ret	0
?Strnicmp@ExampleAppConsole@@SAHPBD0H@Z ENDP		; ExampleAppConsole::Strnicmp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Stricmp@ExampleAppConsole@@SAHPBD0@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
?Stricmp@ExampleAppConsole@@SAHPBD0@Z PROC		; ExampleAppConsole::Stricmp, COMDAT

; 2141 :     static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR __imp__toupper
	push	esi
	mov	esi, DWORD PTR _str1$[ebp]
	push	edi
	movsx	eax, BYTE PTR [esi]
	push	eax
	call	ebx
	mov	edi, eax
	mov	eax, DWORD PTR _str2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	ebx
	mov	ebx, eax
	add	esp, 8
	sub	ebx, edi
	jne	SHORT $LN9@Stricmp
	mov	eax, DWORD PTR _str2$[ebp]
	mov	edi, DWORD PTR __imp__toupper
	sub	eax, esi
	mov	DWORD PTR _str2$[ebp], eax
	npad	7
$LL2@Stricmp:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN9@Stricmp
	movsx	eax, BYTE PTR [eax+esi+1]
	inc	esi
	push	eax
	call	edi
	movsx	ecx, BYTE PTR [esi]
	mov	ebx, eax
	push	ecx
	call	edi
	add	esp, 8
	sub	ebx, eax
	mov	eax, DWORD PTR _str2$[ebp]
	je	SHORT $LL2@Stricmp
$LN9@Stricmp:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
?Stricmp@ExampleAppConsole@@SAHPBD0@Z ENDP		; ExampleAppConsole::Stricmp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ??1ExampleAppConsole@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ExampleAppConsole@@QAE@XZ PROC			; ExampleAppConsole::~ExampleAppConsole, COMDAT
; _this$ = ecx

; 2134 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ExampleAppConsole@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 2135 :         ClearLog();

	call	?ClearLog@ExampleAppConsole@@QAEXXZ	; ExampleAppConsole::ClearLog

; 2136 :         for (int i = 0; i < History.Size; i++)

	xor	esi, esi
	cmp	DWORD PTR [edi+272], esi
	jle	SHORT $LN3@ExampleApp
	mov	ebx, DWORD PTR __imp__free
$LL4@ExampleApp:

; 2137 :             free(History[i]);

	mov	eax, DWORD PTR [edi+280]
	push	DWORD PTR [eax+esi*4]
	call	ebx
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR [edi+272]
	jl	SHORT $LL4@ExampleApp
$LN3@ExampleApp:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [edi+296]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN9@ExampleApp
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN9@ExampleApp:
	mov	eax, DWORD PTR [edi+280]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN13@ExampleApp
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN13@ExampleApp:
	mov	eax, DWORD PTR [edi+264]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN17@ExampleApp
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN17@ExampleApp:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2138 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ExampleAppConsole@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ExampleAppConsole@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ExampleAppConsole@@QAE@XZ ENDP			; ExampleAppConsole::~ExampleAppConsole
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ??0ExampleAppConsole@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -16						; size = 4
$T4 = -16						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ExampleAppConsole@@QAE@XZ PROC			; ExampleAppConsole::ExampleAppConsole, COMDAT
; _this$ = ecx

; 2122 :     ExampleAppConsole()

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ExampleAppConsole@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [edi+260], 0
	mov	DWORD PTR [edi+256], 0
	mov	DWORD PTR [edi+264], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2123 :     {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [edi+276], 0
	mov	DWORD PTR [edi+272], 0
	mov	DWORD PTR [edi+280], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2123 :     {

	lea	esi, DWORD PTR [edi+288]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2123 :     {

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2124 :         ClearLog();

	call	?ClearLog@ExampleAppConsole@@QAEXXZ	; ExampleAppConsole::ClearLog

; 2125 :         memset(InputBuf, 0, sizeof(InputBuf));

	push	256					; 00000100H
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH

; 2126 :         HistoryPos = -1;

	mov	DWORD PTR [edi+284], -1

; 2127 :         Commands.push_back("HELP");

	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], OFFSET ??_C@_04DOKPJKJF@HELP?$AA@
	mov	ecx, esi
	push	eax
	call	?push_back@?$ImVector@PBD@@QAEXABQBD@Z	; ImVector<char const *>::push_back

; 2128 :         Commands.push_back("HISTORY");

	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], OFFSET ??_C@_07DBIJIOJO@HISTORY?$AA@
	push	eax
	mov	ecx, esi
	call	?push_back@?$ImVector@PBD@@QAEXABQBD@Z	; ImVector<char const *>::push_back

; 2129 :         Commands.push_back("CLEAR");

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], OFFSET ??_C@_05PONODPI@CLEAR?$AA@
	push	eax
	mov	ecx, esi
	call	?push_back@?$ImVector@PBD@@QAEXABQBD@Z	; ImVector<char const *>::push_back

; 2130 :         Commands.push_back("CLASSIFY");  // "classify" is here to provide an example of "C"+[tab] completing to "CL" and displaying matches.

	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T2[ebp], OFFSET ??_C@_08GOHMLCGG@CLASSIFY?$AA@
	push	eax
	mov	ecx, esi
	call	?push_back@?$ImVector@PBD@@QAEXABQBD@Z	; ImVector<char const *>::push_back

; 2131 :         AddLog("Welcome to ImGui!");

	push	OFFSET ??_C@_0BC@JPCINNJN@Welcome?5to?5ImGui?$CB?$AA@
	push	edi
	call	?AddLog@ExampleAppConsole@@QAAXPBDZZ	; ExampleAppConsole::AddLog

; 2132 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	add	esp, 8
	mov	eax, edi
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ExampleAppConsole@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 256				; 00000100H
	jmp	??1?$ImVector@PAD@@QAE@XZ		; ImVector<char *>::~ImVector<char *>
__unwindfunclet$??0ExampleAppConsole@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	jmp	??1?$ImVector@PAD@@QAE@XZ		; ImVector<char *>::~ImVector<char *>
__unwindfunclet$??0ExampleAppConsole@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	jmp	??1?$ImVector@PBD@@QAE@XZ		; ImVector<char const *>::~ImVector<char const *>
__ehhandler$??0ExampleAppConsole@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0ExampleAppConsole@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ExampleAppConsole@@QAE@XZ ENDP			; ExampleAppConsole::ExampleAppConsole
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PBD@@QAEXABQBD@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@PBD@@QAEXABQBD@Z PROC		; ImVector<char const *>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@PBD@@QAEXABQBD@Z ENDP		; ImVector<char const *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PBD@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PBD@@QAEXH@Z PROC			; ImVector<char const *>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@PBD@@QAEXH@Z ENDP			; ImVector<char const *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PBD@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@PBD@@QAEHH@Z PROC		; ImVector<char const *>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@PBD@@QAEHH@Z ENDP		; ImVector<char const *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@PBD@@QAEAAPBDH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@PBD@@QAEAAPBDH@Z PROC			; ImVector<char const *>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@PBD@@QAEAAPBDH@Z ENDP			; ImVector<char const *>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@PBD@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@PBD@@QAE@XZ PROC				; ImVector<char const *>::~ImVector<char const *>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@PBD@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PBD@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@PBD@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PBD@@QAE@XZ ENDP				; ImVector<char const *>::~ImVector<char const *>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@PBD@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@PBD@@QAE@XZ PROC				; ImVector<char const *>::ImVector<char const *>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@PBD@@QAE@XZ ENDP				; ImVector<char const *>::ImVector<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?erase@?$ImVector@PAD@@QAEPAPADPBQAD@Z
_TEXT	SEGMENT
_it$ = 8						; size = 4
?erase@?$ImVector@PAD@@QAEPAPADPBQAD@Z PROC		; ImVector<char *>::erase, COMDAT
; _this$ = ecx

; 943  :     inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _it$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+8]
	sub	edx, eax
	sar	edx, 2
	lea	esi, DWORD PTR [edx*4]
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edi]
	sub	eax, edx
	lea	eax, DWORD PTR [eax*4-4]
	push	eax
	lea	eax, DWORD PTR [ecx+4]
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	dec	DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [edi+8]
	add	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?erase@?$ImVector@PAD@@QAEPAPADPBQAD@Z ENDP		; ImVector<char *>::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PAD@@QAEXABQAD@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@PAD@@QAEXABQAD@Z PROC		; ImVector<char *>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@PAD@@QAEXABQAD@Z ENDP		; ImVector<char *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PAD@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PAD@@QAEXH@Z PROC			; ImVector<char *>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@PAD@@QAEXH@Z ENDP			; ImVector<char *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PAD@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@PAD@@QAEHH@Z PROC		; ImVector<char *>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@PAD@@QAEHH@Z ENDP		; ImVector<char *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?begin@?$ImVector@PAD@@QAEPAPADXZ
_TEXT	SEGMENT
?begin@?$ImVector@PAD@@QAEPAPADXZ PROC			; ImVector<char *>::begin, COMDAT
; _this$ = ecx

; 916  :     inline iterator             begin()                         { return Data; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?begin@?$ImVector@PAD@@QAEPAPADXZ ENDP			; ImVector<char *>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PAD@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@PAD@@QAEXXZ PROC			; ImVector<char *>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@PAD@@QAEXXZ ENDP			; ImVector<char *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@PAD@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@PAD@@QAEAAPADH@Z PROC			; ImVector<char *>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@PAD@@QAEAAPADH@Z ENDP			; ImVector<char *>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAD@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAD@@QAE@XZ PROC				; ImVector<char *>::~ImVector<char *>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@PAD@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAD@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@PAD@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAD@@QAE@XZ ENDP				; ImVector<char *>::~ImVector<char *>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAD@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@PAD@@QAE@XZ PROC				; ImVector<char *>::ImVector<char *>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@PAD@@QAE@XZ ENDP				; ImVector<char *>::ImVector<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ PROC ; `ShowExampleAppCustomRendering'::`9'::`dynamic atexit destructor for 'points'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A+8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@dynamic:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ ENDP ; `ShowExampleAppCustomRendering'::`9'::`dynamic atexit destructor for 'points''
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Step@CustomConstraints@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@SAXPAUImGuiSizeConstraintCallbackData@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_data$ = 8						; size = 4
?Step@CustomConstraints@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@SAXPAUImGuiSizeConstraintCallbackData@@@Z PROC ; `ShowExampleAppConstrainedResize'::`2'::CustomConstraints::Step, COMDAT

; 1937 :         static void Step(ImGuiSizeConstraintCallbackData* data)   { float step = (float)(int)(intptr_t)data->UserData; data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step); }

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, DWORD PTR _data$[ebp]
	movss	xmm2, DWORD PTR __real@3f800000
	movd	xmm3, DWORD PTR [ecx]
	cvtdq2ps xmm3, xmm3
	movss	xmm0, DWORD PTR [ecx+20]
	divss	xmm2, xmm3
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1937 :         static void Step(ImGuiSizeConstraintCallbackData* data)   { float step = (float)(int)(intptr_t)data->UserData; data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step); }

	movss	xmm0, DWORD PTR [ecx+24]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movd	xmm0, eax
	mov	eax, DWORD PTR $T1[ebp]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [ecx+20], eax
	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1937 :         static void Step(ImGuiSizeConstraintCallbackData* data)   { float step = (float)(int)(intptr_t)data->UserData; data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step); }

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+24], eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Step@CustomConstraints@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@SAXPAUImGuiSizeConstraintCallbackData@@@Z ENDP ; `ShowExampleAppConstrainedResize'::`2'::CustomConstraints::Step
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Square@CustomConstraints@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@SAXPAUImGuiSizeConstraintCallbackData@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_data$ = 8						; size = 4
?Square@CustomConstraints@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@SAXPAUImGuiSizeConstraintCallbackData@@@Z PROC ; `ShowExampleAppConstrainedResize'::`2'::CustomConstraints::Square, COMDAT

; 1936 :         static void Square(ImGuiSizeConstraintCallbackData* data) { data->DesiredSize = ImVec2(IM_MAX(data->DesiredSize.x, data->DesiredSize.y), IM_MAX(data->DesiredSize.x, data->DesiredSize.y)); }

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+24]
	maxss	xmm0, DWORD PTR [ecx+20]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1936 :         static void Square(ImGuiSizeConstraintCallbackData* data) { data->DesiredSize = ImVec2(IM_MAX(data->DesiredSize.x, data->DesiredSize.y), IM_MAX(data->DesiredSize.x, data->DesiredSize.y)); }

	mov	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1936 :         static void Square(ImGuiSizeConstraintCallbackData* data) { data->DesiredSize = ImVec2(IM_MAX(data->DesiredSize.x, data->DesiredSize.y), IM_MAX(data->DesiredSize.x, data->DesiredSize.y)); }

	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+24], eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Square@CustomConstraints@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@SAXPAUImGuiSizeConstraintCallbackData@@@Z ENDP ; `ShowExampleAppConstrainedResize'::`2'::CustomConstraints::Square
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ PROC ; `ImGui::ShowStyleEditor'::`20'::`dynamic atexit destructor for 'filter'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR ?filter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4UImGuiTextFilter@@A+264
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN7@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN7@dynamic:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ ENDP ; `ImGui::ShowStyleEditor'::`20'::`dynamic atexit destructor for 'filter''
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ PROC ; `ImGui::ShowTestWindow'::`483'::`dynamic atexit destructor for 'filter'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR ?filter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImGuiTextFilter@@A+264
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN7@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN7@dynamic:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ ENDP ; `ImGui::ShowTestWindow'::`483'::`dynamic atexit destructor for 'filter''
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Saw@Funcs@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAMPAXH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
tv66 = 12						; size = 4
_i$ = 12						; size = 4
?Saw@Funcs@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAMPAXH@Z PROC ; `ImGui::ShowTestWindow'::`252'::Funcs::Saw, COMDAT

; 802  :             static float Saw(void*, int i) { return (i & 1) ? 1.0f : -1.0f; }

	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR _i$[ebp], 1
	mov	DWORD PTR tv66[ebp], 1065353216		; 3f800000H
	jne	SHORT $LN5@Saw
	mov	DWORD PTR tv66[ebp], -1082130432	; bf800000H
$LN5@Saw:
	fld	DWORD PTR tv66[ebp]
	pop	ebp
	ret	0
?Saw@Funcs@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAMPAXH@Z ENDP ; `ImGui::ShowTestWindow'::`252'::Funcs::Saw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?Sin@Funcs@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAMPAXH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
tv69 = 12						; size = 4
_i$ = 12						; size = 4
?Sin@Funcs@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAMPAXH@Z PROC ; `ImGui::ShowTestWindow'::`252'::Funcs::Sin, COMDAT

; 801  :             static float Sin(void*, int i) { return sinf(i * 0.1f); }

	npad	2
	push	ebp
	mov	ebp, esp
	movd	xmm0, DWORD PTR _i$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@3dcccccd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	call	___libm_sse2_sinf
	movss	DWORD PTR tv69[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 801  :             static float Sin(void*, int i) { return sinf(i * 0.1f); }

	fld	DWORD PTR tv69[ebp]
	pop	ebp
	ret	0
?Sin@Funcs@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAMPAXH@Z ENDP ; `ImGui::ShowTestWindow'::`252'::Funcs::Sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
;	COMDAT ?FilterImGuiLetters@TextFilters@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAHPAUImGuiTextEditCallbackData@@@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?FilterImGuiLetters@TextFilters@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAHPAUImGuiTextEditCallbackData@@@Z PROC ; `ImGui::ShowTestWindow'::`202'::TextFilters::FilterImGuiLetters, COMDAT

; 501  :             struct TextFilters { static int FilterImGuiLetters(ImGuiTextEditCallbackData* data) { if (data->EventChar < 256 && strchr("imgui", (char)data->EventChar)) return 0; return 1; } };

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, 256				; 00000100H
	cmp	WORD PTR [eax+14], cx
	jae	SHORT $LN2@FilterImGu
	movsx	eax, BYTE PTR [eax+14]
	push	eax
	push	OFFSET ??_C@_05EAJAAGNN@imgui?$AA@
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@FilterImGu
	xor	eax, eax
	pop	ebp
	ret	0
$LN2@FilterImGu:
	mov	eax, 1
	pop	ebp
	ret	0
?FilterImGuiLetters@TextFilters@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAHPAUImGuiTextEditCallbackData@@@Z ENDP ; `ImGui::ShowTestWindow'::`202'::TextFilters::FilterImGuiLetters
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_desc$ = 8						; size = 4
?ShowHelpMarker@@YAXPBD@Z PROC				; ShowHelpMarker

; 76   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 77   :     ImGui::TextDisabled("(?)");

	push	OFFSET $SG10305
	call	?TextDisabled@ImGui@@YAXPBDZZ		; ImGui::TextDisabled
	add	esp, 4

; 78   :     if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN2@ShowHelpMa

; 79   :     {
; 80   :         ImGui::BeginTooltip();

	call	?BeginTooltip@ImGui@@YAXXZ		; ImGui::BeginTooltip

; 81   :         ImGui::PushTextWrapPos(450.0f);

	push	ecx
	mov	DWORD PTR [esp], 1138819072		; 43e10000H
	call	?PushTextWrapPos@ImGui@@YAXM@Z		; ImGui::PushTextWrapPos

; 82   :         ImGui::TextUnformatted(desc);

	push	0
	push	DWORD PTR _desc$[ebp]
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 12					; 0000000cH

; 83   :         ImGui::PopTextWrapPos();

	call	?PopTextWrapPos@ImGui@@YAXXZ		; ImGui::PopTextWrapPos

; 85   :     }
; 86   : }

	pop	ebp

; 84   :         ImGui::EndTooltip();

	jmp	?EndTooltip@ImGui@@YAXXZ		; ImGui::EndTooltip
$LN2@ShowHelpMa:

; 85   :     }
; 86   : }

	pop	ebp
	ret	0
?ShowHelpMarker@@YAXPBD@Z ENDP				; ShowHelpMarker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
?ShowExampleMenuFile@@YAXXZ PROC			; ShowExampleMenuFile

; 1858 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1859 :     ImGui::MenuItem("(dummy menu)", NULL, false, false);

	push	0
	push	0
	push	0
	push	OFFSET $SG12148
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1860 :     if (ImGui::MenuItem("New")) {}

	push	1
	push	0
	push	0
	push	OFFSET $SG12150
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1861 :     if (ImGui::MenuItem("Open", "Ctrl+O")) {}

	push	1
	push	0
	push	OFFSET $SG12152
	push	OFFSET $SG12153
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1862 :     if (ImGui::BeginMenu("Open Recent"))

	push	1
	push	OFFSET $SG12155
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 56					; 00000038H
	test	al, al
	je	$LN10@ShowExampl

; 1863 :     {
; 1864 :         ImGui::MenuItem("fish_hat.c");

	push	1
	push	0
	push	0
	push	OFFSET $SG12156
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1865 :         ImGui::MenuItem("fish_hat.inl");

	push	1
	push	0
	push	0
	push	OFFSET $SG12157
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1866 :         ImGui::MenuItem("fish_hat.h");

	push	1
	push	0
	push	0
	push	OFFSET $SG12158
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1867 :         if (ImGui::BeginMenu("More.."))

	push	1
	push	OFFSET $SG12160
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 56					; 00000038H
	test	al, al
	je	SHORT $LN11@ShowExampl

; 1868 :         {
; 1869 :             ImGui::MenuItem("Hello");

	push	1
	push	0
	push	0
	push	OFFSET $SG12161
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1870 :             ImGui::MenuItem("Sailor");

	push	1
	push	0
	push	0
	push	OFFSET $SG12162
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1871 :             if (ImGui::BeginMenu("Recurse.."))

	push	1
	push	OFFSET $SG12164
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 40					; 00000028H
	test	al, al
	je	SHORT $LN12@ShowExampl

; 1872 :             {
; 1873 :                 ShowExampleMenuFile();

	call	?ShowExampleMenuFile@@YAXXZ		; ShowExampleMenuFile

; 1874 :                 ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN12@ShowExampl:

; 1875 :             }
; 1876 :             ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN11@ShowExampl:

; 1877 :         }
; 1878 :         ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN10@ShowExampl:
	push	esi

; 1879 :     }
; 1880 :     if (ImGui::MenuItem("Save", "Ctrl+S")) {}

	push	1
	push	0
	push	OFFSET $SG12166
	push	OFFSET $SG12167
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1881 :     if (ImGui::MenuItem("Save As..")) {}

	push	1
	push	0
	push	0
	push	OFFSET $SG12169
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1882 :     ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1883 :     if (ImGui::BeginMenu("Options"))

	push	1
	push	OFFSET $SG12171
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 40					; 00000028H
	test	al, al
	je	$LN15@ShowExampl

; 1884 :     {
; 1885 :         static bool enabled = true;
; 1886 :         ImGui::MenuItem("Enabled", "", &enabled);

	push	1
	push	OFFSET ?enabled@?BK@??ShowExampleMenuFile@@YAXXZ@4_NA
	push	OFFSET $SG12172
	push	OFFSET $SG12173
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 1887 :         ImGui::BeginChild("child", ImVec2(0, 60), true);

	push	0
	push	1
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1887 :         ImGui::BeginChild("child", ImVec2(0, 60), true);

	push	eax
	push	OFFSET $SG12174
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 1114636288	; 42700000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1887 :         ImGui::BeginChild("child", ImVec2(0, 60), true);

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild
	add	esp, 32					; 00000020H

; 1888 :         for (int i = 0; i < 10; i++)

	xor	esi, esi
	npad	9
$LL4@ShowExampl:

; 1889 :             ImGui::Text("Scrolling Text %d", i);

	push	esi
	push	OFFSET $SG12175
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	inc	esi
	add	esp, 8
	cmp	esi, 10					; 0000000aH
	jl	SHORT $LL4@ShowExampl

; 1890 :         ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 1891 :         static float f = 0.5f;
; 1892 :         static int n = 0;
; 1893 :         static bool b = true;
; 1894 :         ImGui::SliderFloat("Value", &f, 0.0f, 1.0f);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12176
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	OFFSET ?f@?BK@??ShowExampleMenuFile@@YAXXZ@4MA
	push	OFFSET $SG12177
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat
	add	esp, 24					; 00000018H

; 1895 :         ImGui::InputFloat("Input", &f, 0.1f);

	push	0
	push	-1
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1036831949		; 3dcccccdH
	push	OFFSET ?f@?BK@??ShowExampleMenuFile@@YAXXZ@4MA
	push	OFFSET $SG12178
	call	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z	; ImGui::InputFloat

; 1896 :         ImGui::Combo("Combo", &n, "Yes\0No\0Maybe\0\0");

	push	-1
	push	OFFSET $SG12179
	push	OFFSET ?n@?BK@??ShowExampleMenuFile@@YAXXZ@4HA
	push	OFFSET $SG12180
	call	?Combo@ImGui@@YA_NPBDPAH0H@Z		; ImGui::Combo

; 1897 :         ImGui::Checkbox("Check", &b);

	push	OFFSET ?b@?BK@??ShowExampleMenuFile@@YAXXZ@4_NA
	push	OFFSET $SG12181
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 48					; 00000030H

; 1898 :         ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN15@ShowExampl:

; 1899 :     }
; 1900 :     if (ImGui::BeginMenu("Colors"))

	push	1
	push	OFFSET $SG12183
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	SHORT $LN16@ShowExampl

; 1901 :     {
; 1902 :         for (int i = 0; i < ImGuiCol_COUNT; i++)

	xor	esi, esi
$LL7@ShowExampl:

; 1903 :             ImGui::MenuItem(ImGui::GetStyleColName((ImGuiCol)i));

	push	1
	push	0
	push	0
	push	esi
	call	?GetStyleColName@ImGui@@YAPBDH@Z	; ImGui::GetStyleColName
	add	esp, 4
	push	eax
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, 45					; 0000002dH
	jl	SHORT $LL7@ShowExampl

; 1904 :         ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN16@ShowExampl:

; 1905 :     }
; 1906 :     if (ImGui::BeginMenu("Disabled", false)) // Disabled

	push	0
	push	OFFSET $SG12185
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu

; 1907 :     {
; 1908 :         IM_ASSERT(0);
; 1909 :     }
; 1910 :     if (ImGui::MenuItem("Checked", NULL, true)) {}

	push	1
	push	1
	push	0
	push	OFFSET $SG12187
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1911 :     if (ImGui::MenuItem("Quit", "Alt+F4")) {}

	push	1
	push	0
	push	OFFSET $SG12189
	push	OFFSET $SG12190
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem
	add	esp, 40					; 00000028H
	pop	esi

; 1912 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowExampleMenuFile@@YAXXZ ENDP			; ShowExampleMenuFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
?ShowExampleAppMainMenuBar@@YAXXZ PROC			; ShowExampleAppMainMenuBar

; 1836 :     if (ImGui::BeginMainMenuBar())

	call	?BeginMainMenuBar@ImGui@@YA_NXZ		; ImGui::BeginMainMenuBar
	test	al, al
	je	$LN2@ShowExampl

; 1837 :     {
; 1838 :         if (ImGui::BeginMenu("File"))

	push	1
	push	OFFSET $SG12109
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	SHORT $LN3@ShowExampl

; 1839 :         {
; 1840 :             ShowExampleMenuFile();

	call	?ShowExampleMenuFile@@YAXXZ		; ShowExampleMenuFile

; 1841 :             ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN3@ShowExampl:

; 1842 :         }
; 1843 :         if (ImGui::BeginMenu("Edit"))

	push	1
	push	OFFSET $SG12111
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	SHORT $LN4@ShowExampl

; 1844 :         {
; 1845 :             if (ImGui::MenuItem("Undo", "CTRL+Z")) {}

	push	1
	push	0
	push	OFFSET $SG12113
	push	OFFSET $SG12114
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1846 :             if (ImGui::MenuItem("Redo", "CTRL+Y", false, false)) {}  // Disabled item

	push	0
	push	0
	push	OFFSET $SG12116
	push	OFFSET $SG12117
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1847 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1848 :             if (ImGui::MenuItem("Cut", "CTRL+X")) {}

	push	1
	push	0
	push	OFFSET $SG12119
	push	OFFSET $SG12120
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1849 :             if (ImGui::MenuItem("Copy", "CTRL+C")) {}

	push	1
	push	0
	push	OFFSET $SG12122
	push	OFFSET $SG12123
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem
	add	esp, 64					; 00000040H

; 1850 :             if (ImGui::MenuItem("Paste", "CTRL+V")) {}

	push	1
	push	0
	push	OFFSET $SG12125
	push	OFFSET $SG12126
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem
	add	esp, 16					; 00000010H

; 1851 :             ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN4@ShowExampl:

; 1852 :         }
; 1853 :         ImGui::EndMainMenuBar();

	jmp	?EndMainMenuBar@ImGui@@YAXXZ		; ImGui::EndMainMenuBar
$LN2@ShowExampl:

; 1854 :     }
; 1855 : }

	ret	0
?ShowExampleAppMainMenuBar@@YAXXZ ENDP			; ShowExampleAppMainMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
$T1 = -232						; size = 16
$T2 = -224						; size = 8
$T3 = -216						; size = 8
$T4 = -208						; size = 8
$T5 = -200						; size = 8
$T6 = -192						; size = 8
$T7 = -184						; size = 8
$T8 = -176						; size = 8
$T9 = -168						; size = 8
$T10 = -160						; size = 8
$T11 = -152						; size = 8
$T12 = -144						; size = 8
$T13 = -136						; size = 8
$T14 = -128						; size = 8
$T15 = -120						; size = 16
$T16 = -120						; size = 16
$T17 = -112						; size = 8
$T18 = -104						; size = 16
$T19 = -104						; size = 16
$T20 = -96						; size = 8
$T21 = -88						; size = 16
$T22 = -88						; size = 16
$T23 = -80						; size = 8
$T24 = -80						; size = 8
_draw_list$1$ = -72					; size = 4
$T25 = -68						; size = 16
$T26 = -68						; size = 16
$T27 = -60						; size = 8
$T28 = -60						; size = 8
$T29 = -60						; size = 8
$T30 = -60						; size = 8
$T31 = -60						; size = 8
$T32 = -60						; size = 8
$T33 = -52						; size = 8
_mouse_pos_in_canvas$34 = -52				; size = 8
_p$35 = -52						; size = 8
$T36 = -52						; size = 8
_canvas_pos$37 = -44					; size = 8
tv1580 = -40						; size = 4
_thickness$1$ = -36					; size = 4
$T38 = -32						; size = 16
$T39 = -24						; size = 8
$T40 = -24						; size = 8
$T41 = -24						; size = 8
$T42 = -24						; size = 8
$T43 = -24						; size = 8
$T44 = -24						; size = 8
$T45 = -24						; size = 8
$T46 = -24						; size = 8
$T47 = -24						; size = 8
$T48 = -24						; size = 8
$T49 = -24						; size = 8
$T50 = -24						; size = 8
_y$1$ = -16						; size = 4
_canvas_size$51 = -12					; size = 8
_x$12$ = -8						; size = 4
_x$11$ = -8						; size = 4
_x$10$ = -8						; size = 4
_x$9$ = -8						; size = 4
_x$8$ = -8						; size = 4
_x$7$ = -8						; size = 4
_x$5$ = -8						; size = 4
_x$4$ = -8						; size = 4
_x$3$ = -8						; size = 4
_x$2$ = -8						; size = 4
_x$1$ = -8						; size = 4
_adding_preview$1$ = -1					; size = 1
_p_open$ = 8						; size = 4
?ShowExampleAppCustomRendering@@YAXPA_N@Z PROC		; ShowExampleAppCustomRendering

; 2013 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H

; 2014 :     ImGui::SetNextWindowSize(ImVec2(350,560), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T36[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T36[ebp], 1135542272		; 43af0000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2014 :     ImGui::SetNextWindowSize(ImVec2(350,560), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T36[ebp+4], 1141637120	; 440c0000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2014 :     ImGui::SetNextWindowSize(ImVec2(350,560), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 2015 :     if (!ImGui::Begin("Example: Custom rendering", p_open))

	push	0
	push	DWORD PTR _p_open$[ebp]
	push	OFFSET $SG12403
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN21@ShowExampl

; 2016 :     {
; 2017 :         ImGui::End();
; 2018 :         return;
; 2019 :     }
; 2020 : 
; 2021 :     // Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of overloaded operators, etc.
; 2022 :     // Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your types and ImVec2/ImVec4.
; 2023 :     // ImGui defines overloaded operators but they are internal to imgui.cpp and not exposed outside (to avoid messing with your types)
; 2024 :     // In this example we are not using the maths operators!
; 2025 :     ImDrawList* draw_list = ImGui::GetWindowDrawList();

	push	ebx
	push	esi
	push	edi
	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	ebx, eax

; 2026 : 
; 2027 :     // Primitives
; 2028 :     ImGui::Text("Primitives");

	push	OFFSET $SG12404
	mov	DWORD PTR _draw_list$1$[ebp], ebx
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 2029 :     static float sz = 36.0f;
; 2030 :     static ImVec4 col = ImVec4(1.0f,1.0f,0.4f,1.0f);

	mov	edx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array

; 2031 :     ImGui::DragFloat("Size", &sz, 0.2f, 2.0f, 72.0f, "%.0f");

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12405
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv1580[ebp], eax
	mov	DWORD PTR [esp+8], 1116733440		; 42900000H
	mov	DWORD PTR [esp+4], 1073741824		; 40000000H
	mov	DWORD PTR [esp], 1045220557		; 3e4ccccdH
	push	OFFSET ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA
	push	OFFSET $SG12406
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 2032 :     ImGui::ColorEdit3("Color", &col.x);

	push	OFFSET ?col@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4UImVec4@@A
	push	OFFSET $SG12407
	call	?ColorEdit3@ImGui@@YA_NPBDQAM@Z		; ImGui::ColorEdit3

; 2033 :     {
; 2034 :         const ImVec2 p = ImGui::GetCursorScreenPos();

	lea	eax, DWORD PTR _p$35[ebp]
	push	eax
	call	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos
	movups	xmm0, XMMWORD PTR ?col@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4UImVec4@@A
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	eax, DWORD PTR $T38[ebp]
	push	eax
	movups	XMMWORD PTR $T38[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2036 :         float x = p.x + 4.0f, y = p.y + 4.0f, spacing = 8.0f;

	movss	xmm1, DWORD PTR __real@40800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	add	esp, 44					; 0000002cH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2036 :         float x = p.x + 4.0f, y = p.y + 4.0f, spacing = 8.0f;

	movss	xmm4, DWORD PTR _p$35[ebp]
	mov	edi, eax
	movss	xmm3, DWORD PTR _p$35[ebp+4]
	addss	xmm4, xmm1

; 2037 :         for (int n = 0; n < 2; n++)

	movss	xmm5, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA
	addss	xmm3, xmm1
	xor	esi, esi
	movss	DWORD PTR _x$8$[ebp], xmm4
	movss	DWORD PTR _y$1$[ebp], xmm3
	npad	4
$LL5@ShowExampl:

; 2038 :         {
; 2039 :             float thickness = (n == 0) ? 1.0f : 4.0f;

	test	esi, esi
	jne	SHORT $LN23@ShowExampl
	movss	xmm2, DWORD PTR __real@3f800000
	jmp	SHORT $LN220@ShowExampl
$LN23@ShowExampl:
	movaps	xmm2, xmm1
$LN220@ShowExampl:

; 2040 :             draw_list->AddCircle(ImVec2(x+sz*0.5f, y+sz*0.5f), sz*0.5f, col32, 20, thickness); x += sz+spacing;

	mulss	xmm5, DWORD PTR __real@3f000000
	lea	eax, DWORD PTR $T14[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm2
	push	20					; 00000014H
	movaps	xmm1, xmm5
	movss	DWORD PTR _thickness$1$[ebp], xmm2
	movaps	xmm0, xmm5
	addss	xmm1, xmm4
	push	edi
	addss	xmm0, xmm3
	push	ecx
	movss	DWORD PTR [esp], xmm5
	mov	ecx, ebx
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T14[ebp], xmm1
	movss	DWORD PTR $T14[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2040 :             draw_list->AddCircle(ImVec2(x+sz*0.5f, y+sz*0.5f), sz*0.5f, col32, 20, thickness); x += sz+spacing;

	call	?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle
	movss	xmm1, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2041 :             draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 0.0f, ~0, thickness); x += sz+spacing;

	lea	eax, DWORD PTR $T13[ebp]
	movss	xmm3, DWORD PTR _y$1$[ebp]
	movaps	xmm2, xmm1
	addss	xmm2, DWORD PTR __real@41000000
	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T12[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2041 :             draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 0.0f, ~0, thickness); x += sz+spacing;

	push	ecx
	addss	xmm1, xmm3
	addss	xmm2, DWORD PTR _x$8$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T13[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2041 :             draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 0.0f, ~0, thickness); x += sz+spacing;

	addss	xmm0, xmm2
	movss	DWORD PTR _x$1$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T12[ebp], xmm2
	movss	DWORD PTR $T13[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2041 :             draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 0.0f, ~0, thickness); x += sz+spacing;

	movss	xmm0, DWORD PTR _thickness$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	-1
	push	ecx
	mov	DWORD PTR [esp], 0
	mov	ecx, ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	movss	xmm1, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2042 :             draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ~0, thickness); x += sz+spacing;

	lea	eax, DWORD PTR $T11[ebp]
	movss	xmm3, DWORD PTR _y$1$[ebp]
	movaps	xmm2, xmm1
	addss	xmm2, DWORD PTR __real@41000000
	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2042 :             draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ~0, thickness); x += sz+spacing;

	push	ecx
	addss	xmm1, xmm3
	addss	xmm2, DWORD PTR _x$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2042 :             draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ~0, thickness); x += sz+spacing;

	addss	xmm0, xmm2
	movss	DWORD PTR _x$2$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm2
	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2042 :             draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ~0, thickness); x += sz+spacing;

	movss	xmm0, DWORD PTR _thickness$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	-1
	push	ecx
	mov	DWORD PTR [esp], 1092616192		; 41200000H
	mov	ecx, ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	movss	xmm2, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2043 :             draw_list->AddTriangle(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32, thickness); x += sz+spacing;

	movss	xmm4, DWORD PTR _y$1$[ebp]
	movaps	xmm3, xmm2
	addss	xmm3, DWORD PTR __real@41000000
	movaps	xmm1, xmm2
	addss	xmm1, xmm4
	addss	xmm3, DWORD PTR _x$2$[ebp]
	subss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR _x$3$[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm3
	movss	DWORD PTR $T9[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2043 :             draw_list->AddTriangle(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32, thickness); x += sz+spacing;

	movaps	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2043 :             draw_list->AddTriangle(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32, thickness); x += sz+spacing;

	mulss	xmm2, DWORD PTR __real@3f000000
	addss	xmm0, xmm3
	push	ecx
	lea	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2043 :             draw_list->AddTriangle(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32, thickness); x += sz+spacing;

	mov	ecx, ebx
	addss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2043 :             draw_list->AddTriangle(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32, thickness); x += sz+spacing;

	movss	xmm0, DWORD PTR _thickness$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2043 :             draw_list->AddTriangle(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32, thickness); x += sz+spacing;

	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z ; ImDrawList::AddTriangle
	movss	xmm0, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2044 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y   ), col32, thickness); x += sz+spacing;

	lea	eax, DWORD PTR $T6[ebp]
	movaps	xmm1, xmm0
	addss	xmm1, DWORD PTR __real@41000000
	push	ecx
	mov	ecx, ebx
	addss	xmm1, DWORD PTR _x$3$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _x$4$[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm1
	movss	DWORD PTR $T6[ebp], xmm0
	movss	xmm0, DWORD PTR _y$1$[ebp]
	movss	DWORD PTR $T6[ebp+4], xmm0
	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2044 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y   ), col32, thickness); x += sz+spacing;

	movss	xmm0, DWORD PTR _thickness$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
	movss	xmm1, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2045 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, thickness); x += sz+spacing;

	lea	eax, DWORD PTR $T4[ebp]
	movss	xmm3, DWORD PTR _y$1$[ebp]
	movaps	xmm2, xmm1
	addss	xmm2, DWORD PTR __real@41000000
	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2045 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, thickness); x += sz+spacing;

	push	ecx
	addss	xmm1, xmm3
	mov	ecx, ebx
	addss	xmm2, DWORD PTR _x$4$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2045 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, thickness); x += sz+spacing;

	addss	xmm0, xmm2
	movss	DWORD PTR _x$5$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm2
	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2045 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, thickness); x += sz+spacing;

	movss	xmm0, DWORD PTR _thickness$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
	movss	xmm0, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2046 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x,    y+sz), col32, thickness); x += spacing;

	lea	eax, DWORD PTR $T2[ebp]
	movss	xmm2, DWORD PTR _y$1$[ebp]
	movaps	xmm1, xmm0
	addss	xmm1, DWORD PTR __real@41000000
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T20[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2046 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x,    y+sz), col32, thickness); x += spacing;

	push	ecx
	addss	xmm1, DWORD PTR _x$5$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2046 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x,    y+sz), col32, thickness); x += spacing;

	movss	xmm0, DWORD PTR _thickness$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	edi
	movss	DWORD PTR _x$7$[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm1
	movss	DWORD PTR $T20[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2046 :             draw_list->AddLine(ImVec2(x, y), ImVec2(x,    y+sz), col32, thickness); x += spacing;

	push	eax
	lea	eax, DWORD PTR $T20[ebp]
	mov	ecx, ebx
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
	movss	xmm4, DWORD PTR _x$7$[ebp]

; 2047 :             draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, thickness);

	lea	eax, DWORD PTR $T17[ebp]
	addss	xmm4, DWORD PTR __real@41000000
	movss	xmm3, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA
	movss	xmm5, DWORD PTR _y$1$[ebp]
	movaps	xmm2, xmm3
	movaps	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T50[ebp+4], xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2047 :             draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, thickness);

	mulss	xmm0, DWORD PTR __real@3fa66666
	movaps	xmm1, xmm3
	push	0
	mulss	xmm3, DWORD PTR __real@3e99999a
	addss	xmm2, xmm4
	push	ecx
	addss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T50[ebp], xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2047 :             draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, thickness);

	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T17[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2047 :             draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, thickness);

	subss	xmm2, xmm0
	addss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T17[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2047 :             draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, thickness);

	subss	xmm1, xmm3
	addss	xmm3, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T24[ebp], xmm2
	movss	DWORD PTR $T32[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2047 :             draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, thickness);

	movss	xmm0, DWORD PTR _thickness$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	eax
	lea	eax, DWORD PTR $T24[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T24[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2047 :             draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, thickness);

	push	eax
	lea	eax, DWORD PTR $T32[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T32[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2047 :             draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, thickness);

	push	eax
	lea	eax, DWORD PTR $T50[ebp]
	push	eax
	call	?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z ; ImDrawList::AddBezierCurve

; 2048 :             x = p.x + 4;
; 2049 :             y += sz+spacing;

	movss	xmm5, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA
	inc	esi
	movss	xmm2, DWORD PTR __real@41000000
	movaps	xmm0, xmm5
	movss	xmm3, DWORD PTR _y$1$[ebp]
	addss	xmm0, xmm2
	movss	xmm4, DWORD PTR _p$35[ebp]
	movss	xmm1, DWORD PTR __real@40800000
	addss	xmm4, xmm1
	addss	xmm3, xmm0
	movss	DWORD PTR _x$8$[ebp], xmm4
	movss	DWORD PTR _y$1$[ebp], xmm3
	cmp	esi, 2
	jl	$LL5@ShowExampl

; 2051 :         draw_list->AddCircleFilled(ImVec2(x+sz*0.5f, y+sz*0.5f), sz*0.5f, col32, 32); x += sz+spacing;

	mulss	xmm5, DWORD PTR __real@3f000000
	lea	eax, DWORD PTR $T49[ebp]
	push	32					; 00000020H
	push	edi
	push	ecx
	movaps	xmm1, xmm5
	movss	DWORD PTR [esp], xmm5
	movaps	xmm0, xmm5
	addss	xmm1, xmm4
	addss	xmm0, xmm3
	mov	ecx, ebx
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T49[ebp], xmm1
	movss	DWORD PTR $T49[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2051 :         draw_list->AddCircleFilled(ImVec2(x+sz*0.5f, y+sz*0.5f), sz*0.5f, col32, 32); x += sz+spacing;

	call	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	movss	xmm1, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2052 :         draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32); x += sz+spacing;

	lea	eax, DWORD PTR $T48[ebp]
	movss	xmm4, DWORD PTR _y$1$[ebp]
	movaps	xmm2, xmm1
	addss	xmm2, DWORD PTR __real@41000000
	push	-1
	push	ecx
	movaps	xmm0, xmm1
	mov	DWORD PTR [esp], 0
	push	edi
	addss	xmm2, DWORD PTR _x$8$[ebp]
	addss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T31[ebp+4], xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2052 :         draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32); x += sz+spacing;

	push	eax
	lea	eax, DWORD PTR $T31[ebp]
	mov	ecx, ebx
	push	eax
	addss	xmm0, xmm2
	movss	DWORD PTR _x$9$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T48[ebp+4], xmm1
	movss	DWORD PTR $T31[ebp], xmm2
	movss	DWORD PTR $T48[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2052 :         draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32); x += sz+spacing;

	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	movss	xmm1, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2053 :         draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f); x += sz+spacing;

	lea	eax, DWORD PTR $T47[ebp]
	movss	xmm3, DWORD PTR _y$1$[ebp]
	movaps	xmm2, xmm1
	addss	xmm2, DWORD PTR __real@41000000
	push	-1
	push	ecx
	movaps	xmm0, xmm1
	mov	DWORD PTR [esp], 1092616192		; 41200000H
	push	edi
	addss	xmm2, DWORD PTR _x$9$[ebp]
	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T30[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2053 :         draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f); x += sz+spacing;

	push	eax
	lea	eax, DWORD PTR $T30[ebp]
	mov	ecx, ebx
	push	eax
	addss	xmm0, xmm2
	movss	DWORD PTR _x$10$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T47[ebp+4], xmm1
	movss	DWORD PTR $T30[ebp], xmm2
	movss	DWORD PTR $T47[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2053 :         draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f); x += sz+spacing;

	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	movss	xmm2, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA

; 2054 :         draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32); x += sz+spacing;

	movss	xmm4, DWORD PTR _y$1$[ebp]
	movaps	xmm3, xmm2
	addss	xmm3, DWORD PTR __real@41000000
	movaps	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T23[ebp+4], xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2054 :         draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32); x += sz+spacing;

	movaps	xmm0, xmm2
	addss	xmm1, xmm4
	mulss	xmm2, DWORD PTR __real@3f000000
	push	edi
	addss	xmm3, DWORD PTR _x$10$[ebp]
	subss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm3
	movss	DWORD PTR _x$11$[ebp], xmm3
	addss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T46[ebp], xmm3
	movss	DWORD PTR $T46[ebp+4], xmm1
	movss	DWORD PTR $T29[ebp+4], xmm1
	movss	DWORD PTR $T29[ebp], xmm0
	movss	DWORD PTR $T23[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2054 :         draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32); x += sz+spacing;

	lea	eax, DWORD PTR $T46[ebp]
	mov	ecx, ebx
	push	eax
	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	lea	eax, DWORD PTR $T23[ebp]
	push	eax
	call	?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
	movss	xmm0, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	eax, DWORD PTR $T22[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2054 :         draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32); x += sz+spacing;

	addss	xmm0, DWORD PTR __real@41000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	push	eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2054 :         draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32); x += sz+spacing;

	addss	xmm0, DWORD PTR _x$11$[ebp]
	movss	DWORD PTR _x$12$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f80000000000000
	movups	XMMWORD PTR $T22[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f8000003f800000
	mov	ebx, eax
	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	movups	XMMWORD PTR $T16[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	movaps	xmm0, XMMWORD PTR __xmm@3f80000000000000000000003f800000
	mov	edi, eax
	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	movups	XMMWORD PTR $T19[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000000000000000000000
	mov	esi, eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	movups	XMMWORD PTR $T1[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2055 :         draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+sz, y+sz), ImColor(0,0,0), ImColor(255,0,0), ImColor(255,255,0), ImColor(0,255,0));

	movss	xmm1, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2055 :         draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+sz, y+sz), ImColor(0,0,0), ImColor(255,0,0), ImColor(255,255,0), ImColor(0,255,0));

	movss	xmm2, DWORD PTR _x$12$[ebp]
	movaps	xmm0, xmm1
	movss	xmm3, DWORD PTR _y$1$[ebp]
	addss	xmm0, xmm2
	mov	ecx, DWORD PTR _draw_list$1$[ebp]
	addss	xmm1, xmm3
	push	ebx
	push	edi
	push	esi
	push	eax
	lea	eax, DWORD PTR $T45[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T45[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2055 :         draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+sz, y+sz), ImColor(0,0,0), ImColor(255,0,0), ImColor(255,255,0), ImColor(0,255,0));

	push	eax
	lea	eax, DWORD PTR $T28[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T45[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2055 :         draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+sz, y+sz), ImColor(0,0,0), ImColor(255,0,0), ImColor(255,255,0), ImColor(0,255,0));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T28[ebp], xmm2
	movss	DWORD PTR $T28[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2055 :         draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+sz, y+sz), ImColor(0,0,0), ImColor(255,0,0), ImColor(255,255,0), ImColor(0,255,0));

	call	?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 2056 :         ImGui::Dummy(ImVec2((sz+spacing)*8, (sz+spacing)*3));

	movss	xmm1, DWORD PTR ?sz@?1??ShowExampleAppCustomRendering@@YAXPA_N@Z@4MA
	lea	eax, DWORD PTR $T44[ebp]
	movaps	xmm0, xmm1
	mulss	xmm1, DWORD PTR __real@40400000
	push	eax
	mulss	xmm0, DWORD PTR __real@41000000
	addss	xmm1, DWORD PTR __real@41c00000
	addss	xmm0, DWORD PTR __real@42800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T44[ebp+4], xmm1
	movss	DWORD PTR $T44[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2056 :         ImGui::Dummy(ImVec2((sz+spacing)*8, (sz+spacing)*3));

	call	?Dummy@ImGui@@YAXABUImVec2@@@Z		; ImGui::Dummy
	add	esp, 4

; 2057 :     }
; 2058 :     ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 2059 :     {
; 2060 :         static ImVector<ImVec2> points;

	mov	ecx, DWORD PTR tv1580[ebp]
	mov	eax, DWORD PTR ?$TSS1@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jg	$LN221@ShowExampl
$LN6@ShowExampl:

; 2061 :         static bool adding_line = false;
; 2062 :         ImGui::Text("Canvas example");

	push	OFFSET $SG12408
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 2063 :         if (ImGui::Button("Clear")) points.clear();

	lea	eax, DWORD PTR $T43[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T43[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2063 :         if (ImGui::Button("Clear")) points.clear();

	push	eax
	push	OFFSET $SG12410
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T43[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2063 :         if (ImGui::Button("Clear")) points.clear();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN124@ShowExampl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A+8
	test	eax, eax
	je	SHORT $LN124@ShowExampl
	push	eax
	mov	DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A+4, 0
	mov	DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A, 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A+8, 0
$LN124@ShowExampl:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2064 :         if (points.Size >= 2) { ImGui::SameLine(); if (ImGui::Button("Undo")) { points.pop_back(); points.pop_back(); } }

	cmp	DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A, 2
	jl	SHORT $LN13@ShowExampl
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	lea	eax, DWORD PTR $T42[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T42[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2064 :         if (points.Size >= 2) { ImGui::SameLine(); if (ImGui::Button("Undo")) { points.pop_back(); points.pop_back(); } }

	push	eax
	push	OFFSET $SG12413
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T42[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2064 :         if (points.Size >= 2) { ImGui::SameLine(); if (ImGui::Button("Undo")) { points.pop_back(); points.pop_back(); } }

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN13@ShowExampl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	sub	DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A, 2
$LN13@ShowExampl:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2065 :         ImGui::Text("Left-click and drag to add lines,\nRight-click to undo");

	push	OFFSET $SG12414
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 2066 : 
; 2067 :         // Here we are using InvisibleButton() as a convenience to 1) advance the cursor and 2) allows us to use IsItemHovered()
; 2068 :         // However you can draw directly and poll mouse/keyboard by yourself. You can manipulate the cursor using GetCursorPos() and SetCursorPos().
; 2069 :         // If you only use the ImDrawList API, you can notify the owner window of its extends by using SetCursorPos(max).
; 2070 :         ImVec2 canvas_pos = ImGui::GetCursorScreenPos();            // ImDrawList API uses screen coordinates!

	lea	eax, DWORD PTR _canvas_pos$37[ebp]
	push	eax
	call	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos

; 2071 :         ImVec2 canvas_size = ImGui::GetContentRegionAvail();        // Resize canvas to what's available

	lea	eax, DWORD PTR _canvas_size$51[ebp]
	push	eax
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail

; 2072 :         if (canvas_size.x < 50.0f) canvas_size.x = 50.0f;

	movss	xmm0, DWORD PTR __real@42480000
	add	esp, 12					; 0000000cH
	comiss	xmm0, DWORD PTR _canvas_size$51[ebp]
	jbe	SHORT $LN14@ShowExampl
	mov	DWORD PTR _canvas_size$51[ebp], 1112014848 ; 42480000H
$LN14@ShowExampl:

; 2073 :         if (canvas_size.y < 50.0f) canvas_size.y = 50.0f;

	comiss	xmm0, DWORD PTR _canvas_size$51[ebp+4]
	jbe	SHORT $LN15@ShowExampl
	mov	DWORD PTR _canvas_size$51[ebp+4], 1112014848 ; 42480000H
$LN15@ShowExampl:
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003e70f0f23e48c8ca3e48c8ca
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	movups	XMMWORD PTR $T26[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003e8c8c8d3e70f0f23e70f0f2
	mov	ebx, eax
	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	movups	XMMWORD PTR $T21[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003e70f0f23e48c8ca3e48c8ca
	mov	edi, eax
	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	movups	XMMWORD PTR $T15[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003e48c8ca3e48c8ca3e48c8ca
	mov	esi, eax
	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	movups	XMMWORD PTR $T18[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2074 :         draw_list->AddRectFilledMultiColor(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), ImColor(50,50,50), ImColor(50,50,60), ImColor(60,60,70), ImColor(50,50,60));

	movss	xmm0, DWORD PTR _canvas_pos$37[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2074 :         draw_list->AddRectFilledMultiColor(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), ImColor(50,50,50), ImColor(50,50,60), ImColor(60,60,70), ImColor(50,50,60));

	addss	xmm0, DWORD PTR _canvas_size$51[ebp]
	push	ebx
	mov	ebx, DWORD PTR _draw_list$1$[ebp]
	mov	ecx, ebx
	push	edi
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T41[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2074 :         draw_list->AddRectFilledMultiColor(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), ImColor(50,50,50), ImColor(50,50,60), ImColor(60,60,70), ImColor(50,50,60));

	movss	xmm0, DWORD PTR _canvas_pos$37[ebp+4]
	addss	xmm0, DWORD PTR _canvas_size$51[ebp+4]
	push	eax
	lea	eax, DWORD PTR $T41[ebp]
	push	eax
	lea	eax, DWORD PTR _canvas_pos$37[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T41[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2074 :         draw_list->AddRectFilledMultiColor(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), ImColor(50,50,50), ImColor(50,50,60), ImColor(60,60,70), ImColor(50,50,60));

	call	?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	eax, DWORD PTR $T25[ebp]
	push	eax

; 1124 :     ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }

	movups	XMMWORD PTR $T25[ebp], xmm0

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2075 :         draw_list->AddRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), ImColor(255,255,255));

	movss	xmm0, DWORD PTR _canvas_pos$37[ebp]
	addss	xmm0, DWORD PTR _canvas_size$51[ebp]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	push	ecx
	mov	DWORD PTR [esp], 0
	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T40[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2075 :         draw_list->AddRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), ImColor(255,255,255));

	movss	xmm0, DWORD PTR _canvas_pos$37[ebp+4]
	addss	xmm0, DWORD PTR _canvas_size$51[ebp+4]
	push	eax
	lea	eax, DWORD PTR $T40[ebp]
	push	eax
	lea	eax, DWORD PTR _canvas_pos$37[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T40[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2075 :         draw_list->AddRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), ImColor(255,255,255));

	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 2076 : 
; 2077 :         bool adding_preview = false;
; 2078 :         ImGui::InvisibleButton("canvas", canvas_size);

	lea	eax, DWORD PTR _canvas_size$51[ebp]
	mov	BYTE PTR _adding_preview$1$[ebp], 0
	push	eax
	push	OFFSET $SG12417
	call	?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::InvisibleButton
	add	esp, 8

; 2079 :         ImVec2 mouse_pos_in_canvas = ImVec2(ImGui::GetIO().MousePos.x - canvas_pos.x, ImGui::GetIO().MousePos.y - canvas_pos.y);

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax+204]
	subss	xmm0, DWORD PTR _canvas_pos$37[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _mouse_pos_in_canvas$34[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2079 :         ImVec2 mouse_pos_in_canvas = ImVec2(ImGui::GetIO().MousePos.x - canvas_pos.x, ImGui::GetIO().MousePos.y - canvas_pos.y);

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 2080 :         if (adding_line)

	cmp	BYTE PTR ?adding_line@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4_NA, 0
	movss	xmm0, DWORD PTR [eax+208]
	subss	xmm0, DWORD PTR _canvas_pos$37[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _mouse_pos_in_canvas$34[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2080 :         if (adding_line)

	je	SHORT $LN17@ShowExampl

; 2081 :         {
; 2082 :             adding_preview = true;
; 2083 :             points.push_back(mouse_pos_in_canvas);

	lea	eax, DWORD PTR _mouse_pos_in_canvas$34[ebp]
	mov	BYTE PTR _adding_preview$1$[ebp], 1
	push	eax
	mov	ecx, OFFSET ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 2084 :             if (!ImGui::GetIO().MouseDown[0])

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	cmp	BYTE PTR [eax+212], 0
	jne	SHORT $LN17@ShowExampl

; 2085 :                 adding_line = adding_preview = false;

	mov	BYTE PTR _adding_preview$1$[ebp], 0
	mov	BYTE PTR ?adding_line@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4_NA, 0
$LN17@ShowExampl:

; 2086 :         }
; 2087 :         if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN20@ShowExampl

; 2088 :         {
; 2089 :             if (!adding_line && ImGui::IsMouseClicked(0))

	cmp	BYTE PTR ?adding_line@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4_NA, 0
	jne	SHORT $LN19@ShowExampl
	push	0
	push	0
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	add	esp, 8
	test	al, al
	je	SHORT $LN19@ShowExampl

; 2090 :             {
; 2091 :                 points.push_back(mouse_pos_in_canvas);

	lea	eax, DWORD PTR _mouse_pos_in_canvas$34[ebp]
	mov	ecx, OFFSET ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A
	push	eax
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 2092 :                 adding_line = true;

	mov	BYTE PTR ?adding_line@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4_NA, 1
$LN19@ShowExampl:

; 2094 :             if (ImGui::IsMouseClicked(1) && !points.empty())

	push	0
	push	1
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	add	esp, 8
	test	al, al
	je	SHORT $LN20@ShowExampl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	mov	eax, DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A
	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2094 :             if (ImGui::IsMouseClicked(1) && !points.empty())

	je	SHORT $LN20@ShowExampl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	sub	eax, 2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2096 :                 adding_line = adding_preview = false;

	mov	BYTE PTR _adding_preview$1$[ebp], 0
	mov	BYTE PTR ?adding_line@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4_NA, 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A, eax
$LN20@ShowExampl:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2101 :         draw_list->PushClipRect(canvas_pos, ImVec2(canvas_pos.x+canvas_size.x, canvas_pos.y+canvas_size.y));      // clip lines within the canvas (if we resize it, etc.)

	movss	xmm0, DWORD PTR _canvas_pos$37[ebp]
	mov	ecx, ebx
	addss	xmm0, DWORD PTR _canvas_size$51[ebp]
	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T33[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2101 :         draw_list->PushClipRect(canvas_pos, ImVec2(canvas_pos.x+canvas_size.x, canvas_pos.y+canvas_size.y));      // clip lines within the canvas (if we resize it, etc.)

	movss	xmm0, DWORD PTR _canvas_pos$37[ebp+4]
	addss	xmm0, DWORD PTR _canvas_size$51[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T33[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2101 :         draw_list->PushClipRect(canvas_pos, ImVec2(canvas_pos.x+canvas_size.x, canvas_pos.y+canvas_size.y));      // clip lines within the canvas (if we resize it, etc.)

	push	DWORD PTR $T33[ebp+4]
	push	DWORD PTR $T33[ebp]
	push	DWORD PTR _canvas_pos$37[ebp+4]
	push	DWORD PTR _canvas_pos$37[ebp]
	call	?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z ; ImDrawList::PushClipRect

; 2102 :         for (int i = 0; i < points.Size - 1; i += 2)

	mov	eax, DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A
	xor	esi, esi
	dec	eax
	test	eax, eax
	jle	SHORT $LN8@ShowExampl
	npad	11
$LL9@ShowExampl:
	mov	eax, DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A+8

; 2103 :             draw_list->AddLine(ImVec2(canvas_pos.x + points[i].x, canvas_pos.y + points[i].y), ImVec2(canvas_pos.x + points[i+1].x, canvas_pos.y + points[i+1].y), IM_COL32(255,255,0,255), 2.0f);

	push	ecx
	mov	DWORD PTR [esp], 1073741824		; 40000000H
	mov	ecx, ebx
	push	-16711681				; ff00ffffH
	movss	xmm1, DWORD PTR [eax+esi*8+12]
	movss	xmm0, DWORD PTR [eax+esi*8+8]
	addss	xmm1, DWORD PTR _canvas_pos$37[ebp+4]
	addss	xmm0, DWORD PTR _canvas_pos$37[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T39[ebp+4], xmm1
	movss	DWORD PTR $T39[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2103 :             draw_list->AddLine(ImVec2(canvas_pos.x + points[i].x, canvas_pos.y + points[i].y), ImVec2(canvas_pos.x + points[i+1].x, canvas_pos.y + points[i+1].y), IM_COL32(255,255,0,255), 2.0f);

	movss	xmm1, DWORD PTR [eax+esi*8+4]
	movss	xmm0, DWORD PTR [eax+esi*8]
	lea	eax, DWORD PTR $T39[ebp]
	addss	xmm1, DWORD PTR _canvas_pos$37[ebp+4]
	addss	xmm0, DWORD PTR _canvas_pos$37[ebp]
	push	eax
	lea	eax, DWORD PTR $T27[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T27[ebp+4], xmm1
	movss	DWORD PTR $T27[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2103 :             draw_list->AddLine(ImVec2(canvas_pos.x + points[i].x, canvas_pos.y + points[i].y), ImVec2(canvas_pos.x + points[i+1].x, canvas_pos.y + points[i+1].y), IM_COL32(255,255,0,255), 2.0f);

	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
	mov	eax, DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A
	add	esi, 2
	dec	eax
	cmp	esi, eax
	jl	SHORT $LL9@ShowExampl
$LN8@ShowExampl:

; 2104 :         draw_list->PopClipRect();

	mov	ecx, ebx
	call	?PopClipRect@ImDrawList@@QAEXXZ		; ImDrawList::PopClipRect

; 2105 :         if (adding_preview)

	cmp	BYTE PTR _adding_preview$1$[ebp], 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN21@ShowExampl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR ?points@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4V?$ImVector@UImVec2@@@@A
$LN21@ShowExampl:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2108 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 2109 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN221@ShowExampl:

; 2059 :     {
; 2060 :         static ImVector<ImVec2> points;

	push	OFFSET ?$TSS1@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS1@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4HA, -1
	jne	$LN6@ShowExampl
	push	OFFSET ??__Fpoints@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@YAXXZ ; `ShowExampleAppCustomRendering'::`9'::`dynamic atexit destructor for 'points''
	call	_atexit
	push	OFFSET ?$TSS1@?8??ShowExampleAppCustomRendering@@YAXPA_N@Z@4HA
	call	__Init_thread_footer
	add	esp, 8
	jmp	$LN6@ShowExampl
?ShowExampleAppCustomRendering@@YAXPA_N@Z ENDP		; ShowExampleAppCustomRendering
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_buf$ = -136						; size = 128
$T1 = -8						; size = 8
$T2 = -8						; size = 8
$T3 = -8						; size = 8
tv160 = -4						; size = 4
___formal$ = 8						; size = 4
?ShowExampleAppManipulatingWindowTitle@@YAXPA_N@Z PROC	; ShowExampleAppManipulatingWindowTitle

; 1987 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H

; 1992 :     ImGui::SetNextWindowPos(ImVec2(100,100), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 1120403456		; 42c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1992 :     ImGui::SetNextWindowPos(ImVec2(100,100), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 1120403456	; 42c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1992 :     ImGui::SetNextWindowPos(ImVec2(100,100), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowPos

; 1993 :     ImGui::Begin("Same title as another window##1");

	push	0
	push	0
	push	OFFSET $SG12301
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin

; 1994 :     ImGui::Text("This is window 1.\nMy title is the same as window 2, but my identifier is unique.");

	push	OFFSET $SG12302
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1995 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 1997 :     ImGui::SetNextWindowPos(ImVec2(100,200), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 1120403456		; 42c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1997 :     ImGui::SetNextWindowPos(ImVec2(100,200), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 1128792064	; 43480000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1997 :     ImGui::SetNextWindowPos(ImVec2(100,200), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowPos

; 1998 :     ImGui::Begin("Same title as another window##2");

	push	0
	push	0
	push	OFFSET $SG12303
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin

; 1999 :     ImGui::Text("This is window 2.\nMy title is the same as window 1, but my identifier is unique.");

	push	OFFSET $SG12304
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 48					; 00000030H

; 2000 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 2001 : 
; 2002 :     // Using "###" to display a changing title but keep a static identifier "AnimatedTitle"
; 2003 :     char buf[128];
; 2004 :     sprintf(buf, "Animated title %c %d###AnimatedTitle", "|/-\\"[(int)(ImGui::GetTime()/0.25f)&3], rand());

	call	DWORD PTR __imp__rand
	push	eax
	call	?GetTime@ImGui@@YAMXZ			; ImGui::GetTime
	fmul	DWORD PTR __real@40800000
	fstp	DWORD PTR tv160[ebp]
	cvttss2si eax, DWORD PTR tv160[ebp]
	and	eax, 3
	movsx	eax, BYTE PTR $SG12305[eax]
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	OFFSET $SG12306
	push	eax
	call	_sprintf

; 2005 :     ImGui::SetNextWindowPos(ImVec2(100,300), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 1120403456		; 42c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2005 :     ImGui::SetNextWindowPos(ImVec2(100,300), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 1133903872	; 43960000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2005 :     ImGui::SetNextWindowPos(ImVec2(100,300), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowPos

; 2006 :     ImGui::Begin(buf);

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	0
	push	eax
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin

; 2007 :     ImGui::Text("This window has a changing title.");

	push	OFFSET $SG12307
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 40					; 00000028H

; 2008 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 2009 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowExampleAppManipulatingWindowTitle@@YAXPA_N@Z ENDP	; ShowExampleAppManipulatingWindowTitle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
_p_open$ = 8						; size = 4
?ShowExampleAppFixedOverlay@@YAXPA_N@Z PROC		; ShowExampleAppFixedOverlay

; 1971 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1972 :     ImGui::SetNextWindowPos(ImVec2(10,10));

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 1092616192		; 41200000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1972 :     ImGui::SetNextWindowPos(ImVec2(10,10));

	push	0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 1092616192	; 41200000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1972 :     ImGui::SetNextWindowPos(ImVec2(10,10));

	call	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowPos
	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1973 :     if (!ImGui::Begin("Example: Fixed Overlay", p_open, ImVec2(0,0), 0.3f, ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_NoFocusOnAppearing|ImGuiWindowFlags_NoNavFocus|ImGuiWindowFlags_NoNavInputs))

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1973 :     if (!ImGui::Begin("Example: Fixed Overlay", p_open, ImVec2(0,0), 0.3f, ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_NoFocusOnAppearing|ImGuiWindowFlags_NoNavFocus|ImGuiWindowFlags_NoNavInputs))

	push	397575					; 00061107H
	push	ecx
	mov	DWORD PTR [esp], 1050253722		; 3e99999aH
	push	eax
	push	DWORD PTR _p_open$[ebp]
	push	OFFSET $SG12290
	call	?Begin@ImGui@@YA_NPBDPA_NABUImVec2@@MH@Z ; ImGui::Begin
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN8@ShowExampl

; 1974 :     {
; 1975 :         ImGui::End();
; 1976 :         return;
; 1977 :     }
; 1978 :     ImGui::Text("Simple overlay\non the top-left side of the screen.");

	push	OFFSET $SG12291
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1979 :     ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1980 :     ImGui::Text("Mouse Position: (%.1f,%.1f)", ImGui::GetIO().MousePos.x, ImGui::GetIO().MousePos.y);

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	push	ecx
	movss	xmm0, DWORD PTR [eax+208]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	sub	esp, 8
	movss	xmm0, DWORD PTR [eax+204]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG12292
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 20					; 00000014H
$LN8@ShowExampl:

; 1981 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 1982 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowExampleAppFixedOverlay@@YAXPA_N@Z ENDP		; ShowExampleAppFixedOverlay
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_desc$1 = -40						; size = 24
$T2 = -16						; size = 8
$T3 = -16						; size = 8
$T4 = -16						; size = 8
$T5 = -16						; size = 8
$T6 = -16						; size = 8
$T7 = -16						; size = 8
$T8 = -16						; size = 8
$T9 = -16						; size = 8
$T10 = -16						; size = 8
$T11 = -16						; size = 8
$T12 = -16						; size = 8
$T13 = -16						; size = 8
$T14 = -8						; size = 8
$T15 = -8						; size = 8
$T16 = -8						; size = 8
$T17 = -8						; size = 8
$T18 = -8						; size = 8
$T19 = -8						; size = 8
_p_open$ = 8						; size = 4
?ShowExampleAppConstrainedResize@@YAXPA_N@Z PROC	; ShowExampleAppConstrainedResize

; 1933 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1941 :     if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Vertical only

	mov	eax, DWORD PTR ?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA
	sub	esp, 40					; 00000028H
	test	eax, eax
	jne	SHORT $LN5@ShowExampl
	push	eax
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T13[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1941 :     if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Vertical only

	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	lea	eax, DWORD PTR $T13[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T19[ebp], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1941 :     if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Vertical only

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T19[ebp+4], 2139095039	; 7f7fffffH
	mov	DWORD PTR $T13[ebp], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1941 :     if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Vertical only

	call	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
	mov	eax, DWORD PTR ?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA
	add	esp, 16					; 00000010H
$LN5@ShowExampl:

; 1942 :     if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Horizontal only

	cmp	eax, 1
	jne	SHORT $LN6@ShowExampl
	push	0
	push	0
	lea	eax, DWORD PTR $T12[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T12[ebp], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1942 :     if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Horizontal only

	push	eax
	lea	eax, DWORD PTR $T18[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T12[ebp+4], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1942 :     if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Horizontal only

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T18[ebp], 0
	mov	DWORD PTR $T18[ebp+4], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1942 :     if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Horizontal only

	call	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
	mov	eax, DWORD PTR ?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA
	add	esp, 16					; 00000010H
$LN6@ShowExampl:

; 1943 :     if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100

	cmp	eax, 2
	jne	SHORT $LN7@ShowExampl
	push	0
	push	0
	lea	eax, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T11[ebp], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1943 :     if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100

	push	eax
	lea	eax, DWORD PTR $T17[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T11[ebp+4], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1943 :     if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T17[ebp], 1120403456		; 42c80000H
	mov	DWORD PTR $T17[ebp+4], 1120403456	; 42c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1943 :     if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100

	call	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
	mov	eax, DWORD PTR ?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA
	add	esp, 16					; 00000010H
$LN7@ShowExampl:

; 1944 :     if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(300, 0),   ImVec2(400, FLT_MAX));     // Width 300-400

	cmp	eax, 3
	jne	SHORT $LN8@ShowExampl
	push	0
	push	0
	lea	eax, DWORD PTR $T10[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T10[ebp], 1137180672		; 43c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1944 :     if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(300, 0),   ImVec2(400, FLT_MAX));     // Width 300-400

	push	eax
	lea	eax, DWORD PTR $T16[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T10[ebp+4], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1944 :     if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(300, 0),   ImVec2(400, FLT_MAX));     // Width 300-400

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T16[ebp], 1133903872		; 43960000H
	mov	DWORD PTR $T16[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1944 :     if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(300, 0),   ImVec2(400, FLT_MAX));     // Width 300-400

	call	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
	mov	eax, DWORD PTR ?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA
	add	esp, 16					; 00000010H
$LN8@ShowExampl:

; 1945 :     if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);          // Always Square

	cmp	eax, 4
	jne	SHORT $LN9@ShowExampl
	push	0
	push	OFFSET ?Square@CustomConstraints@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@SAXPAUImGuiSizeConstraintCallbackData@@@Z ; `ShowExampleAppConstrainedResize'::`2'::CustomConstraints::Square
	lea	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1945 :     if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);          // Always Square

	push	eax
	lea	eax, DWORD PTR $T15[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp+4], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1945 :     if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);          // Always Square

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T15[ebp], 0
	mov	DWORD PTR $T15[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1945 :     if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);          // Always Square

	call	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
	mov	eax, DWORD PTR ?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA
	add	esp, 16					; 00000010H
$LN9@ShowExampl:

; 1946 :     if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)100);// Fixed Step

	cmp	eax, 5
	jne	SHORT $LN10@ShowExampl
	push	100					; 00000064H
	push	OFFSET ?Step@CustomConstraints@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@SAXPAUImGuiSizeConstraintCallbackData@@@Z ; `ShowExampleAppConstrainedResize'::`2'::CustomConstraints::Step
	lea	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1946 :     if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)100);// Fixed Step

	push	eax
	lea	eax, DWORD PTR $T14[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp+4], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1946 :     if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)100);// Fixed Step

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T14[ebp], 0
	mov	DWORD PTR $T14[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1946 :     if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)100);// Fixed Step

	call	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
	add	esp, 16					; 00000010H
$LN10@ShowExampl:

; 1947 : 
; 1948 :     if (ImGui::Begin("Example: Constrained Resize", p_open))

	push	0
	push	DWORD PTR _p_open$[ebp]
	push	OFFSET $SG12269
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN3@ShowExampl

; 1949 :     {
; 1950 :         const char* desc[] = 
; 1951 :         {
; 1952 :             "Resize vertical only",
; 1953 :             "Resize horizontal only",
; 1954 :             "Width > 100, Height > 100",
; 1955 :             "Width 300-400",
; 1956 :             "Custom: Always Square",
; 1957 :             "Custom: Fixed Steps (100)",
; 1958 :         };
; 1959 :         ImGui::Combo("Constraint", &type, desc, IM_ARRAYSIZE(desc)); 

	push	-1
	push	6
	lea	eax, DWORD PTR _desc$1[ebp]
	mov	DWORD PTR _desc$1[ebp], OFFSET $SG12270
	push	eax
	push	OFFSET ?type@?1??ShowExampleAppConstrainedResize@@YAXPA_N@Z@4HA
	push	OFFSET $SG12276
	mov	DWORD PTR _desc$1[ebp+4], OFFSET $SG12271
	mov	DWORD PTR _desc$1[ebp+8], OFFSET $SG12272
	mov	DWORD PTR _desc$1[ebp+12], OFFSET $SG12273
	mov	DWORD PTR _desc$1[ebp+16], OFFSET $SG12274
	mov	DWORD PTR _desc$1[ebp+20], OFFSET $SG12275
	call	?Combo@ImGui@@YA_NPBDPAHPBQBDHH@Z	; ImGui::Combo

; 1960 :         if (ImGui::Button("200x200")) ImGui::SetWindowSize(ImVec2(200,200)); ImGui::SameLine();

	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1960 :         if (ImGui::Button("200x200")) ImGui::SetWindowSize(ImVec2(200,200)); ImGui::SameLine();

	push	eax
	push	OFFSET $SG12278
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1960 :         if (ImGui::Button("200x200")) ImGui::SetWindowSize(ImVec2(200,200)); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 28					; 0000001cH
	test	al, al
	je	SHORT $LN12@ShowExampl
	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp], 1128792064		; 43480000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1960 :         if (ImGui::Button("200x200")) ImGui::SetWindowSize(ImVec2(200,200)); ImGui::SameLine();

	push	0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp+4], 1128792064	; 43480000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1960 :         if (ImGui::Button("200x200")) ImGui::SetWindowSize(ImVec2(200,200)); ImGui::SameLine();

	call	?SetWindowSize@ImGui@@YAXABUImVec2@@H@Z	; ImGui::SetWindowSize
	add	esp, 8
$LN12@ShowExampl:
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1961 :         if (ImGui::Button("500x500")) ImGui::SetWindowSize(ImVec2(500,500)); ImGui::SameLine();

	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1961 :         if (ImGui::Button("500x500")) ImGui::SetWindowSize(ImVec2(500,500)); ImGui::SameLine();

	push	eax
	push	OFFSET $SG12280
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1961 :         if (ImGui::Button("500x500")) ImGui::SetWindowSize(ImVec2(500,500)); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN13@ShowExampl
	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 1140457472		; 43fa0000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1961 :         if (ImGui::Button("500x500")) ImGui::SetWindowSize(ImVec2(500,500)); ImGui::SameLine();

	push	0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 1140457472	; 43fa0000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1961 :         if (ImGui::Button("500x500")) ImGui::SetWindowSize(ImVec2(500,500)); ImGui::SameLine();

	call	?SetWindowSize@ImGui@@YAXABUImVec2@@H@Z	; ImGui::SetWindowSize
	add	esp, 8
$LN13@ShowExampl:
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1962 :         if (ImGui::Button("800x200")) ImGui::SetWindowSize(ImVec2(800,200));

	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1962 :         if (ImGui::Button("800x200")) ImGui::SetWindowSize(ImVec2(800,200));

	push	eax
	push	OFFSET $SG12282
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1962 :         if (ImGui::Button("800x200")) ImGui::SetWindowSize(ImVec2(800,200));

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN14@ShowExampl
	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 1145569280		; 44480000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1962 :         if (ImGui::Button("800x200")) ImGui::SetWindowSize(ImVec2(800,200));

	push	0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 1128792064	; 43480000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1962 :         if (ImGui::Button("800x200")) ImGui::SetWindowSize(ImVec2(800,200));

	call	?SetWindowSize@ImGui@@YAXABUImVec2@@H@Z	; ImGui::SetWindowSize
	add	esp, 8
$LN14@ShowExampl:

; 1963 :         for (int i = 0; i < 10; i++) 

	push	esi
	mov	esi, 10					; 0000000aH
	npad	1
$LL4@ShowExampl:

; 1964 :             ImGui::Text("Hello, sailor! Making this line long enough for the example.");

	push	OFFSET $SG12283
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	sub	esi, 1
	jne	SHORT $LL4@ShowExampl
	pop	esi
$LN3@ShowExampl:

; 1965 :     }
; 1966 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 1967 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowExampleAppConstrainedResize@@YAXPA_N@Z ENDP	; ShowExampleAppConstrainedResize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_p_open$ = 8						; size = 4
?ShowExampleAppAutoResize@@YAXPA_N@Z PROC		; ShowExampleAppAutoResize

; 1916 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1917 :     if (!ImGui::Begin("Example: Auto-resizing window", p_open, ImGuiWindowFlags_AlwaysAutoResize))

	push	64					; 00000040H
	push	DWORD PTR _p_open$[ebp]
	push	OFFSET $SG12201
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN5@ShowExampl

; 1929 : }

	pop	ebp

; 1918 :     {
; 1919 :         ImGui::End();

	jmp	?End@ImGui@@YAXXZ			; ImGui::End
$LN5@ShowExampl:
	push	esi

; 1920 :         return;
; 1921 :     }
; 1922 : 
; 1923 :     static int lines = 10;
; 1924 :     ImGui::Text("Window will resize every-frame to the size of its content.\nNote that you probably don't want to query the window size to\noutput your content because that would create a feedback loop.");

	push	OFFSET $SG12202
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1925 :     ImGui::SliderInt("Number of lines", &lines, 1, 20);

	push	OFFSET $SG12203
	push	20					; 00000014H
	push	1
	push	OFFSET ?lines@?1??ShowExampleAppAutoResize@@YAXPA_N@Z@4HA
	push	OFFSET $SG12204
	call	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z	; ImGui::SliderInt

; 1926 :     for (int i = 0; i < lines; i++)

	xor	esi, esi
	add	esp, 24					; 00000018H
	cmp	DWORD PTR ?lines@?1??ShowExampleAppAutoResize@@YAXPA_N@Z@4HA, esi
	jle	SHORT $LN3@ShowExampl
$LL4@ShowExampl:

; 1927 :         ImGui::Text("%*sThis is line %d", i*4, "", i); // Pad with space to extend size horizontally

	push	esi
	push	OFFSET $SG12205
	lea	eax, DWORD PTR [esi*4]
	push	eax
	push	OFFSET $SG12206
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR ?lines@?1??ShowExampleAppAutoResize@@YAXPA_N@Z@4HA
	jl	SHORT $LL4@ShowExampl
$LN3@ShowExampl:
	pop	esi

; 1929 : }

	pop	ebp

; 1928 :     ImGui::End();

	jmp	?End@ImGui@@YAXXZ			; ImGui::End
?ShowExampleAppAutoResize@@YAXPA_N@Z ENDP		; ShowExampleAppAutoResize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_clipper$2 = -56					; size = 24
$T3 = -32						; size = 8
$T4 = -24						; size = 8
$T5 = -24						; size = 8
$T6 = -24						; size = 8
$T7 = -24						; size = 8
$T8 = -24						; size = 8
$T9 = -13						; size = 1
$T10 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_p_open$ = 8						; size = 4
?ShowExampleAppLongText@@YAXPA_N@Z PROC			; ShowExampleAppLongText

; 2603 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShowExampleAppLongText@@YAXPA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH

; 2604 :     ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp], 1140981760		; 44020000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2604 :     ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp+4], 1142292480	; 44160000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2604 :     ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 2605 :     if (!ImGui::Begin("Example: Long text display", p_open))

	push	0
	push	DWORD PTR _p_open$[ebp]
	push	OFFSET $SG13064
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN16@ShowExampl

; 2606 :     {
; 2607 :         ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 2653 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@ShowExampl:

; 2612 :     static ImGuiTextBuffer log;

	mov	eax, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	SHORT $LN2@ShowExampl
	push	OFFSET ?$TSS0@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA, -1
	jne	SHORT $LN2@ShowExampl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1000 :     ImGuiTextBuffer()   { Buf.push_back(0); }

	lea	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	mov	ecx, OFFSET ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A
	mov	BYTE PTR $T10[ebp], 0
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2612 :     static ImGuiTextBuffer log;

	push	OFFSET ??__Flog@?1??ShowExampleAppLongText@@YAXPA_N@Z@YAXXZ ; `ShowExampleAppLongText'::`2'::`dynamic atexit destructor for 'log''
	call	_atexit
	push	OFFSET ?$TSS0@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 8
$LN2@ShowExampl:

; 2613 :     static int lines = 0;
; 2614 :     ImGui::Text("Printing unusually long amount of text.");

	push	OFFSET $SG13065
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 2615 :     ImGui::Combo("Test type", &test_type, "Single call to TextUnformatted()\0Multiple calls to Text(), clipped manually\0Multiple calls to Text(), not clipped\0");

	push	-1
	push	OFFSET $SG13066
	push	OFFSET ?test_type@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	push	OFFSET $SG13067
	call	?Combo@ImGui@@YA_NPBDPAH0H@Z		; ImGui::Combo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1004 :     int                 size() const { return Buf.Size - 1; }

	mov	eax, DWORD PTR ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A
	dec	eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2616 :     ImGui::Text("Buffer contents: %d lines, %d bytes", lines, log.size());

	push	eax
	push	DWORD PTR ?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	push	OFFSET $SG13068
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 2617 :     if (ImGui::Button("Clear")) { log.clear(); lines = 0; }

	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2617 :     if (ImGui::Button("Clear")) { log.clear(); lines = 0; }

	push	eax
	push	OFFSET $SG13070
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2617 :     if (ImGui::Button("Clear")) { log.clear(); lines = 0; }

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 40					; 00000028H
	test	al, al
	je	SHORT $LN17@ShowExampl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A+8
	test	eax, eax
	je	SHORT $LN38@ShowExampl
	push	eax
	mov	DWORD PTR ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A+4, 0
	mov	DWORD PTR ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A, 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A+8, 0
$LN38@ShowExampl:

; 1006 :     void                clear() { Buf.clear(); Buf.push_back(0); }

	lea	eax, DWORD PTR $T9[ebp]
	mov	BYTE PTR $T9[ebp], 0
	push	eax
	mov	ecx, OFFSET ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2617 :     if (ImGui::Button("Clear")) { log.clear(); lines = 0; }

	mov	DWORD PTR ?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA, 0
$LN17@ShowExampl:

; 2618 :     ImGui::SameLine();

	push	esi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 2619 :     if (ImGui::Button("Add 1000 lines"))

	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2619 :     if (ImGui::Button("Add 1000 lines"))

	push	eax
	push	OFFSET $SG13072
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2619 :     if (ImGui::Button("Add 1000 lines"))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN18@ShowExampl

; 2620 :     {
; 2621 :         for (int i = 0; i < 1000; i++)

	xor	esi, esi
	npad	5
$LL5@ShowExampl:

; 2622 :             log.append("%i The quick brown fox jumps over the lazy dog\n", lines+i);

	mov	eax, DWORD PTR ?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	add	eax, esi
	push	eax
	push	OFFSET $SG13073
	push	OFFSET ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A
	call	?append@ImGuiTextBuffer@@QAAXPBDZZ	; ImGuiTextBuffer::append
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, 1000				; 000003e8H
	jl	SHORT $LL5@ShowExampl

; 2623 :         lines += 1000;

	add	DWORD PTR ?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA, 1000 ; 000003e8H
$LN18@ShowExampl:

; 2625 :     ImGui::BeginChild("Log");

	push	0
	push	0
	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2625 :     ImGui::BeginChild("Log");

	push	eax
	push	OFFSET $SG13074
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2625 :     ImGui::BeginChild("Log");

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild

; 2626 :     switch (test_type)

	mov	eax, DWORD PTR ?test_type@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	add	esp, 16					; 00000010H
	sub	eax, 0
	je	$LN19@ShowExampl
	sub	eax, 1
	je	SHORT $LN20@ShowExampl
	sub	eax, 1
	jne	$LN6@ShowExampl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2645 :         ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	push	7
	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 2646 :         for (int i = 0; i < lines; i++)

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR ?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA, esi
	jle	SHORT $LN14@ShowExampl
	npad	6
$LL15@ShowExampl:

; 2647 :             ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);

	push	esi
	push	OFFSET $SG13079
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR ?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	jl	SHORT $LL15@ShowExampl
$LN14@ShowExampl:

; 2648 :         ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	add	esp, 4
	jmp	$LN6@ShowExampl
$LN20@ShowExampl:

; 2635 :             ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2635 :             ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));

	push	eax
	push	7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2635 :             ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1158 :     ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

	add	esp, 4
	lea	ecx, DWORD PTR _clipper$2[ebp]
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	DWORD PTR ?lines@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	call	?Begin@ImGuiListClipper@@QAEXHM@Z	; ImGuiListClipper::Begin
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2637 :             while (clipper.Step())

	lea	ecx, DWORD PTR _clipper$2[ebp]
	call	?Step@ImGuiListClipper@@QAE_NXZ		; ImGuiListClipper::Step
	test	al, al
	je	SHORT $LN9@ShowExampl
$LL8@ShowExampl:

; 2638 :                 for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)

	mov	esi, DWORD PTR _clipper$2[ebp+16]
	cmp	esi, DWORD PTR _clipper$2[ebp+20]
	jge	SHORT $LN11@ShowExampl
	npad	5
$LL12@ShowExampl:

; 2639 :                     ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);

	push	esi
	push	OFFSET $SG13077
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR _clipper$2[ebp+20]
	jl	SHORT $LL12@ShowExampl
$LN11@ShowExampl:

; 2637 :             while (clipper.Step())

	lea	ecx, DWORD PTR _clipper$2[ebp]
	call	?Step@ImGuiListClipper@@QAE_NXZ		; ImGuiListClipper::Step
	test	al, al
	jne	SHORT $LL8@ShowExampl
$LN9@ShowExampl:

; 2640 :             ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	add	esp, 4

; 2641 :             break;

	jmp	SHORT $LN6@ShowExampl
$LN19@ShowExampl:

; 2627 :     {
; 2628 :     case 0:
; 2629 :         // Single call to TextUnformatted() with a big buffer
; 2630 :         ImGui::TextUnformatted(log.begin(), log.end());

	mov	eax, DWORD PTR ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A
	mov	ecx, DWORD PTR ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A+8
	dec	eax
	add	eax, ecx
	push	eax
	push	ecx
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 8
$LN6@ShowExampl:

; 2649 :         break;
; 2650 :     }
; 2651 :     ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 2652 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 2653 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ShowExampleAppLongText@@YAXPA_N@Z$0:
	push	OFFSET ?$TSS0@?1??ShowExampleAppLongText@@YAXPA_N@Z@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__unwindfunclet$?ShowExampleAppLongText@@YAXPA_N@Z$1:
	mov	ecx, OFFSET ?log@?1??ShowExampleAppLongText@@YAXPA_N@Z@4UImGuiTextBuffer@@A
	jmp	??1?$ImVector@D@@QAE@XZ			; ImVector<char>::~ImVector<char>
__ehhandler$?ShowExampleAppLongText@@YAXPA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ShowExampleAppLongText@@YAXPA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShowExampleAppLongText@@YAXPA_N@Z ENDP			; ShowExampleAppLongText
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_label$1 = -48						; size = 32
$T2 = -16						; size = 8
$T3 = -8						; size = 8
$T4 = -8						; size = 8
_obj_i$1$ = -4						; size = 4
_p_open$ = 8						; size = 4
?ShowExampleAppPropertyEditor@@YAXPA_N@Z PROC		; ShowExampleAppPropertyEditor

; 2530 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2531 :     ImGui::SetNextWindowSize(ImVec2(430,450), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 1138163712		; 43d70000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2531 :     ImGui::SetNextWindowSize(ImVec2(430,450), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 1138819072	; 43e10000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2531 :     ImGui::SetNextWindowSize(ImVec2(430,450), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 2532 :     if (!ImGui::Begin("Example: Property editor", p_open))

	push	0
	push	DWORD PTR _p_open$[ebp]
	push	OFFSET $SG13023
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN5@ShowExampl

; 2533 :     {
; 2534 :         ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 2599 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@ShowExampl:
	push	ebx
	push	esi
	push	edi

; 2535 :         return;
; 2536 :     }
; 2537 : 
; 2538 :     ShowHelpMarker("This example shows how you may implement a property editor using two columns.\nAll objects/fields data are dummies here.\nRemember that in many simple cases, you can use ImGui::SameLine(xxx) to position\nyour cursor horizontally instead of using the Columns() API.");

	push	OFFSET $SG13024
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 2540 :     ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2,2));

	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 1073741824		; 40000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2540 :     ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2,2));

	push	eax
	push	5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 1073741824	; 40000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2540 :     ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2,2));

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 2541 :     ImGui::Columns(2);

	push	1
	push	0
	push	2
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 24					; 00000018H

; 2542 :     ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 2588 :         }
; 2589 :     };
; 2590 : 
; 2591 :     // Iterate dummy objects with dummy members (all the same data)
; 2592 :     for (int obj_i = 0; obj_i < 3; obj_i++)

	xor	ebx, ebx
	mov	DWORD PTR _obj_i$1$[ebp], ebx
	npad	2
$LL4@ShowExampl:

; 2548 :             ImGui::PushID(uid);                      // Use object uid as identifier. Most commonly you could also use the object pointer as a base ID.

	push	ebx
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 2549 :             ImGui::AlignFirstTextHeightToWidgets();  // Text and Tree nodes are less high than regular widgets, here we add vertical spacing to make the tree lines equal high.

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 2550 :             bool node_open = ImGui::TreeNode("Object", "%s_%u", prefix, uid);

	push	ebx
	push	OFFSET $SG13025
	push	OFFSET ??_C@_05FIIOEGIK@?$CFs_?$CFu?$AA@
	push	OFFSET ??_C@_06ELFECKBG@Object?$AA@
	call	?TreeNode@ImGui@@YA_NPBD0ZZ		; ImGui::TreeNode
	mov	bl, al

; 2551 :             ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 2552 :             ImGui::AlignFirstTextHeightToWidgets();

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 2553 :             ImGui::Text("my sailor is rich");

	push	OFFSET ??_C@_0BC@LIBEHHHH@my?5sailor?5is?5rich?$AA@
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 24					; 00000018H

; 2554 :             ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 2555 :             if (node_open)

	test	bl, bl
	je	$LN15@ShowExampl

; 2556 :             {
; 2557 :                 static float dummy_members[8] = { 0.0f,0.0f,1.0f,3.1416f,100.0f,999.0f };
; 2558 :                 for (int i = 0; i < 8; i++)

	xor	esi, esi
	mov	edi, OFFSET ?dummy_members@?4??ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z@4PAMA ; ``ShowExampleAppPropertyEditor'::`2'::funcs::ShowDummyObject'::`5'::dummy_members
	npad	3
$LL14@ShowExampl:

; 2559 :                 {
; 2560 :                     ImGui::PushID(i); // Use field index as identifier.

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
	add	esp, 4

; 2561 :                     if (i < 2)

	cmp	esi, 2
	jge	SHORT $LN16@ShowExampl

; 2562 :                     {
; 2563 :                         ShowDummyObject("Child", 424242);

	push	424242					; 00067932H
	push	OFFSET ??_C@_05GIMBDOHM@Child?$AA@
	call	?ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z ; `ShowExampleAppPropertyEditor'::`2'::funcs::ShowDummyObject
	add	esp, 8

; 2564 :                     }
; 2565 :                     else

	jmp	$LN17@ShowExampl
$LN16@ShowExampl:

; 2566 :                     {
; 2567 :                         ImGui::AlignFirstTextHeightToWidgets();

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 2568 :                         // Here we use a Selectable (instead of Text) to highlight on hover
; 2569 :                         //ImGui::Text("Field_%d", i);
; 2570 :                         char label[32];
; 2571 :                         sprintf(label, "Field_%d", i);

	push	esi
	lea	eax, DWORD PTR _label$1[ebp]
	push	OFFSET ??_C@_08BNKJGCPO@Field_?$CFd?$AA@
	push	eax
	call	_sprintf

; 2572 :                         ImGui::Bullet();

	call	?Bullet@ImGui@@YAXXZ			; ImGui::Bullet

; 2573 :                         ImGui::Selectable(label);

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2573 :                         ImGui::Selectable(label);

	push	eax
	push	0
	lea	eax, DWORD PTR _label$1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2573 :                         ImGui::Selectable(label);

	push	0
	push	eax
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable

; 2574 :                         ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 2575 :                         ImGui::PushItemWidth(-1);

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	add	esp, 4

; 2576 :                         if (i >= 5)

	cmp	esi, 5
	jl	SHORT $LN18@ShowExampl

; 2577 :                             ImGui::InputFloat("##value", &dummy_members[i], 1.0f);

	push	0
	push	-1
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	edi
	push	OFFSET ??_C@_07FBBIKLOB@?$CD?$CDvalue?$AA@
	call	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z	; ImGui::InputFloat
	add	esp, 24					; 00000018H

; 2578 :                         else

	jmp	SHORT $LN19@ShowExampl
$LN18@ShowExampl:

; 2579 :                             ImGui::DragFloat("##value", &dummy_members[i], 0.01f);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ??_C@_04GFJLOHHD@?$CF?43f?$AA@
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	push	edi
	push	OFFSET ??_C@_07FBBIKLOB@?$CD?$CDvalue?$AA@
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat
	add	esp, 28					; 0000001cH
$LN19@ShowExampl:

; 2580 :                         ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 2581 :                         ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
$LN17@ShowExampl:

; 2582 :                     }
; 2583 :                     ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	add	edi, 4
	inc	esi
	cmp	edi, OFFSET ?dummy_members@?4??ShowDummyObject@funcs@?1??ShowExampleAppPropertyEditor@@YAXPA_N@Z@SAXPBDH@Z@4PAMA+32
	jl	$LL14@ShowExampl

; 2584 :                 }
; 2585 :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN15@ShowExampl:

; 2586 :             }
; 2587 :             ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 2588 :         }
; 2589 :     };
; 2590 : 
; 2591 :     // Iterate dummy objects with dummy members (all the same data)
; 2592 :     for (int obj_i = 0; obj_i < 3; obj_i++)

	mov	ebx, DWORD PTR _obj_i$1$[ebp]
	inc	ebx
	mov	DWORD PTR _obj_i$1$[ebp], ebx
	cmp	ebx, 3
	jl	$LL4@ShowExampl

; 2593 :         funcs::ShowDummyObject("Object", obj_i);
; 2594 : 
; 2595 :     ImGui::Columns(1);

	push	1
	push	0
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns

; 2596 :     ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 2597 :     ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	add	esp, 16					; 00000010H

; 2598 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	pop	edi
	pop	esi
	pop	ebx

; 2599 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowExampleAppPropertyEditor@@YAXPA_N@Z ENDP		; ShowExampleAppPropertyEditor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_label$1 = -144						; size = 128
$T2 = -16						; size = 8
$T3 = -16						; size = 8
$T4 = -16						; size = 8
tv260 = -12						; size = 4
$T5 = -8						; size = 8
$T6 = -8						; size = 8
$T7 = -8						; size = 8
$T8 = -8						; size = 8
_p_open$ = 8						; size = 4
?ShowExampleAppLayout@@YAXPA_N@Z PROC			; ShowExampleAppLayout

; 2484 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi

; 2485 :     ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 1140457472		; 43fa0000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2485 :     ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 1138491392	; 43dc0000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2485 :     ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 2486 :     if (ImGui::Begin("Example: Layout", p_open, ImGuiWindowFlags_MenuBar))

	mov	esi, DWORD PTR _p_open$[ebp]
	push	1024					; 00000400H
	push	esi
	push	OFFSET $SG12960
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN5@ShowExampl

; 2487 :     {
; 2488 :         if (ImGui::BeginMenuBar())

	call	?BeginMenuBar@ImGui@@YA_NXZ		; ImGui::BeginMenuBar
	test	al, al
	je	SHORT $LN6@ShowExampl

; 2489 :         {
; 2490 :             if (ImGui::BeginMenu("File"))

	push	1
	push	OFFSET $SG12963
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	SHORT $LN7@ShowExampl

; 2491 :             {
; 2492 :                 if (ImGui::MenuItem("Close")) *p_open = false;

	push	1
	push	0
	push	0
	push	OFFSET $SG12965
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN8@ShowExampl
	mov	BYTE PTR [esi], 0
$LN8@ShowExampl:

; 2493 :                 ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN7@ShowExampl:

; 2494 :             }
; 2495 :             ImGui::EndMenuBar();

	call	?EndMenuBar@ImGui@@YAXXZ		; ImGui::EndMenuBar
$LN6@ShowExampl:

; 2500 :         ImGui::BeginChild("left pane", ImVec2(150, 0), true);

	push	0
	push	1
	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 1125515264		; 43160000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2500 :         ImGui::BeginChild("left pane", ImVec2(150, 0), true);

	push	eax
	push	OFFSET $SG12966
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2500 :         ImGui::BeginChild("left pane", ImVec2(150, 0), true);

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild
	add	esp, 16					; 00000010H

; 2501 :         for (int i = 0; i < 100; i++)

	xor	esi, esi
	npad	8
$LL4@ShowExampl:

; 2502 :         {
; 2503 :             char label[128];
; 2504 :             sprintf(label, "MyObject %d", i);

	push	esi
	lea	eax, DWORD PTR _label$1[ebp]
	push	OFFSET $SG12967
	push	eax
	call	_sprintf

; 2505 :             if (ImGui::Selectable(label, selected == i))

	cmp	DWORD PTR ?selected@?4??ShowExampleAppLayout@@YAXPA_N@Z@4HA, esi
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	sete	al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2505 :             if (ImGui::Selectable(label, selected == i))

	movzx	eax, al
	push	0
	push	eax
	lea	eax, DWORD PTR _label$1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2505 :             if (ImGui::Selectable(label, selected == i))

	push	eax
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	mov	ecx, DWORD PTR ?selected@?4??ShowExampleAppLayout@@YAXPA_N@Z@4HA
	add	esp, 28					; 0000001cH
	test	al, al
	cmovne	ecx, esi
	inc	esi
	mov	DWORD PTR ?selected@?4??ShowExampleAppLayout@@YAXPA_N@Z@4HA, ecx
	cmp	esi, 100				; 00000064H
	jl	SHORT $LL4@ShowExampl

; 2506 :                 selected = i;
; 2507 :         }
; 2508 :         ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 2509 :         ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 2510 : 
; 2511 :         // right
; 2512 :         ImGui::BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 2513 :             ImGui::BeginChild("item view", ImVec2(0, -ImGui::GetItemsLineHeightWithSpacing())); // Leave room for 1 line below us

	call	?GetItemsLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetItemsLineHeightWithSpacing
	push	0
	push	0
	lea	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2513 :             ImGui::BeginChild("item view", ImVec2(0, -ImGui::GetItemsLineHeightWithSpacing())); // Leave room for 1 line below us

	fstp	DWORD PTR tv260[ebp]
	movss	xmm0, DWORD PTR tv260[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	eax
	push	OFFSET $SG12969
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2513 :             ImGui::BeginChild("item view", ImVec2(0, -ImGui::GetItemsLineHeightWithSpacing())); // Leave room for 1 line below us

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild

; 2514 :                 ImGui::Text("MyObject: %d", selected);

	push	DWORD PTR ?selected@?4??ShowExampleAppLayout@@YAXPA_N@Z@4HA
	push	OFFSET $SG12970
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 2515 :                 ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 2516 :                 ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ");

	push	OFFSET $SG12971
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 2517 :             ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 2518 :             ImGui::BeginChild("buttons");

	push	0
	push	0
	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2518 :             ImGui::BeginChild("buttons");

	push	eax
	push	OFFSET $SG12972
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2518 :             ImGui::BeginChild("buttons");

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild

; 2519 :                 if (ImGui::Button("Revert")) {}

	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2519 :                 if (ImGui::Button("Revert")) {}

	push	eax
	push	OFFSET $SG12974
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2519 :                 if (ImGui::Button("Revert")) {}

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 2520 :                 ImGui::SameLine();

	add	esp, 52					; 00000034H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 2521 :                 if (ImGui::Button("Save")) {}

	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2521 :                 if (ImGui::Button("Save")) {}

	push	eax
	push	OFFSET $SG12976
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2521 :                 if (ImGui::Button("Save")) {}

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H

; 2522 :             ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 2523 :         ImGui::EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
$LN5@ShowExampl:

; 2524 :     }
; 2525 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	pop	esi

; 2526 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowExampleAppLayout@@YAXPA_N@Z ENDP			; ShowExampleAppLayout
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_random_words$2 = -48					; size = 28
_this$ = -20						; size = 4
_time$ = -20						; size = 4
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_p_open$ = 8						; size = 4
?ShowExampleAppLog@@YAXPA_N@Z PROC			; ShowExampleAppLog

; 2466 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ShowExampleAppLog@@YAXPA_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H

; 2467 :     static ExampleAppLog log;

	mov	eax, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??ShowExampleAppLog@@YAXPA_N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	$LN2@ShowExampl
	push	OFFSET ?$TSS0@?1??ShowExampleAppLog@@YAXPA_N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??ShowExampleAppLog@@YAXPA_N@Z@4HA, -1
	jne	SHORT $LN2@ShowExampl
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR _this$[ebp], OFFSET ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1000 :     ImGuiTextBuffer()   { Buf.push_back(0); }

	lea	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	eax
	mov	ecx, OFFSET ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A
	mov	BYTE PTR $T3[ebp], 0
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, OFFSET ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A+12
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??0ImGuiTextFilter@@QAE@PBD@Z		; ImGuiTextFilter::ImGuiTextFilter
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2467 :     static ExampleAppLog log;

	push	OFFSET ??__Flog@?1??ShowExampleAppLog@@YAXPA_N@Z@YAXXZ ; `ShowExampleAppLog'::`2'::`dynamic atexit destructor for 'log''
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A+288, 0
	mov	DWORD PTR ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A+284, 0
	mov	DWORD PTR ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A+292, 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 2467 :     static ExampleAppLog log;

	call	_atexit
	push	OFFSET ?$TSS0@?1??ShowExampleAppLog@@YAXPA_N@Z@4HA
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 8
$LN2@ShowExampl:

; 2468 : 
; 2469 :     // Demo fill
; 2470 :     static float last_time = -1.0f;
; 2471 :     float time = ImGui::GetTime();

	call	?GetTime@ImGui@@YAMXZ			; ImGui::GetTime
	fstp	DWORD PTR _time$[ebp]

; 2472 :     if (time - last_time >= 0.3f)

	movss	xmm0, DWORD PTR _time$[ebp]
	subss	xmm0, DWORD PTR ?last_time@?1??ShowExampleAppLog@@YAXPA_N@Z@4MA
	comiss	xmm0, DWORD PTR __real@3e99999a
	jb	SHORT $LN3@ShowExampl

; 2473 :     {
; 2474 :         const char* random_words[] = { "system", "info", "warning", "error", "fatal", "notice", "log" };

	mov	DWORD PTR _random_words$2[ebp], OFFSET $SG12926
	mov	DWORD PTR _random_words$2[ebp+4], OFFSET $SG12927
	mov	DWORD PTR _random_words$2[ebp+8], OFFSET $SG12928
	mov	DWORD PTR _random_words$2[ebp+12], OFFSET $SG12929
	mov	DWORD PTR _random_words$2[ebp+16], OFFSET $SG12930
	mov	DWORD PTR _random_words$2[ebp+20], OFFSET $SG12931
	mov	DWORD PTR _random_words$2[ebp+24], OFFSET $SG12932

; 2475 :         log.AddLog("[%s] Hello, time is %.1f, rand() %d\n", random_words[rand() % IM_ARRAYSIZE(random_words)], time, (int)rand());

	call	DWORD PTR __imp__rand
	movss	xmm0, DWORD PTR _time$[ebp]
	cvtps2pd xmm0, xmm0
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__rand
	cdq
	mov	ecx, 7
	idiv	ecx
	mov	eax, DWORD PTR _random_words$2[ebp+edx*4]
	push	eax
	push	OFFSET $SG12933
	push	OFFSET ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A
	call	?AddLog@ExampleAppLog@@QAAXPBDZZ	; ExampleAppLog::AddLog

; 2476 :         last_time = time;

	movss	xmm0, DWORD PTR _time$[ebp]
	add	esp, 24					; 00000018H
	movss	DWORD PTR ?last_time@?1??ShowExampleAppLog@@YAXPA_N@Z@4MA, xmm0
$LN3@ShowExampl:

; 2477 :     }
; 2478 : 
; 2479 :     log.Draw("Example: Log", p_open);

	push	DWORD PTR _p_open$[ebp]
	mov	ecx, OFFSET ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A
	push	OFFSET $SG12934
	call	?Draw@ExampleAppLog@@QAEXPBDPA_N@Z	; ExampleAppLog::Draw

; 2480 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ShowExampleAppLog@@YAXPA_N@Z$0:
	push	OFFSET ?$TSS0@?1??ShowExampleAppLog@@YAXPA_N@Z@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__unwindfunclet$?ShowExampleAppLog@@YAXPA_N@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$ImVector@D@@QAE@XZ			; ImVector<char>::~ImVector<char>
__unwindfunclet$?ShowExampleAppLog@@YAXPA_N@Z$1:
	mov	ecx, OFFSET ?log@?1??ShowExampleAppLog@@YAXPA_N@Z@4UExampleAppLog@@A
	jmp	??1ImGuiTextBuffer@@QAE@XZ
__ehhandler$?ShowExampleAppLog@@YAXPA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ShowExampleAppLog@@YAXPA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShowExampleAppLog@@YAXPA_N@Z ENDP			; ShowExampleAppLog
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_p_open$ = 8						; size = 4
?ShowExampleAppConsole@@YAXPA_N@Z PROC			; ShowExampleAppConsole

; 2395 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ShowExampleAppConsole@@YAXPA_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 2396 :     static ExampleAppConsole console;

	mov	eax, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??ShowExampleAppConsole@@YAXPA_N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	SHORT $LN2@ShowExampl
	push	OFFSET ?$TSS0@?1??ShowExampleAppConsole@@YAXPA_N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??ShowExampleAppConsole@@YAXPA_N@Z@4HA, -1
	jne	SHORT $LN2@ShowExampl
	mov	ecx, OFFSET ?console@?1??ShowExampleAppConsole@@YAXPA_N@Z@4UExampleAppConsole@@A
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0ExampleAppConsole@@QAE@XZ		; ExampleAppConsole::ExampleAppConsole
	push	OFFSET ??__Fconsole@?1??ShowExampleAppConsole@@YAXPA_N@Z@YAXXZ ; `ShowExampleAppConsole'::`2'::`dynamic atexit destructor for 'console''
	call	_atexit
	push	OFFSET ?$TSS0@?1??ShowExampleAppConsole@@YAXPA_N@Z@4HA
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 8
$LN2@ShowExampl:

; 2397 :     console.Draw("Example: Console", p_open);

	push	DWORD PTR _p_open$[ebp]
	mov	ecx, OFFSET ?console@?1??ShowExampleAppConsole@@YAXPA_N@Z@4UExampleAppConsole@@A
	push	OFFSET $SG12789
	call	?Draw@ExampleAppConsole@@QAEXPBDPA_N@Z	; ExampleAppConsole::Draw

; 2398 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ShowExampleAppConsole@@YAXPA_N@Z$0:
	push	OFFSET ?$TSS0@?1??ShowExampleAppConsole@@YAXPA_N@Z@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__ehhandler$?ShowExampleAppConsole@@YAXPA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ShowExampleAppConsole@@YAXPA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShowExampleAppConsole@@YAXPA_N@Z ENDP			; ShowExampleAppConsole
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 735  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 736  :         return (float)sin(_X);

	movss	xmm0, DWORD PTR __X$[ebp]
	call	___libm_sse2_sinf
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]

; 737  :     }

	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 634  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 635  :         return (float)cos(_X);

	movss	xmm0, DWORD PTR __X$[ebp]
	call	___libm_sse2_cosf
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]

; 636  :     }

	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z PROC	; ImVector<ImFont *>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ENDP	; ImVector<ImFont *>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImVec2@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@UImVec2@@@@QAEXXZ PROC		; ImVector<ImVec2>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@UImVec2@@@@QAEXXZ ENDP		; ImVector<ImVec2>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z PROC	; ImVector<ImVec2>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	cmp	esi, ecx
	jne	SHORT $LN8@push_back
	inc	esi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, esi
	cmovg	esi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	esi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [esi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [edi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [edi+4], esi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	esi, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+edx*8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+edx*8+4], eax
	inc	DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ENDP	; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec2@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImVec2@@@@QAEXXZ PROC		; ImVector<ImVec2>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImVec2@@@@QAEXXZ ENDP		; ImVector<ImVec2>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImVec2@@@@QAEAAUImVec2@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImVec2@@@@QAEAAUImVec2@@H@Z PROC		; ImVector<ImVec2>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	pop	ebp
	ret	4
??A?$ImVector@UImVec2@@@@QAEAAUImVec2@@H@Z ENDP		; ImVector<ImVec2>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImVec2@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@UImVec2@@@@QBE_NXZ PROC		; ImVector<ImVec2>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@UImVec2@@@@QBE_NXZ ENDP		; ImVector<ImVec2>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec2@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImVec2@@@@QAE@XZ PROC			; ImVector<ImVec2>::~ImVector<ImVec2>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImVec2@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImVec2@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImVec2@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImVec2@@@@QAE@XZ ENDP			; ImVector<ImVec2>::~ImVector<ImVec2>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec2@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImVec2@@@@QAE@XZ PROC			; ImVector<ImVec2>::ImVector<ImVec2>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImVec2@@@@QAE@XZ ENDP			; ImVector<ImVec2>::ImVector<ImVec2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiListClipper@@QAE@XZ
_TEXT	SEGMENT
??1ImGuiListClipper@@QAE@XZ PROC			; ImGuiListClipper::~ImGuiListClipper, COMDAT
; _this$ = ecx

; 1159 :     ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

	ret	0
??1ImGuiListClipper@@QAE@XZ ENDP			; ImGuiListClipper::~ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImGuiListClipper@@QAE@HM@Z
_TEXT	SEGMENT
_items_count$ = 8					; size = 4
_items_height$ = 12					; size = 4
??0ImGuiListClipper@@QAE@HM@Z PROC			; ImGuiListClipper::ImGuiListClipper, COMDAT
; _this$ = ecx

; 1158 :     ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _items_height$[ebp]
	push	esi
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	esi, ecx
	push	DWORD PTR _items_count$[ebp]
	call	?Begin@ImGuiListClipper@@QAEXHM@Z	; ImGuiListClipper::Begin
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0ImGuiListClipper@@QAE@HM@Z ENDP			; ImGuiListClipper::ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?HSV@ImColor@@SA?AU1@MMMM@Z
_TEXT	SEGMENT
_b$ = -12						; size = 4
_g$ = -8						; size = 4
_r$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_h$ = 12						; size = 4
_s$ = 16						; size = 4
_v$ = 20						; size = 4
_a$ = 24						; size = 4
?HSV@ImColor@@SA?AU1@MMMM@Z PROC			; ImColor::HSV, COMDAT

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _v$[ebp]
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	eax, DWORD PTR _g$[ebp]
	push	eax
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _h$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	add	esp, 24					; 00000018H

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [eax+8], xmm0
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	mov	esp, ebp
	pop	ebp
	ret	0
?HSV@ImColor@@SA?AU1@MMMM@Z ENDP			; ImColor::HSV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??BImColor@@QBE?AUImVec4@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??BImColor@@QBE?AUImVec4@@XZ PROC			; ImColor::operator ImVec4, COMDAT
; _this$ = ecx

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	pop	ebp
	ret	4
??BImColor@@QBE?AUImVec4@@XZ ENDP			; ImColor::operator ImVec4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??BImColor@@QBEIXZ
_TEXT	SEGMENT
??BImColor@@QBEIXZ PROC					; ImColor::operator unsigned int, COMDAT
; _this$ = ecx

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	npad	2
	push	ecx
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	add	esp, 4
	ret	0
??BImColor@@QBEIXZ ENDP					; ImColor::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImColor@@QAE@ABUImVec4@@@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
??0ImColor@@QAE@ABUImVec4@@@Z PROC			; ImColor::ImColor, COMDAT
; _this$ = ecx

; 1127 :     ImColor(const ImVec4& col)                                      { Value = col; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _col$[ebp]

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx], 0

; 1127 :     ImColor(const ImVec4& col)                                      { Value = col; }

	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	pop	ebp
	ret	4
??0ImColor@@QAE@ABUImVec4@@@Z ENDP			; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImColor@@QAE@MMMM@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
??0ImColor@@QAE@MMMM@Z PROC				; ImColor::ImColor, COMDAT
; _this$ = ecx

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _r$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	16					; 00000010H
??0ImColor@@QAE@MMMM@Z ENDP				; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImColor@@QAE@HHHH@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
??0ImColor@@QAE@HHHH@Z PROC				; ImColor::ImColor, COMDAT
; _this$ = ecx

; 1124 :     ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }

	npad	2
	push	ebp
	mov	ebp, esp
	movd	xmm0, DWORD PTR _r$[ebp]
	mov	eax, ecx
	movss	xmm1, DWORD PTR __real@3b808081
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm0
	movd	xmm0, DWORD PTR _g$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+4], xmm0
	movd	xmm0, DWORD PTR _b$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+8], xmm0
	movd	xmm0, DWORD PTR _a$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	16					; 00000010H
??0ImColor@@QAE@HHHH@Z ENDP				; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiTextBuffer@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiTextBuffer@@QAE@XZ PROC				; ImGuiTextBuffer::~ImGuiTextBuffer, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiTextBuffer@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiTextB
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiTextB:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiTextBuffer@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiTextBuffer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiTextBuffer@@QAE@XZ ENDP				; ImGuiTextBuffer::~ImGuiTextBuffer
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@ImGuiTextBuffer@@QAEXXZ
_TEXT	SEGMENT
$T1 = -1						; size = 1
?clear@ImGuiTextBuffer@@QAEXXZ PROC			; ImGuiTextBuffer::clear, COMDAT
; _this$ = ecx

; 1006 :     void                clear() { Buf.clear(); Buf.push_back(0); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN4@clear:

; 1006 :     void                clear() { Buf.clear(); Buf.push_back(0); }

	lea	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR $T1[ebp], 0
	push	eax
	mov	ecx, esi
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@ImGuiTextBuffer@@QAEXXZ ENDP			; ImGuiTextBuffer::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?size@ImGuiTextBuffer@@QBEHXZ
_TEXT	SEGMENT
?size@ImGuiTextBuffer@@QBEHXZ PROC			; ImGuiTextBuffer::size, COMDAT
; _this$ = ecx

; 1004 :     int                 size() const { return Buf.Size - 1; }

	mov	eax, DWORD PTR [ecx]
	dec	eax
	ret	0
?size@ImGuiTextBuffer@@QBEHXZ ENDP			; ImGuiTextBuffer::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?end@ImGuiTextBuffer@@QBEPBDXZ
_TEXT	SEGMENT
?end@ImGuiTextBuffer@@QBEPBDXZ PROC			; ImGuiTextBuffer::end, COMDAT
; _this$ = ecx

; 1003 :     const char*         end() const { return &Buf.back(); }      // Buf is zero-terminated, so end() will point on the zero-terminator

	mov	eax, DWORD PTR [ecx]
	dec	eax
	add	eax, DWORD PTR [ecx+8]
	ret	0
?end@ImGuiTextBuffer@@QBEPBDXZ ENDP			; ImGuiTextBuffer::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?begin@ImGuiTextBuffer@@QBEPBDXZ
_TEXT	SEGMENT
?begin@ImGuiTextBuffer@@QBEPBDXZ PROC			; ImGuiTextBuffer::begin, COMDAT
; _this$ = ecx

; 1002 :     const char*         begin() const { return &Buf.front(); }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?begin@ImGuiTextBuffer@@QBEPBDXZ ENDP			; ImGuiTextBuffer::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??AImGuiTextBuffer@@QAEDH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??AImGuiTextBuffer@@QAEDH@Z PROC			; ImGuiTextBuffer::operator[], COMDAT
; _this$ = ecx

; 1001 :     inline char         operator[](int i) { return Buf.Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR [eax+ecx]
	pop	ebp
	ret	4
??AImGuiTextBuffer@@QAEDH@Z ENDP			; ImGuiTextBuffer::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImGuiTextBuffer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0ImGuiTextBuffer@@QAE@XZ PROC				; ImGuiTextBuffer::ImGuiTextBuffer, COMDAT
; _this$ = ecx

; 1000 :     ImGuiTextBuffer()   { Buf.push_back(0); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ImGuiTextBuffer@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0

; 1000 :     ImGuiTextBuffer()   { Buf.push_back(0); }

	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	mov	BYTE PTR $T2[ebp], 0
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImGuiTextBuffer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$ImVector@D@@QAE@XZ			; ImVector<char>::~ImVector<char>
__ehhandler$??0ImGuiTextBuffer@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0ImGuiTextBuffer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ImGuiTextBuffer@@QAE@XZ ENDP				; ImGuiTextBuffer::ImGuiTextBuffer
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@D@@QAEXABD@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@D@@QAEXABD@Z PROC			; ImVector<char>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back
	push	ebx

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	push	edi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	push	DWORD PTR [esi]
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [esi+8]
	pop	edi
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx], al
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@D@@QAEXABD@Z ENDP			; ImVector<char>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@D@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@D@@QAEXH@Z PROC			; ImVector<char>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	push	ebx
	push	edi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	push	DWORD PTR [esi]
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@D@@QAEXH@Z ENDP			; ImVector<char>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@D@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@D@@QAEHH@Z PROC		; ImVector<char>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@D@@QAEHH@Z ENDP		; ImVector<char>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@D@@QBEABDXZ
_TEXT	SEGMENT
?back@?$ImVector@D@@QBEABDXZ PROC			; ImVector<char>::back, COMDAT
; _this$ = ecx

; 923  :     inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	eax, DWORD PTR [ecx]
	dec	eax
	add	eax, DWORD PTR [ecx+8]
	ret	0
?back@?$ImVector@D@@QBEABDXZ ENDP			; ImVector<char>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?front@?$ImVector@D@@QBEABDXZ
_TEXT	SEGMENT
?front@?$ImVector@D@@QBEABDXZ PROC			; ImVector<char>::front, COMDAT
; _this$ = ecx

; 921  :     inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?front@?$ImVector@D@@QBEABDXZ ENDP			; ImVector<char>::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@D@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@D@@QAEXXZ PROC			; ImVector<char>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@D@@QAEXXZ ENDP			; ImVector<char>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@D@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@D@@QAE@XZ PROC				; ImVector<char>::~ImVector<char>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@D@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@D@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@D@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@D@@QAE@XZ ENDP				; ImVector<char>::~ImVector<char>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@D@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@D@@QAE@XZ PROC				; ImVector<char>::ImVector<char>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@D@@QAE@XZ ENDP				; ImVector<char>::ImVector<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?IsActive@ImGuiTextFilter@@QBE_NXZ
_TEXT	SEGMENT
?IsActive@ImGuiTextFilter@@QBE_NXZ PROC			; ImGuiTextFilter::IsActive, COMDAT
; _this$ = ecx

; 991  :     bool                IsActive() const { return !Filters.empty(); }

	cmp	DWORD PTR [ecx+256], 0
	setne	al
	ret	0
?IsActive@ImGuiTextFilter@@QBE_NXZ ENDP			; ImGuiTextFilter::IsActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiTextFilter@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiTextFilter@@QAE@XZ PROC				; ImGuiTextFilter::~ImGuiTextFilter, COMDAT
; _this$ = ecx

; 987  :     ~ImGuiTextFilter() {}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiTextFilter@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [ecx+264]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiTextF
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiTextF:

; 987  :     ~ImGuiTextFilter() {}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiTextFilter@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiTextFilter@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiTextFilter@@QAE@XZ ENDP				; ImGuiTextFilter::~ImGuiTextFilter
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QBE_NXZ PROC ; ImVector<ImGuiTextFilter::TextRange>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QBE_NXZ ENDP ; ImVector<ImGuiTextFilter::TextRange>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ PROC	; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ ENDP	; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_label$2 = -396						; size = 32
$T3 = -364						; size = 16
$T4 = -364						; size = 16
$T5 = -348						; size = 16
$T6 = -348						; size = 16
$T7 = -332						; size = 16
$T8 = -332						; size = 16
_items$9 = -316						; size = 44
_listbox_items$10 = -272				; size = 36
$T11 = -236						; size = 16
_names$12 = -220					; size = 12
$T13 = -216						; size = 8
$T14 = -208						; size = 16
$T15 = -208						; size = 16
$T16 = -208						; size = 16
$T17 = -192						; size = 16
$T18 = -192						; size = 16
$T19 = -192						; size = 16
$T20 = -192						; size = 16
$T21 = -192						; size = 16
$T22 = -192						; size = 16
_tex_screen_pos$23 = -176				; size = 8
_r$24 = -172						; size = 4
_r$25 = -172						; size = 4
_b$26 = -172						; size = 4
_lines$27 = -168					; size = 32
_label$28 = -168					; size = 32
_label$29 = -168					; size = 32
_buf$30 = -168						; size = 32
_buf$31 = -168						; size = 32
_label$32 = -168					; size = 32
_names$33 = -156					; size = 20
_values$34 = -156					; size = 20
$T35 = -152						; size = 16
$T36 = -152						; size = 16
_num_buf$37 = -152					; size = 16
$T38 = -152						; size = 16
$T39 = -152						; size = 16
$T40 = -152						; size = 16
$T41 = -152						; size = 16
_g$42 = -136						; size = 4
_g$43 = -136						; size = 4
_g$44 = -136						; size = 4
_b$45 = -132						; size = 4
_b$46 = -132						; size = 4
_r$47 = -132						; size = 4
_r$48 = -128						; size = 4
_r$49 = -128						; size = 4
_b$50 = -128						; size = 4
_clip_rect$51 = -124					; size = 16
$T52 = -124						; size = 16
$T53 = -124						; size = 16
$T54 = -124						; size = 16
$T55 = -124						; size = 16
$T56 = -124						; size = 16
$T57 = -124						; size = 16
$T58 = -124						; size = 16
$T59 = -124						; size = 16
_items$60 = -108					; size = 16
$T61 = -108						; size = 16
_paths$62 = -104					; size = 12
_value_raw$63 = -100					; size = 8
$T64 = -100						; size = 8
$T65 = -100						; size = 8
$T66 = -100						; size = 8
$T67 = -100						; size = 8
$T68 = -100						; size = 8
$T69 = -92						; size = 16
$T70 = -92						; size = 16
$T71 = -84						; size = 8
_uv0$72 = -84						; size = 8
$T73 = -84						; size = 8
$T74 = -84						; size = 8
$T75 = -84						; size = 8
_g$76 = -80						; size = 4
_g$77 = -80						; size = 4
_focus_3$1$ = -74					; size = 1
_focus_2$1$ = -73					; size = 1
$T78 = -72						; size = 8
$T79 = -72						; size = 8
$T80 = -72						; size = 8
$T81 = -72						; size = 8
$T82 = -72						; size = 8
_b$83 = -68						; size = 4
_r$84 = -68						; size = 4
__real@42000000$1$ = -64				; size = 4
_b$85 = -64						; size = 4
_b$86 = -64						; size = 4
tv4647 = -64						; size = 4
_g$87 = -64						; size = 4
_g$88 = -60						; size = 4
_g$89 = -60						; size = 4
_r$90 = -60						; size = 4
tv4662 = -60						; size = 4
tv4648 = -60						; size = 4
__y$ = -60						; size = 4
_tex_w$1$ = -56						; size = 4
_num_buttons$1$ = -56					; size = 4
_b$91 = -56						; size = 4
_g$92 = -56						; size = 4
_hue$1$ = -52						; size = 4
_tex_h$1$ = -52						; size = 4
_g$93 = -52						; size = 4
_r$94 = -52						; size = 4
_scroll_x_delta$1$ = -48				; size = 4
_spacing$1$ = -48					; size = 4
_focus_x$2$ = -48					; size = 4
_nx$1$ = -48						; size = 4
tv5692 = -48						; size = 4
_r$95 = -48						; size = 4
_b$96 = -48						; size = 4
__y$ = -48						; size = 4
__y$ = -48						; size = 4
_focus_y$2$ = -44					; size = 4
__x$1$ = -44						; size = 4
__x$1$ = -44						; size = 4
$T97 = -44						; size = 4
_i$1$ = -44						; size = 4
_i$1$ = -44						; size = 4
_line$1$ = -44						; size = 4
tv5696 = -44						; size = 4
tv5690 = -44						; size = 4
tv5689 = -44						; size = 4
tv5688 = -44						; size = 4
tv4861 = -44						; size = 4
tv4785 = -44						; size = 4
_scroll_x_delta$98 = -44				; size = 4
$T99 = -40						; size = 16
_value_with_lock_threshold$100 = -32			; size = 8
$T101 = -32						; size = 8
$T102 = -32						; size = 8
$T103 = -32						; size = 8
$T104 = -32						; size = 8
$T105 = -32						; size = 8
$T106 = -32						; size = 8
$T107 = -32						; size = 8
$T108 = -32						; size = 8
$T109 = -32						; size = 8
$T110 = -32						; size = 8
$T111 = -32						; size = 8
$T112 = -32						; size = 8
$T113 = -32						; size = 8
$T114 = -32						; size = 8
$T115 = -32						; size = 8
$T116 = -32						; size = 8
$T117 = -32						; size = 8
$T118 = -32						; size = 8
$T119 = -32						; size = 8
$T120 = -32						; size = 8
$T121 = -32						; size = 8
$T122 = -32						; size = 8
$T123 = -32						; size = 8
$T124 = -32						; size = 8
$T125 = -32						; size = 8
$T126 = -32						; size = 8
$T127 = -32						; size = 8
$T128 = -32						; size = 8
$T129 = -32						; size = 8
$T130 = -32						; size = 8
$T131 = -32						; size = 8
$T132 = -32						; size = 8
$T133 = -32						; size = 8
$T134 = -32						; size = 8
$T135 = -32						; size = 8
$T136 = -32						; size = 8
$T137 = -32						; size = 8
$T138 = -32						; size = 8
$T139 = -32						; size = 8
$T140 = -32						; size = 8
$T141 = -32						; size = 8
$T142 = -32						; size = 8
$T143 = -32						; size = 8
$T144 = -32						; size = 8
$T145 = -32						; size = 8
$T146 = -32						; size = 8
$T147 = -32						; size = 8
$T148 = -32						; size = 8
$T149 = -32						; size = 8
$T150 = -32						; size = 8
$T151 = -32						; size = 8
$T152 = -32						; size = 8
$T153 = -32						; size = 8
$T154 = -32						; size = 8
$T155 = -32						; size = 8
$T156 = -32						; size = 8
$T157 = -32						; size = 8
$T158 = -32						; size = 8
$T159 = -32						; size = 8
$T160 = -32						; size = 8
$T161 = -32						; size = 8
_small_slider_size$162 = -32				; size = 8
$T163 = -32						; size = 8
$T164 = -32						; size = 8
$T165 = -32						; size = 8
$T166 = -32						; size = 8
$T167 = -32						; size = 8
$T168 = -32						; size = 8
$T169 = -32						; size = 8
_mouse_delta$170 = -24					; size = 8
$T171 = -24						; size = 8
_pos$172 = -24						; size = 8
_size$173 = -24						; size = 8
_sz$174 = -24						; size = 8
$T175 = -24						; size = 8
$T176 = -24						; size = 8
$T177 = -24						; size = 8
$T178 = -24						; size = 8
$T179 = -24						; size = 8
$T180 = -24						; size = 8
$T181 = -24						; size = 8
$T182 = -24						; size = 8
$T183 = -24						; size = 8
$T184 = -24						; size = 8
$T185 = -24						; size = 8
$T186 = -24						; size = 8
$T187 = -24						; size = 8
$T188 = -24						; size = 8
$T189 = -24						; size = 8
$T190 = -24						; size = 8
$T191 = -24						; size = 8
$T192 = -24						; size = 8
$T193 = -24						; size = 8
$T194 = -24						; size = 8
$T195 = -24						; size = 8
$T196 = -24						; size = 8
_uv1$197 = -24						; size = 8
$T198 = -24						; size = 8
_pos$199 = -24						; size = 8
$T200 = -24						; size = 8
_io$1$ = -20						; size = 4
tv6815 = -20						; size = 4
tv6803 = -20						; size = 4
_r$201 = -20						; size = 4
__y$ = -20						; size = 4
_b$202 = -20						; size = 4
_focus_1$1$ = -13					; size = 1
_node_open$1$ = -13					; size = 1
_scroll_to$1$ = -13					; size = 1
_node_open$1$ = -13					; size = 1
_goto_line$1$ = -13					; size = 1
_node_open$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_p_open$ = 8						; size = 4
?ShowTestWindow@ImGui@@YAXPA_N@Z PROC			; ImGui::ShowTestWindow

; 112  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ShowTestWindow@ImGui@@YAXPA_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 384				; 00000180H

; 113  :     // Examples apps
; 114  :     static bool show_app_main_menu_bar = false;
; 115  :     static bool show_app_console = false;
; 116  :     static bool show_app_log = false;
; 117  :     static bool show_app_layout = false;
; 118  :     static bool show_app_property_editor = false;
; 119  :     static bool show_app_long_text = false;
; 120  :     static bool show_app_auto_resize = false;
; 121  :     static bool show_app_constrained_resize = false;
; 122  :     static bool show_app_fixed_overlay = false;
; 123  :     static bool show_app_manipulating_window_title = false;
; 124  :     static bool show_app_custom_rendering = false;
; 125  :     static bool show_app_style_editor = false;
; 126  : 
; 127  :     static bool show_app_metrics = false;
; 128  :     static bool show_app_about = false;
; 129  : 
; 130  :     if (show_app_main_menu_bar) ShowExampleAppMainMenuBar();

	cmp	BYTE PTR ?show_app_main_menu_bar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN125@ShowTestWi
	call	?ShowExampleAppMainMenuBar@@YAXXZ	; ShowExampleAppMainMenuBar
$LN125@ShowTestWi:

; 131  :     if (show_app_console) ShowExampleAppConsole(&show_app_console);

	cmp	BYTE PTR ?show_app_console@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN126@ShowTestWi
	push	OFFSET ?show_app_console@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppConsole@@YAXPA_N@Z	; ShowExampleAppConsole
	add	esp, 4
$LN126@ShowTestWi:

; 132  :     if (show_app_log) ShowExampleAppLog(&show_app_log);

	cmp	BYTE PTR ?show_app_log@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN127@ShowTestWi
	push	OFFSET ?show_app_log@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppLog@@YAXPA_N@Z		; ShowExampleAppLog
	add	esp, 4
$LN127@ShowTestWi:

; 133  :     if (show_app_layout) ShowExampleAppLayout(&show_app_layout);

	cmp	BYTE PTR ?show_app_layout@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN128@ShowTestWi
	push	OFFSET ?show_app_layout@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppLayout@@YAXPA_N@Z	; ShowExampleAppLayout
	add	esp, 4
$LN128@ShowTestWi:

; 134  :     if (show_app_property_editor) ShowExampleAppPropertyEditor(&show_app_property_editor);

	cmp	BYTE PTR ?show_app_property_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN129@ShowTestWi
	push	OFFSET ?show_app_property_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppPropertyEditor@@YAXPA_N@Z ; ShowExampleAppPropertyEditor
	add	esp, 4
$LN129@ShowTestWi:

; 135  :     if (show_app_long_text) ShowExampleAppLongText(&show_app_long_text);

	cmp	BYTE PTR ?show_app_long_text@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN130@ShowTestWi
	push	OFFSET ?show_app_long_text@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppLongText@@YAXPA_N@Z	; ShowExampleAppLongText
	add	esp, 4
$LN130@ShowTestWi:

; 136  :     if (show_app_auto_resize) ShowExampleAppAutoResize(&show_app_auto_resize);

	cmp	BYTE PTR ?show_app_auto_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN131@ShowTestWi
	push	OFFSET ?show_app_auto_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppAutoResize@@YAXPA_N@Z	; ShowExampleAppAutoResize
	add	esp, 4
$LN131@ShowTestWi:

; 137  :     if (show_app_constrained_resize) ShowExampleAppConstrainedResize(&show_app_constrained_resize);

	cmp	BYTE PTR ?show_app_constrained_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN132@ShowTestWi
	push	OFFSET ?show_app_constrained_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppConstrainedResize@@YAXPA_N@Z ; ShowExampleAppConstrainedResize
	add	esp, 4
$LN132@ShowTestWi:

; 138  :     if (show_app_fixed_overlay) ShowExampleAppFixedOverlay(&show_app_fixed_overlay);

	cmp	BYTE PTR ?show_app_fixed_overlay@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN133@ShowTestWi
	push	OFFSET ?show_app_fixed_overlay@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppFixedOverlay@@YAXPA_N@Z	; ShowExampleAppFixedOverlay
	add	esp, 4
$LN133@ShowTestWi:

; 139  :     if (show_app_manipulating_window_title) ShowExampleAppManipulatingWindowTitle(&show_app_manipulating_window_title);

	cmp	BYTE PTR ?show_app_manipulating_window_title@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN134@ShowTestWi
	push	OFFSET ?show_app_manipulating_window_title@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppManipulatingWindowTitle@@YAXPA_N@Z ; ShowExampleAppManipulatingWindowTitle
	add	esp, 4
$LN134@ShowTestWi:

; 140  :     if (show_app_custom_rendering) ShowExampleAppCustomRendering(&show_app_custom_rendering);

	cmp	BYTE PTR ?show_app_custom_rendering@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN135@ShowTestWi
	push	OFFSET ?show_app_custom_rendering@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowExampleAppCustomRendering@@YAXPA_N@Z ; ShowExampleAppCustomRendering
	add	esp, 4
$LN135@ShowTestWi:

; 141  : 
; 142  :     if (show_app_metrics) ImGui::ShowMetricsWindow(&show_app_metrics);

	cmp	BYTE PTR ?show_app_metrics@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN136@ShowTestWi
	push	OFFSET ?show_app_metrics@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	call	?ShowMetricsWindow@ImGui@@YAXPA_N@Z	; ImGui::ShowMetricsWindow
	add	esp, 4
$LN136@ShowTestWi:

; 143  :     if (show_app_style_editor) { ImGui::Begin("Style Editor", &show_app_style_editor); ImGui::ShowStyleEditor(); ImGui::End(); }

	cmp	BYTE PTR ?show_app_style_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN137@ShowTestWi
	push	0
	push	OFFSET ?show_app_style_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11082
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	push	0
	call	?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z ; ImGui::ShowStyleEditor
	add	esp, 16					; 00000010H
	call	?End@ImGui@@YAXXZ			; ImGui::End
$LN137@ShowTestWi:

; 144  :     if (show_app_about)

	cmp	BYTE PTR ?show_app_about@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN138@ShowTestWi

; 145  :     {
; 146  :         ImGui::Begin("About ImGui", &show_app_about, ImGuiWindowFlags_AlwaysAutoResize);

	push	64					; 00000040H
	push	OFFSET ?show_app_about@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11084
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin

; 147  :         ImGui::Text("dear imgui, %s", ImGui::GetVersion());

	call	?GetVersion@ImGui@@YAPBDXZ		; ImGui::GetVersion
	push	eax
	push	OFFSET $SG11085
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 148  :         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 149  :         ImGui::Text("By Omar Cornut and all github contributors.");

	push	OFFSET $SG11086
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 150  :         ImGui::Text("ImGui is licensed under the MIT License, see LICENSE for more information.");

	push	OFFSET $SG11087
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 28					; 0000001cH

; 151  :         ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
$LN138@ShowTestWi:

; 152  :     }
; 153  : 
; 154  :     static bool no_titlebar = false;
; 155  :     static bool no_border = true;
; 156  :     static bool no_resize = false;
; 157  :     static bool no_move = false;
; 158  :     static bool no_scrollbar = false;
; 159  :     static bool no_collapse = false;
; 160  :     static bool no_menu = false;
; 161  :     static bool no_nav = false;
; 162  : 
; 163  :     // Demonstrate the various window flags. Typically you would just use the default.
; 164  :     ImGuiWindowFlags window_flags = 0;

	push	esi
	xor	esi, esi

; 165  :     if (no_titlebar)  window_flags |= ImGuiWindowFlags_NoTitleBar;

	mov	eax, 1
	cmp	BYTE PTR ?no_titlebar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	cmovne	esi, eax

; 166  :     if (!no_border)   window_flags |= ImGuiWindowFlags_ShowBorders;

	cmp	BYTE PTR ?no_border@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	jne	SHORT $LN140@ShowTestWi
	or	esi, 128				; 00000080H
$LN140@ShowTestWi:

; 167  :     if (no_resize)    window_flags |= ImGuiWindowFlags_NoResize;

	cmp	BYTE PTR ?no_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN141@ShowTestWi
	or	esi, 2
$LN141@ShowTestWi:

; 168  :     if (no_move)      window_flags |= ImGuiWindowFlags_NoMove;

	cmp	BYTE PTR ?no_move@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN142@ShowTestWi
	or	esi, 4
$LN142@ShowTestWi:

; 169  :     if (no_scrollbar) window_flags |= ImGuiWindowFlags_NoScrollbar;

	cmp	BYTE PTR ?no_scrollbar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN143@ShowTestWi
	or	esi, 8
$LN143@ShowTestWi:

; 170  :     if (no_collapse)  window_flags |= ImGuiWindowFlags_NoCollapse;

	cmp	BYTE PTR ?no_collapse@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN144@ShowTestWi
	or	esi, 32					; 00000020H
$LN144@ShowTestWi:

; 171  :     if (!no_menu)     window_flags |= ImGuiWindowFlags_MenuBar;

	cmp	BYTE PTR ?no_menu@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	jne	SHORT $LN145@ShowTestWi
	or	esi, 1024				; 00000400H
$LN145@ShowTestWi:

; 172  :     if (no_nav)       window_flags |= ImGuiWindowFlags_NoNavInputs;

	cmp	BYTE PTR ?no_nav@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN146@ShowTestWi
	or	esi, 262144				; 00040000H
$LN146@ShowTestWi:

; 173  :     ImGui::SetNextWindowSize(ImVec2(550,680), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T200[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T200[ebp], 1141473280	; 44098000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 173  :     ImGui::SetNextWindowSize(ImVec2(550,680), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T200[ebp+4], 1143603200	; 442a0000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 173  :     ImGui::SetNextWindowSize(ImVec2(550,680), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 174  :     if (!ImGui::Begin("ImGui Demo", p_open, window_flags))

	push	esi
	push	DWORD PTR _p_open$[ebp]
	push	OFFSET $SG11097
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN147@ShowTestWi

; 175  :     {
; 176  :         // Early out if the window is collapsed, as an optimization.
; 177  :         ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	pop	esi

; 1636 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN147@ShowTestWi:

; 178  :         return;
; 179  :     }
; 180  : 
; 181  :     //ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.65f);    // 2/3 of the space for widget and 1/3 for labels
; 182  :     ImGui::PushItemWidth(-140);                                 // Right align, keep 140 pixels for labels

	push	ecx
	mov	DWORD PTR [esp], -1022623744		; c30c0000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 183  : 
; 184  :     ImGui::Text("Dear ImGui says hello.");

	push	OFFSET $SG11098
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 8

; 185  : 
; 186  :     // Menu
; 187  :     if (ImGui::BeginMenuBar())

	call	?BeginMenuBar@ImGui@@YA_NXZ		; ImGui::BeginMenuBar
	test	al, al
	je	$LN148@ShowTestWi

; 188  :     {
; 189  :         if (ImGui::BeginMenu("Menu"))

	push	1
	push	OFFSET $SG11101
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	SHORT $LN149@ShowTestWi

; 190  :         {
; 191  :             ShowExampleMenuFile();

	call	?ShowExampleMenuFile@@YAXXZ		; ShowExampleMenuFile

; 192  :             ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN149@ShowTestWi:

; 193  :         }
; 194  :         if (ImGui::BeginMenu("Examples"))

	push	1
	push	OFFSET $SG11103
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	$LN150@ShowTestWi

; 195  :         {
; 196  :             ImGui::MenuItem("Main menu bar", NULL, &show_app_main_menu_bar);

	push	1
	push	OFFSET ?show_app_main_menu_bar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11104
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 197  :             ImGui::MenuItem("Console", NULL, &show_app_console);

	push	1
	push	OFFSET ?show_app_console@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11105
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 198  :             ImGui::MenuItem("Log", NULL, &show_app_log);

	push	1
	push	OFFSET ?show_app_log@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11106
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 199  :             ImGui::MenuItem("Simple layout", NULL, &show_app_layout);

	push	1
	push	OFFSET ?show_app_layout@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11107
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem
	add	esp, 64					; 00000040H

; 200  :             ImGui::MenuItem("Property editor", NULL, &show_app_property_editor);

	push	1
	push	OFFSET ?show_app_property_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11108
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 201  :             ImGui::MenuItem("Long text display", NULL, &show_app_long_text);

	push	1
	push	OFFSET ?show_app_long_text@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11109
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 202  :             ImGui::MenuItem("Auto-resizing window", NULL, &show_app_auto_resize);

	push	1
	push	OFFSET ?show_app_auto_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11110
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 203  :             ImGui::MenuItem("Constrained-resizing window", NULL, &show_app_constrained_resize);

	push	1
	push	OFFSET ?show_app_constrained_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11111
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem
	add	esp, 64					; 00000040H

; 204  :             ImGui::MenuItem("Simple overlay", NULL, &show_app_fixed_overlay);

	push	1
	push	OFFSET ?show_app_fixed_overlay@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11112
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 205  :             ImGui::MenuItem("Manipulating window title", NULL, &show_app_manipulating_window_title);

	push	1
	push	OFFSET ?show_app_manipulating_window_title@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11113
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 206  :             ImGui::MenuItem("Custom rendering", NULL, &show_app_custom_rendering);

	push	1
	push	OFFSET ?show_app_custom_rendering@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11114
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem
	add	esp, 48					; 00000030H

; 207  :             ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN150@ShowTestWi:

; 208  :         }
; 209  :         if (ImGui::BeginMenu("Help"))

	push	1
	push	OFFSET $SG11116
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	SHORT $LN151@ShowTestWi

; 210  :         {
; 211  :             ImGui::MenuItem("Metrics", NULL, &show_app_metrics);

	push	1
	push	OFFSET ?show_app_metrics@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11117
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 212  :             ImGui::MenuItem("Style Editor", NULL, &show_app_style_editor);

	push	1
	push	OFFSET ?show_app_style_editor@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11118
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem

; 213  :             ImGui::MenuItem("About ImGui", NULL, &show_app_about);

	push	1
	push	OFFSET ?show_app_about@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	0
	push	OFFSET $SG11119
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem
	add	esp, 48					; 00000030H

; 214  :             ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN151@ShowTestWi:

; 215  :         }
; 216  :         ImGui::EndMenuBar();

	call	?EndMenuBar@ImGui@@YAXXZ		; ImGui::EndMenuBar
$LN148@ShowTestWi:

; 217  :     }
; 218  : 
; 219  :     ImGui::Spacing();

	call	?Spacing@ImGui@@YAXXZ			; ImGui::Spacing

; 220  :     if (ImGui::CollapsingHeader("Help"))

	push	0
	push	OFFSET $SG11121
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	SHORT $LN152@ShowTestWi

; 221  :     {
; 222  :         ImGui::TextWrapped("This window is being created by the ShowTestWindow() function. Please refer to the code for programming reference.\n\nUser Guide:");

	push	OFFSET $SG11122
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped
	add	esp, 4

; 223  :         ImGui::ShowUserGuide();

	call	?ShowUserGuide@ImGui@@YAXXZ		; ImGui::ShowUserGuide
$LN152@ShowTestWi:

; 224  :     }
; 225  : 
; 226  :     if (ImGui::CollapsingHeader("Window options"))

	push	0
	push	OFFSET $SG11124
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	$LN155@ShowTestWi

; 227  :     {
; 228  :         ImGui::Checkbox("No titlebar", &no_titlebar); ImGui::SameLine(150);

	push	OFFSET ?no_titlebar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11125
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1125515264		; 43160000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 229  :         ImGui::Checkbox("No border", &no_border); ImGui::SameLine(300);

	push	OFFSET ?no_border@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11126
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1133903872		; 43960000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 230  :         ImGui::Checkbox("No resize", &no_resize);

	push	OFFSET ?no_resize@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11127
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 231  :         ImGui::Checkbox("No move", &no_move); ImGui::SameLine(150);

	push	OFFSET ?no_move@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11128
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1125515264		; 43160000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 232  :         ImGui::Checkbox("No scrollbar", &no_scrollbar); ImGui::SameLine(300);

	push	OFFSET ?no_scrollbar@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11129
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1133903872		; 43960000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 233  :         ImGui::Checkbox("No collapse", &no_collapse);

	push	OFFSET ?no_collapse@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11130
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 234  :         ImGui::Checkbox("No menu", &no_menu); ImGui::SameLine(150);

	push	OFFSET ?no_menu@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11131
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1125515264		; 43160000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 235  :         ImGui::Checkbox("No nav", &no_nav);

	push	OFFSET ?no_nav@?1??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11132
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 236  : 
; 237  :         if (ImGui::TreeNode("Style"))

	push	OFFSET $SG11134
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN154@ShowTestWi

; 238  :         {
; 239  :             ImGui::ShowStyleEditor();

	push	0
	call	?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z ; ImGui::ShowStyleEditor
	add	esp, 4

; 240  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN154@ShowTestWi:

; 241  :         }
; 242  : 
; 243  :         if (ImGui::TreeNode("Logging"))

	push	OFFSET $SG11136
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN155@ShowTestWi

; 244  :         {
; 245  :             ImGui::TextWrapped("The logging API redirects all text output so you can easily capture the content of a window or a block. Tree nodes can be automatically expanded. You can also call ImGui::LogText() to output directly to the log without a visual output.");

	push	OFFSET $SG11137
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped
	add	esp, 4

; 246  :             ImGui::LogButtons();

	call	?LogButtons@ImGui@@YAXXZ		; ImGui::LogButtons

; 247  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN155@ShowTestWi:

; 248  :         }
; 249  :     }
; 250  : 
; 251  :     if (ImGui::CollapsingHeader("Widgets"))

	push	edi
	push	0
	push	OFFSET $SG11139
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	$LN211@ShowTestWi

; 252  :     {
; 253  :         if (ImGui::TreeNode("Trees"))

	push	OFFSET $SG11141
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN157@ShowTestWi

; 254  :         {
; 255  :             if (ImGui::TreeNode("Basic trees"))

	push	OFFSET $SG11143
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN158@ShowTestWi

; 256  :             {
; 257  :                 for (int i = 0; i < 5; i++)

	xor	esi, esi
	npad	7
$LL4@ShowTestWi:

; 258  :                     if (ImGui::TreeNode((void*)(intptr_t)i, "Child %d", i))

	push	esi
	push	OFFSET $SG11145
	push	esi
	call	?TreeNode@ImGui@@YA_NPBXPBDZZ		; ImGui::TreeNode
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN2@ShowTestWi

; 259  :                     {
; 260  :                         ImGui::Text("blah blah");

	push	OFFSET $SG11146
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 261  :                         ImGui::SameLine(); 

	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	ecx
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 262  :                         if (ImGui::SmallButton("print")) printf("Child %d pressed", i);

	push	OFFSET $SG11148
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN160@ShowTestWi
	push	esi
	push	OFFSET $SG11149
	call	_printf
	add	esp, 8
$LN160@ShowTestWi:

; 263  :                         ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN2@ShowTestWi:

; 256  :             {
; 257  :                 for (int i = 0; i < 5; i++)

	inc	esi
	cmp	esi, 5
	jl	SHORT $LL4@ShowTestWi

; 264  :                     }
; 265  :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN158@ShowTestWi:

; 266  :             }
; 267  : 
; 268  :             if (ImGui::TreeNode("Advanced, with Selectable nodes"))

	push	OFFSET $SG11151
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN161@ShowTestWi

; 269  :             {
; 270  :                 ShowHelpMarker("This is a more standard looking tree with selectable nodes.\nClick to select, CTRL+Click to toggle, click on arrows or double-click to open.");

	push	OFFSET $SG11152
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 271  :                 static bool align_label_with_current_x_position = false;
; 272  :                 ImGui::Checkbox("Align label with current X position)", &align_label_with_current_x_position);

	push	OFFSET ?align_label_with_current_x_position@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11153
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 273  :                 ImGui::Text("Hello!");

	push	OFFSET $SG11154
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H

; 274  :                 if (align_label_with_current_x_position)

	cmp	BYTE PTR ?align_label_with_current_x_position@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN162@ShowTestWi

; 275  :                     ImGui::Unindent(ImGui::GetTreeNodeToLabelSpacing());

	call	?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ	; ImGui::GetTreeNodeToLabelSpacing
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent
	add	esp, 4
$LN162@ShowTestWi:

; 276  : 
; 277  :                 static int selection_mask = (1 << 2); // Dumb representation of what may be user-side selection state. You may carry selection state inside or outside your objects in whatever format you see fit.
; 278  :                 int node_clicked = -1;                // Temporary storage of what node we have clicked to process selection at the end of the loop. May be a pointer to your own node type, etc.

	or	edi, -1

; 279  :                 ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, ImGui::GetFontSize()*3); // Increase spacing to differentiate leaves from expanded contents.

	call	?GetFontSize@ImGui@@YAMXZ		; ImGui::GetFontSize
	fmul	DWORD PTR __real@40400000
	push	ecx
	fstp	DWORD PTR [esp]
	push	9
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 280  :                 for (int i = 0; i < 6; i++)

	mov	eax, 1
	add	esp, 8
	xor	esi, esi
	rol	eax, 0
	mov	DWORD PTR $T97[ebp], eax
	npad	2
$LL7@ShowTestWi:

; 281  :                 {
; 282  :                     // Disable the default open on single-click behavior and pass in Selected flag according to our selection state.
; 283  :                     ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ((selection_mask & (1 << i)) ? ImGuiTreeNodeFlags_Selected : 0);

	and	eax, DWORD PTR ?selection_mask@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	neg	eax

; 284  :                     if (i < 3)
; 285  :                     {
; 286  :                         // Node
; 287  :                         bool node_open = ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Node %d", i);

	push	esi
	sbb	eax, eax
	neg	eax
	add	eax, 192				; 000000c0H
	cmp	esi, 3
	jge	SHORT $LN163@ShowTestWi
	push	OFFSET $SG11158
	push	eax
	push	esi
	call	?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ	; ImGui::TreeNodeEx

; 288  :                         if (ImGui::IsItemClicked()) 

	push	0
	mov	BYTE PTR _node_open$1$[ebp], al
	call	?IsItemClicked@ImGui@@YA_NH@Z		; ImGui::IsItemClicked
	add	esp, 20					; 00000014H
	test	al, al
	cmovne	edi, esi

; 289  :                             node_clicked = i;
; 290  :                         if (node_open)

	cmp	BYTE PTR _node_open$1$[ebp], 0
	je	SHORT $LN5@ShowTestWi

; 291  :                         {
; 292  :                             ImGui::Text("Blah blah\nBlah Blah");

	push	OFFSET $SG11161
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4

; 293  :                             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop

; 294  :                         }
; 295  :                     }
; 296  :                     else

	jmp	SHORT $LN5@ShowTestWi
$LN163@ShowTestWi:

; 297  :                     {
; 298  :                         // Leaf: The only reason we have a TreeNode at all is to allow selection of the leaf. Otherwise we can use BulletText() or TreeAdvanceToLabelPos()+Text().
; 299  :                         ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags | ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen, "Selectable Leaf %d", i);

	push	OFFSET $SG11162
	or	eax, 264				; 00000108H
	push	eax
	push	esi
	call	?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ	; ImGui::TreeNodeEx

; 300  :                         if (ImGui::IsItemClicked()) 

	push	0
	call	?IsItemClicked@ImGui@@YA_NH@Z		; ImGui::IsItemClicked
	add	esp, 20					; 00000014H
	test	al, al
	cmovne	edi, esi
$LN5@ShowTestWi:

; 280  :                 for (int i = 0; i < 6; i++)

	mov	eax, DWORD PTR $T97[ebp]
	inc	esi
	rol	eax, 1
	mov	DWORD PTR $T97[ebp], eax
	cmp	esi, 6
	jl	SHORT $LL7@ShowTestWi

; 301  :                             node_clicked = i;
; 302  :                     }
; 303  :                 }
; 304  :                 if (node_clicked != -1)

	cmp	edi, -1
	je	SHORT $LN170@ShowTestWi

; 305  :                 {
; 306  :                     // Update selection state. Process outside of tree loop to avoid visual inconsistencies during the clicking-frame.
; 307  :                     if (ImGui::GetIO().KeyCtrl)

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	cmp	BYTE PTR [eax+225], 0
	je	SHORT $LN169@ShowTestWi

; 308  :                         selection_mask ^= (1 << node_clicked);          // CTRL+click to toggle

	mov	eax, DWORD PTR ?selection_mask@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	btc	eax, edi

; 309  :                     else //if (!(selection_mask & (1 << node_clicked))) // Depending on selection behavior you want, this commented bit preserve selection when clicking on item that is part of the selection

	jmp	SHORT $LN882@ShowTestWi
$LN169@ShowTestWi:

; 310  :                         selection_mask = (1 << node_clicked);           // Click to single-select

	mov	eax, 1
	mov	ecx, edi
	shl	eax, cl
$LN882@ShowTestWi:
	mov	DWORD PTR ?selection_mask@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, eax
$LN170@ShowTestWi:

; 311  :                 }
; 312  :                 ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	add	esp, 4

; 313  :                 if (align_label_with_current_x_position)

	cmp	BYTE PTR ?align_label_with_current_x_position@?FN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN171@ShowTestWi

; 314  :                     ImGui::Indent(ImGui::GetTreeNodeToLabelSpacing());

	call	?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ	; ImGui::GetTreeNodeToLabelSpacing
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent
	add	esp, 4
$LN171@ShowTestWi:

; 315  :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN161@ShowTestWi:

; 316  :             }
; 317  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN157@ShowTestWi:

; 318  :         }
; 319  : 
; 320  :         if (ImGui::TreeNode("Collapsing Headers"))

	push	OFFSET $SG11169
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN172@ShowTestWi

; 321  :         {
; 322  :             static bool closable_group = true;
; 323  :             if (ImGui::CollapsingHeader("Header"))

	push	0
	push	OFFSET $SG11171
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	SHORT $LN9@ShowTestWi

; 324  :             {
; 325  :                 ImGui::Checkbox("Enable extra group", &closable_group);

	push	OFFSET ?closable_group@?HI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11172
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 8

; 326  :                 for (int i = 0; i < 5; i++)

	xor	esi, esi
	npad	2
$LL10@ShowTestWi:

; 327  :                     ImGui::Text("Some content %d", i);

	push	esi
	push	OFFSET $SG11173
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	inc	esi
	add	esp, 8
	cmp	esi, 5
	jl	SHORT $LL10@ShowTestWi
$LN9@ShowTestWi:

; 328  :             }
; 329  :             if (ImGui::CollapsingHeader("Header with a close button", &closable_group))

	push	0
	push	OFFSET ?closable_group@?HI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11175
	call	?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z	; ImGui::CollapsingHeader
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN12@ShowTestWi

; 330  :             {
; 331  :                 for (int i = 0; i < 5; i++)

	xor	esi, esi
	npad	2
$LL13@ShowTestWi:

; 332  :                     ImGui::Text("More content %d", i);

	push	esi
	push	OFFSET $SG11176
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	inc	esi
	add	esp, 8
	cmp	esi, 5
	jl	SHORT $LL13@ShowTestWi
$LN12@ShowTestWi:

; 333  :             }
; 334  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN172@ShowTestWi:

; 335  :         }
; 336  : 
; 337  :         if (ImGui::TreeNode("Bullets"))

	push	OFFSET $SG11178
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN175@ShowTestWi

; 338  :         {
; 339  :             ImGui::BulletText("Bullet point 1");

	push	OFFSET $SG11179
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 340  :             ImGui::BulletText("Bullet point 2\nOn multiple lines");

	push	OFFSET $SG11180
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 341  :             ImGui::Bullet(); ImGui::Text("Bullet point 3 (two calls)");

	call	?Bullet@ImGui@@YAXXZ			; ImGui::Bullet
	push	OFFSET $SG11181
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 342  :             ImGui::Bullet(); ImGui::SmallButton("Button");

	call	?Bullet@ImGui@@YAXXZ			; ImGui::Bullet
	push	OFFSET $SG11182
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 16					; 00000010H

; 343  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN175@ShowTestWi:

; 344  :         }
; 345  : 
; 346  :         if (ImGui::TreeNode("Colored Text"))

	push	OFFSET $SG11184
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN176@ShowTestWi

; 347  :         {
; 348  :             // Using shortcut. You can use PushStyleColor()/PopStyleColor() for more flexibility.
; 349  :             ImGui::TextColored(ImVec4(1.0f,0.0f,1.0f,1.0f), "Pink");

	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f800000000000003f800000
	lea	eax, DWORD PTR $T59[ebp]
	push	OFFSET $SG11185
	push	eax
	movups	XMMWORD PTR $T59[ebp], xmm0
	call	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ	; ImGui::TextColored
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f8000003f800000

; 350  :             ImGui::TextColored(ImVec4(1.0f,1.0f,0.0f,1.0f), "Yellow");

	lea	eax, DWORD PTR $T58[ebp]
	push	OFFSET $SG11186
	push	eax
	movups	XMMWORD PTR $T58[ebp], xmm0
	call	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ	; ImGui::TextColored

; 351  :             ImGui::TextDisabled("Disabled");

	push	OFFSET $SG11187
	call	?TextDisabled@ImGui@@YAXPBDZZ		; ImGui::TextDisabled
	add	esp, 20					; 00000014H

; 352  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN176@ShowTestWi:

; 353  :         }
; 354  : 
; 355  :         if (ImGui::TreeNode("Word Wrapping"))

	push	OFFSET $SG11189
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN177@ShowTestWi

; 356  :         {
; 357  :             // Using shortcut. You can use PushTextWrapPos()/PopTextWrapPos() for more flexibility.
; 358  :             ImGui::TextWrapped("This text should automatically wrap on the edge of the window. The current implementation for text wrapping follows simple rules suitable for English and possibly other languages.");

	push	OFFSET $SG11190
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 359  :             ImGui::Spacing();

	call	?Spacing@ImGui@@YAXXZ			; ImGui::Spacing

; 360  : 
; 361  :             static float wrap_width = 200.0f;
; 362  :             ImGui::SliderFloat("Wrap width", &wrap_width, -20, 600, "%.0f");

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11191
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1142292480		; 44160000H
	mov	DWORD PTR [esp], -1046478848		; c1a00000H
	push	OFFSET ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11192
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 363  : 
; 364  :             ImGui::Text("Test paragraph 1:");

	push	OFFSET $SG11193
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 365  :             ImVec2 pos = ImGui::GetCursorScreenPos();

	lea	eax, DWORD PTR _pos$199[ebp]
	push	eax
	call	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos

; 366  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	movss	xmm0, DWORD PTR ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	add	esp, 32					; 00000020H
	addss	xmm0, DWORD PTR _pos$199[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR __x$1$[ebp], xmm0
	call	?GetTextLineHeight@ImGui@@YAMXZ		; ImGui::GetTextLineHeight
	fadd	DWORD PTR _pos$199[ebp+4]
	lea	eax, DWORD PTR $T75[ebp]
	push	-1
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR __x$1$[ebp]
	movss	DWORD PTR $T75[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 366  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	fstp	DWORD PTR __y$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR $T75[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 366  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	movss	xmm0, DWORD PTR ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	addss	xmm0, DWORD PTR _pos$199[ebp]
	mov	DWORD PTR [esp], 0
	push	-65281					; ffff00ffH
	push	eax
	lea	eax, DWORD PTR $T82[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T82[ebp], xmm0
	movss	xmm0, DWORD PTR _pos$199[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 366  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T82[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 366  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	ecx, eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 367  :             ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);

	lea	eax, DWORD PTR $T169[ebp]
	push	eax
	call	?GetCursorPos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetCursorPos
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	movss	DWORD PTR [esp], xmm0
	call	?PushTextWrapPos@ImGui@@YAXM@Z		; ImGui::PushTextWrapPos
	movss	xmm0, DWORD PTR ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA

; 368  :             ImGui::Text("The lazy dog is a good dog. This paragraph is made to fit within %.0f pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.", wrap_width);

	cvtps2pd xmm0, xmm0
	push	ecx
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11194
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 369  :             ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));

	add	esp, 8
	lea	eax, DWORD PTR $T168[ebp]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	push	ecx
	mov	DWORD PTR [esp], 0
	push	-16711681				; ff00ffffH
	push	eax
	call	?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetItemRectMax
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T68[ebp]
	push	eax
	call	?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetItemRectMin
	add	esp, 4
	push	eax
	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	ecx, eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 370  :             ImGui::PopTextWrapPos();

	call	?PopTextWrapPos@ImGui@@YAXXZ		; ImGui::PopTextWrapPos

; 371  : 
; 372  :             ImGui::Text("Test paragraph 2:");

	push	OFFSET $SG11195
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 373  :             pos = ImGui::GetCursorScreenPos();

	lea	eax, DWORD PTR $T167[ebp]
	push	eax
	call	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos

; 374  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	movss	xmm0, DWORD PTR ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pos$199[ebp], ecx
	addss	xmm0, DWORD PTR _pos$199[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _pos$199[ebp+4], eax
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR __x$1$[ebp], xmm0
	call	?GetTextLineHeight@ImGui@@YAMXZ		; ImGui::GetTextLineHeight
	fadd	DWORD PTR _pos$199[ebp+4]
	lea	eax, DWORD PTR $T74[ebp]
	push	-1
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR __x$1$[ebp]
	movss	DWORD PTR $T74[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 374  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	fstp	DWORD PTR __y$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR $T74[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 374  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	movss	xmm0, DWORD PTR ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	addss	xmm0, DWORD PTR _pos$199[ebp]
	mov	DWORD PTR [esp], 0
	push	-65281					; ffff00ffH
	push	eax
	lea	eax, DWORD PTR $T81[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T81[ebp], xmm0
	movss	xmm0, DWORD PTR _pos$199[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 374  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T81[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 374  :             ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));

	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	ecx, eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 375  :             ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);

	lea	eax, DWORD PTR $T166[ebp]
	push	eax
	call	?GetCursorPos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetCursorPos
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR ?wrap_width@?IJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	movss	DWORD PTR [esp], xmm0
	call	?PushTextWrapPos@ImGui@@YAXM@Z		; ImGui::PushTextWrapPos

; 376  :             ImGui::Text("aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh");

	push	OFFSET $SG11196
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 377  :             ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));

	add	esp, 4
	lea	eax, DWORD PTR $T165[ebp]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	push	ecx
	mov	DWORD PTR [esp], 0
	push	-16711681				; ff00ffffH
	push	eax
	call	?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetItemRectMax
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T67[ebp]
	push	eax
	call	?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetItemRectMin
	add	esp, 4
	push	eax
	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	ecx, eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 378  :             ImGui::PopTextWrapPos();

	call	?PopTextWrapPos@ImGui@@YAXXZ		; ImGui::PopTextWrapPos

; 379  : 
; 380  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN177@ShowTestWi:

; 381  :         }
; 382  : 
; 383  :         if (ImGui::TreeNode("UTF-8 Text"))

	push	OFFSET $SG11198
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN178@ShowTestWi

; 384  :         {
; 385  :             // UTF-8 test with Japanese characters
; 386  :             // (needs a suitable font, try Arial Unicode or M+ fonts http://mplus-fonts.sourceforge.jp/mplus-outline-fonts/index-en.html)
; 387  :             // Most compiler appears to support UTF-8 in source code (with Visual Studio you need to save your file as 'UTF-8 without signature')
; 388  :             // However for the sake for maximum portability here we are *not* including raw UTF-8 character in this source file, instead we encode the string with hexadecimal constants.
; 389  :             // In your own application be reasonable and use UTF-8 in source or retrieve the data from file system!
; 390  :             // Note that characters values are preserved even if the font cannot be displayed, so you can safely copy & paste garbled characters into another application.
; 391  :             ImGui::TextWrapped("CJK text will only appears if the font was loaded with the appropriate CJK character ranges. Call io.Font->LoadFromFileTTF() manually to load extra character ranges.");

	push	OFFSET $SG11199
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 392  :             ImGui::Text("Hiragana: \xe3\x81\x8b\xe3\x81\x8d\xe3\x81\x8f\xe3\x81\x91\xe3\x81\x93 (kakikukeko)");

	push	OFFSET $SG11200
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 393  :             ImGui::Text("Kanjis: \xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e (nihongo)");

	push	OFFSET $SG11201
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 394  :             static char buf[32] = "\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e";
; 395  :             ImGui::InputText("UTF-8 input", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	32					; 00000020H
	push	OFFSET ?buf@?IM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11202
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 36					; 00000024H

; 396  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN178@ShowTestWi:

; 397  :         }
; 398  : 
; 399  :         if (ImGui::TreeNode("Images"))

	push	OFFSET $SG11204
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN179@ShowTestWi

; 400  :         {
; 401  :             ImGui::TextWrapped("Below we are displaying the font texture (which is the only texture we have access to in this demo). Use the 'ImTextureID' type as storage to pass pointers or identifier to your own texture data. Hover the texture for a zoomed view!");

	push	OFFSET $SG11205
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 402  :             ImVec2 tex_screen_pos = ImGui::GetCursorScreenPos();

	lea	eax, DWORD PTR _tex_screen_pos$23[ebp]
	push	eax
	call	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos

; 403  :             float tex_w = (float)ImGui::GetIO().Fonts->TexWidth;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	eax, DWORD PTR [eax+128]
	movd	xmm0, DWORD PTR [eax+12]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _tex_w$1$[ebp], xmm0

; 404  :             float tex_h = (float)ImGui::GetIO().Fonts->TexHeight;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	eax, DWORD PTR [eax+128]
	movd	xmm0, DWORD PTR [eax+16]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _tex_h$1$[ebp], xmm0

; 405  :             ImTextureID tex_id = ImGui::GetIO().Fonts->TexID;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR _tex_h$1$[ebp]

; 406  :             ImGui::Text("%.0fx%.0f", tex_w, tex_h);

	cvtps2pd xmm0, xmm0
	mov	eax, DWORD PTR [eax+128]
	mov	edi, DWORD PTR [eax]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movss	xmm0, DWORD PTR _tex_w$1$[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11206
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	movaps	xmm0, XMMWORD PTR __xmm@3f0080813f8000003f8000003f800000

; 407  :             ImGui::Image(tex_id, ImVec2(tex_w, tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	lea	eax, DWORD PTR $T57[ebp]
	push	eax
	lea	eax, DWORD PTR $T22[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T198[ebp], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 407  :             ImGui::Image(tex_id, ImVec2(tex_w, tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T57[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 407  :             ImGui::Image(tex_id, ImVec2(tex_w, tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	lea	eax, DWORD PTR $T198[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T198[ebp+4], 1065353216	; 3f800000H
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 407  :             ImGui::Image(tex_id, ImVec2(tex_w, tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	push	eax
	lea	eax, DWORD PTR $T73[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T73[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 407  :             ImGui::Image(tex_id, ImVec2(tex_w, tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T22[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 407  :             ImGui::Image(tex_id, ImVec2(tex_w, tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	lea	eax, DWORD PTR $T80[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T73[ebp+4], 0
	movss	xmm0, DWORD PTR _tex_w$1$[ebp]
	movss	DWORD PTR $T80[ebp], xmm0
	movss	xmm0, DWORD PTR _tex_h$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 407  :             ImGui::Image(tex_id, ImVec2(tex_w, tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	push	eax
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T80[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 407  :             ImGui::Image(tex_id, ImVec2(tex_w, tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	call	?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z ; ImGui::Image
	add	esp, 44					; 0000002cH

; 408  :             if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	$LN180@ShowTestWi

; 409  :             {
; 410  :                 ImGui::BeginTooltip();

	call	?BeginTooltip@ImGui@@YAXXZ		; ImGui::BeginTooltip

; 411  :                 float focus_sz = 32.0f;
; 412  :                 float focus_x = ImGui::GetMousePos().x - tex_screen_pos.x - focus_sz * 0.5f; if (focus_x < 0.0f) focus_x = 0.0f; else if (focus_x > tex_w - focus_sz) focus_x = tex_w - focus_sz;

	lea	eax, DWORD PTR $T164[ebp]
	push	eax
	call	?GetMousePos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetMousePos
	xorps	xmm0, xmm0
	add	esp, 4
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, DWORD PTR _tex_screen_pos$23[ebp]
	subss	xmm1, DWORD PTR __real@41800000
	comiss	xmm0, xmm1
	ja	SHORT $LN883@ShowTestWi
	movss	xmm0, DWORD PTR _tex_w$1$[ebp]
	subss	xmm0, DWORD PTR __real@42000000
	minss	xmm0, xmm1
$LN883@ShowTestWi:

; 413  :                 float focus_y = ImGui::GetMousePos().y - tex_screen_pos.y - focus_sz * 0.5f; if (focus_y < 0.0f) focus_y = 0.0f; else if (focus_y > tex_h - focus_sz) focus_y = tex_h - focus_sz;

	lea	eax, DWORD PTR $T163[ebp]
	movss	DWORD PTR _focus_x$2$[ebp], xmm0
	push	eax
	call	?GetMousePos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetMousePos
	xorps	xmm0, xmm0
	add	esp, 4
	movss	xmm1, DWORD PTR [eax+4]
	subss	xmm1, DWORD PTR _tex_screen_pos$23[ebp+4]
	subss	xmm1, DWORD PTR __real@41800000
	comiss	xmm0, xmm1
	ja	SHORT $LN884@ShowTestWi
	movss	xmm0, DWORD PTR _tex_h$1$[ebp]
	subss	xmm0, DWORD PTR __real@42000000
	minss	xmm0, xmm1
$LN884@ShowTestWi:

; 414  :                 ImGui::Text("Min: (%.2f, %.2f)", focus_x, focus_y);

	movss	DWORD PTR _focus_y$2$[ebp], xmm0
	sub	esp, 16					; 00000010H
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _focus_x$2$[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11214
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 415  :                 ImGui::Text("Max: (%.2f, %.2f)", focus_x + focus_sz, focus_y + focus_sz);

	movss	xmm0, DWORD PTR _focus_y$2$[ebp]
	add	esp, 4
	addss	xmm0, DWORD PTR __real@42000000
	movss	xmm1, DWORD PTR _focus_x$2$[ebp]
	addss	xmm1, DWORD PTR __real@42000000
	movss	DWORD PTR tv4648[ebp], xmm0
	cvtps2pd xmm0, xmm0
	movss	DWORD PTR tv4647[ebp], xmm1
	movsd	QWORD PTR [esp+8], xmm0
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11215
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 416  :                 ImVec2 uv0 = ImVec2((focus_x) / tex_w, (focus_y) / tex_h);

	movss	xmm1, DWORD PTR __real@3f800000

; 418  :                 ImGui::Image(tex_id, ImVec2(128,128), uv0, uv1, ImColor(255,255,255,255), ImColor(255,255,255,128));

	lea	eax, DWORD PTR $T56[ebp]
	movaps	xmm2, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T79[ebp], 1124073472		; 43000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 416  :                 ImVec2 uv0 = ImVec2((focus_x) / tex_w, (focus_y) / tex_h);

	divss	xmm2, DWORD PTR _tex_w$1$[ebp]

; 418  :                 ImGui::Image(tex_id, ImVec2(128,128), uv0, uv1, ImColor(255,255,255,255), ImColor(255,255,255,128));

	push	eax
	lea	eax, DWORD PTR $T21[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T79[ebp+4], 1124073472	; 43000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 418  :                 ImGui::Image(tex_id, ImVec2(128,128), uv0, uv1, ImColor(255,255,255,255), ImColor(255,255,255,128));

	push	eax
	lea	eax, DWORD PTR _uv1$197[ebp]
	push	eax
	lea	eax, DWORD PTR _uv0$72[ebp]
	push	eax
	lea	eax, DWORD PTR $T79[ebp]
	push	eax
	push	edi
	divss	xmm1, DWORD PTR _tex_h$1$[ebp]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _focus_x$2$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _uv0$72[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 416  :                 ImVec2 uv0 = ImVec2((focus_x) / tex_w, (focus_y) / tex_h);

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR _focus_y$2$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _uv0$72[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 417  :                 ImVec2 uv1 = ImVec2((focus_x + focus_sz) / tex_w, (focus_y + focus_sz) / tex_h);

	movss	xmm0, DWORD PTR tv4647[ebp]
	mulss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _uv1$197[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 417  :                 ImVec2 uv1 = ImVec2((focus_x + focus_sz) / tex_w, (focus_y + focus_sz) / tex_h);

	movss	xmm0, DWORD PTR tv4648[ebp]
	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _uv1$197[ebp+4], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f0080813f8000003f8000003f800000

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T56[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	movups	XMMWORD PTR $T21[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 418  :                 ImGui::Image(tex_id, ImVec2(128,128), uv0, uv1, ImColor(255,255,255,255), ImColor(255,255,255,128));

	call	?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z ; ImGui::Image
	add	esp, 44					; 0000002cH

; 419  :                 ImGui::EndTooltip();

	call	?EndTooltip@ImGui@@YAXXZ		; ImGui::EndTooltip
$LN180@ShowTestWi:

; 420  :             }
; 421  :             ImGui::TextWrapped("And now some textured buttons..");

	push	OFFSET $SG11216
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped
	movss	xmm0, DWORD PTR __real@42000000
	add	esp, 4
	movaps	xmm1, xmm0

; 422  :             static int pressed_count = 0;
; 423  :             for (int i = 0; i < 8; i++)

	xor	esi, esi
	divss	xmm1, DWORD PTR _tex_w$1$[ebp]
	divss	xmm0, DWORD PTR _tex_h$1$[ebp]
	movss	DWORD PTR tv4662[ebp], xmm1
	movss	DWORD PTR __real@42000000$1$[ebp], xmm0
$LL16@ShowTestWi:

; 424  :             {
; 425  :                 ImGui::PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000000000000000000000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 427  :                 if (ImGui::ImageButton(tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/tex_w,32/tex_h), frame_padding, ImColor(0,0,0,255)))

	lea	eax, DWORD PTR $T55[ebp]
	push	eax
	lea	eax, DWORD PTR $T20[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T71[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 427  :                 if (ImGui::ImageButton(tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/tex_w,32/tex_h), frame_padding, ImColor(0,0,0,255)))

	push	eax
	lea	eax, DWORD PTR [esi-1]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T71[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 427  :                 if (ImGui::ImageButton(tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/tex_w,32/tex_h), frame_padding, ImColor(0,0,0,255)))

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T20[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 427  :                 if (ImGui::ImageButton(tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/tex_w,32/tex_h), frame_padding, ImColor(0,0,0,255)))

	lea	eax, DWORD PTR $T196[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T78[ebp], 1107296256		; 42000000H
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 427  :                 if (ImGui::ImageButton(tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/tex_w,32/tex_h), frame_padding, ImColor(0,0,0,255)))

	push	eax
	lea	eax, DWORD PTR $T71[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T78[ebp+4], 1107296256	; 42000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 427  :                 if (ImGui::ImageButton(tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/tex_w,32/tex_h), frame_padding, ImColor(0,0,0,255)))

	push	eax
	movups	XMMWORD PTR $T55[ebp], xmm0
	lea	eax, DWORD PTR $T78[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR tv4662[ebp]
	movss	DWORD PTR $T196[ebp], xmm0
	movss	xmm0, DWORD PTR __real@42000000$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 427  :                 if (ImGui::ImageButton(tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/tex_w,32/tex_h), frame_padding, ImColor(0,0,0,255)))

	push	eax
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T196[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 427  :                 if (ImGui::ImageButton(tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/tex_w,32/tex_h), frame_padding, ImColor(0,0,0,255)))

	call	?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z ; ImGui::ImageButton
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN187@ShowTestWi

; 428  :                     pressed_count += 1;

	inc	DWORD PTR ?pressed_count@?IP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
$LN187@ShowTestWi:

; 429  :                 ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 430  :                 ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	inc	esi
	add	esp, 8
	cmp	esi, 8
	jl	$LL16@ShowTestWi

; 431  :             }
; 432  :             ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine

; 433  :             ImGui::Text("Pressed %d times.", pressed_count);

	push	DWORD PTR ?pressed_count@?IP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11218
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 8

; 434  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN179@ShowTestWi:

; 435  :         }
; 436  : 
; 437  :         if (ImGui::TreeNode("Selectables"))

	push	OFFSET $SG11220
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN188@ShowTestWi

; 438  :         {
; 439  :             if (ImGui::TreeNode("Basic"))

	push	OFFSET $SG11222
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN189@ShowTestWi

; 442  :                 ImGui::Selectable("1. I am selectable", &selected[0]);

	lea	eax, DWORD PTR $T195[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T195[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 442  :                 ImGui::Selectable("1. I am selectable", &selected[0]);

	push	eax
	push	0
	push	OFFSET ?selected@?KG@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA
	push	OFFSET $SG11223
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T195[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 442  :                 ImGui::Selectable("1. I am selectable", &selected[0]);

	call	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ; ImGui::Selectable

; 443  :                 ImGui::Selectable("2. I am selectable", &selected[1]);

	lea	eax, DWORD PTR $T194[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T194[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 443  :                 ImGui::Selectable("2. I am selectable", &selected[1]);

	push	eax
	push	0
	push	OFFSET ?selected@?KG@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA+1
	push	OFFSET $SG11224
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T194[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 443  :                 ImGui::Selectable("2. I am selectable", &selected[1]);

	call	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ; ImGui::Selectable

; 444  :                 ImGui::Text("3. I am not selectable");

	push	OFFSET $SG11225
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 445  :                 ImGui::Selectable("4. I am selectable", &selected[2]);

	lea	eax, DWORD PTR $T193[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T193[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 445  :                 ImGui::Selectable("4. I am selectable", &selected[2]);

	push	eax
	push	0
	push	OFFSET ?selected@?KG@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA+2
	push	OFFSET $SG11226
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T193[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 445  :                 ImGui::Selectable("4. I am selectable", &selected[2]);

	call	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ; ImGui::Selectable

; 446  :                 if (ImGui::Selectable("5. I am double clickable", selected[3], ImGuiSelectableFlags_AllowDoubleClick))

	lea	eax, DWORD PTR $T192[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T192[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 446  :                 if (ImGui::Selectable("5. I am double clickable", selected[3], ImGuiSelectableFlags_AllowDoubleClick))

	push	eax
	movzx	eax, BYTE PTR ?selected@?KG@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA+3
	push	4
	push	eax
	push	OFFSET $SG11228
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T192[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 446  :                 if (ImGui::Selectable("5. I am double clickable", selected[3], ImGuiSelectableFlags_AllowDoubleClick))

	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 68					; 00000044H
	test	al, al
	je	SHORT $LN191@ShowTestWi

; 447  :                     if (ImGui::IsMouseDoubleClicked(0))

	push	0
	call	?IsMouseDoubleClicked@ImGui@@YA_NH@Z	; ImGui::IsMouseDoubleClicked
	add	esp, 4
	test	al, al
	je	SHORT $LN191@ShowTestWi

; 448  :                         selected[3] = !selected[3];

	cmp	BYTE PTR ?selected@?KG@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA+3, 0
	sete	BYTE PTR ?selected@?KG@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA+3
$LN191@ShowTestWi:

; 449  :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN189@ShowTestWi:

; 450  :             }
; 451  :             if (ImGui::TreeNode("Rendering more text into the same block"))

	push	OFFSET $SG11231
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN192@ShowTestWi

; 454  :                 ImGui::Selectable("main.c", &selected[0]);    ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");

	lea	eax, DWORD PTR $T191[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T191[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 454  :                 ImGui::Selectable("main.c", &selected[0]);    ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");

	push	eax
	push	0
	push	OFFSET ?selected@?KN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA
	push	OFFSET $SG11232
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T191[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 454  :                 ImGui::Selectable("main.c", &selected[0]);    ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");

	call	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1133903872		; 43960000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11233
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 455  :                 ImGui::Selectable("Hello.cpp", &selected[1]); ImGui::SameLine(300); ImGui::Text("12,345 bytes");

	lea	eax, DWORD PTR $T190[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T190[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 455  :                 ImGui::Selectable("Hello.cpp", &selected[1]); ImGui::SameLine(300); ImGui::Text("12,345 bytes");

	push	eax
	push	0
	push	OFFSET ?selected@?KN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA+1
	push	OFFSET $SG11234
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T190[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 455  :                 ImGui::Selectable("Hello.cpp", &selected[1]); ImGui::SameLine(300); ImGui::Text("12,345 bytes");

	call	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1133903872		; 43960000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11235
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 456  :                 ImGui::Selectable("Hello.h", &selected[2]);   ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");

	lea	eax, DWORD PTR $T189[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T189[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 456  :                 ImGui::Selectable("Hello.h", &selected[2]);   ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");

	push	eax
	push	0
	push	OFFSET ?selected@?KN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA+2
	push	OFFSET $SG11236
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T189[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 456  :                 ImGui::Selectable("Hello.h", &selected[2]);   ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");

	call	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1133903872		; 43960000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11237
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH

; 457  :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN192@ShowTestWi:

; 458  :             }
; 459  :             if (ImGui::TreeNode("In columns"))

	push	OFFSET $SG11239
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN193@ShowTestWi

; 460  :             {
; 461  :                 ImGui::Columns(3, NULL, false);

	push	0
	push	0
	push	3
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 12					; 0000000cH

; 462  :                 static bool selected[16] = { 0 };
; 463  :                 for (int i = 0; i < 16; i++)

	xor	esi, esi
	npad	8
$LL19@ShowTestWi:

; 464  :                 {
; 465  :                     char label[32]; sprintf(label, "Item %d", i);

	push	esi
	lea	eax, DWORD PTR _label$32[ebp]
	push	OFFSET $SG11240
	push	eax
	call	_sprintf

; 466  :                     if (ImGui::Selectable(label, &selected[i])) {}

	lea	eax, DWORD PTR $T188[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T188[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 466  :                     if (ImGui::Selectable(label, &selected[i])) {}

	push	eax
	push	0
	lea	eax, DWORD PTR ?selected@?LA@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA[esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T188[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 466  :                     if (ImGui::Selectable(label, &selected[i])) {}

	push	eax
	lea	eax, DWORD PTR _label$32[ebp]
	push	eax
	call	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 28					; 0000001cH

; 467  :                     ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
	inc	esi
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL19@ShowTestWi

; 468  :                 }
; 469  :                 ImGui::Columns(1);

	push	1
	push	0
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 12					; 0000000cH

; 470  :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN193@ShowTestWi:

; 471  :             }
; 472  :             if (ImGui::TreeNode("Grid"))

	push	OFFSET $SG11243
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN195@ShowTestWi

; 473  :             {
; 474  :                 static bool selected[16] = { true, false, false, false, false, true, false, false, false, false, true, false, false, false, false, true };
; 475  :                 for (int i = 0; i < 16; i++)

	xor	esi, esi
$LL22@ShowTestWi:

; 476  :                 {
; 477  :                     ImGui::PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 478  :                     if (ImGui::Selectable("Sailor", &selected[i], 0, ImVec2(50,50)))

	lea	eax, DWORD PTR $T187[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T187[ebp], 1112014848	; 42480000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 478  :                     if (ImGui::Selectable("Sailor", &selected[i], 0, ImVec2(50,50)))

	push	eax
	push	0
	lea	eax, DWORD PTR ?selected@?LI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA[esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T187[ebp+4], 1112014848	; 42480000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 478  :                     if (ImGui::Selectable("Sailor", &selected[i], 0, ImVec2(50,50)))

	push	eax
	push	OFFSET $SG11245
	call	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN200@ShowTestWi

; 479  :                     {
; 480  :                         int x = i % 4, y = i / 4;

	mov	ecx, esi
	mov	eax, esi
	shr	ecx, 2
	and	eax, 3

; 481  :                         if (x > 0) selected[i - 1] ^= 1;

	je	SHORT $LN197@ShowTestWi
	xor	BYTE PTR ?selected@?LI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA[esi-1], 1
$LN197@ShowTestWi:
	cmp	eax, 3

; 482  :                         if (x < 3) selected[i + 1] ^= 1;

	jae	SHORT $LN198@ShowTestWi
	xor	BYTE PTR ?selected@?LI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA[esi+1], 1
$LN198@ShowTestWi:
	test	ecx, ecx

; 483  :                         if (y > 0) selected[i - 4] ^= 1;

	je	SHORT $LN199@ShowTestWi
	xor	BYTE PTR ?selected@?LI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA[esi-4], 1
$LN199@ShowTestWi:
	cmp	ecx, 3

; 484  :                         if (y < 3) selected[i + 4] ^= 1;

	jae	SHORT $LN200@ShowTestWi
	xor	BYTE PTR ?selected@?LI@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA[esi+4], 1
$LN200@ShowTestWi:

; 485  :                     }
; 486  :                     if ((i % 4) < 3) ImGui::SameLine();

	mov	eax, esi
	and	eax, 3
	cmp	al, 3
	jae	SHORT $LN201@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN201@ShowTestWi:

; 487  :                     ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	inc	esi
	cmp	esi, 16					; 00000010H
	jl	$LL22@ShowTestWi

; 488  :                 }
; 489  :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN195@ShowTestWi:

; 490  :             }
; 491  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN188@ShowTestWi:

; 492  :         }
; 493  : 
; 494  :         if (ImGui::TreeNode("Filtered Text Input"))

	push	OFFSET $SG11252
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN202@ShowTestWi

; 495  :         {
; 496  :             static char buf1[64] = ""; ImGui::InputText("default", buf1, 64);

	push	0
	push	0
	push	0
	push	64					; 00000040H
	push	OFFSET ?buf1@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11253
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 497  :             static char buf2[64] = ""; ImGui::InputText("decimal", buf2, 64, ImGuiInputTextFlags_CharsDecimal);

	push	0
	push	0
	push	1
	push	64					; 00000040H
	push	OFFSET ?buf2@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11254
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 498  :             static char buf3[64] = ""; ImGui::InputText("hexadecimal", buf3, 64, ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase);

	push	0
	push	0
	push	6
	push	64					; 00000040H
	push	OFFSET ?buf3@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11255
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 72					; 00000048H

; 499  :             static char buf4[64] = ""; ImGui::InputText("uppercase", buf4, 64, ImGuiInputTextFlags_CharsUppercase);

	push	0
	push	0
	push	4
	push	64					; 00000040H
	push	OFFSET ?buf4@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11256
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 500  :             static char buf5[64] = ""; ImGui::InputText("no blank", buf5, 64, ImGuiInputTextFlags_CharsNoBlank);

	push	0
	push	0
	push	8
	push	64					; 00000040H
	push	OFFSET ?buf5@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11257
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 501  :             struct TextFilters { static int FilterImGuiLetters(ImGuiTextEditCallbackData* data) { if (data->EventChar < 256 && strchr("imgui", (char)data->EventChar)) return 0; return 1; } };
; 502  :             static char buf6[64] = ""; ImGui::InputText("\"imgui\" letters", buf6, 64, ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterImGuiLetters);

	push	0
	push	OFFSET ?FilterImGuiLetters@TextFilters@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAHPAUImGuiTextEditCallbackData@@@Z ; `ImGui::ShowTestWindow'::`202'::TextFilters::FilterImGuiLetters
	push	512					; 00000200H
	push	64					; 00000040H
	push	OFFSET ?buf6@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11258
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 72					; 00000048H

; 503  : 
; 504  :             ImGui::Text("Password input");

	push	OFFSET $SG11259
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 505  :             static char bufpass[64] = "password123";
; 506  :             ImGui::InputText("password", bufpass, 64, ImGuiInputTextFlags_Password | ImGuiInputTextFlags_CharsNoBlank);

	push	0
	push	0
	push	32776					; 00008008H
	push	64					; 00000040H
	push	OFFSET ?bufpass@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11260
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 507  :             ImGui::SameLine(); ShowHelpMarker("Display all characters as '*'.\nDisable clipboard cut and copy.\nDisable logging.\n");

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11261
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 508  :             ImGui::InputText("password (clear)", bufpass, 64, ImGuiInputTextFlags_CharsNoBlank);

	push	0
	push	0
	push	8
	push	64					; 00000040H
	push	OFFSET ?bufpass@?MK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11262
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 36					; 00000024H

; 509  : 
; 510  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN202@ShowTestWi:

; 511  :         }
; 512  : 
; 513  :         if (ImGui::TreeNode("Multi-line Text Input"))

	push	OFFSET $SG11264
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN203@ShowTestWi

; 528  :             ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	lea	eax, DWORD PTR $T186[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T186[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 528  :             ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	push	eax
	push	5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T186[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 528  :             ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 529  :             ImGui::Checkbox("Read-only", &read_only);

	push	OFFSET ?read_only@?MN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11265
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 530  :             ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 531  :             ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16), ImGuiInputTextFlags_AllowTabInput | (read_only ? ImGuiInputTextFlags_ReadOnly : 0));

	call	?GetTextLineHeight@ImGui@@YAMXZ		; ImGui::GetTextLineHeight
	fmul	DWORD PTR __real@41800000
	xor	eax, eax
	cmp	BYTE PTR ?read_only@?MN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, al
	mov	ecx, 16384				; 00004000H
	push	0
	push	0
	cmovne	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T185[ebp], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 531  :             ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16), ImGuiInputTextFlags_AllowTabInput | (read_only ? ImGuiInputTextFlags_ReadOnly : 0));

	or	eax, 1024				; 00000400H
	push	eax
	lea	eax, DWORD PTR $T185[ebp]
	push	eax
	push	ecx
	fstp	DWORD PTR __y$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR __y$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 531  :             ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16), ImGuiInputTextFlags_AllowTabInput | (read_only ? ImGuiInputTextFlags_ReadOnly : 0));

	push	OFFSET ?text@?MN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11266
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T185[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 531  :             ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16), ImGuiInputTextFlags_AllowTabInput | (read_only ? ImGuiInputTextFlags_ReadOnly : 0));

	call	?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputTextMultiline
	add	esp, 48					; 00000030H

; 532  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN203@ShowTestWi:

; 536  :         if (ImGui::Button("Button")) 

	lea	eax, DWORD PTR $T184[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T184[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 536  :         if (ImGui::Button("Button")) 

	push	eax
	push	OFFSET $SG11268
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T184[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 536  :         if (ImGui::Button("Button")) 

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	test	al, al

; 537  :             clicked++;

	mov	eax, DWORD PTR ?clicked@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	je	SHORT $LN204@ShowTestWi
	inc	eax
	mov	DWORD PTR ?clicked@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, eax
$LN204@ShowTestWi:

; 538  :         if (clicked & 1)

	test	al, 1
	je	SHORT $LN205@ShowTestWi

; 539  :         {
; 540  :             ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 541  :             ImGui::Text("Thanks for clicking me!");

	push	OFFSET $SG11270
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH
$LN205@ShowTestWi:

; 542  :         }
; 543  : 
; 544  :         static bool check = true;
; 545  :         ImGui::Checkbox("checkbox", &check);

	push	OFFSET ?check@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11271
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 546  : 
; 547  :         static int e = 0;
; 548  :         ImGui::RadioButton("radio a", &e, 0); ImGui::SameLine();

	push	0
	push	OFFSET ?e@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11272
	call	?RadioButton@ImGui@@YA_NPBDPAHH@Z	; ImGui::RadioButton
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 549  :         ImGui::RadioButton("radio b", &e, 1); ImGui::SameLine();

	push	1
	push	OFFSET ?e@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11273
	call	?RadioButton@ImGui@@YA_NPBDPAHH@Z	; ImGui::RadioButton
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 550  :         ImGui::RadioButton("radio c", &e, 2);

	push	2
	push	OFFSET ?e@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11274
	call	?RadioButton@ImGui@@YA_NPBDPAHH@Z	; ImGui::RadioButton
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	DWORD PTR $T99[ebp+12], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 553  :         for (int i = 0; i < 7; i++)

	xor	esi, esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	DWORD PTR $T61[ebp+12], 1065353216	; 3f800000H
	mov	DWORD PTR $T70[ebp+12], 1065353216	; 3f800000H
	npad	3
$LL25@ShowTestWi:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 555  :             if (i > 0) ImGui::SameLine();

	test	esi, esi
	jle	SHORT $LN206@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN206@ShowTestWi:

; 556  :             ImGui::PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
	add	esp, 4
	movd	xmm0, esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	lea	eax, DWORD PTR _b$96[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 557  :             ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(i/7.0f, 0.6f, 0.6f));

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	lea	eax, DWORD PTR _g$87[ebp]
	push	eax
	lea	eax, DWORD PTR _r$90[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 557  :             ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(i/7.0f, 0.6f, 0.6f));

	mulss	xmm0, DWORD PTR __real@3e124925
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	sub	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 557  :             ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(i/7.0f, 0.6f, 0.6f));

	movss	DWORD PTR tv4785[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	mov	DWORD PTR [esp+8], 1058642330		; 3f19999aH
	mov	DWORD PTR [esp+4], 1058642330		; 3f19999aH
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$90[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 557  :             ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(i/7.0f, 0.6f, 0.6f));

	lea	eax, DWORD PTR $T54[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T99[ebp], xmm0
	movss	xmm0, DWORD PTR _g$87[ebp]
	movss	DWORD PTR $T99[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$96[ebp]
	movss	DWORD PTR $T99[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T99[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 557  :             ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(i/7.0f, 0.6f, 0.6f));

	push	eax
	push	22					; 00000016H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T54[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 557  :             ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(i/7.0f, 0.6f, 0.6f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	xmm0, DWORD PTR tv4785[ebp]
	lea	eax, DWORD PTR _b$50[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 557  :             ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(i/7.0f, 0.6f, 0.6f));

	add	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	lea	eax, DWORD PTR _g$92[ebp]
	push	eax
	lea	eax, DWORD PTR _r$94[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1060320051		; 3f333333H
	mov	DWORD PTR [esp+4], 1060320051		; 3f333333H
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$94[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 558  :             ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImColor::HSV(i/7.0f, 0.7f, 0.7f));

	lea	eax, DWORD PTR $T19[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T61[ebp], xmm0
	movss	xmm0, DWORD PTR _g$92[ebp]
	movss	DWORD PTR $T61[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$50[ebp]
	movss	DWORD PTR $T61[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T61[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 558  :             ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImColor::HSV(i/7.0f, 0.7f, 0.7f));

	push	eax
	push	23					; 00000017H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T19[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 558  :             ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImColor::HSV(i/7.0f, 0.7f, 0.7f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	xmm0, DWORD PTR tv4785[ebp]
	lea	eax, DWORD PTR _b$26[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 558  :             ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImColor::HSV(i/7.0f, 0.7f, 0.7f));

	add	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	lea	eax, DWORD PTR _g$44[ebp]
	push	eax
	lea	eax, DWORD PTR _r$47[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1061997773		; 3f4ccccdH
	mov	DWORD PTR [esp+4], 1061997773		; 3f4ccccdH
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$47[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 559  :             ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImColor::HSV(i/7.0f, 0.8f, 0.8f));

	lea	eax, DWORD PTR $T16[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T70[ebp], xmm0
	movss	xmm0, DWORD PTR _g$44[ebp]
	movss	DWORD PTR $T70[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$26[ebp]
	movss	DWORD PTR $T70[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T70[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 559  :             ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImColor::HSV(i/7.0f, 0.8f, 0.8f));

	push	eax
	push	24					; 00000018H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T16[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 559  :             ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImColor::HSV(i/7.0f, 0.8f, 0.8f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T183[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 560  :             ImGui::Button("Click");

	lea	eax, DWORD PTR $T183[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T183[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 560  :             ImGui::Button("Click");

	push	eax
	push	OFFSET $SG11276
	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 561  :             ImGui::PopStyleColor(3);

	push	3
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 44					; 0000002cH

; 562  :             ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	inc	esi
	cmp	esi, 7
	jl	$LL25@ShowTestWi

; 563  :         }
; 564  : 
; 565  :         ImGui::Text("Hover over me");

	push	OFFSET $SG11277
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4

; 566  :         if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN207@ShowTestWi

; 567  :             ImGui::SetTooltip("I am a tooltip");

	push	OFFSET $SG11279
	call	?SetTooltip@ImGui@@YAXPBDZZ		; ImGui::SetTooltip
	add	esp, 4
$LN207@ShowTestWi:

; 568  : 
; 569  :         ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 570  :         ImGui::Text("- or me");

	push	OFFSET $SG11280
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH

; 571  :         if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN208@ShowTestWi

; 572  :         {
; 573  :             ImGui::BeginTooltip();

	call	?BeginTooltip@ImGui@@YAXXZ		; ImGui::BeginTooltip

; 574  :             ImGui::Text("I am a fancy tooltip");

	push	OFFSET $SG11282
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T182[ebp+4], 0
	mov	DWORD PTR $T182[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 576  :             ImGui::PlotLines("Curve", arr, IM_ARRAYSIZE(arr));

	push	4
	push	DWORD PTR $T182[ebp+4]
	push	DWORD PTR $T182[ebp]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esp], 2139095039		; 7f7fffffH
	push	0
	push	0
	push	7
	push	OFFSET ?arr@?NL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11283
	call	?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ; ImGui::PlotLines
	add	esp, 40					; 00000028H

; 577  :             ImGui::EndTooltip();

	call	?EndTooltip@ImGui@@YAXXZ		; ImGui::EndTooltip
$LN208@ShowTestWi:

; 578  :         }
; 579  : 
; 580  :         // Testing IMGUI_ONCE_UPON_A_FRAME macro
; 581  :         //for (int i = 0; i < 5; i++)
; 582  :         //{
; 583  :         //  IMGUI_ONCE_UPON_A_FRAME
; 584  :         //  {
; 585  :         //      ImGui::Text("This will be displayed only once.");
; 586  :         //  }
; 587  :         //}
; 588  : 
; 589  :         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 590  : 
; 591  :         ImGui::LabelText("label", "Value");

	push	OFFSET $SG11284
	push	OFFSET $SG11285
	call	?LabelText@ImGui@@YAXPBD0ZZ		; ImGui::LabelText

; 592  : 
; 593  :         static int item = 1;
; 594  :         ImGui::Combo("combo", &item, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");   // Combo using values packed in a single constant string (for really quick combo)

	push	-1
	push	OFFSET $SG11286
	push	OFFSET ?item@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11287
	call	?Combo@ImGui@@YA_NPBDPAH0H@Z		; ImGui::Combo

; 595  : 
; 596  :         const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK" };
; 597  :         static int item2 = -1;
; 598  :         ImGui::Combo("combo scroll", &item2, items, IM_ARRAYSIZE(items));   // Combo using proper array. You can also pass a callback to retrieve array value, no need to create/copy an array just for that.

	push	-1
	push	11					; 0000000bH
	lea	eax, DWORD PTR _items$9[ebp]
	mov	DWORD PTR _items$9[ebp], OFFSET $SG11288
	push	eax
	push	OFFSET ?item2@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11299
	mov	DWORD PTR _items$9[ebp+4], OFFSET $SG11289
	mov	DWORD PTR _items$9[ebp+8], OFFSET $SG11290
	mov	DWORD PTR _items$9[ebp+12], OFFSET $SG11291
	mov	DWORD PTR _items$9[ebp+16], OFFSET $SG11292
	mov	DWORD PTR _items$9[ebp+20], OFFSET $SG11293
	mov	DWORD PTR _items$9[ebp+24], OFFSET $SG11294
	mov	DWORD PTR _items$9[ebp+28], OFFSET $SG11295
	mov	DWORD PTR _items$9[ebp+32], OFFSET $SG11296
	mov	DWORD PTR _items$9[ebp+36], OFFSET $SG11297
	mov	DWORD PTR _items$9[ebp+40], OFFSET $SG11298
	call	?Combo@ImGui@@YA_NPBDPAHPBQBDHH@Z	; ImGui::Combo

; 599  : 
; 600  :         {
; 601  :             static char str0[128] = "Hello, world!";
; 602  :             static int i0=123;
; 603  :             static float f0=0.001f;
; 604  :             ImGui::InputText("input text", str0, IM_ARRAYSIZE(str0));

	push	0
	push	0
	push	0
	push	128					; 00000080H
	push	OFFSET ?str0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11300
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 605  :             ImGui::SameLine(); ShowHelpMarker("Hold SHIFT or use mouse to select text.\n" "CTRL+Left/Right to word jump.\n" "CTRL+A or double-click to select all.\n" "CTRL+X,CTRL+C,CTRL+V clipboard.\n" "CTRL+Z,CTRL+Y undo/redo.\n" "ESCAPE to revert.\n");

	add	esp, 60					; 0000003cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11301
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 606  : 
; 607  :             ImGui::InputInt("input int", &i0);

	push	0
	push	100					; 00000064H
	push	1
	push	OFFSET ?i0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11302
	call	?InputInt@ImGui@@YA_NPBDPAHHHH@Z	; ImGui::InputInt

; 608  :             ImGui::SameLine(); ShowHelpMarker("You can apply arithmetic operators +,*,/ on numerical values.\n  e.g. [ 100 ], input \'*2\', result becomes [ 200 ]\nUse +- to subtract.\n");

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11303
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker
	add	esp, 12					; 0000000cH

; 609  : 
; 610  :             ImGui::InputFloat("input float", &f0, 0.01f, 1.0f);

	push	0
	push	-1
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	push	OFFSET ?f0@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11304
	call	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z	; ImGui::InputFloat

; 611  : 
; 612  :             static float vec4a[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
; 613  :             ImGui::InputFloat3("input float3", vec4a);

	push	0
	push	-1
	push	OFFSET ?vec4a@?NM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11305
	call	?InputFloat3@ImGui@@YA_NPBDQAMHH@Z	; ImGui::InputFloat3
	add	esp, 40					; 00000028H

; 614  :         }
; 615  : 
; 616  :         {
; 617  :             static int i1=50, i2=42;
; 618  :             ImGui::DragInt("drag int", &i1, 1);

	push	OFFSET $SG11306
	push	0
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?i1@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11307
	call	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z	; ImGui::DragInt

; 619  :             ImGui::SameLine(); ShowHelpMarker("Click and drag to edit value.\nHold SHIFT/ALT for faster/slower edit.\nDouble-click or CTRL+click to input value.");

	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11308
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker
	add	esp, 12					; 0000000cH

; 620  : 
; 621  :             ImGui::DragInt("drag int 0..100", &i2, 1, 0, 100, "%.0f%%");

	push	OFFSET $SG11309
	push	100					; 00000064H
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?i2@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11310
	call	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z	; ImGui::DragInt

; 622  : 
; 623  :             static float f1=1.00f, f2=0.0067f;
; 624  :             ImGui::DragFloat("drag float", &f1, 0.005f);

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11311
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1000593162		; 3ba3d70aH
	push	OFFSET ?f1@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11312
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 625  :             ImGui::DragFloat("drag small float", &f2, 0.0001f, 0.0f, 0.0f, "%.06f ns");

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11313
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 953267991		; 38d1b717H
	push	OFFSET ?f2@?NN@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11314
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 626  :         }
; 627  : 
; 628  :         {
; 629  :             static int i1=0;
; 630  :             ImGui::SliderInt("slider int", &i1, -1, 3);

	push	OFFSET $SG11315
	push	3
	push	-1
	push	OFFSET ?i1@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11316
	call	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z	; ImGui::SliderInt

; 631  :             ImGui::SameLine(); ShowHelpMarker("CTRL+click to input value.");

	add	esp, 40					; 00000028H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11317
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 632  : 
; 633  :             static float f1=0.123f, f2=0.0f;
; 634  :             ImGui::SliderFloat("slider float", &f1, 0.0f, 1.0f, "ratio = %.3f");

	add	esp, 8
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11318
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	OFFSET ?f1@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11319
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 635  :             ImGui::SliderFloat("slider log float", &f2, -10.0f, 10.0f, "%.4f", 3.0f);

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp], 1077936128		; 40400000H
	push	OFFSET $SG11320
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1092616192		; 41200000H
	mov	DWORD PTR [esp], -1054867456		; c1200000H
	push	OFFSET ?f2@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11321
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 636  :             static float angle = 0.0f;
; 637  :             ImGui::SliderAngle("slider angle", &angle);

	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], 1135869952		; 43b40000H
	mov	DWORD PTR [esp], -1011613696		; c3b40000H
	push	OFFSET ?angle@?NO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11322
	call	?SliderAngle@ImGui@@YA_NPBDPAMMM@Z	; ImGui::SliderAngle

; 638  :         }
; 639  : 
; 640  :         static float col1[3] = { 1.0f,0.0f,0.2f };
; 641  :         static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };
; 642  :         ImGui::ColorEdit3("color 1", col1);

	push	OFFSET ?col1@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11323
	call	?ColorEdit3@ImGui@@YA_NPBDQAM@Z		; ImGui::ColorEdit3

; 643  :         ImGui::SameLine(); ShowHelpMarker("Click on the colored square to change edit mode.\nCTRL+click on individual component to input value.\n");

	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11324
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 644  : 
; 645  :         ImGui::ColorEdit4("color 2", col2);

	push	1
	push	OFFSET ?col2@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11325
	call	?ColorEdit4@ImGui@@YA_NPBDQAM_N@Z	; ImGui::ColorEdit4

; 646  : 
; 647  :         const char* listbox_items[] = { "Apple", "Banana", "Cherry", "Kiwi", "Mango", "Orange", "Pineapple", "Strawberry", "Watermelon" };

	mov	DWORD PTR _listbox_items$10[ebp], OFFSET $SG11326
	mov	DWORD PTR _listbox_items$10[ebp+4], OFFSET $SG11327
	mov	DWORD PTR _listbox_items$10[ebp+8], OFFSET $SG11328

; 648  :         static int listbox_item_current = 1;
; 649  :         ImGui::ListBox("listbox\n(single select)", &listbox_item_current, listbox_items, IM_ARRAYSIZE(listbox_items), 4);

	push	4
	push	9
	lea	eax, DWORD PTR _listbox_items$10[ebp]
	mov	DWORD PTR _listbox_items$10[ebp+12], OFFSET $SG11329
	push	eax
	push	OFFSET ?listbox_item_current@?EO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11335
	mov	DWORD PTR _listbox_items$10[ebp+16], OFFSET $SG11330
	mov	DWORD PTR _listbox_items$10[ebp+20], OFFSET $SG11331
	mov	DWORD PTR _listbox_items$10[ebp+24], OFFSET $SG11332
	mov	DWORD PTR _listbox_items$10[ebp+28], OFFSET $SG11333
	mov	DWORD PTR _listbox_items$10[ebp+32], OFFSET $SG11334
	call	?ListBox@ImGui@@YA_NPBDPAHPBQBDHH@Z	; ImGui::ListBox

; 650  : 
; 651  :         //static int listbox_item_current2 = 2;
; 652  :         //ImGui::PushItemWidth(-1);
; 653  :         //ImGui::ListBox("##listbox2", &listbox_item_current2, listbox_items, IM_ARRAYSIZE(listbox_items), 4);
; 654  :         //ImGui::PopItemWidth();
; 655  : 
; 656  :         if (ImGui::TreeNode("Range Widgets"))

	push	OFFSET $SG11337
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 48					; 00000030H
	test	al, al
	je	$LN209@ShowTestWi

; 657  :         {
; 658  :             ImGui::Unindent();

	push	ecx
	mov	DWORD PTR [esp], 0
	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent

; 659  : 
; 660  :             static float begin = 10, end = 90;
; 661  :             static int begin_i = 100, end_i = 1000;
; 662  :             ImGui::DragFloatRange2("range", &begin, &end, 0.25f, 0.0f, 100.0f, "Min: %.1f %%", "Max: %.1f %%");

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11338
	push	OFFSET $SG11339
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1120403456		; 42c80000H
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1048576000		; 3e800000H
	push	OFFSET ?end@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET ?begin@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11340
	call	?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z ; ImGui::DragFloatRange2
	add	esp, 36					; 00000024H

; 663  :             ImGui::DragIntRange2("range int (no bounds)", &begin_i, &end_i, 5, 0, 0, "Min: %.0f units", "Max: %.0f units");

	push	OFFSET $SG11341
	push	OFFSET $SG11342
	push	0
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1084227584		; 40a00000H
	push	OFFSET ?end_i@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET ?begin_i@?OB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11343
	call	?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z ; ImGui::DragIntRange2

; 664  : 
; 665  :             ImGui::Indent();

	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esp], 0
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent
	add	esp, 4

; 666  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN209@ShowTestWi:

; 667  :         }
; 668  : 
; 669  :         if (ImGui::TreeNode("Multi-component Widgets"))

	push	OFFSET $SG11345
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN210@ShowTestWi

; 670  :         {
; 671  :             ImGui::Unindent();

	push	ecx
	mov	DWORD PTR [esp], 0
	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent

; 672  : 
; 673  :             static float vec4f[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
; 674  :             static int vec4i[4] = { 1, 5, 100, 255 };
; 675  : 
; 676  :             ImGui::InputFloat2("input float2", vec4f);

	push	0
	push	-1
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11346
	call	?InputFloat2@ImGui@@YA_NPBDQAMHH@Z	; ImGui::InputFloat2

; 677  :             ImGui::DragFloat2("drag float2", vec4f, 0.01f, 0.0f, 1.0f);

	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11347
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1065353216		; 3f800000H
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11348
	call	?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z	; ImGui::DragFloat2

; 678  :             ImGui::SliderFloat2("slider float2", vec4f, 0.0f, 1.0f);

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11349
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11350
	call	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat2
	add	esp, 24					; 00000018H

; 679  :             ImGui::DragInt2("drag int2", vec4i, 1, 0, 255);

	push	OFFSET $SG11351
	push	255					; 000000ffH
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11352
	call	?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z	; ImGui::DragInt2

; 680  :             ImGui::InputInt2("input int2", vec4i);

	push	0
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11353
	call	?InputInt2@ImGui@@YA_NPBDQAHH@Z		; ImGui::InputInt2

; 681  :             ImGui::SliderInt2("slider int2", vec4i, 0, 255);

	push	OFFSET $SG11354
	push	255					; 000000ffH
	push	0
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11355
	call	?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z	; ImGui::SliderInt2

; 682  :             ImGui::Spacing();

	call	?Spacing@ImGui@@YAXXZ			; ImGui::Spacing

; 683  : 
; 684  :             ImGui::InputFloat3("input float3", vec4f);

	push	0
	push	-1
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11356
	call	?InputFloat3@ImGui@@YA_NPBDQAMHH@Z	; ImGui::InputFloat3

; 685  :             ImGui::DragFloat3("drag float3", vec4f, 0.01f, 0.0f, 1.0f);

	add	esp, 68					; 00000044H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11357
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1065353216		; 3f800000H
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11358
	call	?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z	; ImGui::DragFloat3

; 686  :             ImGui::SliderFloat3("slider float3", vec4f, 0.0f, 1.0f);

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11359
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11360
	call	?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat3
	add	esp, 24					; 00000018H

; 687  :             ImGui::DragInt3("drag int3", vec4i, 1, 0, 255);

	push	OFFSET $SG11361
	push	255					; 000000ffH
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11362
	call	?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z	; ImGui::DragInt3

; 688  :             ImGui::InputInt3("input int3", vec4i);

	push	0
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11363
	call	?InputInt3@ImGui@@YA_NPBDQAHH@Z		; ImGui::InputInt3

; 689  :             ImGui::SliderInt3("slider int3", vec4i, 0, 255);

	push	OFFSET $SG11364
	push	255					; 000000ffH
	push	0
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11365
	call	?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z	; ImGui::SliderInt3

; 690  :             ImGui::Spacing();

	call	?Spacing@ImGui@@YAXXZ			; ImGui::Spacing

; 691  : 
; 692  :             ImGui::InputFloat4("input float4", vec4f);

	push	0
	push	-1
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11366
	call	?InputFloat4@ImGui@@YA_NPBDQAMHH@Z	; ImGui::InputFloat4

; 693  :             ImGui::DragFloat4("drag float4", vec4f, 0.01f, 0.0f, 1.0f);

	add	esp, 68					; 00000044H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11367
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1065353216		; 3f800000H
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11368
	call	?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z	; ImGui::DragFloat4

; 694  :             ImGui::SliderFloat4("slider float4", vec4f, 0.0f, 1.0f);

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11369
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	OFFSET ?vec4f@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11370
	call	?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat4

; 695  :             ImGui::InputInt4("input int4", vec4i);

	push	0
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11371
	call	?InputInt4@ImGui@@YA_NPBDQAHH@Z		; ImGui::InputInt4
	add	esp, 36					; 00000024H

; 696  :             ImGui::DragInt4("drag int4", vec4i, 1, 0, 255);

	push	OFFSET $SG11372
	push	255					; 000000ffH
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11373
	call	?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z	; ImGui::DragInt4

; 697  :             ImGui::SliderInt4("slider int4", vec4i, 0, 255);

	push	OFFSET $SG11374
	push	255					; 000000ffH
	push	0
	push	OFFSET ?vec4i@?OE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA
	push	OFFSET $SG11375
	call	?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z	; ImGui::SliderInt4

; 698  : 
; 699  :             ImGui::Indent();

	add	esp, 40					; 00000028H
	mov	DWORD PTR [esp], 0
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent
	add	esp, 4

; 700  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN210@ShowTestWi:

; 701  :         }
; 702  : 
; 703  :         if (ImGui::TreeNode("Vertical Sliders"))

	push	OFFSET $SG11377
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN211@ShowTestWi

; 705  :             ImGui::Unindent();

	push	ecx
	mov	DWORD PTR [esp], 0
	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent

; 707  :             ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

	lea	eax, DWORD PTR $T181[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T181[ebp], 1082130432	; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 707  :             ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

	push	eax
	push	7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T181[ebp+4], 1082130432	; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 707  :             ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 710  :             ImGui::VSliderInt("##int", ImVec2(18,160), &int_value, 0, 5);

	push	OFFSET $SG11378
	push	5
	push	0
	push	OFFSET ?int_value@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	lea	eax, DWORD PTR $T180[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T180[ebp], 1099956224	; 41900000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 710  :             ImGui::VSliderInt("##int", ImVec2(18,160), &int_value, 0, 5);

	push	eax
	push	OFFSET $SG11379
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T180[ebp+4], 1126170624	; 43200000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 710  :             ImGui::VSliderInt("##int", ImVec2(18,160), &int_value, 0, 5);

	call	?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z ; ImGui::VSliderInt

; 711  :             ImGui::SameLine();

	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 712  : 
; 713  :             static float values[7] = { 0.0f, 0.60f, 0.35f, 0.9f, 0.70f, 0.20f, 0.0f };
; 714  :             ImGui::PushID("set1");

	push	OFFSET $SG11380
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID
	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	DWORD PTR $T11[ebp+12], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 715  :             for (int i = 0; i < 7; i++)

	xor	edi, edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	DWORD PTR $T15[ebp+12], 1065353216	; 3f800000H
	mov	DWORD PTR $T18[ebp+12], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 705  :             ImGui::Unindent();

	mov	esi, OFFSET ?values@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	DWORD PTR $T53[ebp+12], 1065353216	; 3f800000H
	npad	5
$LL28@ShowTestWi:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 717  :                 if (i > 0) ImGui::SameLine();

	test	edi, edi
	jle	SHORT $LN212@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN212@ShowTestWi:

; 718  :                 ImGui::PushID(i);

	push	edi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
	add	esp, 4
	movd	xmm0, edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	lea	eax, DWORD PTR _b$46[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 719  :                 ImGui::PushStyleColor(ImGuiCol_FrameBg, ImColor::HSV(i/7.0f, 0.5f, 0.5f));

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	lea	eax, DWORD PTR _g$43[ebp]
	push	eax
	lea	eax, DWORD PTR _r$25[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 719  :                 ImGui::PushStyleColor(ImGuiCol_FrameBg, ImColor::HSV(i/7.0f, 0.5f, 0.5f));

	mulss	xmm0, DWORD PTR __real@3e124925
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	sub	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 719  :                 ImGui::PushStyleColor(ImGuiCol_FrameBg, ImColor::HSV(i/7.0f, 0.5f, 0.5f));

	movss	DWORD PTR tv4861[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	mov	DWORD PTR [esp+8], 1056964608		; 3f000000H
	mov	DWORD PTR [esp+4], 1056964608		; 3f000000H
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$25[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 719  :                 ImGui::PushStyleColor(ImGuiCol_FrameBg, ImColor::HSV(i/7.0f, 0.5f, 0.5f));

	lea	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T11[ebp], xmm0
	movss	xmm0, DWORD PTR _g$43[ebp]
	movss	DWORD PTR $T11[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$46[ebp]
	movss	DWORD PTR $T11[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 719  :                 ImGui::PushStyleColor(ImGuiCol_FrameBg, ImColor::HSV(i/7.0f, 0.5f, 0.5f));

	push	eax
	push	7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T8[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 719  :                 ImGui::PushStyleColor(ImGuiCol_FrameBg, ImColor::HSV(i/7.0f, 0.5f, 0.5f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	xmm0, DWORD PTR tv4861[ebp]
	lea	eax, DWORD PTR _b$86[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 719  :                 ImGui::PushStyleColor(ImGuiCol_FrameBg, ImColor::HSV(i/7.0f, 0.5f, 0.5f));

	add	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	lea	eax, DWORD PTR _g$89[ebp]
	push	eax
	lea	eax, DWORD PTR _r$49[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1056964608		; 3f000000H
	mov	DWORD PTR [esp+4], 1058642330		; 3f19999aH
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$49[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 720  :                 ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImColor::HSV(i/7.0f, 0.6f, 0.5f));

	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T15[ebp], xmm0
	movss	xmm0, DWORD PTR _g$89[ebp]
	movss	DWORD PTR $T15[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$86[ebp]
	movss	DWORD PTR $T15[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T15[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 720  :                 ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImColor::HSV(i/7.0f, 0.6f, 0.5f));

	push	eax
	push	8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T6[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 720  :                 ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImColor::HSV(i/7.0f, 0.6f, 0.5f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	xmm0, DWORD PTR tv4861[ebp]
	lea	eax, DWORD PTR _b$91[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 720  :                 ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImColor::HSV(i/7.0f, 0.6f, 0.5f));

	add	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	lea	eax, DWORD PTR _g$93[ebp]
	push	eax
	lea	eax, DWORD PTR _r$95[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1056964608		; 3f000000H
	mov	DWORD PTR [esp+4], 1060320051		; 3f333333H
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$95[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 721  :                 ImGui::PushStyleColor(ImGuiCol_FrameBgActive, ImColor::HSV(i/7.0f, 0.7f, 0.5f));

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T18[ebp], xmm0
	movss	xmm0, DWORD PTR _g$93[ebp]
	movss	DWORD PTR $T18[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$91[ebp]
	movss	DWORD PTR $T18[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T18[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 721  :                 ImGui::PushStyleColor(ImGuiCol_FrameBgActive, ImColor::HSV(i/7.0f, 0.7f, 0.5f));

	push	eax
	push	9
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 721  :                 ImGui::PushStyleColor(ImGuiCol_FrameBgActive, ImColor::HSV(i/7.0f, 0.7f, 0.5f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
	add	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	xmm0, DWORD PTR tv4861[ebp]
	lea	eax, DWORD PTR _b$202[ebp]
	push	eax
	lea	eax, DWORD PTR _g$77[ebp]
	push	eax
	lea	eax, DWORD PTR _r$84[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1063675494		; 3f666666H
	mov	DWORD PTR [esp+4], 1063675494		; 3f666666H
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$84[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 722  :                 ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImColor::HSV(i/7.0f, 0.9f, 0.9f));

	lea	eax, DWORD PTR $T41[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T53[ebp], xmm0
	movss	xmm0, DWORD PTR _g$77[ebp]
	movss	DWORD PTR $T53[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$202[ebp]
	movss	DWORD PTR $T53[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T53[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 722  :                 ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImColor::HSV(i/7.0f, 0.9f, 0.9f));

	push	eax
	push	20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T41[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 722  :                 ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImColor::HSV(i/7.0f, 0.9f, 0.9f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor

; 723  :                 ImGui::VSliderFloat("##v", ImVec2(18,160), &values[i], 0.0f, 1.0f, "");

	add	esp, 28					; 0000001cH
	lea	eax, DWORD PTR $T66[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T66[ebp], 1099956224		; 41900000H
	mov	DWORD PTR $T66[ebp+4], 1126170624	; 43200000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 723  :                 ImGui::VSliderFloat("##v", ImVec2(18,160), &values[i], 0.0f, 1.0f, "");

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11382
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	esi
	push	eax
	push	OFFSET $SG11383
	call	?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z ; ImGui::VSliderFloat
	add	esp, 28					; 0000001cH

; 724  :                 if (ImGui::IsItemActive() || ImGui::IsItemHovered())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	jne	SHORT $LN214@ShowTestWi
	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN213@ShowTestWi
$LN214@ShowTestWi:
	movss	xmm0, DWORD PTR [esi]

; 725  :                     ImGui::SetTooltip("%.3f", values[i]);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11386
	call	?SetTooltip@ImGui@@YAXPBDZZ		; ImGui::SetTooltip
	add	esp, 12					; 0000000cH
$LN213@ShowTestWi:

; 726  :                 ImGui::PopStyleColor(4);

	push	4
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 4

; 727  :                 ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	add	esi, 4
	inc	edi
	cmp	esi, OFFSET ?values@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA+28
	jl	$LL28@ShowTestWi

; 728  :             }
; 729  :             ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 730  : 
; 731  :             ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 732  :             ImGui::PushID("set2");

	push	OFFSET $SG11387
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID
	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR _small_slider_size$162[ebp], 1099956224 ; 41900000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 736  :             for (int nx = 0; nx < 4; nx++)

	xor	eax, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR _small_slider_size$162[ebp+4], 1112189611 ; 424aaaabH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 736  :             for (int nx = 0; nx < 4; nx++)

	mov	DWORD PTR _nx$1$[ebp], eax
	mov	edi, OFFSET ?values2@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	mov	DWORD PTR tv5696[ebp], eax
	npad	5
$LL31@ShowTestWi:

; 737  :             {
; 738  :                 if (nx > 0) ImGui::SameLine();

	test	eax, eax
	jle	SHORT $LN215@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN215@ShowTestWi:

; 739  :                 ImGui::BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 740  :                 for (int ny = 0; ny < rows; ny++)

	xor	esi, esi
$LL34@ShowTestWi:
	mov	eax, DWORD PTR tv5696[ebp]
	add	eax, esi

; 741  :                 {
; 742  :                     ImGui::PushID(nx*rows+ny);

	push	eax
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 743  :                     ImGui::VSliderFloat("##v", small_slider_size, &values2[nx], 0.0f, 1.0f, "");

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	lea	eax, DWORD PTR _small_slider_size$162[ebp]
	push	OFFSET $SG11389
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	edi
	push	eax
	push	OFFSET $SG11390
	call	?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z ; ImGui::VSliderFloat
	add	esp, 28					; 0000001cH

; 744  :                     if (ImGui::IsItemActive() || ImGui::IsItemHovered())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	jne	SHORT $LN217@ShowTestWi
	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN216@ShowTestWi
$LN217@ShowTestWi:
	movss	xmm0, DWORD PTR [edi]

; 745  :                         ImGui::SetTooltip("%.3f", values2[nx]);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11393
	call	?SetTooltip@ImGui@@YAXPBDZZ		; ImGui::SetTooltip
	add	esp, 12					; 0000000cH
$LN216@ShowTestWi:

; 746  :                     ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	inc	esi
	cmp	esi, 3
	jl	SHORT $LL34@ShowTestWi

; 747  :                 }
; 748  :                 ImGui::EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	mov	eax, DWORD PTR _nx$1$[ebp]
	add	edi, 4
	add	DWORD PTR tv5696[ebp], 3
	inc	eax
	mov	DWORD PTR _nx$1$[ebp], eax
	cmp	edi, OFFSET ?values2@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA+16
	jl	$LL31@ShowTestWi

; 749  :             }
; 750  :             ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 751  : 
; 752  :             ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 753  :             ImGui::PushID("set3");

	push	OFFSET $SG11394
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET ?values@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA

; 754  :             for (int i = 0; i < 4; i++)

	xor	esi, esi
$LL37@ShowTestWi:

; 755  :             {
; 756  :                 if (i > 0) ImGui::SameLine();

	test	esi, esi
	jle	SHORT $LN218@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN218@ShowTestWi:

; 757  :                 ImGui::PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 758  :                 ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize, 40);

	mov	DWORD PTR [esp], 1109393408		; 42200000H
	push	10					; 0000000aH
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 759  :                 ImGui::VSliderFloat("##v", ImVec2(40,160), &values[i], 0.0f, 1.0f, "%.2f\nsec");

	add	esp, 4
	lea	eax, DWORD PTR $T65[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T65[ebp], 1109393408		; 42200000H
	mov	DWORD PTR $T65[ebp+4], 1126170624	; 43200000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 759  :                 ImGui::VSliderFloat("##v", ImVec2(40,160), &values[i], 0.0f, 1.0f, "%.2f\nsec");

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11396
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	edi
	push	eax
	push	OFFSET $SG11397
	call	?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z ; ImGui::VSliderFloat

; 760  :                 ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	add	esp, 32					; 00000020H

; 761  :                 ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	add	edi, 4
	inc	esi
	cmp	edi, OFFSET ?values@?OH@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA+16
	jl	$LL37@ShowTestWi

; 762  :             }
; 763  :             ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 764  :             ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 765  : 
; 766  :             ImGui::Indent();

	mov	DWORD PTR [esp], 0
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent
	add	esp, 4

; 767  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN211@ShowTestWi:

; 768  :         }
; 769  :     }
; 770  : 
; 771  :     if (ImGui::CollapsingHeader("Plots widgets"))

	push	0
	push	OFFSET $SG11399
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	$LN219@ShowTestWi

; 772  :     {
; 773  :         static bool animate = true;
; 774  :         ImGui::Checkbox("Animate", &animate);

	push	OFFSET ?animate@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11400
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T179[ebp+4], 0
	mov	DWORD PTR $T179[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 777  :         ImGui::PlotLines("Frame Times", arr, IM_ARRAYSIZE(arr));

	push	4
	push	DWORD PTR $T179[ebp+4]
	push	DWORD PTR $T179[ebp]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esp], 2139095039		; 7f7fffffH
	push	0
	push	0
	push	7
	push	OFFSET ?arr@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11401
	call	?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ; ImGui::PlotLines
	add	esp, 40					; 00000028H

; 778  : 
; 779  :         // Create a dummy array of contiguous float values to plot
; 780  :         // Tip: If your float aren't contiguous but part of a structure, you can pass a pointer to your first float and the sizeof() of your structure in the Stride parameter.
; 781  :         static float values[90] = { 0 };
; 782  :         static int values_offset = 0;
; 783  :         static float refresh_time = 0.0f;
; 784  :         if (!animate || refresh_time == 0.0f)

	cmp	BYTE PTR ?animate@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN221@ShowTestWi
	movss	xmm0, DWORD PTR ?refresh_time@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN729@ShowTestWi
$LN221@ShowTestWi:

; 785  :             refresh_time = ImGui::GetTime();

	call	?GetTime@ImGui@@YAMXZ			; ImGui::GetTime
	fstp	DWORD PTR ?refresh_time@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
$LN729@ShowTestWi:

; 786  :         while (refresh_time < ImGui::GetTime()) // Create dummy data at fixed 60 hz rate for the demo

	call	?GetTime@ImGui@@YAMXZ			; ImGui::GetTime
	fstp	DWORD PTR tv6815[ebp]
	movss	xmm0, DWORD PTR tv6815[ebp]
	comiss	xmm0, DWORD PTR ?refresh_time@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	jbe	$LN39@ShowTestWi
	mov	esi, 90					; 0000005aH
	npad	8
$LL38@ShowTestWi:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 635  :         return (float)cos(_X);

	movss	xmm0, DWORD PTR ?phase@?BAA@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	call	___libm_sse2_cosf
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 789  :             values[values_offset] = cosf(phase);

	mov	eax, DWORD PTR ?values_offset@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	movss	DWORD PTR ?values@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA[eax*4], xmm0

; 790  :             values_offset = (values_offset+1) % IM_ARRAYSIZE(values);

	inc	eax
	cdq
	idiv	esi
	mov	DWORD PTR ?values_offset@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, edx
	movd	xmm0, edx

; 791  :             phase += 0.10f*values_offset;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR ?phase@?BAA@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	movss	DWORD PTR ?phase@?BAA@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, xmm0

; 792  :             refresh_time += 1.0f/60.0f;

	movss	xmm0, DWORD PTR ?refresh_time@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	addss	xmm0, DWORD PTR __real@3c888889
	movss	DWORD PTR ?refresh_time@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, xmm0
	call	?GetTime@ImGui@@YAMXZ			; ImGui::GetTime
	fstp	DWORD PTR tv6803[ebp]
	movss	xmm0, DWORD PTR tv6803[ebp]
	comiss	xmm0, DWORD PTR ?refresh_time@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	ja	SHORT $LL38@ShowTestWi
$LN39@ShowTestWi:

; 794  :         ImGui::PlotLines("Lines", values, IM_ARRAYSIZE(values), values_offset, "avg 0.0", -1.0f, 1.0f, ImVec2(0,80));

	push	4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T178[ebp+4], 1117782016	; 42a00000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 794  :         ImGui::PlotLines("Lines", values, IM_ARRAYSIZE(values), values_offset, "avg 0.0", -1.0f, 1.0f, ImVec2(0,80));

	push	DWORD PTR $T178[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T178[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 794  :         ImGui::PlotLines("Lines", values, IM_ARRAYSIZE(values), values_offset, "avg 0.0", -1.0f, 1.0f, ImVec2(0,80));

	push	DWORD PTR $T178[ebp]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	OFFSET $SG11404
	push	DWORD PTR ?values_offset@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	90					; 0000005aH
	push	OFFSET ?values@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11405
	call	?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ; ImGui::PlotLines
	add	esp, 40					; 00000028H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T177[ebp+4], 1117782016	; 42a00000H
	mov	DWORD PTR $T177[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 795  :         ImGui::PlotHistogram("Histogram", arr, IM_ARRAYSIZE(arr), 0, NULL, 0.0f, 1.0f, ImVec2(0,80));

	push	4
	push	DWORD PTR $T177[ebp+4]
	push	DWORD PTR $T177[ebp]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	0
	push	0
	push	7
	push	OFFSET ?arr@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAMA
	push	OFFSET $SG11406
	call	?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ; ImGui::PlotHistogram

; 796  : 
; 797  :         // Use functions to generate output
; 798  :         // FIXME: This is rather awkward because current plot API only pass in indices. We probably want an API passing floats and user provide sample rate/count.
; 799  :         struct Funcs
; 800  :         {
; 801  :             static float Sin(void*, int i) { return sinf(i * 0.1f); }
; 802  :             static float Saw(void*, int i) { return (i & 1) ? 1.0f : -1.0f; }
; 803  :         };
; 804  :         static int func_type = 0, display_count = 70;
; 805  :         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 806  :         ImGui::PushItemWidth(100); ImGui::Combo("func", &func_type, "Sin\0Saw\0"); ImGui::PopItemWidth();

	add	esp, 36					; 00000024H
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	push	-1
	push	OFFSET $SG11407
	push	OFFSET ?func_type@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11408
	call	?Combo@ImGui@@YA_NPBDPAH0H@Z		; ImGui::Combo
	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 807  :         ImGui::SameLine();

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 808  :         ImGui::SliderInt("Sample count", &display_count, 1, 400);

	push	OFFSET $SG11409
	push	400					; 00000190H
	push	1
	push	OFFSET ?display_count@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11410
	call	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z	; ImGui::SliderInt
	add	esp, 28					; 0000001cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T176[ebp+4], 1117782016	; 42a00000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 809  :         float (*func)(void*, int) = (func_type == 0) ? Funcs::Sin : Funcs::Saw;

	cmp	DWORD PTR ?func_type@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, 0
	mov	eax, OFFSET ?Sin@Funcs@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAMPAXH@Z ; `ImGui::ShowTestWindow'::`252'::Funcs::Sin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T176[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 809  :         float (*func)(void*, int) = (func_type == 0) ? Funcs::Sin : Funcs::Saw;

	mov	esi, OFFSET ?Saw@Funcs@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@SAMPAXH@Z ; `ImGui::ShowTestWindow'::`252'::Funcs::Saw
	cmove	esi, eax

; 810  :         ImGui::PlotLines("Lines", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));

	push	DWORD PTR $T176[ebp+4]
	push	DWORD PTR $T176[ebp]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	0
	push	0
	push	DWORD PTR ?display_count@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	0
	push	esi
	push	OFFSET $SG11411
	call	?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ; ImGui::PlotLines
	add	esp, 40					; 00000028H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T175[ebp+4], 1117782016	; 42a00000H
	mov	DWORD PTR $T175[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 811  :         ImGui::PlotHistogram("Histogram", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));

	push	DWORD PTR $T175[ebp+4]
	push	DWORD PTR $T175[ebp]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	0
	push	0
	push	DWORD PTR ?display_count@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	0
	push	esi
	push	OFFSET $SG11412
	call	?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ; ImGui::PlotHistogram
	add	esp, 40					; 00000028H

; 812  :         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 813  : 
; 814  :         // Animate a simple progress bar
; 815  :         static float progress = 0.0f, progress_dir = 1.0f;
; 816  :         if (animate)

	cmp	BYTE PTR ?animate@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	$LN878@ShowTestWi

; 817  :         {
; 818  :             progress += progress_dir * 0.4f * ImGui::GetIO().DeltaTime;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm1, DWORD PTR ?progress_dir@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA

; 819  :             if (progress >= +1.1f) { progress = +1.1f; progress_dir *= -1.0f; }

	movss	xmm2, DWORD PTR __real@3f8ccccd
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3ecccccd
	mulss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR ?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	comiss	xmm0, xmm2
	movss	DWORD PTR ?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, xmm0
	jb	SHORT $LN223@ShowTestWi
	mulss	xmm1, DWORD PTR __real@bf800000
	movaps	xmm0, xmm2
	movss	DWORD PTR ?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, xmm0
	movss	DWORD PTR ?progress_dir@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, xmm1

; 820  :             if (progress <= -0.1f) { progress = -0.1f; progress_dir *= -1.0f; }

	jmp	SHORT $LN224@ShowTestWi
$LN223@ShowTestWi:
	movss	xmm2, DWORD PTR __real@bdcccccd
	comiss	xmm2, xmm0
	jb	SHORT $LN224@ShowTestWi
	mulss	xmm1, DWORD PTR __real@bf800000
	movaps	xmm0, xmm2
	movss	DWORD PTR ?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, xmm0
	movss	DWORD PTR ?progress_dir@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, xmm1
	jmp	SHORT $LN224@ShowTestWi
$LN878@ShowTestWi:
	movss	xmm0, DWORD PTR ?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
$LN224@ShowTestWi:

; 824  :         ImGui::ProgressBar(progress, ImVec2(0.0f,0.0f));

	push	0
	lea	eax, DWORD PTR $T161[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T161[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 824  :         ImGui::ProgressBar(progress, ImVec2(0.0f,0.0f));

	push	eax
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T161[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 824  :         ImGui::ProgressBar(progress, ImVec2(0.0f,0.0f));

	movss	DWORD PTR [esp], xmm0
	call	?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z ; ImGui::ProgressBar

; 825  :         ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);

	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle
	add	esp, 4
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 826  :         ImGui::Text("Progress Bar");

	push	OFFSET $SG11416
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 827  : 
; 828  :         float progress_saturated = (progress < 0.0f) ? 0.0f : (progress > 1.0f) ? 1.0f : progress;

	movss	xmm0, DWORD PTR ?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	xorps	xmm1, xmm1
	add	esp, 12					; 0000000cH
	comiss	xmm1, xmm0
	jbe	SHORT $LN333@ShowTestWi
	xorps	xmm0, xmm0
	jmp	SHORT $LN334@ShowTestWi
$LN333@ShowTestWi:
	minss	xmm0, DWORD PTR __real@3f800000
$LN334@ShowTestWi:

; 829  :         char buf[32];
; 830  :         sprintf(buf, "%d/%d", (int)(progress_saturated*1753), 1753);

	mulss	xmm0, DWORD PTR __real@44db2000
	push	1753					; 000006d9H
	cvttss2si eax, xmm0
	push	eax
	lea	eax, DWORD PTR _buf$31[ebp]
	push	OFFSET $SG11417
	push	eax
	call	_sprintf

; 831  :         ImGui::ProgressBar(progress, ImVec2(0.f,0.f), buf);

	movss	xmm0, DWORD PTR ?progress@?PM@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	lea	eax, DWORD PTR _buf$31[ebp]
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T160[ebp], 0
	mov	DWORD PTR $T160[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 831  :         ImGui::ProgressBar(progress, ImVec2(0.f,0.f), buf);

	push	eax
	lea	eax, DWORD PTR $T160[ebp]
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z ; ImGui::ProgressBar
	add	esp, 12					; 0000000cH
$LN219@ShowTestWi:

; 832  :     }
; 833  : 
; 834  :     if (ImGui::CollapsingHeader("Layout"))

	push	0
	push	OFFSET $SG11419
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	$LN250@ShowTestWi

; 835  :     {
; 836  :         if (ImGui::TreeNode("Child regions"))

	push	OFFSET $SG11421
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN226@ShowTestWi

; 837  :         {
; 838  :             ImGui::Text("Without border");

	push	OFFSET $SG11422
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 840  :             bool goto_line = ImGui::Button("Goto");

	lea	eax, DWORD PTR $T159[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T159[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 840  :             bool goto_line = ImGui::Button("Goto");

	push	eax
	push	OFFSET $SG11423
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T159[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 840  :             bool goto_line = ImGui::Button("Goto");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 841  :             ImGui::SameLine();

	add	esp, 4
	mov	BYTE PTR _goto_line$1$[ebp], al
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 842  :             ImGui::PushItemWidth(100);

	add	esp, 4
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 843  :             goto_line |= ImGui::InputInt("##Line", &line, 0, 0, ImGuiInputTextFlags_EnterReturnsTrue);

	push	32					; 00000020H
	push	0
	push	0
	push	OFFSET ?line@?BAP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11424
	call	?InputInt@ImGui@@YA_NPBDPAHHHH@Z	; ImGui::InputInt
	or	BYTE PTR _goto_line$1$[ebp], al

; 844  :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 845  :             ImGui::BeginChild("Sub1", ImVec2(ImGui::GetWindowContentRegionWidth() * 0.5f,300), false, ImGuiWindowFlags_HorizontalScrollbar);

	call	?GetWindowContentRegionWidth@ImGui@@YAMXZ ; ImGui::GetWindowContentRegionWidth
	fmul	DWORD PTR __real@3f000000
	lea	eax, DWORD PTR $T158[ebp]
	push	2048					; 00000800H
	push	0
	push	eax
	push	OFFSET $SG11425
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	fstp	DWORD PTR $T158[ebp]
	mov	DWORD PTR $T158[ebp+4], 1133903872	; 43960000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 845  :             ImGui::BeginChild("Sub1", ImVec2(ImGui::GetWindowContentRegionWidth() * 0.5f,300), false, ImGuiWindowFlags_HorizontalScrollbar);

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild
	add	esp, 40					; 00000028H

; 846  :             for (int i = 0; i < 100; i++)

	xor	esi, esi
	npad	3
$LL42@ShowTestWi:

; 847  :             {
; 848  :                 ImGui::Text("%04d: scrollable region", i);

	push	esi
	push	OFFSET $SG11426
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 849  :                 if (goto_line && line == i)

	mov	al, BYTE PTR _goto_line$1$[ebp]
	add	esp, 8
	test	al, al
	je	SHORT $LN40@ShowTestWi
	cmp	DWORD PTR ?line@?BAP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, esi
	jne	SHORT $LN40@ShowTestWi

; 850  :                     ImGui::SetScrollHere();

	push	ecx
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	call	?SetScrollHere@ImGui@@YAXM@Z		; ImGui::SetScrollHere
	mov	al, BYTE PTR _goto_line$1$[ebp]
	add	esp, 4
$LN40@ShowTestWi:

; 846  :             for (int i = 0; i < 100; i++)

	inc	esi
	cmp	esi, 100				; 00000064H
	jl	SHORT $LL42@ShowTestWi

; 851  :             }
; 852  :             if (goto_line && line >= 100)

	test	al, al
	je	SHORT $LN228@ShowTestWi
	cmp	DWORD PTR ?line@?BAP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, 100 ; 00000064H
	jl	SHORT $LN228@ShowTestWi

; 853  :                 ImGui::SetScrollHere();

	push	ecx
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	call	?SetScrollHere@ImGui@@YAXM@Z		; ImGui::SetScrollHere
	add	esp, 4
$LN228@ShowTestWi:

; 854  :             ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 855  : 
; 856  :             ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 857  : 
; 858  :             ImGui::PushStyleVar(ImGuiStyleVar_ChildWindowRounding, 5.0f);

	add	esp, 4
	mov	DWORD PTR [esp], 1084227584		; 40a00000H
	push	4
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 859  :             ImGui::BeginChild("Sub2", ImVec2(0,300), true);

	push	0
	push	1
	lea	eax, DWORD PTR $T157[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T157[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 859  :             ImGui::BeginChild("Sub2", ImVec2(0,300), true);

	push	eax
	push	OFFSET $SG11429
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T157[ebp+4], 1133903872	; 43960000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 859  :             ImGui::BeginChild("Sub2", ImVec2(0,300), true);

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild

; 860  :             ImGui::Text("With border");

	push	OFFSET $SG11430
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 861  :             ImGui::Columns(2);

	push	1
	push	0
	push	2
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 40					; 00000028H

; 862  :             for (int i = 0; i < 100; i++)

	xor	esi, esi
	npad	6
$LL45@ShowTestWi:

; 863  :             {
; 864  :                 if (i == 50)

	cmp	esi, 50					; 00000032H
	jne	SHORT $LN229@ShowTestWi

; 865  :                     ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
$LN229@ShowTestWi:

; 866  :                 char buf[32];
; 867  :                 sprintf(buf, "%08x", i*5731);

	imul	eax, esi, 5731
	push	eax
	lea	eax, DWORD PTR _buf$30[ebp]
	push	OFFSET $SG11432
	push	eax
	call	_sprintf

; 868  :                 if (ImGui::Button(buf, ImVec2(-1.0f, 0.0f)))

	lea	eax, DWORD PTR $T156[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T156[ebp], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 868  :                 if (ImGui::Button(buf, ImVec2(-1.0f, 0.0f)))

	push	eax
	lea	eax, DWORD PTR _buf$30[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T156[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 868  :                 if (ImGui::Button(buf, ImVec2(-1.0f, 0.0f)))

	push	eax
	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN43@ShowTestWi

; 869  :                     printf("Pressed '%s'\n", buf);

	lea	eax, DWORD PTR _buf$30[ebp]
	push	eax
	push	OFFSET $SG11434
	call	_printf
	add	esp, 8
$LN43@ShowTestWi:

; 862  :             for (int i = 0; i < 100; i++)

	inc	esi
	cmp	esi, 100				; 00000064H
	jl	SHORT $LL45@ShowTestWi

; 870  :             }
; 871  :             ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 872  :             ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	add	esp, 4

; 873  : 
; 874  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN226@ShowTestWi:

; 875  :         }
; 876  : 
; 877  :         if (ImGui::TreeNode("Widgets Width"))

	push	OFFSET $SG11436
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN231@ShowTestWi

; 878  :         {
; 879  :             static float f = 0.0f;
; 880  :             ImGui::Text("PushItemWidth(100)");

	push	OFFSET $SG11437
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 881  :             ImGui::SameLine(); ShowHelpMarker("Fixed width.");

	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	ecx
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11438
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 882  :             ImGui::PushItemWidth(100);

	add	esp, 8
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 883  :             ImGui::DragFloat("float##1", &f);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11439
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?f@?BBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11440
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 884  :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 885  : 
; 886  :             ImGui::Text("PushItemWidth(GetWindowWidth() * 0.5f)");

	push	OFFSET $SG11441
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 887  :             ImGui::SameLine(); ShowHelpMarker("Half of window width.");

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11442
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 888  :             ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.5f);

	call	?GetWindowWidth@ImGui@@YAMXZ		; ImGui::GetWindowWidth
	fmul	DWORD PTR __real@3f000000
	add	esp, 8
	fstp	DWORD PTR [esp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 889  :             ImGui::DragFloat("float##2", &f);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11443
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?f@?BBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11444
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 890  :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 891  : 
; 892  :             ImGui::Text("PushItemWidth(GetContentRegionAvailWidth() * 0.5f)");

	push	OFFSET $SG11445
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 893  :             ImGui::SameLine(); ShowHelpMarker("Half of available width.\n(~ right-cursor_pos)\n(works within a column set)");

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11446
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 894  :             ImGui::PushItemWidth(ImGui::GetContentRegionAvailWidth() * 0.5f);

	call	?GetContentRegionAvailWidth@ImGui@@YAMXZ ; ImGui::GetContentRegionAvailWidth
	fmul	DWORD PTR __real@3f000000
	add	esp, 8
	fstp	DWORD PTR [esp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 895  :             ImGui::DragFloat("float##3", &f);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11447
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?f@?BBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11448
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 896  :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 897  : 
; 898  :             ImGui::Text("PushItemWidth(-100)");

	push	OFFSET $SG11449
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 899  :             ImGui::SameLine(); ShowHelpMarker("Align to right edge minus 100");

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11450
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 900  :             ImGui::PushItemWidth(-100);

	add	esp, 8
	mov	DWORD PTR [esp], -1027080192		; c2c80000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 901  :             ImGui::DragFloat("float##4", &f);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11451
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?f@?BBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11452
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 902  :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 903  : 
; 904  :             ImGui::Text("PushItemWidth(-1)");

	push	OFFSET $SG11453
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 905  :             ImGui::SameLine(); ShowHelpMarker("Align to right edge");

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11454
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 906  :             ImGui::PushItemWidth(-1);

	add	esp, 8
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 907  :             ImGui::DragFloat("float##5", &f);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11455
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 0
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?f@?BBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11456
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat
	add	esp, 28					; 0000001cH

; 908  :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 909  : 
; 910  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN231@ShowTestWi:

; 911  :         }
; 912  : 
; 913  :         if (ImGui::TreeNode("Basic Horizontal Layout"))

	push	OFFSET $SG11458
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN232@ShowTestWi

; 914  :         {
; 915  :             ImGui::TextWrapped("(Use ImGui::SameLine() to keep adding items to the right of the preceding item)");

	push	OFFSET $SG11459
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 916  : 
; 917  :             // Text
; 918  :             ImGui::Text("Two items: Hello"); ImGui::SameLine();

	push	OFFSET $SG11460
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f8000003f800000

; 919  :             ImGui::TextColored(ImVec4(1,1,0,1), "Sailor");

	lea	eax, DWORD PTR $T40[ebp]
	push	OFFSET $SG11461
	push	eax
	movups	XMMWORD PTR $T40[ebp], xmm0
	call	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ	; ImGui::TextColored

; 920  : 
; 921  :             // Adjust spacing
; 922  :             ImGui::Text("More spacing: Hello"); ImGui::SameLine(0, 20);

	push	OFFSET $SG11462
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], 1101004800		; 41a00000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f8000003f800000

; 923  :             ImGui::TextColored(ImVec4(1,1,0,1), "Sailor");

	lea	eax, DWORD PTR $T39[ebp]
	push	OFFSET $SG11463
	push	eax
	movups	XMMWORD PTR $T39[ebp], xmm0
	call	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ	; ImGui::TextColored

; 924  : 
; 925  :             // Button
; 926  :             ImGui::AlignFirstTextHeightToWidgets();

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 927  :             ImGui::Text("Normal buttons"); ImGui::SameLine();

	push	OFFSET $SG11464
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 928  :             ImGui::Button("Banana"); ImGui::SameLine();

	lea	eax, DWORD PTR $T155[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T155[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 928  :             ImGui::Button("Banana"); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11465
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T155[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 928  :             ImGui::Button("Banana"); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 929  :             ImGui::Button("Apple"); ImGui::SameLine();

	lea	eax, DWORD PTR $T154[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T154[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 929  :             ImGui::Button("Apple"); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11466
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T154[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 929  :             ImGui::Button("Apple"); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 930  :             ImGui::Button("Corniflower");

	lea	eax, DWORD PTR $T153[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T153[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 930  :             ImGui::Button("Corniflower");

	push	eax
	push	OFFSET $SG11467
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T153[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 930  :             ImGui::Button("Corniflower");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 931  : 
; 932  :             // Button
; 933  :             ImGui::Text("Small buttons"); ImGui::SameLine();

	push	OFFSET $SG11468
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 934  :             ImGui::SmallButton("Like this one"); ImGui::SameLine();

	push	OFFSET $SG11469
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 935  :             ImGui::Text("can fit within a text block.");

	push	OFFSET $SG11470
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 936  : 
; 937  :             // Aligned to arbitrary position. Easy/cheap column.
; 938  :             ImGui::Text("Aligned");

	push	OFFSET $SG11471
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 939  :             ImGui::SameLine(150); ImGui::Text("x=150");

	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1125515264		; 43160000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11472
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 940  :             ImGui::SameLine(300); ImGui::Text("x=300");

	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1133903872		; 43960000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11473
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 941  :             ImGui::Text("Aligned");

	push	OFFSET $SG11474
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 942  :             ImGui::SameLine(150); ImGui::SmallButton("x=150");

	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1125515264		; 43160000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11475
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton

; 943  :             ImGui::SameLine(300); ImGui::SmallButton("x=300");

	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1133903872		; 43960000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11476
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton

; 944  : 
; 945  :             // Checkbox
; 946  :             static bool c1=false,c2=false,c3=false,c4=false;
; 947  :             ImGui::Checkbox("My", &c1); ImGui::SameLine();

	push	OFFSET ?c1@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11477
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 948  :             ImGui::Checkbox("Tailor", &c2); ImGui::SameLine();

	push	OFFSET ?c2@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11478
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 949  :             ImGui::Checkbox("Is", &c3); ImGui::SameLine();

	push	OFFSET ?c3@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11479
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 950  :             ImGui::Checkbox("Rich", &c4);

	push	OFFSET ?c4@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11480
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 951  : 
; 952  :             // Various
; 953  :             static float f0=1.0f, f1=2.0f, f2=3.0f;
; 954  :             ImGui::PushItemWidth(80);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp], 1117782016		; 42a00000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 955  :             const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD" };
; 956  :             static int item = -1;
; 957  :             ImGui::Combo("Combo", &item, items, IM_ARRAYSIZE(items)); ImGui::SameLine();

	push	-1
	push	4
	lea	eax, DWORD PTR _items$60[ebp]
	mov	DWORD PTR _items$60[ebp], OFFSET $SG11481
	push	eax
	push	OFFSET ?item@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11485
	mov	DWORD PTR _items$60[ebp+4], OFFSET $SG11482
	mov	DWORD PTR _items$60[ebp+8], OFFSET $SG11483
	mov	DWORD PTR _items$60[ebp+12], OFFSET $SG11484
	call	?Combo@ImGui@@YA_NPBDPAHPBQBDHH@Z	; ImGui::Combo
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 958  :             ImGui::SliderFloat("X", &f0, 0.0f,5.0f); ImGui::SameLine();

	add	esp, 4
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11486
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1084227584		; 40a00000H
	mov	DWORD PTR [esp], 0
	push	OFFSET ?f0@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11487
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 959  :             ImGui::SliderFloat("Y", &f1, 0.0f,5.0f); ImGui::SameLine();

	add	esp, 4
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11488
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1084227584		; 40a00000H
	mov	DWORD PTR [esp], 0
	push	OFFSET ?f1@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11489
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 960  :             ImGui::SliderFloat("Z", &f2, 0.0f,5.0f);

	add	esp, 4
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11490
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1084227584		; 40a00000H
	mov	DWORD PTR [esp], 0
	push	OFFSET ?f2@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11491
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 961  :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 962  : 
; 963  :             ImGui::PushItemWidth(80);

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp], 1117782016		; 42a00000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 964  :             ImGui::Text("Lists:");

	push	OFFSET $SG11492
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 8
	mov	edi, OFFSET ?selection@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA

; 965  :             static int selection[4] = { 0, 1, 2, 3 };
; 966  :             for (int i = 0; i < 4; i++)

	xor	esi, esi
	npad	7
$LL48@ShowTestWi:

; 967  :             {
; 968  :                 if (i > 0) ImGui::SameLine();

	test	esi, esi
	jle	SHORT $LN233@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN233@ShowTestWi:

; 969  :                 ImGui::PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 970  :                 ImGui::ListBox("", &selection[i], items, IM_ARRAYSIZE(items));

	push	-1
	push	4
	lea	eax, DWORD PTR _items$60[ebp]
	push	eax
	push	edi
	push	OFFSET $SG11494
	call	?ListBox@ImGui@@YA_NPBDPAHPBQBDHH@Z	; ImGui::ListBox
	add	esp, 24					; 00000018H

; 971  :                 ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	add	edi, 4
	inc	esi
	cmp	edi, OFFSET ?selection@?BCB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PAHA+16
	jl	SHORT $LL48@ShowTestWi

; 972  :                 //if (ImGui::IsItemHovered()) ImGui::SetTooltip("ListBox %d hovered", i);
; 973  :             }
; 974  :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 978  :             ImGui::Button("A", sz); ImGui::SameLine();

	lea	eax, DWORD PTR _sz$174[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR _sz$174[ebp], 1106247680	; 41f00000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 978  :             ImGui::Button("A", sz); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11495
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR _sz$174[ebp+4], 1106247680	; 41f00000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 978  :             ImGui::Button("A", sz); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 979  :             ImGui::Dummy(sz); ImGui::SameLine();

	lea	eax, DWORD PTR _sz$174[ebp]
	push	eax
	call	?Dummy@ImGui@@YAXABUImVec2@@@Z		; ImGui::Dummy
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 980  :             ImGui::Button("B", sz);

	lea	eax, DWORD PTR _sz$174[ebp]
	push	eax
	push	OFFSET $SG11496
	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H

; 981  : 
; 982  :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN232@ShowTestWi:

; 983  :         }
; 984  : 
; 985  :         if (ImGui::TreeNode("Groups"))

	push	OFFSET $SG11498
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN234@ShowTestWi

; 986  :         {
; 987  :             ImGui::TextWrapped("(Using ImGui::BeginGroup()/EndGroup() to layout items. BeginGroup() basically locks the horizontal position. EndGroup() bundles the whole group so that you can use functions such as IsItemHovered() on it.)");

	push	OFFSET $SG11499
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 988  :             ImGui::BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 989  :             {
; 990  :                 ImGui::BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 991  :                 ImGui::Button("AAA");

	lea	eax, DWORD PTR $T152[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T152[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 991  :                 ImGui::Button("AAA");

	push	eax
	push	OFFSET $SG11500
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T152[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 991  :                 ImGui::Button("AAA");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 992  :                 ImGui::SameLine();

	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 993  :                 ImGui::Button("BBB");

	lea	eax, DWORD PTR $T151[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T151[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 993  :                 ImGui::Button("BBB");

	push	eax
	push	OFFSET $SG11501
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T151[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 993  :                 ImGui::Button("BBB");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 994  :                 ImGui::SameLine();

	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 995  :                 ImGui::BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 996  :                 ImGui::Button("CCC");

	lea	eax, DWORD PTR $T150[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T150[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 996  :                 ImGui::Button("CCC");

	push	eax
	push	OFFSET $SG11502
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T150[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 996  :                 ImGui::Button("CCC");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 997  :                 ImGui::Button("DDD");

	lea	eax, DWORD PTR $T149[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T149[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 997  :                 ImGui::Button("DDD");

	push	eax
	push	OFFSET $SG11503
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T149[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 997  :                 ImGui::Button("DDD");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 24					; 00000018H

; 998  :                 ImGui::EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 999  :                 if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN235@ShowTestWi

; 1000 :                     ImGui::SetTooltip("Group hovered");

	push	OFFSET $SG11505
	call	?SetTooltip@ImGui@@YAXPBDZZ		; ImGui::SetTooltip
	add	esp, 4
$LN235@ShowTestWi:

; 1001 :                 ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1002 :                 ImGui::Button("EEE");

	lea	eax, DWORD PTR $T148[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T148[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1002 :                 ImGui::Button("EEE");

	push	eax
	push	OFFSET $SG11506
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T148[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1002 :                 ImGui::Button("EEE");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1003 :                 ImGui::EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 1004 :             }
; 1005 :             // Capture the group size and create widgets using the same size
; 1006 :             ImVec2 size = ImGui::GetItemRectSize();

	lea	eax, DWORD PTR _size$173[ebp]
	push	eax
	call	?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetItemRectSize
	add	esp, 20					; 00000014H
	movaps	xmm0, XMMWORD PTR __xmm@3f19999a3f4ccccd3e4ccccd3f000000

; 1007 :             const float values[5] = { 0.5f, 0.20f, 0.80f, 0.60f, 0.25f };
; 1008 :             ImGui::PlotHistogram("##values", values, IM_ARRAYSIZE(values), 0, NULL, 0.0f, 1.0f, size);

	lea	eax, DWORD PTR _values$34[ebp]
	mov	DWORD PTR _values$34[ebp+16], 1048576000 ; 3e800000H
	movups	XMMWORD PTR _values$34[ebp], xmm0
	push	4
	push	DWORD PTR _size$173[ebp+4]
	push	DWORD PTR _size$173[ebp]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	0
	push	0
	push	5
	push	eax
	push	OFFSET $SG11507
	call	?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ; ImGui::PlotHistogram

; 1010 :             ImGui::Button("ACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f,size.y));

	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle
	movss	xmm0, DWORD PTR _size$173[ebp]
	subss	xmm0, DWORD PTR [eax+48]
	lea	eax, DWORD PTR $T147[ebp]
	push	eax
	push	OFFSET $SG11508
	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T147[ebp], xmm0
	movss	xmm0, DWORD PTR _size$173[ebp+4]
	movss	DWORD PTR $T147[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1010 :             ImGui::Button("ACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f,size.y));

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1011 :             ImGui::SameLine();

	add	esp, 40					; 00000028H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1012 :             ImGui::Button("REACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f,size.y));

	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle
	movss	xmm0, DWORD PTR _size$173[ebp]
	subss	xmm0, DWORD PTR [eax+48]
	lea	eax, DWORD PTR $T146[ebp]
	push	eax
	push	OFFSET $SG11509
	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T146[ebp], xmm0
	movss	xmm0, DWORD PTR _size$173[ebp+4]
	movss	DWORD PTR $T146[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1012 :             ImGui::Button("REACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f,size.y));

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1013 :             ImGui::EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 1014 :             ImGui::SameLine();

	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1015 : 
; 1016 :             ImGui::Button("LEVERAGE\nBUZZWORD", size);

	lea	eax, DWORD PTR _size$173[ebp]
	push	eax
	push	OFFSET $SG11510
	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1017 :             ImGui::SameLine();

	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1018 : 
; 1019 :             ImGui::ListBoxHeader("List", size);

	lea	eax, DWORD PTR _size$173[ebp]
	push	eax
	push	OFFSET $SG11511
	call	?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::ListBoxHeader

; 1020 :             ImGui::Selectable("Selected", true);

	lea	eax, DWORD PTR $T145[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T145[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1020 :             ImGui::Selectable("Selected", true);

	push	eax
	push	0
	push	1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T145[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1020 :             ImGui::Selectable("Selected", true);

	push	OFFSET $SG11512
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable

; 1021 :             ImGui::Selectable("Not Selected", false);

	lea	eax, DWORD PTR $T144[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T144[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1021 :             ImGui::Selectable("Not Selected", false);

	push	eax
	push	0
	push	0
	push	OFFSET $SG11513
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T144[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1021 :             ImGui::Selectable("Not Selected", false);

	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 48					; 00000030H

; 1022 :             ImGui::ListBoxFooter();

	call	?ListBoxFooter@ImGui@@YAXXZ		; ImGui::ListBoxFooter

; 1023 : 
; 1024 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN234@ShowTestWi:

; 1025 :         }
; 1026 : 
; 1027 :         if (ImGui::TreeNode("Text Baseline Alignment"))

	push	OFFSET $SG11515
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN236@ShowTestWi

; 1028 :         {
; 1029 :             ImGui::TextWrapped("(This is testing the vertical alignment that occurs on text to keep it at the same baseline as widgets. Lines only composed of text or \"small\" widgets fit in less vertical spaces than lines with normal widgets)");

	push	OFFSET $SG11516
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1030 : 
; 1031 :             ImGui::Text("One\nTwo\nThree"); ImGui::SameLine();

	push	OFFSET $SG11517
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1032 :             ImGui::Text("Hello\nWorld"); ImGui::SameLine();

	push	OFFSET $SG11518
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1033 :             ImGui::Text("Banana");

	push	OFFSET $SG11519
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1034 : 
; 1035 :             ImGui::Text("Banana"); ImGui::SameLine();

	push	OFFSET $SG11520
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1036 :             ImGui::Text("Hello\nWorld"); ImGui::SameLine();

	push	OFFSET $SG11521
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1037 :             ImGui::Text("One\nTwo\nThree");

	push	OFFSET $SG11522
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1039 :             ImGui::Button("HOP##1"); ImGui::SameLine();

	lea	eax, DWORD PTR $T143[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T143[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1039 :             ImGui::Button("HOP##1"); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11523
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T143[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1039 :             ImGui::Button("HOP##1"); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1040 :             ImGui::Text("Banana"); ImGui::SameLine();

	push	OFFSET $SG11524
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1041 :             ImGui::Text("Hello\nWorld"); ImGui::SameLine();

	push	OFFSET $SG11525
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1042 :             ImGui::Text("Banana");

	push	OFFSET $SG11526
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1044 :             ImGui::Button("HOP##2"); ImGui::SameLine();

	lea	eax, DWORD PTR $T142[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T142[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1044 :             ImGui::Button("HOP##2"); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11527
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T142[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1044 :             ImGui::Button("HOP##2"); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1045 :             ImGui::Text("Hello\nWorld"); ImGui::SameLine();

	push	OFFSET $SG11528
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1046 :             ImGui::Text("Banana");

	push	OFFSET $SG11529
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1048 :             ImGui::Button("TEST##1"); ImGui::SameLine();

	lea	eax, DWORD PTR $T141[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T141[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1048 :             ImGui::Button("TEST##1"); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11530
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T141[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1048 :             ImGui::Button("TEST##1"); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1049 :             ImGui::Text("TEST"); ImGui::SameLine();

	push	OFFSET $SG11531
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1050 :             ImGui::SmallButton("TEST##2");

	push	OFFSET $SG11532
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton

; 1051 : 
; 1052 :             ImGui::AlignFirstTextHeightToWidgets(); // If your line starts with text, call this to align it to upcoming widgets.

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 1053 :             ImGui::Text("Text aligned to Widget"); ImGui::SameLine();

	push	OFFSET $SG11533
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1054 :             ImGui::Button("Widget##1"); ImGui::SameLine();

	lea	eax, DWORD PTR $T140[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T140[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1054 :             ImGui::Button("Widget##1"); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11534
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T140[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1054 :             ImGui::Button("Widget##1"); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1055 :             ImGui::Text("Widget"); ImGui::SameLine();

	push	OFFSET $SG11535
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1056 :             ImGui::SmallButton("Widget##2");

	push	OFFSET $SG11536
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton

; 1059 :             const float spacing = ImGui::GetStyle().ItemInnerSpacing.x;

	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T139[ebp], 0
	mov	DWORD PTR $T139[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1059 :             const float spacing = ImGui::GetStyle().ItemInnerSpacing.x;

	movss	xmm0, DWORD PTR [eax+56]

; 1060 :             ImGui::Button("Button##1");

	lea	eax, DWORD PTR $T139[ebp]
	push	eax
	push	OFFSET $SG11537
	movss	DWORD PTR _spacing$1$[ebp], xmm0
	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1061 :             ImGui::SameLine(0.0f, spacing);

	movss	xmm0, DWORD PTR _spacing$1$[ebp]
	add	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1062 :             if (ImGui::TreeNode("Node##1")) { for (int i = 0; i < 6; i++) ImGui::BulletText("Item %d..", i); ImGui::TreePop(); }    // Dummy tree data

	push	OFFSET $SG11539
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN237@ShowTestWi
	xor	esi, esi
$LL51@ShowTestWi:
	push	esi
	push	OFFSET $SG11540
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	inc	esi
	add	esp, 8
	cmp	esi, 6
	jl	SHORT $LL51@ShowTestWi
	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN237@ShowTestWi:

; 1063 : 
; 1064 :             ImGui::AlignFirstTextHeightToWidgets();         // Vertically align text node a bit lower so it'll be vertically centered with upcoming widget. Otherwise you can use SmallButton (smaller fit).

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 1065 :             bool node_open = ImGui::TreeNode("Node##2");  // Common mistake to avoid: if we want to SameLine after TreeNode we need to do it before we add child content.

	push	OFFSET $SG11541
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode

; 1066 :             ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##2");

	movss	xmm0, DWORD PTR _spacing$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	mov	BYTE PTR _node_open$1$[ebp], al
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	lea	eax, DWORD PTR $T138[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T138[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1066 :             ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##2");

	push	eax
	push	OFFSET $SG11542
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T138[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1066 :             ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##2");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H

; 1067 :             if (node_open) { for (int i = 0; i < 6; i++) ImGui::BulletText("Item %d..", i); ImGui::TreePop(); }   // Dummy tree data

	cmp	BYTE PTR _node_open$1$[ebp], 0
	je	SHORT $LN238@ShowTestWi
	xor	esi, esi
	npad	4
$LL54@ShowTestWi:
	push	esi
	push	OFFSET $SG11544
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	inc	esi
	add	esp, 8
	cmp	esi, 6
	jl	SHORT $LL54@ShowTestWi
	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN238@ShowTestWi:

; 1070 :             ImGui::Button("Button##3");

	lea	eax, DWORD PTR $T137[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T137[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1070 :             ImGui::Button("Button##3");

	push	eax
	push	OFFSET $SG11545
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T137[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1070 :             ImGui::Button("Button##3");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1071 :             ImGui::SameLine(0.0f, spacing);

	movss	xmm0, DWORD PTR _spacing$1$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1072 :             ImGui::BulletText("Bullet text");

	push	OFFSET $SG11546
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 1073 : 
; 1074 :             ImGui::AlignFirstTextHeightToWidgets();

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 1075 :             ImGui::BulletText("Node");

	push	OFFSET $SG11547
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 1076 :             ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##4");

	movss	xmm0, DWORD PTR _spacing$1$[ebp]
	add	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	lea	eax, DWORD PTR $T136[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T136[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1076 :             ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##4");

	push	eax
	push	OFFSET $SG11548
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T136[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1076 :             ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##4");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H

; 1077 : 
; 1078 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN236@ShowTestWi:

; 1079 :         }
; 1080 : 
; 1081 :         if (ImGui::TreeNode("Scrolling"))

	push	OFFSET $SG11550
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN239@ShowTestWi

; 1082 :         {
; 1083 :             ImGui::TextWrapped("(Use SetScrollHere() or SetScrollFromPosY() to scroll to a given position.)");

	push	OFFSET $SG11551
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1084 :             static bool track = true;
; 1085 :             static int track_line = 50, scroll_to_px = 200;
; 1086 :             ImGui::Checkbox("Track", &track);

	push	OFFSET ?track@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11552
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1087 :             ImGui::PushItemWidth(100);

	add	esp, 8
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 1088 :             ImGui::SameLine(130); track |= ImGui::DragInt("##line", &track_line, 0.25f, 0, 99, "Line %.0f");

	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	ecx
	mov	DWORD PTR [esp], 1124204544		; 43020000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
	push	OFFSET $SG11553
	push	99					; 00000063H
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1048576000		; 3e800000H
	push	OFFSET ?track_line@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11554
	call	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z	; ImGui::DragInt
	or	BYTE PTR ?track@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, al

; 1089 :             bool scroll_to = ImGui::Button("Scroll To");

	lea	eax, DWORD PTR $T135[ebp]
	push	eax
	push	OFFSET $SG11555
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T135[ebp], 0
	mov	DWORD PTR $T135[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1089 :             bool scroll_to = ImGui::Button("Scroll To");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1090 :             ImGui::SameLine(130); scroll_to |= ImGui::DragInt("##pos_y", &scroll_to_px, 1.00f, 0, 9999, "y = %.0f px");

	add	esp, 24					; 00000018H
	mov	BYTE PTR _scroll_to$1$[ebp], al
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 1124204544		; 43020000H
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
	push	OFFSET $SG11556
	push	9999					; 0000270fH
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET ?scroll_to_px@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11557
	call	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z	; ImGui::DragInt
	or	BYTE PTR _scroll_to$1$[ebp], al
	add	esp, 24					; 00000018H

; 1091 :             ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 1092 :             if (scroll_to) track = false;

	movzx	eax, BYTE PTR ?track@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	xor	ecx, ecx
	cmp	BYTE PTR _scroll_to$1$[ebp], cl

; 1093 : 
; 1094 :             for (int i = 0; i < 5; i++)

	mov	esi, OFFSET $SG11564
	cmovne	eax, ecx
	xor	edi, edi
	mov	BYTE PTR ?track@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, al
	npad	1
$LL57@ShowTestWi:

; 1095 :             {
; 1096 :                 if (i > 0) ImGui::SameLine();

	test	edi, edi
	jle	SHORT $LN241@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN241@ShowTestWi:

; 1097 :                 ImGui::BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 1098 :                 ImGui::Text("%s", i == 0 ? "Top" : i == 1 ? "25%" : i == 2 ? "Center" : i == 3 ? "75%" : "Bottom");

	test	edi, edi
	jne	SHORT $LN339@ShowTestWi
	mov	eax, OFFSET $SG11560
	jmp	SHORT $LN336@ShowTestWi
$LN339@ShowTestWi:
	cmp	edi, 1
	jne	SHORT $LN337@ShowTestWi
	mov	eax, OFFSET $SG11561
	jmp	SHORT $LN336@ShowTestWi
$LN337@ShowTestWi:
	cmp	edi, 2
	jne	SHORT $LN335@ShowTestWi
	mov	eax, OFFSET $SG11562
	jmp	SHORT $LN336@ShowTestWi
$LN335@ShowTestWi:
	cmp	edi, 3
	mov	eax, OFFSET $SG11563
	cmovne	eax, esi
$LN336@ShowTestWi:
	push	eax
	push	OFFSET $SG11565
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 8

; 1099 :                 ImGui::BeginChild(ImGui::GetID((void*)(intptr_t)i), ImVec2(ImGui::GetWindowWidth() * 0.17f, 200.0f), true);

	call	?GetWindowWidth@ImGui@@YAMXZ		; ImGui::GetWindowWidth
	fmul	DWORD PTR __real@3e2e147b
	lea	eax, DWORD PTR $T134[ebp]
	push	0
	push	1
	push	eax
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	fstp	DWORD PTR $T134[ebp]
	mov	DWORD PTR $T134[ebp+4], 1128792064	; 43480000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1099 :                 ImGui::BeginChild(ImGui::GetID((void*)(intptr_t)i), ImVec2(ImGui::GetWindowWidth() * 0.17f, 200.0f), true);

	call	?GetID@ImGui@@YAIPBX@Z			; ImGui::GetID
	add	esp, 4
	push	eax
	call	?BeginChild@ImGui@@YA_NIABUImVec2@@_NH@Z ; ImGui::BeginChild
	add	esp, 16					; 00000010H

; 1100 :                 if (scroll_to)

	cmp	BYTE PTR _scroll_to$1$[ebp], 0
	je	SHORT $LN242@ShowTestWi

; 1101 :                     ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + scroll_to_px, i * 0.25f);

	lea	eax, DWORD PTR $T64[ebp]
	push	eax
	call	?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorStartPos
	movd	xmm0, edi
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	movd	xmm0, DWORD PTR ?scroll_to_px@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	cvtdq2ps xmm0, xmm0
	push	ecx
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp], xmm0
	call	?SetScrollFromPosY@ImGui@@YAXMM@Z	; ImGui::SetScrollFromPosY
	add	esp, 8
$LN242@ShowTestWi:

; 1102 :                 for (int line = 0; line < 100; line++)

	xor	esi, esi
$LL60@ShowTestWi:

; 1103 :                 {
; 1104 :                     if (track && line == track_line)

	cmp	BYTE PTR ?track@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN243@ShowTestWi
	cmp	esi, DWORD PTR ?track_line@?BDJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	jne	SHORT $LN243@ShowTestWi

; 1106 :                         ImGui::TextColored(ImColor(255,255,0), "Line %d", line);

	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f8000003f800000
	lea	eax, DWORD PTR $T38[ebp]
	push	esi
	push	OFFSET $SG11569
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T38[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1106 :                         ImGui::TextColored(ImColor(255,255,0), "Line %d", line);

	call	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ	; ImGui::TextColored
	movd	xmm0, edi

; 1107 :                         ImGui::SetScrollHere(i * 0.25f); // 0.0f:top, 0.5f:center, 1.0f:bottom

	add	esp, 8
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	call	?SetScrollHere@ImGui@@YAXM@Z		; ImGui::SetScrollHere
	add	esp, 4

; 1108 :                     }
; 1109 :                     else

	jmp	SHORT $LN58@ShowTestWi
$LN243@ShowTestWi:

; 1110 :                     {
; 1111 :                         ImGui::Text("Line %d", line);

	push	esi
	push	OFFSET $SG11570
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 8
$LN58@ShowTestWi:

; 1102 :                 for (int line = 0; line < 100; line++)

	inc	esi
	cmp	esi, 100				; 00000064H
	jl	SHORT $LL60@ShowTestWi

; 1112 :                     }
; 1113 :                 }
; 1114 :                 ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 1115 :                 ImGui::EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	inc	edi
	mov	esi, OFFSET $SG11564
	cmp	edi, 5
	jl	$LL57@ShowTestWi

; 1116 :             }
; 1117 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN239@ShowTestWi:

; 1118 :         }
; 1119 : 
; 1120 :         if (ImGui::TreeNode("Horizontal Scrolling"))

	push	OFFSET $SG11572
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN245@ShowTestWi

; 1121 :         {
; 1122 :             ImGui::Bullet(); ImGui::TextWrapped("Horizontal scrolling for a window has to be enabled explicitly via the ImGuiWindowFlags_HorizontalScrollbar flag.");

	call	?Bullet@ImGui@@YAXXZ			; ImGui::Bullet
	push	OFFSET $SG11573
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1123 :             ImGui::Bullet(); ImGui::TextWrapped("You may want to explicitly specify content width by calling SetNextWindowContentWidth() before Begin().");

	call	?Bullet@ImGui@@YAXXZ			; ImGui::Bullet
	push	OFFSET $SG11574
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1124 :             static int lines = 7;
; 1125 :             ImGui::SliderInt("Lines", &lines, 1, 15);

	push	OFFSET $SG11575
	push	15					; 0000000fH
	push	1
	push	OFFSET ?lines@?BEL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11576
	call	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z	; ImGui::SliderInt

; 1126 :             ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp], 1077936128		; 40400000H
	push	6
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 1127 :             ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));

	lea	eax, DWORD PTR $T133[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T133[ebp], 1073741824	; 40000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1127 :             ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));

	push	eax
	push	5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T133[ebp+4], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1127 :             ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 1128 :             ImGui::BeginChild("scrolling", ImVec2(0, ImGui::GetItemsLineHeightWithSpacing()*7 + 30), true, ImGuiWindowFlags_HorizontalScrollbar);

	call	?GetItemsLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetItemsLineHeightWithSpacing
	fmul	DWORD PTR __real@40e00000
	lea	eax, DWORD PTR $T132[ebp]
	push	2048					; 00000800H
	push	1
	push	eax
	push	OFFSET $SG11577
	fadd	DWORD PTR __real@41f00000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T132[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1128 :             ImGui::BeginChild("scrolling", ImVec2(0, ImGui::GetItemsLineHeightWithSpacing()*7 + 30), true, ImGuiWindowFlags_HorizontalScrollbar);

	fstp	DWORD PTR __y$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR $T132[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1128 :             ImGui::BeginChild("scrolling", ImVec2(0, ImGui::GetItemsLineHeightWithSpacing()*7 + 30), true, ImGuiWindowFlags_HorizontalScrollbar);

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild

; 1129 :             for (int line = 0; line < lines; line++)

	mov	edx, DWORD PTR ?lines@?BEL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	xor	ecx, ecx
	add	esp, 32					; 00000020H
	mov	DWORD PTR _line$1$[ebp], ecx
	test	edx, edx
	jle	$LN62@ShowTestWi

; 1121 :         {
; 1122 :             ImGui::Bullet(); ImGui::TextWrapped("Horizontal scrolling for a window has to be enabled explicitly via the ImGuiWindowFlags_HorizontalScrollbar flag.");

	xor	edi, edi
	mov	esi, 9
	mov	DWORD PTR tv5692[ebp], edi
$LL63@ShowTestWi:

; 1130 :             {
; 1131 :                 // Display random stuff (for the sake of this trivial demo we are using basic Button+SameLine. If you want to create your own time line for a real application you may be better off 
; 1132 :                 // manipulating the cursor position yourself, aka using SetCursorPos/SetCursorScreenPos to position the widgets yourself. You may also want to use the lower-level ImDrawList API)
; 1133 :                 int num_buttons = 10 + ((line & 1) ? line * 9 : line * 3);

	test	cl, 1
	mov	eax, 3
	cmovne	eax, esi

; 1134 :                 for (int n = 0; n < num_buttons; n++)

	xor	esi, esi
	imul	ecx, eax
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _num_buttons$1$[ebp], ecx
	test	ecx, ecx
	jle	$LN61@ShowTestWi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	DWORD PTR $T52[ebp+12], 1065353216	; 3f800000H
	mov	DWORD PTR $T17[ebp+12], 1065353216	; 3f800000H
	mov	DWORD PTR $T14[ebp+12], 1065353216	; 3f800000H
	npad	3
$LL66@ShowTestWi:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1136 :                     if (n > 0) ImGui::SameLine();

	test	esi, esi
	jle	SHORT $LN246@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN246@ShowTestWi:

; 1137 :                     ImGui::PushID(n + line * 1000);

	lea	eax, DWORD PTR [esi+edi]
	push	eax
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 1138 :                     char num_buf[16];
; 1139 :                     const char* label = (!(n%15)) ? "FizzBuzz" : (!(n%3)) ? "Fizz" : (!(n%5)) ? "Buzz" : (sprintf(num_buf, "%d", n), num_buf);

	mov	eax, -2004318071			; 88888889H
	add	esp, 4
	mul	esi
	mov	eax, esi
	shr	edx, 3
	mov	ecx, edx
	shl	ecx, 4
	sub	ecx, edx
	sub	eax, ecx
	jne	SHORT $LN347@ShowTestWi
	mov	edi, OFFSET $SG11579
	jmp	SHORT $LN344@ShowTestWi
$LN347@ShowTestWi:
	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, esi
	mul	esi
	shr	edx, 1
	lea	eax, DWORD PTR [edx+edx*2]
	sub	ecx, eax
	jne	SHORT $LN345@ShowTestWi
	mov	edi, OFFSET $SG11580
	jmp	SHORT $LN344@ShowTestWi
$LN345@ShowTestWi:
	mov	eax, -858993459				; cccccccdH
	mov	ecx, esi
	mul	esi
	shr	edx, 2
	lea	eax, DWORD PTR [edx+edx*4]
	sub	ecx, eax
	jne	SHORT $LN343@ShowTestWi
	mov	edi, OFFSET $SG11581
	jmp	SHORT $LN344@ShowTestWi
$LN343@ShowTestWi:
	push	esi
	lea	eax, DWORD PTR _num_buf$37[ebp]
	push	OFFSET $SG11582
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	lea	edi, DWORD PTR _num_buf$37[ebp]
$LN344@ShowTestWi:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	lea	eax, DWORD PTR _b$83[ebp]
	movd	xmm0, esi
	push	eax
	lea	eax, DWORD PTR _g$76[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1140 :                     float hue = n*0.05f;

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	lea	eax, DWORD PTR _r$201[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1140 :                     float hue = n*0.05f;

	mulss	xmm0, DWORD PTR __real@3d4ccccd
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	mov	DWORD PTR [esp+8], 1058642330		; 3f19999aH
	mov	DWORD PTR [esp+4], 1058642330		; 3f19999aH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1140 :                     float hue = n*0.05f;

	movss	DWORD PTR _hue$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$201[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1141 :                     ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(hue, 0.6f, 0.6f));

	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T52[ebp], xmm0
	movss	xmm0, DWORD PTR _g$76[ebp]
	movss	DWORD PTR $T52[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$83[ebp]
	movss	DWORD PTR $T52[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T52[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1141 :                     ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(hue, 0.6f, 0.6f));

	push	eax
	push	22					; 00000016H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1141 :                     ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(hue, 0.6f, 0.6f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	xmm0, DWORD PTR _hue$1$[ebp]
	lea	eax, DWORD PTR _b$45[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1141 :                     ImGui::PushStyleColor(ImGuiCol_Button, ImColor::HSV(hue, 0.6f, 0.6f));

	add	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	lea	eax, DWORD PTR _g$42[ebp]
	push	eax
	lea	eax, DWORD PTR _r$24[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1060320051		; 3f333333H
	mov	DWORD PTR [esp+4], 1060320051		; 3f333333H
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$24[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1142 :                     ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImColor::HSV(hue, 0.7f, 0.7f));

	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T17[ebp], xmm0
	movss	xmm0, DWORD PTR _g$42[ebp]
	movss	DWORD PTR $T17[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$45[ebp]
	movss	DWORD PTR $T17[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T17[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1142 :                     ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImColor::HSV(hue, 0.7f, 0.7f));

	push	eax
	push	23					; 00000017H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1142 :                     ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImColor::HSV(hue, 0.7f, 0.7f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	xmm0, DWORD PTR _hue$1$[ebp]
	lea	eax, DWORD PTR _b$85[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1142 :                     ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImColor::HSV(hue, 0.7f, 0.7f));

	add	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	lea	eax, DWORD PTR _g$88[ebp]
	push	eax
	lea	eax, DWORD PTR _r$48[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1061997773		; 3f4ccccdH
	mov	DWORD PTR [esp+4], 1061997773		; 3f4ccccdH
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$48[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1143 :                     ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImColor::HSV(hue, 0.8f, 0.8f));

	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T14[ebp], xmm0
	movss	xmm0, DWORD PTR _g$88[ebp]
	movss	DWORD PTR $T14[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$85[ebp]
	movss	DWORD PTR $T14[ebp+8], xmm0

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR $T14[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1143 :                     ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImColor::HSV(hue, 0.8f, 0.8f));

	push	eax
	push	24					; 00000018H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1143 :                     ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImColor::HSV(hue, 0.8f, 0.8f));

	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor

; 1144 :                     ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));

	mov	eax, DWORD PTR _line$1$[ebp]
	add	eax, esi
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	call	___libm_sse2_sinf
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1144 :                     ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));

	mulss	xmm0, DWORD PTR __real@41a00000
	lea	eax, DWORD PTR $T131[ebp]
	push	eax
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T131[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1144 :                     ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));

	addss	xmm0, DWORD PTR __real@42200000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T131[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1144 :                     ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1145 :                     ImGui::PopStyleColor(3);

	push	3
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 44					; 0000002cH

; 1146 :                     ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	mov	edi, DWORD PTR tv5692[ebp]
	inc	esi
	cmp	esi, DWORD PTR _num_buttons$1$[ebp]
	jl	$LL66@ShowTestWi

; 1134 :                 for (int n = 0; n < num_buttons; n++)

	mov	edx, DWORD PTR ?lines@?BEL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
$LN61@ShowTestWi:

; 1129 :             for (int line = 0; line < lines; line++)

	mov	ecx, DWORD PTR _line$1$[ebp]
	add	edi, 1000				; 000003e8H
	inc	ecx
	mov	DWORD PTR tv5692[ebp], edi
	mov	DWORD PTR _line$1$[ebp], ecx
	mov	esi, 9
	cmp	ecx, edx
	jl	$LL63@ShowTestWi
$LN62@ShowTestWi:

; 1147 :                 }
; 1148 :             }
; 1149 :             ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 1150 :             ImGui::PopStyleVar(2);

	push	2
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	xorps	xmm0, xmm0

; 1151 :             float scroll_x_delta = 0.0f;
; 1152 :             ImGui::SmallButton("<<"); if (ImGui::IsItemActive()) scroll_x_delta = -ImGui::GetIO().DeltaTime * 1000.0f;

	push	OFFSET $SG11583
	movss	DWORD PTR _scroll_x_delta$1$[ebp], xmm0
	movss	DWORD PTR _scroll_x_delta$98[ebp], xmm0
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 8
	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	je	SHORT $LN247@ShowTestWi
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@c47a0000
	movss	DWORD PTR _scroll_x_delta$1$[ebp], xmm0
	movss	DWORD PTR _scroll_x_delta$98[ebp], xmm0
$LN247@ShowTestWi:

; 1153 :             ImGui::SameLine(); ImGui::Text("Scroll from code"); ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11585
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1154 :             ImGui::SmallButton(">>"); if (ImGui::IsItemActive()) scroll_x_delta = +ImGui::GetIO().DeltaTime * 1000.0f;

	push	OFFSET $SG11586
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 12					; 0000000cH
	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	je	SHORT $LN880@ShowTestWi
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _scroll_x_delta$98[ebp], xmm0
	jmp	SHORT $LN248@ShowTestWi
$LN880@ShowTestWi:
	movss	xmm0, DWORD PTR _scroll_x_delta$1$[ebp]
$LN248@ShowTestWi:

; 1155 :             if (scroll_x_delta != 0.0f)

	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN249@ShowTestWi

; 1157 :                 ImGui::BeginChild("scrolling"); // Demonstrate a trick: you can use Begin to set yourself in the context of another window (here we are already out of your child window)

	push	0
	push	0
	lea	eax, DWORD PTR $T130[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T130[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1157 :                 ImGui::BeginChild("scrolling"); // Demonstrate a trick: you can use Begin to set yourself in the context of another window (here we are already out of your child window)

	push	eax
	push	OFFSET $SG11589
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T130[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1157 :                 ImGui::BeginChild("scrolling"); // Demonstrate a trick: you can use Begin to set yourself in the context of another window (here we are already out of your child window)

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild

; 1158 :                 ImGui::SetScrollX(ImGui::GetScrollX() + scroll_x_delta);

	call	?GetScrollX@ImGui@@YAMXZ		; ImGui::GetScrollX
	fadd	DWORD PTR _scroll_x_delta$98[ebp]
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?SetScrollX@ImGui@@YAXM@Z		; ImGui::SetScrollX
	add	esp, 4

; 1159 :                 ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
$LN249@ShowTestWi:

; 1160 :             }
; 1161 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN245@ShowTestWi:

; 1162 :         }
; 1163 : 
; 1164 :         if (ImGui::TreeNode("Clipping"))

	push	OFFSET $SG11591
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN250@ShowTestWi

; 1165 :         {
; 1166 :             static ImVec2 size(100, 100), offset(50, 20);
; 1167 :             ImGui::TextWrapped("On a per-widget basis we are occasionally clipping text CPU-side if it won't fit in its frame. Otherwise we are doing coarser clipping + passing a scissor rectangle to the renderer. The system is designed to try minimizing both execution and CPU/GPU rendering cost.");

	push	OFFSET $SG11592
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1168 :             ImGui::DragFloat2("size", (float*)&size, 0.5f, 0.0f, 200.0f, "%.0f");

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG11593
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1128792064		; 43480000H
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	push	OFFSET ?size@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A
	push	OFFSET $SG11594
	call	?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z	; ImGui::DragFloat2

; 1169 :             ImGui::TextWrapped("(Click and drag)");

	push	OFFSET $SG11595
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1170 :             ImVec2 pos = ImGui::GetCursorScreenPos();

	lea	eax, DWORD PTR _pos$172[ebp]
	push	eax
	call	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos

; 1171 :             ImVec4 clip_rect(pos.x, pos.y, pos.x+size.x, pos.y+size.y);

	movss	xmm1, DWORD PTR _pos$172[ebp]
	movss	xmm0, DWORD PTR _pos$172[ebp+4]
	movaps	xmm3, xmm1
	addss	xmm3, DWORD PTR ?size@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A
	movaps	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _clip_rect$51[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1171 :             ImVec4 clip_rect(pos.x, pos.y, pos.x+size.x, pos.y+size.y);

	addss	xmm2, DWORD PTR ?size@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A+4

; 1172 :             ImGui::InvisibleButton("##dummy", size);

	push	OFFSET ?size@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A
	push	OFFSET $SG11596
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _clip_rect$51[ebp+4], xmm0
	movss	DWORD PTR _clip_rect$51[ebp+8], xmm3
	movss	DWORD PTR _clip_rect$51[ebp+12], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1172 :             ImGui::InvisibleButton("##dummy", size);

	call	?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::InvisibleButton
	add	esp, 44					; 0000002cH

; 1173 :             if (ImGui::IsItemActive() && ImGui::IsMouseDragging()) { offset.x += ImGui::GetIO().MouseDelta.x; offset.y += ImGui::GetIO().MouseDelta.y; }

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	je	SHORT $LN251@ShowTestWi
	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	0
	call	?IsMouseDragging@ImGui@@YA_NHM@Z	; ImGui::IsMouseDragging
	add	esp, 8
	test	al, al
	je	SHORT $LN251@ShowTestWi
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax+868]
	addss	xmm0, DWORD PTR ?offset@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A
	movss	DWORD PTR ?offset@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A, xmm0
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax+872]
	addss	xmm0, DWORD PTR ?offset@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A+4
	movss	DWORD PTR ?offset@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A+4, xmm0
$LN251@ShowTestWi:
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003ef0f0f23eb4b4b53eb4b4b5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	eax, DWORD PTR $T36[ebp]
	push	eax
	movups	XMMWORD PTR $T36[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1174 :             ImGui::GetWindowDrawList()->AddRectFilled(pos, ImVec2(pos.x+size.x,pos.y+size.y), ImColor(90,90,120,255));

	movss	xmm1, DWORD PTR _pos$172[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	add	esp, 4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1174 :             ImGui::GetWindowDrawList()->AddRectFilled(pos, ImVec2(pos.x+size.x,pos.y+size.y), ImColor(90,90,120,255));

	movss	xmm0, DWORD PTR _pos$172[ebp+4]
	addss	xmm1, DWORD PTR ?size@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A
	addss	xmm0, DWORD PTR ?size@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A+4
	push	-1
	push	ecx
	mov	DWORD PTR [esp], 0
	push	eax
	lea	eax, DWORD PTR $T129[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T129[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1174 :             ImGui::GetWindowDrawList()->AddRectFilled(pos, ImVec2(pos.x+size.x,pos.y+size.y), ImColor(90,90,120,255));

	push	eax
	lea	eax, DWORD PTR _pos$172[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T129[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1174 :             ImGui::GetWindowDrawList()->AddRectFilled(pos, ImVec2(pos.x+size.x,pos.y+size.y), ImColor(90,90,120,255));

	push	eax
	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	ecx, eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	eax, DWORD PTR $T35[ebp]
	push	eax
	movups	XMMWORD PTR $T35[ebp], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1175 :             ImGui::GetWindowDrawList()->AddText(ImGui::GetFont(), ImGui::GetFontSize()*2.0f, ImVec2(pos.x+offset.x,pos.y+offset.y), ImColor(255,255,255,255), "Line 1 hello\nLine 2 clip me!", NULL, 0.0f, &clip_rect);

	movss	xmm1, DWORD PTR _pos$172[ebp]
	lea	ecx, DWORD PTR _clip_rect$51[ebp]
	movss	xmm0, DWORD PTR _pos$172[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	add	esp, 4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1175 :             ImGui::GetWindowDrawList()->AddText(ImGui::GetFont(), ImGui::GetFontSize()*2.0f, ImVec2(pos.x+offset.x,pos.y+offset.y), ImColor(255,255,255,255), "Line 1 hello\nLine 2 clip me!", NULL, 0.0f, &clip_rect);

	addss	xmm1, DWORD PTR ?offset@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A
	addss	xmm0, DWORD PTR ?offset@?BFL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec2@@A+4
	push	ecx
	push	ecx
	mov	DWORD PTR [esp], 0
	push	0
	push	OFFSET $SG11598
	push	eax
	lea	eax, DWORD PTR $T128[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T128[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1175 :             ImGui::GetWindowDrawList()->AddText(ImGui::GetFont(), ImGui::GetFontSize()*2.0f, ImVec2(pos.x+offset.x,pos.y+offset.y), ImColor(255,255,255,255), "Line 1 hello\nLine 2 clip me!", NULL, 0.0f, &clip_rect);

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T128[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1175 :             ImGui::GetWindowDrawList()->AddText(ImGui::GetFont(), ImGui::GetFontSize()*2.0f, ImVec2(pos.x+offset.x,pos.y+offset.y), ImColor(255,255,255,255), "Line 1 hello\nLine 2 clip me!", NULL, 0.0f, &clip_rect);

	call	?GetFontSize@ImGui@@YAMXZ		; ImGui::GetFontSize
	fadd	ST(0), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?GetFont@ImGui@@YAPAUImFont@@XZ		; ImGui::GetFont
	push	eax
	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	ecx, eax
	call	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText

; 1176 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN250@ShowTestWi:

; 1177 :         }
; 1178 :     }
; 1179 : 
; 1180 :     if (ImGui::CollapsingHeader("Popups & Modal windows"))

	push	0
	push	OFFSET $SG11600
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	$LN273@ShowTestWi

; 1181 :     {
; 1182 :         if (ImGui::TreeNode("Popups"))

	push	OFFSET $SG11602
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN253@ShowTestWi

; 1183 :         {
; 1184 :             ImGui::TextWrapped("When a popup is active, it inhibits interacting with windows that are behind the popup. Clicking outside the popup closes it.");

	push	OFFSET $SG11603
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1192 :             if (ImGui::Button("Select.."))

	lea	eax, DWORD PTR $T127[ebp]
	mov	DWORD PTR _names$33[ebp], OFFSET $SG11604
	push	eax
	push	OFFSET $SG11610
	mov	DWORD PTR _names$33[ebp+4], OFFSET $SG11605
	mov	DWORD PTR _names$33[ebp+8], OFFSET $SG11606
	mov	DWORD PTR _names$33[ebp+12], OFFSET $SG11607
	mov	DWORD PTR _names$33[ebp+16], OFFSET $SG11608
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T127[ebp], 0
	mov	DWORD PTR $T127[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1192 :             if (ImGui::Button("Select.."))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN254@ShowTestWi

; 1193 :                 ImGui::OpenPopup("select");

	push	OFFSET $SG11611
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 4
$LN254@ShowTestWi:

; 1194 :             ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1195 :             ImGui::Text(selected_fish == -1 ? "<None>" : names[selected_fish]);

	mov	eax, DWORD PTR ?selected_fish@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN349@ShowTestWi
	mov	eax, OFFSET $SG11612
	jmp	SHORT $LN350@ShowTestWi
$LN349@ShowTestWi:
	mov	eax, DWORD PTR _names$33[ebp+eax*4]
$LN350@ShowTestWi:
	push	eax
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1196 :             if (ImGui::BeginPopup("select"))

	push	OFFSET $SG11614
	call	?BeginPopup@ImGui@@YA_NPBD@Z		; ImGui::BeginPopup
	add	esp, 8
	test	al, al
	je	SHORT $LN255@ShowTestWi

; 1197 :             {
; 1198 :                 ImGui::Text("Aquarium");

	push	OFFSET $SG11615
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4

; 1199 :                 ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1200 :                 for (int i = 0; i < IM_ARRAYSIZE(names); i++)

	xor	esi, esi
$LL71@ShowTestWi:

; 1201 :                     if (ImGui::Selectable(names[i]))

	lea	eax, DWORD PTR $T126[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T126[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1201 :                     if (ImGui::Selectable(names[i]))

	push	eax
	push	0
	push	0
	push	DWORD PTR _names$33[ebp+esi*4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T126[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1201 :                     if (ImGui::Selectable(names[i]))

	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	mov	ecx, DWORD PTR ?selected_fish@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	add	esp, 16					; 00000010H
	test	al, al
	cmovne	ecx, esi
	inc	esi
	mov	DWORD PTR ?selected_fish@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, ecx
	cmp	esi, 5
	jl	SHORT $LL71@ShowTestWi

; 1202 :                         selected_fish = i;
; 1203 :                 ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN255@ShowTestWi:

; 1207 :             if (ImGui::Button("Toggle.."))

	lea	eax, DWORD PTR $T125[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T125[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1207 :             if (ImGui::Button("Toggle.."))

	push	eax
	push	OFFSET $SG11618
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T125[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1207 :             if (ImGui::Button("Toggle.."))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	test	al, al
	je	SHORT $LN257@ShowTestWi

; 1208 :                 ImGui::OpenPopup("toggle");

	push	OFFSET $SG11619
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 4
$LN257@ShowTestWi:

; 1209 :             if (ImGui::BeginPopup("toggle"))

	push	OFFSET $SG11621
	call	?BeginPopup@ImGui@@YA_NPBD@Z		; ImGui::BeginPopup
	add	esp, 4
	test	al, al
	je	$LN258@ShowTestWi

; 1210 :             {
; 1211 :                 for (int i = 0; i < IM_ARRAYSIZE(names); i++)

	xor	esi, esi
	npad	4
$LL74@ShowTestWi:

; 1212 :                     ImGui::MenuItem(names[i], "", &toggles[i]);

	push	1
	lea	eax, DWORD PTR ?toggles@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA[esi]
	push	eax
	push	OFFSET $SG11622
	push	DWORD PTR _names$33[ebp+esi*4]
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, 5
	jl	SHORT $LL74@ShowTestWi

; 1213 :                 if (ImGui::BeginMenu("Sub-menu"))

	push	1
	push	OFFSET $SG11624
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	SHORT $LN259@ShowTestWi

; 1214 :                 {
; 1215 :                     ImGui::MenuItem("Click me");

	push	1
	push	0
	push	0
	push	OFFSET $SG11625
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem
	add	esp, 16					; 00000010H

; 1216 :                     ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN259@ShowTestWi:

; 1217 :                 }
; 1218 : 
; 1219 :                 ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1220 :                 ImGui::Text("Tooltip here");

	push	OFFSET $SG11626
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4

; 1221 :                 if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN260@ShowTestWi

; 1222 :                     ImGui::SetTooltip("I am a tooltip over a popup");

	push	OFFSET $SG11628
	call	?SetTooltip@ImGui@@YAXPBDZZ		; ImGui::SetTooltip
	add	esp, 4
$LN260@ShowTestWi:

; 1224 :                 if (ImGui::Button("Stacked Popup"))

	lea	eax, DWORD PTR $T124[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T124[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1224 :                 if (ImGui::Button("Stacked Popup"))

	push	eax
	push	OFFSET $SG11630
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T124[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1224 :                 if (ImGui::Button("Stacked Popup"))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	test	al, al
	je	SHORT $LN261@ShowTestWi

; 1225 :                     ImGui::OpenPopup("another popup");

	push	OFFSET $SG11631
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 4
$LN261@ShowTestWi:

; 1226 :                 if (ImGui::BeginPopup("another popup"))

	push	OFFSET $SG11633
	call	?BeginPopup@ImGui@@YA_NPBD@Z		; ImGui::BeginPopup
	add	esp, 4
	test	al, al
	je	SHORT $LN262@ShowTestWi

; 1227 :                 {
; 1228 :                     for (int i = 0; i < IM_ARRAYSIZE(names); i++)

	xor	esi, esi
	npad	7
$LL77@ShowTestWi:

; 1229 :                         ImGui::MenuItem(names[i], "", &toggles[i]);

	push	1
	lea	eax, DWORD PTR ?toggles@?BGE@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PA_NA[esi]
	push	eax
	push	OFFSET $SG11634
	push	DWORD PTR _names$33[ebp+esi*4]
	call	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z	; ImGui::MenuItem
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, 5
	jl	SHORT $LL77@ShowTestWi

; 1230 :                     if (ImGui::BeginMenu("Sub-menu"))

	push	1
	push	OFFSET $SG11636
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 8
	test	al, al
	je	SHORT $LN263@ShowTestWi

; 1231 :                     {
; 1232 :                         ImGui::MenuItem("Click me");

	push	1
	push	0
	push	0
	push	OFFSET $SG11637
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem
	add	esp, 16					; 00000010H

; 1233 :                         ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN263@ShowTestWi:

; 1234 :                     }
; 1235 :                     ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN262@ShowTestWi:

; 1236 :                 }
; 1237 :                 ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN258@ShowTestWi:

; 1240 :             if (ImGui::Button("Popup Menu.."))

	lea	eax, DWORD PTR $T123[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T123[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1240 :             if (ImGui::Button("Popup Menu.."))

	push	eax
	push	OFFSET $SG11639
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T123[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1240 :             if (ImGui::Button("Popup Menu.."))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	test	al, al
	je	SHORT $LN264@ShowTestWi

; 1241 :                 ImGui::OpenPopup("FilePopup");

	push	OFFSET $SG11640
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 4
$LN264@ShowTestWi:

; 1242 :             if (ImGui::BeginPopup("FilePopup"))

	push	OFFSET $SG11642
	call	?BeginPopup@ImGui@@YA_NPBD@Z		; ImGui::BeginPopup
	add	esp, 4
	test	al, al
	je	SHORT $LN265@ShowTestWi

; 1243 :             {
; 1244 :                 ShowExampleMenuFile();

	call	?ShowExampleMenuFile@@YAXXZ		; ShowExampleMenuFile

; 1245 :                 ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN265@ShowTestWi:

; 1246 :             }
; 1247 : 
; 1248 :             ImGui::Spacing();

	call	?Spacing@ImGui@@YAXXZ			; ImGui::Spacing

; 1249 :             ImGui::TextWrapped("Below we are testing adding menu items to a regular window. It's rather unusual but should work!");

	push	OFFSET $SG11643
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1250 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1251 :             // NB: As a quirk in this very specific example, we want to differentiate the parent of this menu from the parent of the various popup menus above.
; 1252 :             // To do so we are encloding the items in a PushID()/PopID() block to make them two different menusets. If we don't, opening any popup above and hovering our menu here
; 1253 :             // would open it. This is because once a menu is active, we allow to switch to a sibling menu by just hovering on it, which is the desired behavior for regular menus.
; 1254 :             ImGui::PushID("foo");

	push	OFFSET $SG11644
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 1255 :             ImGui::MenuItem("Menu item", "CTRL+M");

	push	1
	push	0
	push	OFFSET $SG11645
	push	OFFSET $SG11646
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem

; 1256 :             if (ImGui::BeginMenu("Menu inside a regular window"))

	push	1
	push	OFFSET $SG11648
	call	?BeginMenu@ImGui@@YA_NPBD_N@Z		; ImGui::BeginMenu
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN266@ShowTestWi

; 1257 :             {
; 1258 :                 ShowExampleMenuFile();

	call	?ShowExampleMenuFile@@YAXXZ		; ShowExampleMenuFile

; 1259 :                 ImGui::EndMenu();

	call	?EndMenu@ImGui@@YAXXZ			; ImGui::EndMenu
$LN266@ShowTestWi:

; 1260 :             }
; 1261 :             ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 1262 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1263 : 
; 1264 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN253@ShowTestWi:

; 1265 :         }
; 1266 : 
; 1267 :         if (ImGui::TreeNode("Context menus"))

	push	OFFSET $SG11650
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN267@ShowTestWi

; 1268 :         {
; 1269 :             static float value = 0.5f;
; 1270 :             ImGui::Text("Value = %.3f (<-- right-click here)", value);

	movss	xmm0, DWORD PTR ?value@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11651
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1271 :             if (ImGui::BeginPopupContextItem("item context menu"))

	push	1
	push	OFFSET $SG11653
	call	?BeginPopupContextItem@ImGui@@YA_NPBDH@Z ; ImGui::BeginPopupContextItem
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN268@ShowTestWi

; 1273 :                 if (ImGui::Selectable("Set to zero")) value = 0.0f;

	lea	eax, DWORD PTR $T122[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T122[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1273 :                 if (ImGui::Selectable("Set to zero")) value = 0.0f;

	push	eax
	push	0
	push	0
	push	OFFSET $SG11655
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T122[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1273 :                 if (ImGui::Selectable("Set to zero")) value = 0.0f;

	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN269@ShowTestWi
	mov	DWORD PTR ?value@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, 0
$LN269@ShowTestWi:

; 1274 :                 if (ImGui::Selectable("Set to PI")) value = 3.1415f;

	lea	eax, DWORD PTR $T121[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T121[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1274 :                 if (ImGui::Selectable("Set to PI")) value = 3.1415f;

	push	eax
	push	0
	push	0
	push	OFFSET $SG11657
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T121[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1274 :                 if (ImGui::Selectable("Set to PI")) value = 3.1415f;

	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN270@ShowTestWi
	mov	DWORD PTR ?value@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA, 1078529622 ; 40490e56H
$LN270@ShowTestWi:

; 1275 :                 ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN268@ShowTestWi:

; 1278 :             static ImVec4 color = ImColor(0.8f, 0.5f, 1.0f, 1.0f);

	mov	eax, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS2@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	SHORT $LN78@ShowTestWi
	push	OFFSET ?$TSS2@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS2@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, -1
	jne	SHORT $LN78@ShowTestWi
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f0000003f4ccccd
	push	OFFSET ?$TSS2@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR ?color@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec4@@A, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1278 :             static ImVec4 color = ImColor(0.8f, 0.5f, 1.0f, 1.0f);

	call	__Init_thread_footer
	add	esp, 4
$LN78@ShowTestWi:

; 1279 :             ImGui::ColorButton(color);

	push	1
	push	0
	push	OFFSET ?color@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec4@@A
	call	?ColorButton@ImGui@@YA_NABUImVec4@@_N1@Z ; ImGui::ColorButton

; 1280 :             if (ImGui::BeginPopupContextItem("color context menu"))

	push	1
	push	OFFSET $SG11659
	call	?BeginPopupContextItem@ImGui@@YA_NPBDH@Z ; ImGui::BeginPopupContextItem
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN271@ShowTestWi

; 1281 :             {
; 1282 :                 ImGui::Text("Edit color");

	push	OFFSET $SG11660
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1283 :                 ImGui::ColorEdit3("##edit", (float*)&color);

	push	OFFSET ?color@?BIL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImVec4@@A
	push	OFFSET $SG11661
	call	?ColorEdit3@ImGui@@YA_NPBDQAM@Z		; ImGui::ColorEdit3

; 1284 :                 if (ImGui::Button("Close"))

	lea	eax, DWORD PTR $T120[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T120[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1284 :                 if (ImGui::Button("Close"))

	push	eax
	push	OFFSET $SG11663
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T120[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1284 :                 if (ImGui::Button("Close"))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN272@ShowTestWi

; 1285 :                     ImGui::CloseCurrentPopup();

	call	?CloseCurrentPopup@ImGui@@YAXXZ		; ImGui::CloseCurrentPopup
$LN272@ShowTestWi:

; 1286 :                 ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN271@ShowTestWi:

; 1287 :             }
; 1288 :             ImGui::SameLine(); ImGui::Text("(<-- right-click here)");

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11664
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH

; 1289 : 
; 1290 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN267@ShowTestWi:

; 1291 :         }
; 1292 : 
; 1293 :         if (ImGui::TreeNode("Modals"))

	push	OFFSET $SG11666
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN273@ShowTestWi

; 1294 :         {
; 1295 :             ImGui::TextWrapped("Modal windows are like popups but the user cannot close them by clicking outside the window.");

	push	OFFSET $SG11667
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1297 :             if (ImGui::Button("Delete.."))

	lea	eax, DWORD PTR $T119[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T119[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1297 :             if (ImGui::Button("Delete.."))

	push	eax
	push	OFFSET $SG11669
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T119[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1297 :             if (ImGui::Button("Delete.."))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN274@ShowTestWi

; 1298 :                 ImGui::OpenPopup("Delete?");

	push	OFFSET $SG11670
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 4
$LN274@ShowTestWi:

; 1299 :             if (ImGui::BeginPopupModal("Delete?", NULL, ImGuiWindowFlags_AlwaysAutoResize))

	push	64					; 00000040H
	push	0
	push	OFFSET $SG11672
	call	?BeginPopupModal@ImGui@@YA_NPBDPA_NH@Z	; ImGui::BeginPopupModal
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN275@ShowTestWi

; 1300 :             {
; 1301 :                 ImGui::Text("All those beautiful files will be deleted.\nThis operation cannot be undone!\n\n");

	push	OFFSET $SG11673
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1302 :                 ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1308 :                 ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	lea	eax, DWORD PTR $T118[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T118[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1308 :                 ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	push	eax
	push	5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T118[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1308 :                 ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 1309 :                 ImGui::Checkbox("Don't ask me next time", &dont_ask_me_next_time);

	push	OFFSET ?dont_ask_me_next_time@?BJP@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11674
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1310 :                 ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 1312 :                 if (ImGui::Button("OK", ImVec2(120,0))) { ImGui::CloseCurrentPopup(); }

	lea	eax, DWORD PTR $T117[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T117[ebp], 1123024896	; 42f00000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1312 :                 if (ImGui::Button("OK", ImVec2(120,0))) { ImGui::CloseCurrentPopup(); }

	push	eax
	push	OFFSET $SG11676
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T117[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1312 :                 if (ImGui::Button("OK", ImVec2(120,0))) { ImGui::CloseCurrentPopup(); }

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN276@ShowTestWi
	call	?CloseCurrentPopup@ImGui@@YAXXZ		; ImGui::CloseCurrentPopup
$LN276@ShowTestWi:

; 1313 :                 ImGui::SetItemDefaultFocus();

	call	?SetItemDefaultFocus@ImGui@@YAXXZ	; ImGui::SetItemDefaultFocus

; 1314 :                 ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1315 :                 if (ImGui::Button("Cancel", ImVec2(120,0))) { ImGui::CloseCurrentPopup(); }

	lea	eax, DWORD PTR $T116[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T116[ebp], 1123024896	; 42f00000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1315 :                 if (ImGui::Button("Cancel", ImVec2(120,0))) { ImGui::CloseCurrentPopup(); }

	push	eax
	push	OFFSET $SG11678
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T116[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1315 :                 if (ImGui::Button("Cancel", ImVec2(120,0))) { ImGui::CloseCurrentPopup(); }

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN277@ShowTestWi
	call	?CloseCurrentPopup@ImGui@@YAXXZ		; ImGui::CloseCurrentPopup
$LN277@ShowTestWi:

; 1316 :                 ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN275@ShowTestWi:

; 1319 :             if (ImGui::Button("Stacked modals.."))

	lea	eax, DWORD PTR $T115[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T115[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1319 :             if (ImGui::Button("Stacked modals.."))

	push	eax
	push	OFFSET $SG11680
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T115[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1319 :             if (ImGui::Button("Stacked modals.."))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	test	al, al
	je	SHORT $LN278@ShowTestWi

; 1320 :                 ImGui::OpenPopup("Stacked 1");

	push	OFFSET $SG11681
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 4
$LN278@ShowTestWi:

; 1321 :             if (ImGui::BeginPopupModal("Stacked 1"))

	push	0
	push	0
	push	OFFSET $SG11683
	call	?BeginPopupModal@ImGui@@YA_NPBDPA_NH@Z	; ImGui::BeginPopupModal
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN279@ShowTestWi

; 1322 :             {
; 1323 :                 ImGui::Text("Hello from Stacked The First\nUsing style.Colors[ImGuiCol_ModalWindowDarkening] for darkening.");

	push	OFFSET $SG11684
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1324 :                 static int item = 1;
; 1325 :                 ImGui::Combo("Combo", &item, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");

	push	-1
	push	OFFSET $SG11685
	push	OFFSET ?item@?BKK@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	push	OFFSET $SG11686
	call	?Combo@ImGui@@YA_NPBDPAH0H@Z		; ImGui::Combo

; 1327 :                 if (ImGui::Button("Add another modal.."))

	lea	eax, DWORD PTR $T114[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T114[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1327 :                 if (ImGui::Button("Add another modal.."))

	push	eax
	push	OFFSET $SG11688
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T114[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1327 :                 if (ImGui::Button("Add another modal.."))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 28					; 0000001cH
	test	al, al
	je	SHORT $LN280@ShowTestWi

; 1328 :                     ImGui::OpenPopup("Stacked 2");

	push	OFFSET $SG11689
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 4
$LN280@ShowTestWi:

; 1329 :                 if (ImGui::BeginPopupModal("Stacked 2"))

	push	0
	push	0
	push	OFFSET $SG11691
	call	?BeginPopupModal@ImGui@@YA_NPBDPA_NH@Z	; ImGui::BeginPopupModal
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN281@ShowTestWi

; 1330 :                 {
; 1331 :                     ImGui::Text("Hello from Stacked The Second!\nWe are piling a modal over another here,\nand also testing if the menu-bar works.");

	push	OFFSET $SG11692
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1332 :                     if (ImGui::Button("Close"))

	lea	eax, DWORD PTR $T113[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T113[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1332 :                     if (ImGui::Button("Close"))

	push	eax
	push	OFFSET $SG11694
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T113[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1332 :                     if (ImGui::Button("Close"))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN282@ShowTestWi

; 1333 :                         ImGui::CloseCurrentPopup();

	call	?CloseCurrentPopup@ImGui@@YAXXZ		; ImGui::CloseCurrentPopup
$LN282@ShowTestWi:

; 1334 :                     ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN281@ShowTestWi:

; 1337 :                 if (ImGui::Button("Close"))

	lea	eax, DWORD PTR $T112[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T112[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1337 :                 if (ImGui::Button("Close"))

	push	eax
	push	OFFSET $SG11696
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T112[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1337 :                 if (ImGui::Button("Close"))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	test	al, al
	je	SHORT $LN283@ShowTestWi

; 1338 :                     ImGui::CloseCurrentPopup();

	call	?CloseCurrentPopup@ImGui@@YAXXZ		; ImGui::CloseCurrentPopup
$LN283@ShowTestWi:

; 1339 :                 ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN279@ShowTestWi:

; 1340 :             }
; 1341 : 
; 1342 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN273@ShowTestWi:

; 1343 :         }
; 1344 :     }
; 1345 : 
; 1346 :     if (ImGui::CollapsingHeader("Columns"))

	push	0
	push	OFFSET $SG11698
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	$LN296@ShowTestWi

; 1347 :     {
; 1348 :         // Basic columns
; 1349 :         if (ImGui::TreeNode("Basic"))

	push	OFFSET $SG11700
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN285@ShowTestWi

; 1350 :         {
; 1351 :             ImGui::Text("Without border:");

	push	OFFSET $SG11701
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1352 :             ImGui::Columns(3, "mycolumns3", false);  // 3-ways, no border

	push	0
	push	OFFSET $SG11702
	push	3
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 16					; 00000010H

; 1353 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1354 :             for (int n = 0; n < 14; n++)

	xor	esi, esi
	npad	11
$LL81@ShowTestWi:

; 1355 :             {
; 1356 :                 char label[32];
; 1357 :                 sprintf(label, "Item %d", n);

	push	esi
	lea	eax, DWORD PTR _label$29[ebp]
	push	OFFSET $SG11703
	push	eax
	call	_sprintf

; 1358 :                 if (ImGui::Selectable(label)) {}

	lea	eax, DWORD PTR $T111[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T111[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1358 :                 if (ImGui::Selectable(label)) {}

	push	eax
	push	0
	lea	eax, DWORD PTR _label$29[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T111[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1358 :                 if (ImGui::Selectable(label)) {}

	push	0
	push	eax
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 28					; 0000001cH

; 1359 :                 //if (ImGui::Button(label, ImVec2(-1,0))) {}
; 1360 :                 ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
	inc	esi
	cmp	esi, 14					; 0000000eH
	jl	SHORT $LL81@ShowTestWi

; 1361 :             }
; 1362 :             ImGui::Columns(1);

	push	1
	push	0
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns

; 1363 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1364 : 
; 1365 :             ImGui::Text("With border:");

	push	OFFSET $SG11705
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1366 :             ImGui::Columns(4, "mycolumns"); // 4-ways, with border

	push	1
	push	OFFSET $SG11706
	push	4
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns

; 1367 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1368 :             ImGui::Text("ID"); ImGui::NextColumn();

	push	OFFSET $SG11707
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1369 :             ImGui::Text("Name"); ImGui::NextColumn();

	push	OFFSET $SG11708
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1370 :             ImGui::Text("Path"); ImGui::NextColumn();

	push	OFFSET $SG11709
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1371 :             ImGui::Text("Flags"); ImGui::NextColumn();

	push	OFFSET $SG11710
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 44					; 0000002cH
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1372 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1373 :             const char* names[3] = { "One", "Two", "Three" };

	mov	DWORD PTR _names$12[ebp], OFFSET $SG11711

; 1374 :             const char* paths[3] = { "/path/one", "/path/two", "/path/three" };
; 1375 :             static int selected = -1;
; 1376 :             for (int i = 0; i < 3; i++)

	xor	esi, esi
	mov	DWORD PTR _names$12[ebp+4], OFFSET $SG11712
	mov	DWORD PTR _names$12[ebp+8], OFFSET $SG11713
	mov	DWORD PTR _paths$62[ebp], OFFSET $SG11714
	mov	DWORD PTR _paths$62[ebp+4], OFFSET $SG11715
	mov	DWORD PTR _paths$62[ebp+8], OFFSET $SG11716
	npad	8
$LL84@ShowTestWi:

; 1377 :             {
; 1378 :                 char label[32];
; 1379 :                 sprintf(label, "%04d", i);

	push	esi
	lea	eax, DWORD PTR _label$28[ebp]
	push	OFFSET $SG11717
	push	eax
	call	_sprintf

; 1380 :                 if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))

	cmp	DWORD PTR ?selected@?BLJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, esi
	lea	eax, DWORD PTR $T110[ebp]
	push	eax
	sete	al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T110[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1380 :                 if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))

	movzx	eax, al
	push	2
	push	eax
	lea	eax, DWORD PTR _label$28[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T110[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1380 :                 if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))

	push	eax
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	mov	ecx, DWORD PTR ?selected@?BLJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	test	al, al
	cmovne	ecx, esi
	mov	DWORD PTR ?selected@?BLJ@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, ecx

; 1381 :                     selected = i;
; 1382 :                 ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1383 :                 ImGui::Text(names[i]); ImGui::NextColumn();

	push	DWORD PTR _names$12[ebp+esi*4]
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1384 :                 ImGui::Text(paths[i]); ImGui::NextColumn();

	push	DWORD PTR _paths$62[ebp+esi*4]
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1385 :                 ImGui::Text("...."); ImGui::NextColumn();

	push	OFFSET $SG11719
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 40					; 00000028H
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
	inc	esi
	cmp	esi, 3
	jl	$LL84@ShowTestWi

; 1386 :             }
; 1387 :             ImGui::Columns(1);

	push	1
	push	0
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 12					; 0000000cH

; 1388 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1389 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN285@ShowTestWi:

; 1390 :         }
; 1391 : 
; 1392 :         // Scrolling columns
; 1393 :         /*
; 1394 :         if (ImGui::TreeNode("Scrolling"))
; 1395 :         {
; 1396 :             ImGui::BeginChild("##header", ImVec2(0, ImGui::GetTextLineHeightWithSpacing()+ImGui::GetStyle().ItemSpacing.y));
; 1397 :             ImGui::Columns(3);
; 1398 :             ImGui::Text("ID"); ImGui::NextColumn();
; 1399 :             ImGui::Text("Name"); ImGui::NextColumn();
; 1400 :             ImGui::Text("Path"); ImGui::NextColumn();
; 1401 :             ImGui::Columns(1);
; 1402 :             ImGui::Separator();
; 1403 :             ImGui::EndChild();
; 1404 :             ImGui::BeginChild("##scrollingregion", ImVec2(0, 60));
; 1405 :             ImGui::Columns(3);
; 1406 :             for (int i = 0; i < 10; i++)
; 1407 :             {
; 1408 :                 ImGui::Text("%04d", i); ImGui::NextColumn();
; 1409 :                 ImGui::Text("Foobar"); ImGui::NextColumn();
; 1410 :                 ImGui::Text("/path/foobar/%04d/", i); ImGui::NextColumn();
; 1411 :             }
; 1412 :             ImGui::Columns(1);
; 1413 :             ImGui::EndChild();
; 1414 :             ImGui::TreePop();
; 1415 :         }
; 1416 :         */
; 1417 : 
; 1418 :         // Create multiple items in a same cell before switching to next column
; 1419 :         if (ImGui::TreeNode("Mixed items"))

	push	OFFSET $SG11721
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN288@ShowTestWi

; 1420 :         {
; 1421 :             ImGui::Columns(3, "mixed");

	push	1
	push	OFFSET $SG11722
	push	3
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns

; 1422 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1423 : 
; 1424 :             ImGui::Text("Hello");

	push	OFFSET $SG11723
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1425 :             ImGui::Button("Banana");

	lea	eax, DWORD PTR $T109[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T109[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1425 :             ImGui::Button("Banana");

	push	eax
	push	OFFSET $SG11724
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T109[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1425 :             ImGui::Button("Banana");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button

; 1426 :             ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1427 : 
; 1428 :             ImGui::Text("ImGui");

	push	OFFSET $SG11725
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1429 :             ImGui::Button("Apple");

	lea	eax, DWORD PTR $T108[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T108[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1429 :             ImGui::Button("Apple");

	push	eax
	push	OFFSET $SG11726
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T108[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1429 :             ImGui::Button("Apple");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 36					; 00000024H

; 1430 :             static float foo = 1.0f;
; 1431 :             ImGui::InputFloat("red", &foo, 0.05f, 0, 3);

	push	0
	push	3
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1028443341		; 3d4ccccdH
	push	OFFSET ?foo@?BMF@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11727
	call	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z	; ImGui::InputFloat

; 1432 :             ImGui::Text("An extra line here.");

	push	OFFSET $SG11728
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1433 :             ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1434 : 
; 1435 :             ImGui::Text("Sailor");

	push	OFFSET $SG11729
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1436 :             ImGui::Button("Corniflower");

	lea	eax, DWORD PTR $T107[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T107[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1436 :             ImGui::Button("Corniflower");

	push	eax
	push	OFFSET $SG11730
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T107[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1436 :             ImGui::Button("Corniflower");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 40					; 00000028H

; 1437 :             static float bar = 1.0f;
; 1438 :             ImGui::InputFloat("blue", &bar, 0.05f, 0, 3);

	push	0
	push	3
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1028443341		; 3d4ccccdH
	push	OFFSET ?bar@?BMF@??ShowTestWindow@ImGui@@YAXPA_N@Z@4MA
	push	OFFSET $SG11731
	call	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z	; ImGui::InputFloat

; 1439 :             ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1440 : 
; 1441 :             if (ImGui::CollapsingHeader("Category A")) ImGui::Text("Blah blah blah"); ImGui::NextColumn();

	push	0
	push	OFFSET $SG11733
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN289@ShowTestWi
	push	OFFSET $SG11734
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
$LN289@ShowTestWi:
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1442 :             if (ImGui::CollapsingHeader("Category B")) ImGui::Text("Blah blah blah"); ImGui::NextColumn();

	push	0
	push	OFFSET $SG11736
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	SHORT $LN290@ShowTestWi
	push	OFFSET $SG11737
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
$LN290@ShowTestWi:
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1443 :             if (ImGui::CollapsingHeader("Category C")) ImGui::Text("Blah blah blah"); ImGui::NextColumn();

	push	0
	push	OFFSET $SG11739
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	SHORT $LN291@ShowTestWi
	push	OFFSET $SG11740
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
$LN291@ShowTestWi:
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1444 :             ImGui::Columns(1);

	push	1
	push	0
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 12					; 0000000cH

; 1445 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1446 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN288@ShowTestWi:

; 1447 :         }
; 1448 : 
; 1449 :         // Word wrapping
; 1450 :         if (ImGui::TreeNode("Word-wrapping"))

	push	OFFSET $SG11742
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN292@ShowTestWi

; 1451 :         {
; 1452 :             ImGui::Columns(2, "word-wrapping");

	push	1
	push	OFFSET $SG11743
	push	2
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns

; 1453 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1454 :             ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");

	push	OFFSET $SG11744
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1455 :             ImGui::TextWrapped("Hello Left");

	push	OFFSET $SG11745
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1456 :             ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1457 :             ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");

	push	OFFSET $SG11746
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1458 :             ImGui::TextWrapped("Hello Right");

	push	OFFSET $SG11747
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1459 :             ImGui::Columns(1);

	push	1
	push	0
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 40					; 00000028H

; 1460 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1461 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN292@ShowTestWi:

; 1462 :         }
; 1463 : 
; 1464 :         if (ImGui::TreeNode("Borders"))

	push	OFFSET $SG11749
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN293@ShowTestWi

; 1465 :         {
; 1466 :             static bool h_borders = true;
; 1467 :             static bool v_borders = true;
; 1468 :             ImGui::Checkbox("horizontal", &h_borders);

	push	OFFSET ?h_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11750
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1469 :             ImGui::SameLine();

	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1470 :             ImGui::Checkbox("vertical", &v_borders);

	push	OFFSET ?v_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG11751
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1471 :             ImGui::Columns(4, NULL, v_borders);

	movzx	eax, BYTE PTR ?v_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA
	push	eax
	push	0
	push	4
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 28					; 0000001cH

; 1472 :             if (h_borders) ImGui::Separator();

	cmp	BYTE PTR ?h_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN294@ShowTestWi
	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
$LN294@ShowTestWi:

; 1473 :             for (int i = 0; i < 8; i++)

	mov	esi, 97					; 00000061H
	lea	edi, DWORD PTR [esi-89]
	npad	4
$LL87@ShowTestWi:

; 1474 :             {
; 1475 :                 ImGui::Text("%c%c%c", 'a'+i, 'a'+i, 'a'+i);

	push	esi
	push	esi
	push	esi
	push	OFFSET $SG11753
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H

; 1476 :                 ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
	inc	esi
	sub	edi, 1
	jne	SHORT $LL87@ShowTestWi

; 1477 :             }
; 1478 :             ImGui::Columns(1);

	push	1
	push	edi
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 12					; 0000000cH

; 1479 :             if (h_borders) ImGui::Separator();

	cmp	BYTE PTR ?h_borders@?BNB@??ShowTestWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	SHORT $LN295@ShowTestWi
	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
$LN295@ShowTestWi:

; 1480 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN293@ShowTestWi:

; 1481 :         }
; 1482 : 
; 1483 :         bool node_open = ImGui::TreeNode("Tree within single cell");

	push	OFFSET $SG11755
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode

; 1484 :         ImGui::SameLine(); ShowHelpMarker("NB: Tree node must be poped before ending the cell. There's no storage of state per-cell.");

	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	ecx
	mov	BYTE PTR _node_open$1$[ebp], al
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11756
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker
	add	esp, 12					; 0000000cH

; 1485 :         if (node_open)

	cmp	BYTE PTR _node_open$1$[ebp], 0
	je	$LN296@ShowTestWi

; 1486 :         {
; 1487 :             ImGui::Columns(2, "tree items");

	push	1
	push	OFFSET $SG11758
	push	2
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns

; 1488 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1489 :             if (ImGui::TreeNode("Hello")) { ImGui::BulletText("Sailor"); ImGui::TreePop(); } ImGui::NextColumn();

	push	OFFSET $SG11760
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN297@ShowTestWi
	push	OFFSET $SG11761
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 4
	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN297@ShowTestWi:
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1490 :             if (ImGui::TreeNode("Bonjour")) { ImGui::BulletText("Marin"); ImGui::TreePop(); } ImGui::NextColumn();

	push	OFFSET $SG11763
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	SHORT $LN298@ShowTestWi
	push	OFFSET $SG11764
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 4
	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN298@ShowTestWi:
	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 1491 :             ImGui::Columns(1);

	push	1
	push	0
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 12					; 0000000cH

; 1492 :             ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 1493 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN296@ShowTestWi:

; 1494 :         }
; 1495 :     }
; 1496 : 
; 1497 :     if (ImGui::CollapsingHeader("Filtering"))

	push	0
	push	OFFSET $SG11766
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	$LN90@ShowTestWi

; 1498 :     {
; 1499 :         static ImGuiTextFilter filter;

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?$TSS3@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	SHORT $LN88@ShowTestWi
	push	OFFSET ?$TSS3@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS3@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA, -1
	jne	SHORT $LN88@ShowTestWi
	push	OFFSET $SG11767
	mov	ecx, OFFSET ?filter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImGuiTextFilter@@A
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0ImGuiTextFilter@@QAE@PBD@Z		; ImGuiTextFilter::ImGuiTextFilter
	push	OFFSET ??__Ffilter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@YAXXZ ; `ImGui::ShowTestWindow'::`483'::`dynamic atexit destructor for 'filter''
	call	_atexit
	push	OFFSET ?$TSS3@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 8
$LN88@ShowTestWi:

; 1500 :         ImGui::Text("Filter usage:\n"

	push	OFFSET $SG11768
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1501 :                     "  \"\"         display all lines\n"
; 1502 :                     "  \"xxx\"      display lines containing \"xxx\"\n"
; 1503 :                     "  \"xxx,yyy\"  display lines containing \"xxx\" or \"yyy\"\n"
; 1504 :                     "  \"-xxx\"     hide lines containing \"xxx\"");
; 1505 :         filter.Draw();

	mov	DWORD PTR [esp], 0
	mov	ecx, OFFSET ?filter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImGuiTextFilter@@A
	push	OFFSET $SG11769
	call	?Draw@ImGuiTextFilter@@QAE_NPBDM@Z	; ImGuiTextFilter::Draw

; 1506 :         const char* lines[] = { "aaa1.c", "bbb1.c", "ccc1.c", "aaa2.cpp", "bbb2.cpp", "ccc2.cpp", "abc.h", "hello, world" };

	mov	DWORD PTR _lines$27[ebp], OFFSET $SG11770

; 1507 :         for (int i = 0; i < IM_ARRAYSIZE(lines); i++)

	xor	esi, esi
	mov	DWORD PTR _lines$27[ebp+4], OFFSET $SG11771
	mov	DWORD PTR _lines$27[ebp+8], OFFSET $SG11772
	mov	DWORD PTR _lines$27[ebp+12], OFFSET $SG11773
	mov	DWORD PTR _lines$27[ebp+16], OFFSET $SG11774
	mov	DWORD PTR _lines$27[ebp+20], OFFSET $SG11775
	mov	DWORD PTR _lines$27[ebp+24], OFFSET $SG11776
	mov	DWORD PTR _lines$27[ebp+28], OFFSET $SG11777
	npad	3
$LL91@ShowTestWi:

; 1508 :             if (filter.PassFilter(lines[i]))

	mov	edi, DWORD PTR _lines$27[ebp+esi*4]
	mov	ecx, OFFSET ?filter@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4UImGuiTextFilter@@A
	push	0
	push	edi
	call	?PassFilter@ImGuiTextFilter@@QBE_NPBD0@Z ; ImGuiTextFilter::PassFilter
	test	al, al
	je	SHORT $LN89@ShowTestWi

; 1509 :                 ImGui::BulletText("%s", lines[i]);

	push	edi
	push	OFFSET $SG11779
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 8
$LN89@ShowTestWi:

; 1507 :         for (int i = 0; i < IM_ARRAYSIZE(lines); i++)

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL91@ShowTestWi
$LN90@ShowTestWi:

; 1510 :     }
; 1511 : 
; 1512 :     if (ImGui::CollapsingHeader("Inputs, Navigation & Focus"))

	push	0
	push	OFFSET $SG11781
	call	?CollapsingHeader@ImGui@@YA_NPBDH@Z	; ImGui::CollapsingHeader
	add	esp, 8
	test	al, al
	je	$LN327@ShowTestWi

; 1513 :     {
; 1514 :         ImGuiIO& io = ImGui::GetIO();

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	edi, eax
	mov	DWORD PTR _io$1$[ebp], edi

; 1515 :         ImGui::Checkbox("io.NavMovesMouse", &io.NavMovesMouse);

	lea	ecx, DWORD PTR [edi+120]
	push	ecx
	push	OFFSET $SG11782
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1516 :         ImGui::SameLine(); ShowHelpMarker("Request ImGui to move your move cursor when using gamepad/keyboard navigation. NewFrame() will change io.MousePos and set the io.WantMoveMouse flag, your backend will need to apply the new mouse position.");

	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11783
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 1517 : 
; 1518 :         ImGui::Checkbox("io.MouseDrawCursor", &io.MouseDrawCursor);

	lea	eax, DWORD PTR [edi+224]
	push	eax
	push	OFFSET $SG11784
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1519 :         ImGui::SameLine(); ShowHelpMarker("Request ImGui to render a mouse cursor for you in software. Note that a mouse cursor rendered via regular GPU rendering will feel more laggy than hardware cursor, but will be more in sync with your other visuals.");

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11785
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 1520 : 
; 1521 :         ImGui::Text("WantCaptureMouse: %d", io.WantCaptureMouse);

	movzx	eax, BYTE PTR [edi+840]
	push	eax
	push	OFFSET $SG11786
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1522 :         ImGui::Text("WantCaptureKeyboard: %d", io.WantCaptureKeyboard);

	movzx	eax, BYTE PTR [edi+841]
	push	eax
	push	OFFSET $SG11787
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1523 :         ImGui::Text("WantTextInput: %d", io.WantTextInput);

	movzx	eax, BYTE PTR [edi+842]
	push	eax
	push	OFFSET $SG11788
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1524 :         ImGui::Text("WantMoveMouse: %d", io.WantMoveMouse);

	movzx	eax, BYTE PTR [edi+843]
	push	eax
	push	OFFSET $SG11789
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1525 : 
; 1526 :         if (ImGui::TreeNode("Keyboard, Mouse & Navigation State"))

	push	OFFSET $SG11791
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 48					; 00000030H
	test	al, al
	je	$LN302@ShowTestWi

; 1527 :         {
; 1528 :             ImGui::Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);

	movss	xmm0, DWORD PTR [edi+208]
	sub	esp, 16					; 00000010H
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [edi+204]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11792
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1529 :             ImGui::Text("Mouse down:");     for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (io.MouseDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]); }

	push	OFFSET $SG11793
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	lea	eax, DWORD PTR [edi+968]
	add	esp, 24					; 00000018H
	xor	esi, esi
	mov	DWORD PTR tv5690[ebp], eax
	xorps	xmm1, xmm1
$LL94@ShowTestWi:
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jb	SHORT $LN92@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	mov	eax, DWORD PTR tv5690[ebp]
	movss	xmm0, DWORD PTR [eax]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	esi
	push	OFFSET $SG11795
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	mov	eax, DWORD PTR tv5690[ebp]
	add	esp, 16					; 00000010H
	xorps	xmm1, xmm1
$LN92@ShowTestWi:
	inc	esi
	add	eax, 4
	mov	DWORD PTR tv5690[ebp], eax
	cmp	esi, 5
	jl	SHORT $LL94@ShowTestWi

; 1530 :             ImGui::Text("Mouse clicked:");  for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseClicked(i))          { ImGui::SameLine(); ImGui::Text("b%d", i); }

	push	OFFSET $SG11796
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	xor	esi, esi
	npad	1
$LL97@ShowTestWi:
	push	0
	push	esi
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	add	esp, 8
	test	al, al
	je	SHORT $LN95@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	esi
	push	OFFSET $SG11798
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H
$LN95@ShowTestWi:
	inc	esi
	cmp	esi, 5
	jl	SHORT $LL97@ShowTestWi

; 1531 :             ImGui::Text("Mouse dbl-clicked:"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseDoubleClicked(i)) { ImGui::SameLine(); ImGui::Text("b%d", i); }

	push	OFFSET $SG11799
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	xor	esi, esi
	npad	7
$LL100@ShowTestWi:
	push	esi
	call	?IsMouseDoubleClicked@ImGui@@YA_NH@Z	; ImGui::IsMouseDoubleClicked
	add	esp, 4
	test	al, al
	je	SHORT $LN98@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	esi
	push	OFFSET $SG11801
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H
$LN98@ShowTestWi:
	inc	esi
	cmp	esi, 5
	jl	SHORT $LL100@ShowTestWi

; 1532 :             ImGui::Text("Mouse released:"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseReleased(i))         { ImGui::SameLine(); ImGui::Text("b%d", i); }

	push	OFFSET $SG11802
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	xor	esi, esi
$LL103@ShowTestWi:
	push	esi
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	add	esp, 4
	test	al, al
	je	SHORT $LN101@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	esi
	push	OFFSET $SG11804
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H
$LN101@ShowTestWi:
	inc	esi
	cmp	esi, 5
	jl	SHORT $LL103@ShowTestWi

; 1533 :             ImGui::Text("Mouse wheel: %.1f", io.MouseWheel);

	movss	xmm0, DWORD PTR [edi+220]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11805
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1534 : 
; 1535 :             ImGui::Text("Keys down:");      for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (io.KeysDownDuration[i] >= 0.0f)     { ImGui::SameLine(); ImGui::Text("%d (%.02f secs)", i, io.KeysDownDuration[i]); }

	push	OFFSET $SG11806
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	lea	eax, DWORD PTR [edi+1028]
	add	esp, 16					; 00000010H
	xor	esi, esi
	mov	DWORD PTR tv5689[ebp], eax
	xorps	xmm1, xmm1
$LL106@ShowTestWi:
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jb	SHORT $LN104@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	mov	eax, DWORD PTR tv5689[ebp]
	movss	xmm0, DWORD PTR [eax]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	esi
	push	OFFSET $SG11808
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	mov	eax, DWORD PTR tv5689[ebp]
	add	esp, 16					; 00000010H
	xorps	xmm1, xmm1
$LN104@ShowTestWi:
	inc	esi
	add	eax, 4
	mov	DWORD PTR tv5689[ebp], eax
	cmp	esi, 512				; 00000200H
	jl	SHORT $LL106@ShowTestWi

; 1536 :             ImGui::Text("Keys pressed:");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text("%d", i); }

	push	OFFSET $SG11809
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	xor	esi, esi
$LL109@ShowTestWi:
	push	1
	push	esi
	call	?IsKeyPressed@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressed
	add	esp, 8
	test	al, al
	je	SHORT $LN107@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	esi
	push	OFFSET $SG11811
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H
$LN107@ShowTestWi:
	inc	esi
	cmp	esi, 512				; 00000200H
	jl	SHORT $LL109@ShowTestWi

; 1537 :             ImGui::Text("Keys release:");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyReleased(i))            { ImGui::SameLine(); ImGui::Text("%d", i); }

	push	OFFSET $SG11812
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	xor	esi, esi
$LL112@ShowTestWi:
	push	esi
	call	?IsKeyReleased@ImGui@@YA_NH@Z		; ImGui::IsKeyReleased
	add	esp, 4
	test	al, al
	je	SHORT $LN110@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	esi
	push	OFFSET $SG11814
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H
$LN110@ShowTestWi:
	inc	esi
	cmp	esi, 512				; 00000200H
	jl	SHORT $LL112@ShowTestWi

; 1538 :             ImGui::Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "");

	cmp	BYTE PTR [edi+228], 0
	mov	ecx, OFFSET $SG11816
	mov	eax, OFFSET $SG11815
	cmove	eax, ecx
	cmp	BYTE PTR [edi+227], 0
	push	eax
	mov	ecx, OFFSET $SG11818
	mov	eax, OFFSET $SG11817
	cmove	eax, ecx
	cmp	BYTE PTR [edi+226], 0
	push	eax
	mov	ecx, OFFSET $SG11820
	mov	eax, OFFSET $SG11819
	cmove	eax, ecx
	cmp	BYTE PTR [edi+225], 0
	push	eax
	mov	ecx, OFFSET $SG11822
	mov	eax, OFFSET $SG11821
	cmove	eax, ecx
	push	eax
	push	OFFSET $SG11823
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1539 : 
; 1540 :             ImGui::Text("NavUsable: %d, NavActive: %d", io.NavUsable, io.NavActive);

	movzx	eax, BYTE PTR [edi+845]
	push	eax
	movzx	eax, BYTE PTR [edi+844]
	push	eax
	push	OFFSET $SG11824
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1541 :             ImGui::Text("NavInputs down:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputs[i] > 0.0f)                    { ImGui::SameLine(); ImGui::Text("[%d] %.2f", i, io.NavInputs[i]); }

	push	OFFSET $SG11825
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	lea	eax, DWORD PTR [edi+776]
	add	esp, 36					; 00000024H
	xor	esi, esi
	mov	DWORD PTR tv5688[ebp], eax
	xorps	xmm1, xmm1
$LL115@ShowTestWi:
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jbe	SHORT $LN113@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	mov	eax, DWORD PTR tv5688[ebp]
	movss	xmm0, DWORD PTR [eax]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	esi
	push	OFFSET $SG11827
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	mov	eax, DWORD PTR tv5688[ebp]
	add	esp, 16					; 00000010H
	xorps	xmm1, xmm1
$LN113@ShowTestWi:
	inc	esi
	add	eax, 4
	mov	DWORD PTR tv5688[ebp], eax
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL115@ShowTestWi

; 1542 :             ImGui::Text("NavInputs pressed:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] == 0.0f)    { ImGui::SameLine(); ImGui::Text("[%d]", i); }

	push	OFFSET $SG11828
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
	lea	esi, DWORD PTR [edi+5124]
	xor	ecx, ecx
	mov	edi, esi
	mov	DWORD PTR _i$1$[ebp], ecx
	xorps	xmm1, xmm1
	npad	2
$LL118@ShowTestWi:
	movss	xmm0, DWORD PTR [edi]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN116@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	DWORD PTR _i$1$[ebp]
	push	OFFSET $SG11830
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	mov	ecx, DWORD PTR _i$1$[ebp]
	add	esp, 16					; 00000010H
	xorps	xmm1, xmm1
$LN116@ShowTestWi:
	inc	ecx
	add	edi, 4
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL118@ShowTestWi

; 1543 :             ImGui::Text("NavInputs duration:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text("[%d] %.2f", i, io.NavInputsDownDuration[i]); }

	push	OFFSET $SG11831
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	mov	edi, DWORD PTR _io$1$[ebp]
	add	esp, 4
	xor	eax, eax
	xorps	xmm1, xmm1
	mov	DWORD PTR _i$1$[ebp], eax
	npad	2
$LL121@ShowTestWi:
	movss	xmm0, DWORD PTR [esi]
	comiss	xmm0, xmm1
	jb	SHORT $LN119@ShowTestWi
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	movss	xmm0, DWORD PTR [esi]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _i$1$[ebp]
	push	OFFSET $SG11833
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	mov	eax, DWORD PTR _i$1$[ebp]
	add	esp, 16					; 00000010H
	xorps	xmm1, xmm1
$LN119@ShowTestWi:
	inc	eax
	add	esi, 4
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL121@ShowTestWi

; 1545 :             ImGui::Button("Hovering me sets the\nkeyboard capture flag");

	lea	eax, DWORD PTR $T106[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T106[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1545 :             ImGui::Button("Hovering me sets the\nkeyboard capture flag");

	push	eax
	push	OFFSET $SG11834
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T106[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1545 :             ImGui::Button("Hovering me sets the\nkeyboard capture flag");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8

; 1546 :             if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN313@ShowTestWi

; 1547 :                 ImGui::CaptureKeyboardFromApp(true);

	push	1
	call	?CaptureKeyboardFromApp@ImGui@@YAX_N@Z	; ImGui::CaptureKeyboardFromApp
	add	esp, 4
$LN313@ShowTestWi:

; 1548 :             ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1549 :             ImGui::Button("Holding me clears the\nthe keyboard capture flag");

	lea	eax, DWORD PTR $T105[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T105[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1549 :             ImGui::Button("Holding me clears the\nthe keyboard capture flag");

	push	eax
	push	OFFSET $SG11836
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T105[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1549 :             ImGui::Button("Holding me clears the\nthe keyboard capture flag");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H

; 1550 :             if (ImGui::IsItemActive())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	je	SHORT $LN314@ShowTestWi

; 1551 :                 ImGui::CaptureKeyboardFromApp(false);

	push	0
	call	?CaptureKeyboardFromApp@ImGui@@YAX_N@Z	; ImGui::CaptureKeyboardFromApp
	add	esp, 4
$LN314@ShowTestWi:

; 1552 : 
; 1553 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN302@ShowTestWi:

; 1554 :         }
; 1555 : 
; 1556 :         if (ImGui::TreeNode("Tabbing"))

	push	OFFSET $SG11839
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN315@ShowTestWi

; 1557 :         {
; 1558 :             ImGui::Text("Use TAB/SHIFT+TAB to cycle through keyboard editable fields.");

	push	OFFSET $SG11840
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1559 :             static char buf[32] = "dummy";
; 1560 :             ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	32					; 00000020H
	push	OFFSET ?buf@?CBL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11841
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 1561 :             ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	32					; 00000020H
	push	OFFSET ?buf@?CBL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11842
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 1562 :             ImGui::InputText("3", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	32					; 00000020H
	push	OFFSET ?buf@?CBL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11843
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 76					; 0000004cH

; 1563 :             ImGui::PushAllowKeyboardFocus(false);

	push	0
	call	?PushAllowKeyboardFocus@ImGui@@YAX_N@Z	; ImGui::PushAllowKeyboardFocus

; 1564 :             ImGui::InputText("4 (tab skip)", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	32					; 00000020H
	push	OFFSET ?buf@?CBL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11844
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 1565 :             //ImGui::SameLine(); ShowHelperMarker("Use ImGui::PushAllowKeyboardFocus(bool)\nto disable tabbing through certain widgets.");
; 1566 :             ImGui::PopAllowKeyboardFocus();

	call	?PopAllowKeyboardFocus@ImGui@@YAXXZ	; ImGui::PopAllowKeyboardFocus

; 1567 :             ImGui::InputText("5", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	32					; 00000020H
	push	OFFSET ?buf@?CBL@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11845
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 52					; 00000034H

; 1568 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN315@ShowTestWi:

; 1569 :         }
; 1570 : 
; 1571 :         if (ImGui::TreeNode("Focus from code"))

	push	OFFSET $SG11847
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN316@ShowTestWi

; 1573 :             bool focus_1 = ImGui::Button("Focus on 1"); ImGui::SameLine();

	lea	eax, DWORD PTR $T104[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T104[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1573 :             bool focus_1 = ImGui::Button("Focus on 1"); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11848
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T104[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1573 :             bool focus_1 = ImGui::Button("Focus on 1"); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	BYTE PTR _focus_1$1$[ebp], al
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1574 :             bool focus_2 = ImGui::Button("Focus on 2"); ImGui::SameLine();

	lea	eax, DWORD PTR $T103[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T103[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1574 :             bool focus_2 = ImGui::Button("Focus on 2"); ImGui::SameLine();

	push	eax
	push	OFFSET $SG11849
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T103[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1574 :             bool focus_2 = ImGui::Button("Focus on 2"); ImGui::SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	mov	BYTE PTR _focus_2$1$[ebp], al
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1575 :             bool focus_3 = ImGui::Button("Focus on 3");

	lea	eax, DWORD PTR $T102[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T102[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1575 :             bool focus_3 = ImGui::Button("Focus on 3");

	push	eax
	push	OFFSET $SG11850
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T102[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1575 :             bool focus_3 = ImGui::Button("Focus on 3");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	mov	BYTE PTR _focus_3$1$[ebp], al

; 1576 :             int has_focus = 0;

	xor	esi, esi

; 1577 :             static char buf[128] = "click on a button to set focus";
; 1578 : 
; 1579 :             if (focus_1) ImGui::SetKeyboardFocusHere();

	cmp	BYTE PTR _focus_1$1$[ebp], 0
	je	SHORT $LN317@ShowTestWi
	push	esi
	call	?SetKeyboardFocusHere@ImGui@@YAXH@Z	; ImGui::SetKeyboardFocusHere
	add	esp, 4
$LN317@ShowTestWi:

; 1580 :             ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	128					; 00000080H
	push	OFFSET ?buf@?CBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11852
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 24					; 00000018H

; 1581 :             if (ImGui::IsItemActive()) has_focus = 1;

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	mov	eax, 1
	cmovne	esi, eax

; 1582 : 
; 1583 :             if (focus_2) ImGui::SetKeyboardFocusHere();

	cmp	BYTE PTR _focus_2$1$[ebp], 0
	je	SHORT $LN319@ShowTestWi
	push	0
	call	?SetKeyboardFocusHere@ImGui@@YAXH@Z	; ImGui::SetKeyboardFocusHere
	add	esp, 4
$LN319@ShowTestWi:

; 1584 :             ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	128					; 00000080H
	push	OFFSET ?buf@?CBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11855
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 1585 :             if (ImGui::IsItemActive()) has_focus = 2;

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	mov	ecx, 2

; 1586 : 
; 1587 :             ImGui::PushAllowKeyboardFocus(false);

	push	0
	cmovne	esi, ecx
	call	?PushAllowKeyboardFocus@ImGui@@YAX_N@Z	; ImGui::PushAllowKeyboardFocus
	add	esp, 28					; 0000001cH

; 1588 :             if (focus_3) ImGui::SetKeyboardFocusHere();

	cmp	BYTE PTR _focus_3$1$[ebp], 0
	je	SHORT $LN321@ShowTestWi
	push	0
	call	?SetKeyboardFocusHere@ImGui@@YAXH@Z	; ImGui::SetKeyboardFocusHere
	add	esp, 4
$LN321@ShowTestWi:

; 1589 :             ImGui::InputText("3 (tab skip)", buf, IM_ARRAYSIZE(buf));

	push	0
	push	0
	push	0
	push	128					; 00000080H
	push	OFFSET ?buf@?CBO@??ShowTestWindow@ImGui@@YAXPA_N@Z@4PADA
	push	OFFSET $SG11858
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 24					; 00000018H

; 1590 :             if (ImGui::IsItemActive()) has_focus = 3;

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	mov	eax, 3
	cmovne	esi, eax

; 1591 :             ImGui::PopAllowKeyboardFocus();

	call	?PopAllowKeyboardFocus@ImGui@@YAXXZ	; ImGui::PopAllowKeyboardFocus
	test	esi, esi

; 1592 :             if (has_focus)

	je	SHORT $LN323@ShowTestWi

; 1593 :                 ImGui::Text("Item with focus: %d", has_focus);

	push	esi
	push	OFFSET $SG11862
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 8

; 1594 :             else

	jmp	SHORT $LN324@ShowTestWi
$LN323@ShowTestWi:

; 1595 :                 ImGui::Text("Item with focus: <none>");

	push	OFFSET $SG11863
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 4
$LN324@ShowTestWi:

; 1596 :             ImGui::TextWrapped("Cursor & selection are preserved when refocusing last used item in code.");

	push	OFFSET $SG11864
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped
	add	esp, 4

; 1597 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN316@ShowTestWi:

; 1598 :         }
; 1599 : 
; 1600 :         if (ImGui::TreeNode("Dragging"))

	push	OFFSET $SG11866
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN325@ShowTestWi

; 1601 :         {
; 1602 :             ImGui::TextWrapped("You can use ImGui::GetMouseDragDelta(0) to query for the dragged amount on any widget.");

	push	OFFSET $SG11867
	call	?TextWrapped@ImGui@@YAXPBDZZ		; ImGui::TextWrapped

; 1603 :             ImGui::Button("Drag Me");

	lea	eax, DWORD PTR $T101[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T101[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1603 :             ImGui::Button("Drag Me");

	push	eax
	push	OFFSET $SG11868
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T101[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1603 :             ImGui::Button("Drag Me");

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 12					; 0000000cH

; 1604 :             if (ImGui::IsItemActive())

	call	?IsItemActive@ImGui@@YA_NXZ		; ImGui::IsItemActive
	test	al, al
	je	$LN326@ShowTestWi

; 1605 :             {
; 1606 :                 // Draw a line between the button and the mouse cursor
; 1607 :                 ImDrawList* draw_list = ImGui::GetWindowDrawList();

	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	mov	esi, eax

; 1608 :                 draw_list->PushClipRectFullScreen();

	mov	ecx, esi
	call	?PushClipRectFullScreen@ImDrawList@@QAEXXZ ; ImDrawList::PushClipRectFullScreen

; 1609 :                 draw_list->AddLine(ImGui::CalcItemRectClosestPoint(io.MousePos, true, -2.0f), io.MousePos, ImColor(ImGui::GetStyle().Colors[ImGuiCol_Button]), 4.0f);

	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR $T69[ebp+12], 0
	mov	DWORD PTR $T69[ebp+8], 0
	mov	DWORD PTR $T69[ebp+4], 0
	mov	DWORD PTR $T69[ebp], 0

; 1127 :     ImColor(const ImVec4& col)                                      { Value = col; }

	movups	xmm0, XMMWORD PTR [eax+480]

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	eax, DWORD PTR $T69[ebp]
	push	eax

; 1127 :     ImColor(const ImVec4& col)                                      { Value = col; }

	movups	XMMWORD PTR $T69[ebp], xmm0

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1609 :                 draw_list->AddLine(ImGui::CalcItemRectClosestPoint(io.MousePos, true, -2.0f), io.MousePos, ImColor(ImGui::GetStyle().Colors[ImGuiCol_Button]), 4.0f);

	mov	DWORD PTR [esp], 1082130432		; 40800000H
	lea	ecx, DWORD PTR [edi+204]
	push	eax
	push	ecx
	push	ecx
	mov	DWORD PTR [esp], -1073741824		; c0000000H
	lea	eax, DWORD PTR $T171[ebp]
	push	1
	push	ecx
	push	eax
	call	?CalcItemRectClosestPoint@ImGui@@YA?AUImVec2@@ABU2@_NM@Z ; ImGui::CalcItemRectClosestPoint
	add	esp, 16					; 00000010H
	mov	ecx, esi
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 1610 :                 draw_list->PopClipRect();

	mov	ecx, esi
	call	?PopClipRect@ImDrawList@@QAEXXZ		; ImDrawList::PopClipRect

; 1611 :                 ImVec2 value_raw = ImGui::GetMouseDragDelta(0, 0.0f);

	push	ecx
	mov	DWORD PTR [esp], 0
	lea	eax, DWORD PTR _value_raw$63[ebp]
	push	0
	push	eax
	call	?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z ; ImGui::GetMouseDragDelta

; 1612 :                 ImVec2 value_with_lock_threshold = ImGui::GetMouseDragDelta(0);

	add	esp, 8
	lea	eax, DWORD PTR _value_with_lock_threshold$100[ebp]
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	0
	push	eax
	call	?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z ; ImGui::GetMouseDragDelta

; 1613 :                 ImVec2 mouse_delta = io.MouseDelta;

	mov	eax, DWORD PTR [edi+868]

; 1614 :                 ImGui::SameLine(); ImGui::Text("Raw (%.1f, %.1f), WithLockThresold (%.1f, %.1f), MouseDelta (%.1f, %.1f)", value_raw.x, value_raw.y, value_with_lock_threshold.x, value_with_lock_threshold.y, mouse_delta.x, mouse_delta.y);

	add	esp, 4
	mov	DWORD PTR _mouse_delta$170[ebp], eax
	mov	eax, DWORD PTR [edi+872]
	mov	DWORD PTR _mouse_delta$170[ebp+4], eax
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	movss	xmm0, DWORD PTR _mouse_delta$170[ebp+4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 40					; 00000028H
	movss	xmm0, DWORD PTR _mouse_delta$170[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+32], xmm0
	movss	xmm0, DWORD PTR _value_with_lock_threshold$100[ebp+4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR _value_with_lock_threshold$100[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _value_raw$63[ebp+4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _value_raw$63[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG11870
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 52					; 00000034H
$LN326@ShowTestWi:

; 1615 :             }
; 1616 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN325@ShowTestWi:

; 1617 :         }
; 1618 : 
; 1619 :         if (ImGui::TreeNode("Mouse cursors"))

	push	OFFSET $SG11872
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN327@ShowTestWi

; 1620 :         {
; 1621 :             ImGui::Text("Hover to see mouse cursors:");

	push	OFFSET $SG11873
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1622 :             ImGui::SameLine(); ShowHelpMarker("Your application can render a different mouse cursor based on what ImGui::GetMouseCursor() returns. If software cursor rendering (io.MouseDrawCursor) is set ImGui will draw the right cursor for you, otherwise your backend needs to handle it.");

	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	ecx
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG11874
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker
	add	esp, 12					; 0000000cH

; 1623 :             for (int i = 0; i < ImGuiMouseCursor_Count_; i++)

	xor	esi, esi
	npad	8
$LL124@ShowTestWi:

; 1624 :             {
; 1625 :                 char label[32];
; 1626 :                 sprintf(label, "Mouse cursor %d", i);

	push	esi
	lea	eax, DWORD PTR _label$2[ebp]
	push	OFFSET $SG11875
	push	eax
	call	_sprintf

; 1627 :                 ImGui::Bullet(); ImGui::Selectable(label, false);

	call	?Bullet@ImGui@@YAXXZ			; ImGui::Bullet
	lea	eax, DWORD PTR $T13[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T13[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1627 :                 ImGui::Bullet(); ImGui::Selectable(label, false);

	push	eax
	push	0
	lea	eax, DWORD PTR _label$2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T13[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1627 :                 ImGui::Bullet(); ImGui::Selectable(label, false);

	push	0
	push	eax
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 28					; 0000001cH

; 1628 :                 if (ImGui::IsItemHovered() || ImGui::IsItemFocused())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	jne	SHORT $LN329@ShowTestWi
	call	?IsItemFocused@ImGui@@YA_NXZ		; ImGui::IsItemFocused
	test	al, al
	je	SHORT $LN122@ShowTestWi
$LN329@ShowTestWi:

; 1629 :                     ImGui::SetMouseCursor(i);

	push	esi
	call	?SetMouseCursor@ImGui@@YAXH@Z		; ImGui::SetMouseCursor
	add	esp, 4
$LN122@ShowTestWi:

; 1623 :             for (int i = 0; i < ImGuiMouseCursor_Count_; i++)

	inc	esi
	cmp	esi, 7
	jl	SHORT $LL124@ShowTestWi

; 1630 :             }
; 1631 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN327@ShowTestWi:

; 1632 :         }
; 1633 :     }
; 1634 : 
; 1635 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 1636 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ShowTestWindow@ImGui@@YAXPA_N@Z$3:
	push	OFFSET ?$TSS3@?BOD@??ShowTestWindow@ImGui@@YAXPA_N@Z@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__ehhandler$?ShowTestWindow@ImGui@@YAXPA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?ShowTestWindow@ImGui@@YAXPA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShowTestWindow@ImGui@@YAXPA_N@Z ENDP			; ImGui::ShowTestWindow
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
_default_style$ = -972					; size = 848
$T3 = -124						; size = 16
$T4 = -108						; size = 16
$T5 = -92						; size = 8
_base_pos$6 = -84					; size = 8
_atlas$1$ = -76						; size = 4
tv1681 = -72						; size = 4
tv1680 = -68						; size = 4
$T7 = -64						; size = 8
_glyph_fallback$1$ = -60				; size = 4
_cell_spacing$1$ = -56					; size = 4
_draw_list$1$ = -52					; size = 4
_cell_p1$8 = -48					; size = 8
$T9 = -48						; size = 8
$T10 = -48						; size = 8
_i$1$ = -40						; size = 4
_name$1$ = -40						; size = 4
_name$1$ = -40						; size = 4
_style$1$ = -36						; size = 4
_cell_p2$11 = -32					; size = 8
$T12 = -32						; size = 8
$T13 = -32						; size = 8
$T14 = -32						; size = 8
$T15 = -32						; size = 8
$T16 = -32						; size = 8
$T17 = -32						; size = 8
_cell_size$1$sroa$746$1$ = -24				; size = 4
_i$1$ = -24						; size = 4
tv1694 = -24						; size = 4
_base$1$ = -20						; size = 4
tv1690 = -20						; size = 4
tv1686 = -20						; size = 4
_n$1$ = -16						; size = 4
_count$1$ = -16						; size = 4
_i$1$ = -16						; size = 4
tv1683 = -16						; size = 4
tv1676 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_font$1$ = 8						; size = 4
_ref$ = 8						; size = 4
?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z PROC	; ImGui::ShowStyleEditor

; 1639 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 960				; 000003c0H
	push	esi
	push	edi

; 1640 :     ImGuiStyle& style = ImGui::GetStyle();

	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	edi, eax

; 1641 : 
; 1642 :     // You can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it compares to the default style)
; 1643 :     const ImGuiStyle default_style; // Default style

	lea	ecx, DWORD PTR _default_style$[ebp]
	mov	DWORD PTR _style$1$[ebp], edi
	call	??0ImGuiStyle@@QAE@XZ			; ImGuiStyle::ImGuiStyle

; 1644 :     if (ImGui::Button("Revert Style"))

	lea	eax, DWORD PTR $T17[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T17[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1644 :     if (ImGui::Button("Revert Style"))

	push	eax
	push	OFFSET $SG11994
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T17[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1644 :     if (ImGui::Button("Revert Style"))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	test	al, al
	je	SHORT $LN24@ShowStyleE

; 1645 :         style = ref ? *ref : default_style;

	mov	eax, DWORD PTR _ref$[ebp]
	lea	esi, DWORD PTR _default_style$[ebp]
	test	eax, eax
	mov	ecx, 212				; 000000d4H
	cmovne	esi, eax
	rep movsd
	mov	edi, DWORD PTR _style$1$[ebp]
$LN24@ShowStyleE:

; 1646 : 
; 1647 :     if (ref)

	mov	esi, DWORD PTR _ref$[ebp]
	test	esi, esi
	je	SHORT $LN26@ShowStyleE

; 1648 :     {
; 1649 :         ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1650 :         if (ImGui::Button("Save Style"))

	lea	eax, DWORD PTR $T16[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T16[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1650 :         if (ImGui::Button("Save Style"))

	push	eax
	push	OFFSET $SG11997
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T16[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1650 :         if (ImGui::Button("Save Style"))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN26@ShowStyleE

; 1651 :             *ref = style;

	mov	esi, edi
	mov	ecx, 212				; 000000d4H
	mov	edi, DWORD PTR _ref$[ebp]
	rep movsd
	mov	esi, DWORD PTR _ref$[ebp]
$LN26@ShowStyleE:

; 1652 :     }
; 1653 : 
; 1654 :     ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.55f);

	call	?GetWindowWidth@ImGui@@YAMXZ		; ImGui::GetWindowWidth
	fmul	DWORD PTR __real@3f0ccccd
	push	ecx
	fstp	DWORD PTR [esp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 1655 : 
; 1656 :     if (ImGui::TreeNode("Rendering"))

	push	OFFSET $SG11999
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode

; 1657 :     {
; 1658 :         ImGui::Checkbox("Anti-aliased lines", &style.AntiAliasedLines);

	mov	edi, DWORD PTR _style$1$[ebp]
	add	esp, 8
	test	al, al
	je	$LN27@ShowStyleE
	lea	eax, DWORD PTR [edi+120]
	push	eax
	push	OFFSET $SG12000
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1659 :         ImGui::Checkbox("Anti-aliased shapes", &style.AntiAliasedShapes);

	lea	eax, DWORD PTR [edi+121]
	push	eax
	push	OFFSET $SG12001
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1660 :         ImGui::PushItemWidth(100);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 1661 :         ImGui::DragFloat("Curve Tessellation Tolerance", &style.CurveTessellationTol, 0.02f, 0.10f, FLT_MAX, NULL, 2.0f);

	mov	DWORD PTR [esp], 1073741824		; 40000000H
	add	edi, 124				; 0000007cH
	push	0
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esp+4], 1036831949		; 3dcccccdH
	mov	DWORD PTR [esp], 1017370378		; 3ca3d70aH
	push	edi
	push	OFFSET $SG12002
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat
	xorps	xmm0, xmm0
	add	esp, 28					; 0000001cH

; 1662 :         if (style.CurveTessellationTol < 0.0f) style.CurveTessellationTol = 0.10f;

	comiss	xmm0, DWORD PTR [edi]
	jbe	SHORT $LN28@ShowStyleE
	mov	DWORD PTR [edi], 1036831949		; 3dcccccdH
$LN28@ShowStyleE:

; 1663 :         ImGui::DragFloat("Global Alpha", &style.Alpha, 0.005f, 0.20f, 1.0f, "%.2f"); // Not exposing zero here so user doesn't "lose" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.

	mov	edi, DWORD PTR _style$1$[ebp]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12004
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1065353216		; 3f800000H
	mov	DWORD PTR [esp+4], 1045220557		; 3e4ccccdH
	mov	DWORD PTR [esp], 1000593162		; 3ba3d70aH
	push	edi
	push	OFFSET $SG12005
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat
	add	esp, 28					; 0000001cH

; 1664 :         ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 1665 :         ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN27@ShowStyleE:

; 1666 :     }
; 1667 : 
; 1668 :     if (ImGui::TreeNode("Settings"))

	push	OFFSET $SG12007
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN29@ShowStyleE

; 1669 :     {
; 1670 :         ImGui::SliderFloat2("WindowPadding", (float*)&style.WindowPadding, 0.0f, 20.0f, "%.0f");

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	lea	eax, DWORD PTR [edi+4]
	push	OFFSET $SG12008
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1101004800		; 41a00000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12009
	call	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat2

; 1671 :         ImGui::SliderFloat("WindowRounding", &style.WindowRounding, 0.0f, 16.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12010
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1098907648		; 41800000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12011
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 1672 :         ImGui::SliderFloat("ChildWindowRounding", &style.ChildWindowRounding, 0.0f, 16.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12012
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1098907648		; 41800000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12013
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 1673 :         ImGui::SliderFloat2("FramePadding", (float*)&style.FramePadding, 0.0f, 20.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12014
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1101004800		; 41a00000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12015
	call	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat2

; 1674 :         ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 16.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12016
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1098907648		; 41800000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12017
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 1675 :         ImGui::SliderFloat2("ItemSpacing", (float*)&style.ItemSpacing, 0.0f, 20.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12018
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1101004800		; 41a00000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12019
	call	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat2

; 1676 :         ImGui::SliderFloat2("ItemInnerSpacing", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+56]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12020
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1101004800		; 41a00000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12021
	call	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat2

; 1677 :         ImGui::SliderFloat2("TouchExtraPadding", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+64]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12022
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1092616192		; 41200000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12023
	call	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat2

; 1678 :         ImGui::SliderFloat("IndentSpacing", &style.IndentSpacing, 0.0f, 30.0f, "%.0f");

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	lea	eax, DWORD PTR [edi+72]
	push	OFFSET $SG12024
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1106247680		; 41f00000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12025
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 1679 :         ImGui::SliderFloat("ScrollbarSize", &style.ScrollbarSize, 1.0f, 20.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12026
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1101004800		; 41a00000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	push	OFFSET $SG12027
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 1680 :         ImGui::SliderFloat("ScrollbarRounding", &style.ScrollbarRounding, 0.0f, 16.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+84]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12028
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1098907648		; 41800000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12029
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 1681 :         ImGui::SliderFloat("GrabMinSize", &style.GrabMinSize, 1.0f, 20.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+88]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12030
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1101004800		; 41a00000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	push	OFFSET $SG12031
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 1682 :         ImGui::SliderFloat("GrabRounding", &style.GrabRounding, 0.0f, 16.0f, "%.0f");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+92]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12032
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1098907648		; 41800000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12033
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 1683 :         ImGui::Text("Alignment");

	push	OFFSET $SG12034
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1684 :         ImGui::SliderFloat2("WindowTitleAlign", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, "%.2f");

	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12035
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12036
	call	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat2

; 1685 :         ImGui::SliderFloat2("ButtonTextAlign", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, "%.2f"); ImGui::SameLine(); ShowHelpMarker("Alignment applies when a button is larger than its text content.");

	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12037
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 0
	push	eax
	push	OFFSET $SG12038
	call	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z	; ImGui::SliderFloat2
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG12039
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker
	add	esp, 12					; 0000000cH

; 1686 :         ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN29@ShowStyleE:

; 1687 :     }
; 1688 : 
; 1689 :     if (ImGui::TreeNode("Colors"))

	push	OFFSET $SG12041
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN30@ShowStyleE

; 1693 :         if (ImGui::Button("Copy Colors"))

	lea	eax, DWORD PTR $T15[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T15[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1693 :         if (ImGui::Button("Copy Colors"))

	push	eax
	push	OFFSET $SG12043
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T15[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1693 :         if (ImGui::Button("Copy Colors"))

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	test	al, al
	je	$LN31@ShowStyleE

; 1694 :         {
; 1695 :             if (output_dest == 0)

	cmp	DWORD PTR ?output_dest@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA, 0

; 1696 :                 ImGui::LogToClipboard();

	push	-1
	jne	SHORT $LN32@ShowStyleE
	call	?LogToClipboard@ImGui@@YAXH@Z		; ImGui::LogToClipboard

; 1697 :             else

	jmp	SHORT $LN170@ShowStyleE
$LN32@ShowStyleE:

; 1698 :                 ImGui::LogToTTY();

	call	?LogToTTY@ImGui@@YAXH@Z			; ImGui::LogToTTY
$LN170@ShowStyleE:
	add	esp, 4

; 1699 :             ImGui::LogText("ImGuiStyle& style = ImGui::GetStyle();" IM_NEWLINE);

	push	OFFSET $SG12046
	call	?LogText@ImGui@@YAXPBDZZ		; ImGui::LogText
	lea	ecx, DWORD PTR _default_style$[ebp+128]

; 1700 :             for (int i = 0; i < ImGuiCol_COUNT; i++)

	xor	eax, eax
	mov	DWORD PTR tv1694[ebp], ecx
	add	esp, 4
	lea	ecx, DWORD PTR [esi+128]
	mov	DWORD PTR _i$1$[ebp], eax
	mov	DWORD PTR tv1690[ebp], ecx
	add	edi, 136				; 00000088H
$LL4@ShowStyleE:

; 1701 :             {
; 1702 :                 const ImVec4& col = style.Colors[i];
; 1703 :                 const char* name = ImGui::GetStyleColName(i);

	push	eax
	call	?GetStyleColName@ImGui@@YAPBDH@Z	; ImGui::GetStyleColName
	add	esp, 4
	mov	edx, eax

; 1704 :                 if (!output_only_modified || memcmp(&col, (ref ? &ref->Colors[i] : &default_style.Colors[i]), sizeof(ImVec4)) != 0)

	cmp	BYTE PTR ?output_only_modified@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4_NA, 0
	mov	DWORD PTR _name$1$[ebp], edx
	je	SHORT $LN156@ShowStyleE
	mov	ecx, DWORD PTR tv1694[ebp]
	lea	edx, DWORD PTR [edi-8]
	test	esi, esi
	mov	esi, 12					; 0000000cH
	cmovne	ecx, DWORD PTR tv1690[ebp]
	npad	4
$LL157@ShowStyleE:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN166@ShowStyleE
	add	edx, 4
	add	ecx, 4
	sub	esi, 4
	jae	SHORT $LL157@ShowStyleE
	jmp	SHORT $LN2@ShowStyleE
$LN166@ShowStyleE:
	mov	edx, DWORD PTR _name$1$[ebp]
$LN156@ShowStyleE:

; 1705 :                     ImGui::LogText("style.Colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);" IM_NEWLINE, name, 22 - (int)strlen(name), "", col.x, col.y, col.z, col.w);

	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
	npad	5
$LL158@ShowStyleE:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL158@ShowStyleE
	movss	xmm0, DWORD PTR [edi+4]
	sub	esp, 32					; 00000020H
	cvtps2pd xmm0, xmm0
	sub	ecx, esi
	mov	eax, 22					; 00000016H
	sub	eax, ecx
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [edi]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [edi-4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [edi-8]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG12049
	push	eax
	push	edx
	push	OFFSET $SG12050
	call	?LogText@ImGui@@YAXPBDZZ		; ImGui::LogText
	add	esp, 48					; 00000030H
$LN2@ShowStyleE:

; 1700 :             for (int i = 0; i < ImGuiCol_COUNT; i++)

	mov	eax, DWORD PTR _i$1$[ebp]
	add	edi, 16					; 00000010H
	add	DWORD PTR tv1690[ebp], 16		; 00000010H
	inc	eax
	add	DWORD PTR tv1694[ebp], 16		; 00000010H
	mov	esi, DWORD PTR _ref$[ebp]
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, 45					; 0000002dH
	jl	$LL4@ShowStyleE

; 1706 :             }
; 1707 :             ImGui::LogFinish();

	call	?LogFinish@ImGui@@YAXXZ			; ImGui::LogFinish
$LN31@ShowStyleE:

; 1708 :         }
; 1709 :         ImGui::SameLine(); ImGui::PushItemWidth(120); ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0"); ImGui::PopItemWidth();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 4
	mov	DWORD PTR [esp], 1123024896		; 42f00000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	push	-1
	push	OFFSET $SG12051
	push	OFFSET ?output_dest@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	push	OFFSET $SG12052
	call	?Combo@ImGui@@YA_NPBDPAH0H@Z		; ImGui::Combo
	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 1710 :         ImGui::SameLine(); ImGui::Checkbox("Only Modified Fields", &output_only_modified);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET ?output_only_modified@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4_NA
	push	OFFSET $SG12053
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox

; 1711 : 
; 1712 :         static ImGuiColorEditMode edit_mode = ImGuiColorEditMode_RGB;
; 1713 :         ImGui::RadioButton("RGB", &edit_mode, ImGuiColorEditMode_RGB);

	push	0
	push	OFFSET ?edit_mode@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	push	OFFSET $SG12054
	call	?RadioButton@ImGui@@YA_NPBDPAHH@Z	; ImGui::RadioButton

; 1714 :         ImGui::SameLine();

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1715 :         ImGui::RadioButton("HSV", &edit_mode, ImGuiColorEditMode_HSV);

	push	1
	push	OFFSET ?edit_mode@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	push	OFFSET $SG12055
	call	?RadioButton@ImGui@@YA_NPBDPAHH@Z	; ImGui::RadioButton

; 1716 :         ImGui::SameLine();

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 1717 :         ImGui::RadioButton("HEX", &edit_mode, ImGuiColorEditMode_HEX);

	push	2
	push	OFFSET ?edit_mode@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	push	OFFSET $SG12056
	call	?RadioButton@ImGui@@YA_NPBDPAHH@Z	; ImGui::RadioButton

; 1718 :         //ImGui::Text("Tip: Click on colored square to change edit mode.");
; 1719 : 
; 1720 :         static ImGuiTextFilter filter;

	mov	eax, DWORD PTR fs:__tls_array
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	SHORT $LN5@ShowStyleE
	push	OFFSET ?$TSS0@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA, -1
	jne	SHORT $LN5@ShowStyleE
	push	OFFSET $SG12057
	mov	ecx, OFFSET ?filter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4UImGuiTextFilter@@A
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0ImGuiTextFilter@@QAE@PBD@Z		; ImGuiTextFilter::ImGuiTextFilter
	push	OFFSET ??__Ffilter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@YAXXZ ; `ImGui::ShowStyleEditor'::`20'::`dynamic atexit destructor for 'filter''
	call	_atexit
	push	OFFSET ?$TSS0@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 8
$LN5@ShowStyleE:

; 1721 :         filter.Draw("Filter colors", 200);

	push	ecx
	mov	DWORD PTR [esp], 1128792064		; 43480000H
	mov	ecx, OFFSET ?filter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4UImGuiTextFilter@@A
	push	OFFSET $SG12058
	call	?Draw@ImGuiTextFilter@@QAE_NPBDM@Z	; ImGuiTextFilter::Draw

; 1723 :         ImGui::BeginChild("#colors", ImVec2(0, 300), true, ImGuiWindowFlags_AlwaysVerticalScrollbar);

	push	16384					; 00004000H
	push	1
	lea	eax, DWORD PTR $T14[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T14[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1723 :         ImGui::BeginChild("#colors", ImVec2(0, 300), true, ImGuiWindowFlags_AlwaysVerticalScrollbar);

	push	eax
	push	OFFSET $SG12059
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T14[ebp+4], 1133903872	; 43960000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1723 :         ImGui::BeginChild("#colors", ImVec2(0, 300), true, ImGuiWindowFlags_AlwaysVerticalScrollbar);

	call	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ; ImGui::BeginChild

; 1724 :         ImGui::PushItemWidth(-160);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp], -1021313024		; c3200000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 1725 :         ImGui::ColorEditMode(edit_mode);

	push	DWORD PTR ?edit_mode@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	call	?ColorEditMode@ImGui@@YAXH@Z		; ImGui::ColorEditMode
	mov	ecx, DWORD PTR _style$1$[ebp]

; 1726 :         for (int i = 0; i < ImGuiCol_COUNT; i++)

	xor	edi, edi
	mov	eax, DWORD PTR _ref$[ebp]
	add	esp, 8
	sub	eax, ecx
	mov	DWORD PTR _i$1$[ebp], edi
	mov	DWORD PTR tv1686[ebp], eax
	lea	eax, DWORD PTR _default_style$[ebp]
	sub	eax, ecx
	lea	esi, DWORD PTR [ecx+128]
	mov	DWORD PTR tv1683[ebp], eax
	npad	7
$LL8@ShowStyleE:

; 1727 :         {
; 1728 :             const char* name = ImGui::GetStyleColName(i);

	push	edi
	call	?GetStyleColName@ImGui@@YAPBDH@Z	; ImGui::GetStyleColName
	add	esp, 4
	mov	DWORD PTR _name$1$[ebp], eax

; 1729 :             if (!filter.PassFilter(name))

	mov	ecx, OFFSET ?filter@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4UImGuiTextFilter@@A
	push	0
	push	eax
	call	?PassFilter@ImGuiTextFilter@@QBE_NPBD0@Z ; ImGuiTextFilter::PassFilter
	test	al, al
	je	$LN6@ShowStyleE

; 1730 :                 continue;
; 1731 :             ImGui::PushID(i);

	push	edi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 1732 :             ImGui::ColorEdit4(name, (float*)&style.Colors[i], true);

	push	1
	push	esi
	push	DWORD PTR _name$1$[ebp]
	call	?ColorEdit4@ImGui@@YA_NPBDQAM_N@Z	; ImGui::ColorEdit4

; 1733 :             if (memcmp(&style.Colors[i], (ref ? &ref->Colors[i] : &default_style.Colors[i]), sizeof(ImVec4)) != 0)

	mov	ecx, DWORD PTR tv1686[ebp]
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _ref$[ebp], 0
	jne	SHORT $LN171@ShowStyleE
	mov	ecx, DWORD PTR tv1683[ebp]
$LN171@ShowStyleE:
	add	ecx, esi
	mov	edx, esi
	mov	edi, 12					; 0000000cH
	npad	6
$LL161@ShowStyleE:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN160@ShowStyleE
	add	edx, 4
	add	ecx, 4
	sub	edi, 4
	jae	SHORT $LL161@ShowStyleE
	jmp	$LN40@ShowStyleE
$LN160@ShowStyleE:

; 1735 :                 ImGui::SameLine(); if (ImGui::Button("Revert")) style.Colors[i] = ref ? ref->Colors[i] : default_style.Colors[i];

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	lea	eax, DWORD PTR $T13[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T13[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1735 :                 ImGui::SameLine(); if (ImGui::Button("Revert")) style.Colors[i] = ref ? ref->Colors[i] : default_style.Colors[i];

	push	eax
	push	OFFSET $SG12063
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T13[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1735 :                 ImGui::SameLine(); if (ImGui::Button("Revert")) style.Colors[i] = ref ? ref->Colors[i] : default_style.Colors[i];

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	test	al, al
	mov	eax, DWORD PTR _ref$[ebp]
	je	SHORT $LN38@ShowStyleE
	mov	ecx, DWORD PTR tv1686[ebp]
	test	eax, eax
	jne	SHORT $LN172@ShowStyleE
	mov	ecx, DWORD PTR tv1683[ebp]
$LN172@ShowStyleE:
	movups	xmm0, XMMWORD PTR [ecx+esi]
	add	ecx, esi
	movups	XMMWORD PTR [esi], xmm0
$LN38@ShowStyleE:

; 1736 :                 if (ref) { ImGui::SameLine(); if (ImGui::Button("Save")) ref->Colors[i] = style.Colors[i]; }

	test	eax, eax
	je	SHORT $LN40@ShowStyleE
	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	lea	eax, DWORD PTR $T10[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T10[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1736 :                 if (ref) { ImGui::SameLine(); if (ImGui::Button("Save")) ref->Colors[i] = style.Colors[i]; }

	push	eax
	push	OFFSET $SG12066
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T10[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1736 :                 if (ref) { ImGui::SameLine(); if (ImGui::Button("Save")) ref->Colors[i] = style.Colors[i]; }

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN40@ShowStyleE
	mov	eax, DWORD PTR tv1686[ebp]
	movups	xmm0, XMMWORD PTR [esi]
	movups	XMMWORD PTR [eax+esi], xmm0
$LN40@ShowStyleE:

; 1737 :             }
; 1738 :             ImGui::PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	mov	edi, DWORD PTR _i$1$[ebp]
$LN6@ShowStyleE:

; 1726 :         for (int i = 0; i < ImGuiCol_COUNT; i++)

	inc	edi
	add	esi, 16					; 00000010H
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, 45					; 0000002dH
	jl	$LL8@ShowStyleE

; 1739 :         }
; 1740 :         ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 1741 :         ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 1742 : 
; 1743 :         ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN30@ShowStyleE:

; 1744 :     }
; 1745 : 
; 1746 :     if (ImGui::TreeNode("Fonts", "Fonts (%d)", ImGui::GetIO().Fonts->Fonts.Size))

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	eax, DWORD PTR [eax+128]
	push	DWORD PTR [eax+32]
	push	OFFSET $SG12068
	push	OFFSET $SG12069
	call	?TreeNode@ImGui@@YA_NPBD0ZZ		; ImGui::TreeNode
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN41@ShowStyleE

; 1747 :     {
; 1748 :         ImGui::SameLine(); ShowHelpMarker("Tip: Load fonts with io.Fonts->AddFontFromFileTTF()\nbefore calling io.Fonts->GetTex* functions.");

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG12070
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 1749 :         ImFontAtlas* atlas = ImGui::GetIO().Fonts;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	esi, DWORD PTR [eax+128]
	mov	DWORD PTR _atlas$1$[ebp], esi

; 1750 :         if (ImGui::TreeNode("Atlas texture", "Atlas texture (%dx%d pixels)", atlas->TexWidth, atlas->TexHeight))

	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+12]
	push	OFFSET $SG12072
	push	OFFSET $SG12073
	call	?TreeNode@ImGui@@YA_NPBD0ZZ		; ImGui::TreeNode
	add	esp, 28					; 0000001cH
	test	al, al
	je	SHORT $LN42@ShowStyleE

; 1752 :             ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	movaps	xmm0, XMMWORD PTR __xmm@3f0080813f8000003f8000003f800000
	lea	eax, DWORD PTR $T4[ebp]
	movups	XMMWORD PTR $T4[ebp], xmm0
	push	eax
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	lea	eax, DWORD PTR $T3[ebp]
	movups	XMMWORD PTR $T3[ebp], xmm0
	push	eax
	movd	xmm0, DWORD PTR [esi+12]
	lea	eax, DWORD PTR $T12[ebp]
	cvtdq2ps xmm0, xmm0
	push	eax
	lea	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T12[ebp], 1065353216		; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1752 :             ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	push	eax
	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T12[ebp+4], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1752 :             ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	push	eax
	push	DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
	movd	xmm0, DWORD PTR [esi+16]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1752 :             ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp], 0
	mov	DWORD PTR $T9[ebp+4], 0
	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1752 :             ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));

	call	?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z ; ImGui::Image
	add	esp, 24					; 00000018H

; 1753 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN42@ShowStyleE:

; 1754 :         }
; 1755 :         ImGui::PushItemWidth(100);

	push	ecx
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 1756 :         for (int i = 0; i < atlas->Fonts.Size; i++)

	xor	edi, edi
	add	esp, 4
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR [esi+32], edi
	jle	$LN10@ShowStyleE
$LL11@ShowStyleE:

; 1757 :         {
; 1758 :             ImFont* font = atlas->Fonts[i];

	mov	eax, DWORD PTR [esi+40]
	mov	esi, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _font$1$[ebp], esi

; 1759 :             ImGui::BulletText("Font %d: \'%s\', %.2f px, %d glyphs", i, font->ConfigData ? font->ConfigData[0].Name : "", font->FontSize, font->Glyphs.Size);

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN55@ShowStyleE
	add	eax, 46					; 0000002eH
	jmp	SHORT $LN56@ShowStyleE
$LN55@ShowStyleE:
	mov	eax, OFFSET $SG12074
$LN56@ShowStyleE:
	push	DWORD PTR [esi+16]
	movss	xmm0, DWORD PTR [esi]
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	eax
	push	edi
	push	OFFSET $SG12075
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 1760 :             ImGui::TreePush((void*)(intptr_t)i);

	push	edi
	call	?TreePush@ImGui@@YAXPBX@Z		; ImGui::TreePush

; 1761 :             ImGui::SameLine(); if (ImGui::SmallButton("Set as default")) ImGui::GetIO().FontDefault = font;

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG12077
	call	?SmallButton@ImGui@@YA_NPBD@Z		; ImGui::SmallButton
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN43@ShowStyleE
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	DWORD PTR [eax+140], esi
$LN43@ShowStyleE:

; 1762 :             ImGui::PushFont(font);

	push	esi
	call	?PushFont@ImGui@@YAXPAUImFont@@@Z	; ImGui::PushFont

; 1763 :             ImGui::Text("The quick brown fox jumps over the lazy dog");

	push	OFFSET $SG12078
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1764 :             ImGui::PopFont();

	call	?PopFont@ImGui@@YAXXZ			; ImGui::PopFont

; 1765 :             if (ImGui::TreeNode("Details"))

	push	OFFSET $SG12080
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN44@ShowStyleE

; 1766 :             {
; 1767 :                 ImGui::DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");   // Scale only this font

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	lea	eax, DWORD PTR [esi+4]
	push	OFFSET $SG12081
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1073741824		; 40000000H
	mov	DWORD PTR [esp+4], 1050253722		; 3e99999aH
	mov	DWORD PTR [esp], 1000593162		; 3ba3d70aH
	push	eax
	push	OFFSET $SG12082
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 1768 :                 ImGui::SameLine(); ShowHelpMarker("Note than the default embedded font is NOT meant to be scaled.\n\nFont are currently rendered into bitmaps at a given size at the time of building the atlas. You may oversample them to get some flexibility with scaling. You can also render at multiple sizes and select which one to use at runtime.\n\n(Glimmer of hope: the atlas system should hopefully be rewritten in the future to make scaling more natural and automatic.)");

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	push	OFFSET $SG12083
	call	?ShowHelpMarker@@YAXPBD@Z		; ShowHelpMarker

; 1769 :                 ImGui::Text("Ascent: %f, Descent: %f, Height: %f", font->Ascent, font->Descent, font->Ascent - font->Descent);

	movss	xmm2, DWORD PTR [esi+72]
	sub	esp, 12					; 0000000cH
	movss	xmm1, DWORD PTR [esi+76]
	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp+8], xmm0
	cvtps2pd xmm0, xmm2
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG12084
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1770 :                 ImGui::Text("Fallback character: '%c' (%d)", font->FallbackChar, font->FallbackChar);

	movzx	eax, WORD PTR [esi+60]
	push	eax
	push	eax
	push	OFFSET $SG12085
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1771 :                 ImGui::Text("Texture surface: %d pixels (approx)", font->MetricsTotalSurface);

	push	DWORD PTR [esi+80]
	push	OFFSET $SG12086
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	xor	eax, eax
	add	esp, 48					; 00000030H

; 1772 :                 for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)

	xor	edi, edi
	cmp	ax, WORD PTR [esi+62]
	jge	SHORT $LN13@ShowStyleE

; 1766 :             {
; 1767 :                 ImGui::DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");   // Scale only this font

	xor	edx, edx
	mov	DWORD PTR tv1676[ebp], edx
	npad	3
$LL14@ShowStyleE:

; 1773 :                 {
; 1774 :                     ImFontConfig* cfg = &font->ConfigData[config_i];

	mov	ecx, DWORD PTR [esi+64]
	add	ecx, edx

; 1775 :                     ImGui::BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d", config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV, cfg->PixelSnapH);

	movzx	eax, BYTE PTR [ecx+28]
	push	eax
	push	DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [ecx+46]
	push	DWORD PTR [ecx+20]
	push	eax
	push	edi
	push	OFFSET $SG12087
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	mov	edx, DWORD PTR tv1676[ebp]
	inc	edi
	movsx	eax, WORD PTR [esi+62]
	add	edx, 84					; 00000054H
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv1676[ebp], edx
	cmp	edi, eax
	jl	SHORT $LL14@ShowStyleE
$LN13@ShowStyleE:

; 1776 :                 }
; 1777 :                 if (ImGui::TreeNode("Glyphs", "Glyphs (%d)", font->Glyphs.Size))

	push	DWORD PTR [esi+16]
	push	OFFSET $SG12089
	push	OFFSET $SG12090
	call	?TreeNode@ImGui@@YA_NPBD0ZZ		; ImGui::TreeNode
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN45@ShowStyleE

; 1778 :                 {
; 1779 :                     // Display all glyphs of the fonts in separate pages of 256 characters
; 1780 :                     const ImFont::Glyph* glyph_fallback = font->FallbackGlyph; // Forcefully/dodgily make FindGlyph() return NULL on fallback, which isn't the default behavior.

	mov	eax, DWORD PTR [esi+52]

; 1781 :                     font->FallbackGlyph = NULL;
; 1782 :                     for (int base = 0; base < 0x10000; base += 256)

	xor	edi, edi
	mov	DWORD PTR _glyph_fallback$1$[ebp], eax
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR _base$1$[ebp], edi
$LL17@ShowStyleE:

; 1783 :                     {
; 1784 :                         int count = 0;

	mov	DWORD PTR _count$1$[ebp], 0

; 1785 :                         for (int n = 0; n < 256; n++)

	xor	esi, esi
	npad	4
$LL20@ShowStyleE:

; 1786 :                             count += font->FindGlyph((ImWchar)(base + n)) ? 1 : 0;

	mov	ecx, DWORD PTR _font$1$[ebp]
	lea	eax, DWORD PTR [edi+esi]
	push	eax
	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph
	mov	ecx, DWORD PTR _count$1$[ebp]
	neg	eax
	sbb	eax, eax
	inc	esi
	neg	eax
	add	ecx, eax
	mov	DWORD PTR _count$1$[ebp], ecx
	cmp	esi, 256				; 00000100H
	jl	SHORT $LL20@ShowStyleE

; 1787 :                         if (count > 0 && ImGui::TreeNode((void*)(intptr_t)base, "U+%04X..U+%04X (%d %s)", base, base+255, count, count > 1 ? "glyphs" : "glyph"))

	test	ecx, ecx
	jle	$LN164@ShowStyleE
	cmp	ecx, 1
	mov	edx, OFFSET $SG12093
	mov	eax, OFFSET $SG12092
	cmovle	eax, edx
	push	eax
	push	ecx
	lea	eax, DWORD PTR [edi+255]
	push	eax
	push	edi
	push	OFFSET $SG12094
	push	edi
	call	?TreeNode@ImGui@@YA_NPBXPBDZZ		; ImGui::TreeNode
	add	esp, 24					; 00000018H
	test	al, al
	je	$LN164@ShowStyleE

; 1789 :                             float cell_spacing = style.ItemSpacing.y;

	mov	eax, DWORD PTR _style$1$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR _font$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1789 :                             float cell_spacing = style.ItemSpacing.y;

	movss	DWORD PTR _cell_spacing$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1791 :                             ImVec2 base_pos = ImGui::GetCursorScreenPos();

	lea	eax, DWORD PTR _base_pos$6[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _cell_size$1$sroa$746$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1791 :                             ImVec2 base_pos = ImGui::GetCursorScreenPos();

	call	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos
	add	esp, 4

; 1792 :                             ImDrawList* draw_list = ImGui::GetWindowDrawList();

	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	movss	xmm3, DWORD PTR _cell_size$1$sroa$746$1$[ebp]

; 1793 :                             for (int n = 0; n < 256; n++)

	xor	ecx, ecx
	movaps	xmm1, xmm3
	mov	DWORD PTR _draw_list$1$[ebp], eax
	addss	xmm1, DWORD PTR _cell_spacing$1$[ebp]
	movaps	xmm4, xmm3
	mov	DWORD PTR _n$1$[ebp], ecx
	addss	xmm4, DWORD PTR _cell_spacing$1$[ebp]
	movss	DWORD PTR tv1680[ebp], xmm1
	movss	DWORD PTR tv1681[ebp], xmm4
	jmp	SHORT $LN23@ShowStyleE
	npad	2
$LL162@ShowStyleE:
	movss	xmm3, DWORD PTR _cell_size$1$sroa$746$1$[ebp]
$LN23@ShowStyleE:

; 1794 :                             {
; 1795 :                                 ImVec2 cell_p1(base_pos.x + (n % 16) * (cell_size.x + cell_spacing), base_pos.y + (n / 16) * (cell_size.y + cell_spacing));

	mov	eax, ecx
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN169@ShowStyleE
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN169@ShowStyleE:

; 1797 :                                 const ImFont::Glyph* glyph = font->FindGlyph((ImWchar)(base+n));;

	movd	xmm2, eax
	lea	esi, DWORD PTR [ecx+edi]
	mov	eax, ecx
	movaps	xmm0, xmm3
	cdq
	cvtdq2ps xmm2, xmm2
	and	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _font$1$[ebp]
	add	eax, edx
	sar	eax, 4
	push	esi
	mulss	xmm2, xmm1
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	addss	xmm2, DWORD PTR _base_pos$6[ebp]
	mulss	xmm1, xmm4
	addss	xmm1, DWORD PTR _base_pos$6[ebp+4]
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _cell_p1$8[ebp], xmm2
	movss	DWORD PTR _cell_p1$8[ebp+4], xmm1
	movss	DWORD PTR _cell_p2$11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1796 :                                 ImVec2 cell_p2(cell_p1.x + cell_size.x, cell_p1.y + cell_size.y);

	movaps	xmm0, xmm3
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _cell_p2$11[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1797 :                                 const ImFont::Glyph* glyph = font->FindGlyph((ImWchar)(base+n));;

	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph

; 1798 :                                 draw_list->AddRect(cell_p1, cell_p2, glyph ? IM_COL32(255,255,255,100) : IM_COL32(255,255,255,50));

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	mov	edi, eax
	push	-1
	push	ecx
	test	edi, edi
	mov	DWORD PTR [esp], 0
	mov	eax, 1694498815				; 64ffffffH
	mov	ecx, 855638015				; 32ffffffH
	cmovne	ecx, eax
	lea	eax, DWORD PTR _cell_p2$11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _draw_list$1$[ebp]
	push	eax
	lea	eax, DWORD PTR _cell_p1$8[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 1799 :                                 font->RenderChar(draw_list, cell_size.x, cell_p1, ImGui::GetColorU32(ImGuiCol_Text), (ImWchar)(base+n)); // We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions available to generate a string.

	push	esi
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR _cell_size$1$sroa$746$1$[ebp]
	add	esp, 8
	mov	esi, DWORD PTR _font$1$[ebp]
	push	eax
	push	DWORD PTR _cell_p1$8[ebp+4]
	push	DWORD PTR _cell_p1$8[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, esi
	push	DWORD PTR _draw_list$1$[ebp]
	call	?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z ; ImFont::RenderChar

; 1800 :                                 if (glyph && ImGui::IsMouseHoveringRect(cell_p1, cell_p2))

	test	edi, edi
	je	$LN21@ShowStyleE
	push	1
	lea	eax, DWORD PTR _cell_p2$11[ebp]
	push	eax
	lea	eax, DWORD PTR _cell_p1$8[ebp]
	push	eax
	call	?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN21@ShowStyleE

; 1801 :                                 {
; 1802 :                                     ImGui::BeginTooltip();

	call	?BeginTooltip@ImGui@@YAXXZ		; ImGui::BeginTooltip

; 1803 :                                     ImGui::Text("Codepoint: U+%04X", base+n);

	mov	eax, DWORD PTR _n$1$[ebp]
	add	eax, DWORD PTR _base$1$[ebp]
	push	eax
	push	OFFSET $SG12096
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 1804 :                                     ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
	movss	xmm0, DWORD PTR [edi+4]

; 1805 :                                     ImGui::Text("XAdvance+1: %.1f", glyph->XAdvance);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG12097
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	movss	xmm0, DWORD PTR [edi+20]

; 1806 :                                     ImGui::Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph->X0, glyph->Y0, glyph->X1, glyph->Y1);

	sub	esp, 20					; 00000014H
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [edi+16]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [edi+12]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [edi+8]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG12098
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	movss	xmm0, DWORD PTR [edi+36]

; 1807 :                                     ImGui::Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph->U0, glyph->V0, glyph->U1, glyph->V1);

	add	esp, 4
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [edi+32]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [edi+28]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [edi+24]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG12099
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 36					; 00000024H

; 1808 :                                     ImGui::EndTooltip();

	call	?EndTooltip@ImGui@@YAXXZ		; ImGui::EndTooltip
$LN21@ShowStyleE:

; 1793 :                             for (int n = 0; n < 256; n++)

	mov	ecx, DWORD PTR _n$1$[ebp]
	movss	xmm1, DWORD PTR tv1680[ebp]
	inc	ecx
	movss	xmm4, DWORD PTR tv1681[ebp]
	mov	edi, DWORD PTR _base$1$[ebp]
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, 256				; 00000100H
	jl	$LL162@ShowStyleE

; 1811 :                             ImGui::Dummy(ImVec2((cell_size.x + cell_spacing) * 16, (cell_size.y + cell_spacing) * 16));

	movss	xmm1, DWORD PTR _cell_size$1$sroa$746$1$[ebp]
	lea	eax, DWORD PTR $T5[ebp]
	movss	xmm3, DWORD PTR __real@41800000
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR _cell_spacing$1$[ebp]
	mulss	xmm2, xmm3
	push	eax
	mulss	xmm0, xmm3
	mulss	xmm1, xmm3
	addss	xmm0, xmm2
	addss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
	movss	DWORD PTR $T5[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp

; 1811 :                             ImGui::Dummy(ImVec2((cell_size.x + cell_spacing) * 16, (cell_size.y + cell_spacing) * 16));

	call	?Dummy@ImGui@@YAXABUImVec2@@@Z		; ImGui::Dummy
	add	esp, 4

; 1812 :                             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	jmp	SHORT $LN15@ShowStyleE
$LN164@ShowStyleE:
	mov	esi, DWORD PTR _font$1$[ebp]
$LN15@ShowStyleE:

; 1781 :                     font->FallbackGlyph = NULL;
; 1782 :                     for (int base = 0; base < 0x10000; base += 256)

	add	edi, 256				; 00000100H
	mov	DWORD PTR _base$1$[ebp], edi
	cmp	edi, 65536				; 00010000H
	jl	$LL17@ShowStyleE

; 1813 :                         }
; 1814 :                     }
; 1815 :                     font->FallbackGlyph = glyph_fallback;

	mov	eax, DWORD PTR _glyph_fallback$1$[ebp]
	mov	DWORD PTR [esi+52], eax

; 1816 :                     ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN45@ShowStyleE:

; 1817 :                 }
; 1818 :                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	mov	edi, DWORD PTR _i$1$[ebp]
$LN44@ShowStyleE:

; 1819 :             }
; 1820 :             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	mov	esi, DWORD PTR _atlas$1$[ebp]
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, DWORD PTR [esi+32]
	jl	$LL11@ShowStyleE
$LN10@ShowStyleE:

; 1821 :         }
; 1822 :         static float window_scale = 1.0f;
; 1823 :         ImGui::DragFloat("this window scale", &window_scale, 0.005f, 0.3f, 2.0f, "%.1f");              // scale only this window

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12100
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1073741824		; 40000000H
	mov	DWORD PTR [esp+4], 1050253722		; 3e99999aH
	mov	DWORD PTR [esp], 1000593162		; 3ba3d70aH
	push	OFFSET ?window_scale@?CP@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4MA
	push	OFFSET $SG12101
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 1824 :         ImGui::DragFloat("global scale", &ImGui::GetIO().FontGlobalScale, 0.005f, 0.3f, 2.0f, "%.1f"); // scale everything

	add	esp, 24					; 00000018H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG12102
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [esp+8], 1073741824		; 40000000H
	mov	DWORD PTR [esp+4], 1050253722		; 3e99999aH
	mov	DWORD PTR [esp], 1000593162		; 3ba3d70aH
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	add	eax, 132				; 00000084H
	push	eax
	push	OFFSET $SG12103
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 1825 :         ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 1826 :         ImGui::SetWindowFontScale(window_scale);

	movss	xmm0, DWORD PTR ?window_scale@?CP@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4MA
	add	esp, 24					; 00000018H
	movss	DWORD PTR [esp], xmm0
	call	?SetWindowFontScale@ImGui@@YAXM@Z	; ImGui::SetWindowFontScale
	add	esp, 4

; 1827 :         ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN41@ShowStyleE:

; 1828 :     }
; 1829 : 
; 1830 :     ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 1831 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z$0:
	push	OFFSET ?$TSS0@?BE@??ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__ehhandler$?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShowStyleEditor@ImGui@@YAXPAUImGuiStyle@@@Z ENDP	; ImGui::ShowStyleEditor
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_demo.cpp
_TEXT	SEGMENT
?ShowUserGuide@ImGui@@YAXXZ PROC			; ImGui::ShowUserGuide

; 90   :     ImGui::BulletText("Double-click on title bar to collapse window.");

	push	OFFSET $SG10309
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 91   :     ImGui::BulletText("Click and drag on lower right corner to resize window.");

	push	OFFSET $SG10310
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 92   :     ImGui::BulletText("Click and drag on any empty space to move window.");

	push	OFFSET $SG10311
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 93   :     ImGui::BulletText("Mouse Wheel to scroll.");

	push	OFFSET $SG10312
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 16					; 00000010H

; 94   :     if (ImGui::GetIO().FontAllowUserScaling)

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	cmp	BYTE PTR [eax+136], 0
	je	SHORT $LN2@ShowUserGu

; 95   :         ImGui::BulletText("CTRL+Mouse Wheel to zoom window contents.");

	push	OFFSET $SG10314
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 4
$LN2@ShowUserGu:

; 96   :     ImGui::BulletText("TAB/SHIFT+TAB to cycle through keyboard editable fields.");

	push	OFFSET $SG10315
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 97   :     ImGui::BulletText("CTRL+Click on a slider or drag box to input text.");

	push	OFFSET $SG10316
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 98   :     ImGui::BulletText(

	push	OFFSET $SG10317
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 12					; 0000000cH

; 99   :         "While editing text:\n"
; 100  :         "- Hold SHIFT or use mouse to select text\n"
; 101  :         "- CTRL+Left/Right to word jump\n"
; 102  :         "- CTRL+A or double-click to select all\n"
; 103  :         "- CTRL+X,CTRL+C,CTRL+V clipboard\n"
; 104  :         "- CTRL+Z,CTRL+Y undo/redo\n"
; 105  :         "- ESCAPE to revert\n"
; 106  :         "- You can apply arithmetic operators +,*,/ on numerical values.\n"
; 107  :         "  Use +- to subtract.\n");
; 108  : }

	ret	0
?ShowUserGuide@ImGui@@YAXXZ ENDP			; ImGui::ShowUserGuide
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@MMMM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
??0ImVec4@@QAE@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR __z$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR __w$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	16					; 00000010H
??0ImVec4@@QAE@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@XZ
_TEXT	SEGMENT
??0ImVec4@@QAE@XZ PROC					; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR [ecx+12], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx], 0
	ret	0
??0ImVec4@@QAE@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
END
