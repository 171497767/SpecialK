; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\imgui\backends\imgui_d3d11.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	_LIBID_ATLLib
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	_CLSID_Registrar
PUBLIC	_IID_IRegistrar
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
_BSS	SEGMENT
?g_Time@@3_JA DQ 01H DUP (?)				; g_Time
?g_TicksPerSecond@@3_JA DQ 01H DUP (?)			; g_TicksPerSecond
?g_hWnd@@3PAUHWND__@@A DD 01H DUP (?)			; g_hWnd
?g_pVB@@3PAUID3D11Buffer@@A DD 01H DUP (?)		; g_pVB
?g_pIB@@3PAUID3D11Buffer@@A DD 01H DUP (?)		; g_pIB
?g_pVertexShaderBlob@@3PAUID3D10Blob@@A DD 01H DUP (?)	; g_pVertexShaderBlob
?g_pVertexShader@@3PAUID3D11VertexShader@@A DD 01H DUP (?) ; g_pVertexShader
?g_pInputLayout@@3PAUID3D11InputLayout@@A DD 01H DUP (?) ; g_pInputLayout
?g_pVertexConstantBuffer@@3PAUID3D11Buffer@@A DD 01H DUP (?) ; g_pVertexConstantBuffer
?g_pPixelShaderBlob@@3PAUID3D10Blob@@A DD 01H DUP (?)	; g_pPixelShaderBlob
?g_pPixelShader@@3PAUID3D11PixelShader@@A DD 01H DUP (?) ; g_pPixelShader
?g_pFontSampler@@3PAUID3D11SamplerState@@A DD 01H DUP (?) ; g_pFontSampler
?g_pFontTextureView@@3PAUID3D11ShaderResourceView@@A DD 01H DUP (?) ; g_pFontTextureView
?g_pRasterizerState@@3PAUID3D11RasterizerState@@A DD 01H DUP (?) ; g_pRasterizerState
?g_pBlendState@@3PAUID3D11BlendState@@A DD 01H DUP (?)	; g_pBlendState
?g_pDepthStencilState@@3PAUID3D11DepthStencilState@@A DD 01H DUP (?) ; g_pDepthStencilState
?g_frameBufferWidth@@3IA DD 01H DUP (?)			; g_frameBufferWidth
?g_frameBufferHeight@@3IA DD 01H DUP (?)		; g_frameBufferHeight
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
_DATA	SEGMENT
?g_VertexBufferSize@@3HA DD 01388H			; g_VertexBufferSize
?g_IndexBufferSize@@3HA DD 02710H			; g_IndexBufferSize
_DATA	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:$SG236572			; ATL::szDelete
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:$SG236570		; ATL::szNoRemove
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:$SG236568		; ATL::szForceRemove
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:$SG236566		; ATL::szValToken
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:$SG236564		; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:$SG236562		; ATL::szDwordVal
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:$SG236560		; ATL::multiszStringVal
CONST	ENDS
CONST	SEGMENT
$SG236558 DB	'S', 00H, 00H, 00H
$SG236560 DB	'M', 00H, 00H, 00H
$SG236562 DB	'D', 00H, 00H, 00H
$SG236564 DB	'B', 00H, 00H, 00H
$SG236566 DB	'V', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG236568 DB	'F', 00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG236570 DB	'N', 00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'v', 00H, 'e', 00H, 00H, 00H
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
	ORG $+1
$SG236572 DB	'D', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG225310 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG225357 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG225404 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e'
	DB	00H, 00H, 00H
$SG225451 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'l', 00H, 00H, 00H
$SG225498 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG225545 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H
$SG225550 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG225597 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG244072 DB	'cbuffer vertexBuffer : register(b0)       {      float4x'
	DB	'4 ProjectionMatrix;       };      struct VS_INPUT      {     '
	DB	' float2 pos : POSITION;      float4 col : COLOR0;      float2'
	DB	' uv  : TEXCOORD0;      };            struct PS_INPUT      {  '
	DB	'    float4 pos : SV_POSITION;      float4 col : COLOR0;      '
	DB	'float2 uv  : TEXCOORD0;      };            PS_INPUT main(VS_I'
	DB	'NPUT input)      {      PS_INPUT output;      output.pos = mu'
	DB	'l( ProjectionMatrix, float4(input.pos.xy, 0.f, 1.f));      ou'
	DB	'tput.col = input.col;      output.uv  = input.uv;      return'
	DB	' output;      }', 00H
$SG225644 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+6
$SG244087 DB	'struct PS_INPUT      {      float4 pos : SV_POSITION;   '
	DB	'   float4 col : COLOR0;      float2 uv  : TEXCOORD0;      }; '
	DB	'     sampler sampler0;      Texture2D texture0;            fl'
	DB	'oat4 main(PS_INPUT input) : SV_Target      {      float4 out_'
	DB	'col = input.col * texture0.Sample(sampler0, input.uv);       '
	DB	'return out_col;       }', 00H
$SG244100 DB	'vs_4_0', 00H
	ORG $+1
$SG244101 DB	'main', 00H
	ORG $+3
$SG244106 DB	'POSITION', 00H
	ORG $+3
$SG244107 DB	'TEXCOORD', 00H
	ORG $+3
$SG244108 DB	'COLOR', 00H
	ORG $+2
$SG244111 DB	'ps_4_0', 00H
	ORG $+1
$SG244112 DB	'main', 00H
	ORG $+3
$SG225691 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I'
	DB	00H, 00H, 00H
$SG224675 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG224746 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H
$SG224793 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H
	ORG $+2
$SG224840 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H
$SG224887 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG224934 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG237248 DB	'A', 00H, 'p', 00H, 'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG237249 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG237250 DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG237251 DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG237252 DB	'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG237253 DB	'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG237254 DB	'M', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG237255 DB	'S', 00H, 'A', 00H, 'M', 00H, 00H, 00H
$SG237256 DB	'S', 00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H
	DB	'T', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG237257 DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	00H, 00H
	ORG $+2
$SG237258 DB	'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG237259 DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H
	DB	'b', 00H, 00H, 00H
$SG224981 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r'
	DB	00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG225028 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG225075 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG225122 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o'
	DB	00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG225169 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i'
	DB	00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG225216 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm'
	DB	00H, 'p', 00H, 'l', 00H, 00H, 00H
$SG225263 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:$SG236558		; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z ; ImGui_ImplDX11_Init
PUBLIC	?ImGui_ImplDX11_Shutdown@@YAXXZ			; ImGui_ImplDX11_Shutdown
PUBLIC	?ImGui_ImplDX11_NewFrame@@YAXXZ			; ImGui_ImplDX11_NewFrame
PUBLIC	?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ	; ImGui_ImplDX11_InvalidateDeviceObjects
PUBLIC	?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ	; ImGui_ImplDX11_CreateDeviceObjects
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??0SK_ScopedBool@@QAE@PAH@Z			; SK_ScopedBool::SK_ScopedBool
PUBLIC	??1SK_ScopedBool@@QAE@XZ			; SK_ScopedBool::~SK_ScopedBool
PUBLIC	?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z ; ImGui_ImplDX11_RenderDrawLists
PUBLIC	??0?$CComPtrBase@UIDXGISwapChain@@@ATL@@IAE@PAUIDXGISwapChain@@@Z ; ATL::CComPtrBase<IDXGISwapChain>::CComPtrBase<IDXGISwapChain>
PUBLIC	??1?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGISwapChain>::~CComPtrBase<IDXGISwapChain>
PUBLIC	??I?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAEPAPAUIDXGISwapChain@@XZ ; ATL::CComPtrBase<IDXGISwapChain>::operator&
PUBLIC	??C?$CComPtrBase@UIDXGISwapChain@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGISwapChain@@@1@XZ ; ATL::CComPtrBase<IDXGISwapChain>::operator->
PUBLIC	??0?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@PAUIDXGISwapChain@@@Z ; ATL::CComPtr<IDXGISwapChain>::CComPtr<IDXGISwapChain>
PUBLIC	??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGISwapChain>::~CComPtr<IDXGISwapChain>
PUBLIC	??$QueryInterface@UIDXGISwapChain@@@IUnknown@@QAGJPAPAUIDXGISwapChain@@@Z ; IUnknown::QueryInterface<IDXGISwapChain>
PUBLIC	??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@PAUID3D11Device@@@Z ; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>
PUBLIC	??1?$CComPtrBase@UID3D11Device@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ID3D11Device>::~CComPtrBase<ID3D11Device>
PUBLIC	??I?$CComPtrBase@UID3D11Device@@@ATL@@QAEPAPAUID3D11Device@@XZ ; ATL::CComPtrBase<ID3D11Device>::operator&
PUBLIC	??C?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device@@@1@XZ ; ATL::CComPtrBase<ID3D11Device>::operator->
PUBLIC	??0?$CComPtr@UID3D11Device@@@ATL@@QAE@PAUID3D11Device@@@Z ; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>
PUBLIC	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11Device>::~CComPtr<ID3D11Device>
PUBLIC	??$QueryInterface@UID3D11Device@@@IUnknown@@QAGJPAPAUID3D11Device@@@Z ; IUnknown::QueryInterface<ID3D11Device>
PUBLIC	??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@PAUID3D11DeviceContext@@@Z ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>
PUBLIC	??1?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ID3D11DeviceContext>::~CComPtrBase<ID3D11DeviceContext>
PUBLIC	??I?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAEPAPAUID3D11DeviceContext@@XZ ; ATL::CComPtrBase<ID3D11DeviceContext>::operator&
PUBLIC	??C?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11DeviceContext@@@1@XZ ; ATL::CComPtrBase<ID3D11DeviceContext>::operator->
PUBLIC	??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@PAUID3D11DeviceContext@@@Z ; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>
PUBLIC	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11DeviceContext>::~CComPtr<ID3D11DeviceContext>
PUBLIC	??$QueryInterface@UID3D11DeviceContext@@@IUnknown@@QAGJPAPAUID3D11DeviceContext@@@Z ; IUnknown::QueryInterface<ID3D11DeviceContext>
PUBLIC	??0?$CComPtrBase@UID3D11Texture2D@@@ATL@@IAE@PAUID3D11Texture2D@@@Z ; ATL::CComPtrBase<ID3D11Texture2D>::CComPtrBase<ID3D11Texture2D>
PUBLIC	??1?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ID3D11Texture2D>::~CComPtrBase<ID3D11Texture2D>
PUBLIC	??B?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAUID3D11Texture2D@@XZ ; ATL::CComPtrBase<ID3D11Texture2D>::operator ID3D11Texture2D *
PUBLIC	??I?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAEPAPAUID3D11Texture2D@@XZ ; ATL::CComPtrBase<ID3D11Texture2D>::operator&
PUBLIC	??C?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Texture2D@@@1@XZ ; ATL::CComPtrBase<ID3D11Texture2D>::operator->
PUBLIC	??0?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@PAUID3D11Texture2D@@@Z ; ATL::CComPtr<ID3D11Texture2D>::CComPtr<ID3D11Texture2D>
PUBLIC	??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11Texture2D>::~CComPtr<ID3D11Texture2D>
PUBLIC	??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z ; IID_PPV_ARGS_Helper<ID3D11Texture2D>
PUBLIC	??0?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@IAE@PAUID3D11RenderTargetView@@@Z ; ATL::CComPtrBase<ID3D11RenderTargetView>::CComPtrBase<ID3D11RenderTargetView>
PUBLIC	??1?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ID3D11RenderTargetView>::~CComPtrBase<ID3D11RenderTargetView>
PUBLIC	??I?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAEPAPAUID3D11RenderTargetView@@XZ ; ATL::CComPtrBase<ID3D11RenderTargetView>::operator&
PUBLIC	??0?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@PAUID3D11RenderTargetView@@@Z ; ATL::CComPtr<ID3D11RenderTargetView>::CComPtr<ID3D11RenderTargetView>
PUBLIC	??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ ; ATL::CComPtr<ID3D11RenderTargetView>::~CComPtr<ID3D11RenderTargetView>
PUBLIC	??0?$allocator@PAUIUnknown@@@std@@QAE@XZ	; std::allocator<IUnknown *>::allocator<IUnknown *>
PUBLIC	?deallocate@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@I@Z ; std::allocator<IUnknown *>::deallocate
PUBLIC	?allocate@?$allocator@PAUIUnknown@@@std@@QAEPAPAUIUnknown@@I@Z ; std::allocator<IUnknown *>::allocate
PUBLIC	?max_size@?$allocator@PAUIUnknown@@@std@@QBEIXZ	; std::allocator<IUnknown *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAIABV?$allocator@PAUIUnknown@@@2@@Z ; std::allocator_traits<std::allocator<IUnknown *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<IUnknown *> >::_Wrap_alloc<std::allocator<IUnknown *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEPAPAUIUnknown@@I@Z ; std::_Wrap_alloc<std::allocator<IUnknown *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@I@Z ; std::_Wrap_alloc<std::allocator<IUnknown *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<IUnknown *> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IUnknown *> >::_Vector_val<std::_Simple_types<IUnknown *> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_second
PUBLIC	??0?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::vector<IUnknown *,std::allocator<IUnknown *> >
PUBLIC	??1?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::~vector<IUnknown *,std::allocator<IUnknown *> >
PUBLIC	?push_back@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::push_back
PUBLIC	?clear@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXXZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::clear
PUBLIC	?begin@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@2@XZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::begin
PUBLIC	?end@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@2@XZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::end
PUBLIC	?size@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::size
PUBLIC	?max_size@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::max_size
PUBLIC	?capacity@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::capacity
PUBLIC	?_Has_unused_capacity@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABE_NXZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Has_unused_capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@00U?$integral_constant@_N$00@2@@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@00@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@0@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABEII@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXQAPAUIUnknown@@II@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXXZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@CAXXZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABEXPAPAUIUnknown@@0@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Orphan_range
PUBLIC	?_Kfn@?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@SAABQ6GXXZABQ6GXXZ@Z ; std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0>::_Kfn
PUBLIC	??0?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@I@Z ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::allocate
PUBLIC	?max_size@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::max_size
PUBLIC	?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Color
PUBLIC	?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Isnil
PUBLIC	?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Left
PUBLIC	?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Parent
PUBLIC	?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Right
PUBLIC	?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myval
PUBLIC	?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Max
PUBLIC	?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Min
PUBLIC	??0?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@ABU?$less@P6GXXZ@1@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >
PUBLIC	?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Construct
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::~_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buyheadnode
PUBLIC	?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Freeheadnode
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Freenode0
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAU?$less@P6GXXZ@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getcomp
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABU?$less@P6GXXZ@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getcomp
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getal
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getal
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Get_data
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Get_data
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myhead
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myhead
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAIXZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Mysize
PUBLIC	??R?$less@P6GXXZ@std@@QBE_NABQ6GXXZ0@Z		; std::less<void (__stdcall*)(void)>::operator()
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Isnil
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Myval
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Min
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_second
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAEAAU?$less@P6GXXZ@2@XZ ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QBEABU?$less@P6GXXZ@2@XZ ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_second
PUBLIC	??0?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@ABU?$less@P6GXXZ@1@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >
PUBLIC	??1?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::~_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::end
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEIABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::clear
PUBLIC	?count@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEIABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::count
PUBLIC	?equal_range@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@2@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::equal_range
PUBLIC	?equal_range@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@2@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::equal_range
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Destroy_if_not_nil
PUBLIC	?_Erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Erase
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rrotate
PUBLIC	?_Tidy@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tidy
PUBLIC	?_Kfn@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEABQ6GXXZABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEABQ6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Key
PUBLIC	??0?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@QAE@XZ ; std::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >
PUBLIC	??1?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@QAE@XZ ; std::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >::~set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >
PUBLIC	?SKX_ImGui_RegisterResource@@YGXPAUIUnknown@@@Z	; SKX_ImGui_RegisterResource
PUBLIC	?SKX_ImGui_RegisterResetCallback@@YGXP6GXXZ@Z	; SKX_ImGui_RegisterResetCallback
PUBLIC	??$emplace@AAP6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@AAP6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::emplace<void (__stdcall*&)(void)>
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@P6GXXZPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator--
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAE@PAU?$_Tree_node@P6GXXZPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBEABQ6GXXZXZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator++
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator++
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator--
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator!=
PUBLIC	?SKX_ImGui_UnregisterResetCallback@@YGXP6GXXZ@Z	; SKX_ImGui_UnregisterResetCallback
PUBLIC	?SK_ImGui_ResetExternal@@YAXXZ			; SK_ImGui_ResetExternal
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAE@PAPAUIUnknown@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEABQAUIUnknown@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAE@PAPAUIUnknown@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEAAPAUIUnknown@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator++
PUBLIC	?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z ; ImGui_ImplDX11_Resize
PUBLIC	??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0@Z ; std::distance<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IUnknown *> > >
PUBLIC	??$emplace_back@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::emplace_back<IUnknown * const &>
PUBLIC	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
PUBLIC	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@PAUIUnknown@@@std@@PAPAUIUnknown@@@std@@YAXPAPAUIUnknown@@0AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<IUnknown *>,IUnknown * *>
PUBLIC	??$addressof@PAU?$_Tree_node@P6GXXZPAX@std@@@std@@YAPAPAU?$_Tree_node@P6GXXZPAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<void (__stdcall*)(void),void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>
PUBLIC	??$?0ABU?$less@P6GXXZ@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@P6GXXZ@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1><std::less<void (__stdcall*)(void)> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$swap@DX@std@@YAXAAD0@Z			; std::swap<char,void>
PUBLIC	??$addressof@P6GXXZ@std@@YAPAP6GXXZAAP6GXXZ@Z	; std::addressof<void (__stdcall*)(void)>
PUBLIC	??$destroy@P6GXXZ@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAP6GXXZ@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<void (__stdcall*)(void)>
PUBLIC	??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>
PUBLIC	??$forward@AAP6GXXZ@std@@YAAAP6GXXZAAP6GXXZ@Z	; std::forward<void (__stdcall*&)(void)>
PUBLIC	??$_Buynode@AAP6GXXZ@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode<void (__stdcall*&)(void)>
PUBLIC	??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_nohint<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>
PUBLIC	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
PUBLIC	??$forward@ABQAUIUnknown@@@std@@YAABQAUIUnknown@@ABQAU1@@Z ; std::forward<IUnknown * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXABQAUIUnknown@@@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Emplace_back_with_unused_capacity<IUnknown * const &>
PUBLIC	??$_Unfancy@PAUIUnknown@@@std@@YAPAPAUIUnknown@@PAPAU1@@Z ; std::_Unfancy<IUnknown *>
PUBLIC	??$construct@PAUIUnknown@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@ABQAU2@@Z ; std::_Wrap_alloc<std::allocator<IUnknown *> >::construct<IUnknown *,IUnknown * const &>
PUBLIC	??$destroy@PAUIUnknown@@@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@@Z ; std::_Wrap_alloc<std::allocator<IUnknown *> >::destroy<IUnknown *>
PUBLIC	??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@0@Z ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > ><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,void,0>
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > const >
PUBLIC	??$_Destroy_range1@V?$allocator@PAUIUnknown@@@std@@PAPAUIUnknown@@@std@@YAXPAPAUIUnknown@@0AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<IUnknown *>,IUnknown * *>
PUBLIC	??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>
PUBLIC	??$forward@ABU?$less@P6GXXZ@std@@@std@@YAABU?$less@P6GXXZ@0@ABU10@@Z ; std::forward<std::less<void (__stdcall*)(void)> const &>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1><>
PUBLIC	??$move@AAD@std@@YA$$QADAAD@Z			; std::move<char &>
PUBLIC	??$destroy@P6GXXZ@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAP6GXXZ@Z ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<void (__stdcall*)(void)>
PUBLIC	??$forward@AAPAU?$_Tree_node@P6GXXZPAX@std@@@std@@YAAAPAU?$_Tree_node@P6GXXZPAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<void (__stdcall*)(void),void *> * &>
PUBLIC	??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>
PUBLIC	??$_Uninitialized_move@PAPAUIUnknown@@PAPAU1@V?$allocator@PAUIUnknown@@@std@@@std@@YAPAPAUIUnknown@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@@Z ; std::_Uninitialized_move<IUnknown * *,IUnknown * *,std::allocator<IUnknown *> >
PUBLIC	??$construct@P6GXXZAAP6GXXZ@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAP6GXXZAAP6GXXZ@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>
PUBLIC	??$_Insert_at@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@_NPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ1@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_at<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>
PUBLIC	??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool,void,0>
PUBLIC	??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,bool,void,0>
PUBLIC	??$construct@PAUIUnknown@@ABQAU1@@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAXAAV?$allocator@PAUIUnknown@@@1@PAPAUIUnknown@@ABQAU3@@Z ; std::allocator_traits<std::allocator<IUnknown *> >::construct<IUnknown *,IUnknown * const &>
PUBLIC	??$destroy@PAUIUnknown@@@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAXAAV?$allocator@PAUIUnknown@@@1@PAPAUIUnknown@@@Z ; std::allocator_traits<std::allocator<IUnknown *> >::destroy<IUnknown *>
PUBLIC	??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &>
PUBLIC	??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>
PUBLIC	??$destroy@P6GXXZ@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAP6GXXZ@Z ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::destroy<void (__stdcall*)(void)>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>
PUBLIC	??$_Unchecked@PAPAUIUnknown@@@std@@YAPAPAUIUnknown@@PAPAU1@@Z ; std::_Unchecked<IUnknown * *>
PUBLIC	??$_Ptr_move_cat@PAUIUnknown@@PAU1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUIUnknown@@0@Z ; std::_Ptr_move_cat<IUnknown *,IUnknown *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAUIUnknown@@PAU1@V?$allocator@PAUIUnknown@@@std@@@std@@YAPAPAUIUnknown@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<IUnknown *,IUnknown *,std::allocator<IUnknown *> >
PUBLIC	??$_Rechecked@PAPAUIUnknown@@PAPAU1@@std@@YAAAPAPAUIUnknown@@AAPAPAU1@PAPAU1@@Z ; std::_Rechecked<IUnknown * *,IUnknown * *>
PUBLIC	??$construct@P6GXXZAAP6GXXZ@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAP6GXXZAAP6GXXZ@Z ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>
PUBLIC	??$_Buynode_if_nil@AAP6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@P6GXXZPAX@1@PAU21@AAP6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode_if_nil<void (__stdcall*&)(void)>
PUBLIC	??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
PUBLIC	??$construct@PAUIUnknown@@ABQAU1@@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@ABQAU2@@Z ; std::allocator<IUnknown *>::construct<IUnknown *,IUnknown * const &>
PUBLIC	??$destroy@PAUIUnknown@@@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@@Z ; std::allocator<IUnknown *>::destroy<IUnknown *>
PUBLIC	??$_Copy_memmove@PAPAUIUnknown@@PAPAU1@@std@@YAPAPAUIUnknown@@PAPAU1@00@Z ; std::_Copy_memmove<IUnknown * *,IUnknown * *>
PUBLIC	??$construct@P6GXXZAAP6GXXZ@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAP6GXXZAAP6GXXZ@Z ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	__GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
PUBLIC	?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A ; external_resources
PUBLIC	?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a
PUBLIC	__GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
PUBLIC	__GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__real@3b808081
PUBLIC	__real@3f800000
PUBLIC	__real@bf800000
PUBLIC	__xmm@00000000000000080000000100000000
PUBLIC	__xmm@00000001000000060000000500000001
PUBLIC	__xmm@00000003000000030000000300000015
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__memmove:PROC
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?NewFrame@ImGui@@YAXXZ:PROC			; ImGui::NewFrame
EXTRN	?Shutdown@ImGui@@YAXXZ:PROC			; ImGui::Shutdown
EXTRN	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z:PROC ; ImFontAtlas::GetTexDataAsRGBA32
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__free:PROC
EXTRN	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ:PROC ; SK_GetCurrentRenderBackend
EXTRN	?SK_COM_ValidateRelease@@YAPAUIUnknown@@PAPAU1@@Z:PROC ; SK_COM_ValidateRelease
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	_D3DCompile@44:PROC
EXTRN	?SK_ImGui_LoadFonts@@YAXXZ:PROC			; SK_ImGui_LoadFonts
EXTRN	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ:PROC		; SK_TLS_Bottom
EXTRN	?SK_ImGui_PollGamepad@@YAXXZ:PROC		; SK_ImGui_PollGamepad
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	__ltod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA:DWORD ; QueryPerformanceCounter_Original
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
EXTRN	__fltused:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?init@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4_NA
_BSS	SEGMENT
?init@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4_NA DB 01H DUP (?) ; `ImGui_ImplDX11_CreateFontsTexture'::`2'::init
_BSS	ENDS
;	COMDAT ?pixels@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4PAEA
_BSS	SEGMENT
?pixels@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4PAEA DD 01H DUP (?) ; `ImGui_ImplDX11_CreateFontsTexture'::`2'::pixels
_BSS	ENDS
;	COMDAT ?width@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4HA
_BSS	SEGMENT
?width@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4HA DD 01H DUP (?) ; `ImGui_ImplDX11_CreateFontsTexture'::`2'::width
_BSS	ENDS
;	COMDAT ?height@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4HA
_BSS	SEGMENT
?height@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4HA DD 01H DUP (?) ; `ImGui_ImplDX11_CreateFontsTexture'::`2'::height
_BSS	ENDS
_BSS	SEGMENT
?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A DB 0cH DUP (?) ; external_resources
	ALIGN	8

?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A DQ 01H DUP (?) ; reset_callbacks
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@00000003000000030000000300000015
CONST	SEGMENT
__xmm@00000003000000030000000300000015 DB 015H, 00H, 00H, 00H, 03H, 00H, 00H
	DB	00H, 03H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000001000000060000000500000001
CONST	SEGMENT
__xmm@00000001000000060000000500000001 DB 01H, 00H, 00H, 00H, 05H, 00H, 00H
	DB	00H, 06H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000080000000100000000
CONST	SEGMENT
__xmm@00000000000000080000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 08H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
CONST	SEGMENT
__GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da DD 0c0bfa96cH
	DW	0e089H
	DW	044fbH
	DB	08eH
	DB	0afH
	DB	026H
	DB	0f8H
	DB	079H
	DB	061H
	DB	090H
	DB	0daH
CONST	ENDS
;	COMDAT __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
CONST	SEGMENT
__GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140 DD 0db6f6ddbH
	DW	0ac77H
	DW	04e88H
	DB	082H
	DB	053H
	DB	081H
	DB	09dH
	DB	0f9H
	DB	0bbH
	DB	0f1H
	DB	040H
CONST	ENDS
;	COMDAT __GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a
CONST	SEGMENT
__GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a DD 0310d36a0H
	DW	0d2e7H
	DW	04c0aH
	DB	0aaH
	DB	04H
	DB	06aH
	DB	09dH
	DB	023H
	DB	0b8H
	DB	088H
	DB	06aH
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?first@?1??ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z@4_NA
_DATA	SEGMENT
?first@?1??ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z@4_NA DB 01H ; `ImGui_ImplDX11_Init'::`2'::first
_DATA	ENDS
;	COMDAT ?pixelShader@?BE@??ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ@4PBDB
_DATA	SEGMENT
?pixelShader@?BE@??ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ@4PBDB DD FLAT:$SG244087 ; `ImGui_ImplDX11_CreateDeviceObjects'::`20'::pixelShader
_DATA	ENDS
;	COMDAT ?vertexShader@?L@??ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ@4PBDB
_DATA	SEGMENT
?vertexShader@?L@??ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ@4PBDB DD FLAT:$SG244072 ; `ImGui_ImplDX11_CreateDeviceObjects'::`11'::vertexShader
_DATA	ENDS
;	COMDAT __GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
CONST	SEGMENT
__GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c DD 06f15aaf2H
	DW	0d208H
	DW	04e89H
	DB	09aH
	DB	0b4H
	DB	048H
	DB	095H
	DB	035H
	DB	0d3H
	DB	04fH
	DB	09cH
CONST	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_DATA	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 04H DUP (?)
	DD	FLAT:___ImageBase			; ATL::_AtlComModule
	DD	FLAT:___pobjMapEntryFirst+4
	DD	FLAT:___pobjMapEntryLast
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z$51 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z$51
__ehfuncinfo$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__F_AtlComModule@ATL@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__F_AtlComModule@ATL@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ$0
__unwindtable$?ImGui_ImplDX11_Shutdown@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_Shutdown@@YAXXZ$0
__unwindtable$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ$1
__unwindtable$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z$2
__unwindtable$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ$2
__ehfuncinfo$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ImGui_ImplDX11_Shutdown@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ImGui_ImplDX11_Shutdown@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$5
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?external_resources$initializer$@@3P6AXXZA DD FLAT:??__Eexternal_resources@@YAXXZ ; external_resources$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?reset_callbacks$initializer$@@3P6AXXZA DD FLAT:??__Ereset_callbacks@@YAXXZ ; reset_callbacks$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@P6GXXZAAP6GXXZ@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAP6GXXZAAP6GXXZ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@P6GXXZAAP6GXXZ@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAP6GXXZAAP6GXXZ@Z PROC ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@P6GXXZAAP6GXXZ@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAP6GXXZAAP6GXXZ@Z ENDP ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUIUnknown@@PAPAU1@@std@@YAPAPAUIUnknown@@PAPAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUIUnknown@@PAPAU1@@std@@YAPAPAUIUnknown@@PAPAU1@00@Z PROC ; std::_Copy_memmove<IUnknown * *,IUnknown * *>, COMDAT

; 2295 : 	{	// implement copy-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2302 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAPAUIUnknown@@PAPAU1@@std@@YAPAPAUIUnknown@@PAPAU1@00@Z ENDP ; std::_Copy_memmove<IUnknown * *,IUnknown * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAUIUnknown@@@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAUIUnknown@@@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@@Z PROC ; std::allocator<IUnknown *>::destroy<IUnknown *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAUIUnknown@@@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@@Z ENDP ; std::allocator<IUnknown *>::destroy<IUnknown *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAUIUnknown@@ABQAU1@@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@ABQAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUIUnknown@@ABQAU1@@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@ABQAU2@@Z PROC ; std::allocator<IUnknown *>::construct<IUnknown *,IUnknown * const &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PAUIUnknown@@ABQAU1@@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@ABQAU2@@Z ENDP ; std::allocator<IUnknown *>::construct<IUnknown *,IUnknown * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAP6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@P6GXXZPAX@1@PAU21@AAP6GXXZ@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buynode_if_nil@AAP6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@P6GXXZPAX@1@PAU21@AAP6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode_if_nil<void (__stdcall*&)(void)>, COMDAT
; _this$ = ecx

; 1637 : 		{	// node exists, just return it

	npad	2
	push	ebp
	mov	ebp, esp

; 1638 : 		return (_Node);

	mov	eax, DWORD PTR __Node$[ebp]

; 1639 : 		}

	pop	ebp
	ret	8
??$_Buynode_if_nil@AAP6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@P6GXXZPAX@1@PAU21@AAP6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode_if_nil<void (__stdcall*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@P6GXXZAAP6GXXZ@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAP6GXXZAAP6GXXZ@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@P6GXXZAAP6GXXZ@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAP6GXXZAAP6GXXZ@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@P6GXXZAAP6GXXZ@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAP6GXXZAAP6GXXZ@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAPAUIUnknown@@PAPAU1@@std@@YAAAPAPAUIUnknown@@AAPAPAU1@PAPAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAUIUnknown@@PAPAU1@@std@@YAAAPAPAUIUnknown@@AAPAPAU1@PAPAU1@@Z PROC ; std::_Rechecked<IUnknown * *,IUnknown * *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAPAUIUnknown@@PAPAU1@@std@@YAAAPAPAUIUnknown@@AAPAPAU1@PAPAU1@@Z ENDP ; std::_Rechecked<IUnknown * *,IUnknown * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAUIUnknown@@PAU1@V?$allocator@PAUIUnknown@@@std@@@std@@YAPAPAUIUnknown@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@PAUIUnknown@@PAU1@V?$allocator@PAUIUnknown@@@std@@@std@@YAPAPAUIUnknown@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<IUnknown *,IUnknown *,std::allocator<IUnknown *> >, COMDAT

; 157  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 159  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@PAUIUnknown@@PAU1@V?$allocator@PAUIUnknown@@@std@@@std@@YAPAPAUIUnknown@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<IUnknown *,IUnknown *,std::allocator<IUnknown *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@PAUIUnknown@@PAU1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUIUnknown@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@PAUIUnknown@@PAU1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUIUnknown@@0@Z PROC ; std::_Ptr_move_cat<IUnknown *,IUnknown *>, COMDAT

; 892  : 	{	// return pointer move optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 893  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 894  : 	}

	pop	ebp
	ret	0
??$_Ptr_move_cat@PAUIUnknown@@PAU1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUIUnknown@@0@Z ENDP ; std::_Ptr_move_cat<IUnknown *,IUnknown *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAPAUIUnknown@@@std@@YAPAPAUIUnknown@@PAPAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAUIUnknown@@@std@@YAPAPAUIUnknown@@PAPAU1@@Z PROC ; std::_Unchecked<IUnknown * *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAPAUIUnknown@@@std@@YAPAPAUIUnknown@@PAPAU1@@Z ENDP ; std::_Unchecked<IUnknown * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@P6GXXZ@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAP6GXXZ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@P6GXXZ@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAP6GXXZ@Z PROC ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::destroy<void (__stdcall*)(void)>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@P6GXXZ@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAP6GXXZ@Z ENDP ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::destroy<void (__stdcall*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z PROC ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z ENDP ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAUIUnknown@@@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAXAAV?$allocator@PAUIUnknown@@@1@PAPAUIUnknown@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAUIUnknown@@@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAXAAV?$allocator@PAUIUnknown@@@1@PAPAUIUnknown@@@Z PROC ; std::allocator_traits<std::allocator<IUnknown *> >::destroy<IUnknown *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAUIUnknown@@@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAXAAV?$allocator@PAUIUnknown@@@1@PAPAUIUnknown@@@Z ENDP ; std::allocator_traits<std::allocator<IUnknown *> >::destroy<IUnknown *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAUIUnknown@@ABQAU1@@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAXAAV?$allocator@PAUIUnknown@@@1@PAPAUIUnknown@@ABQAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAUIUnknown@@ABQAU1@@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAXAAV?$allocator@PAUIUnknown@@@1@PAPAUIUnknown@@ABQAU3@@Z PROC ; std::allocator_traits<std::allocator<IUnknown *> >::construct<IUnknown *,IUnknown * const &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PAUIUnknown@@ABQAU1@@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAXAAV?$allocator@PAUIUnknown@@@1@PAPAUIUnknown@@ABQAU3@@Z ENDP ; std::allocator_traits<std::allocator<IUnknown *> >::construct<IUnknown *,IUnknown * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Insert_at@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@_NPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@_NPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ1@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_at<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>, COMDAT
; _this$ = ecx

; 1843 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1844 : 		if (max_size() - 1 <= this->_Mysize())

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 214748363				; 0ccccccbH
	jb	SHORT $LN5@Insert_at

; 1845 : 			{	// tree would get too big, fail
; 1846 : 			_Destroy_if_not_nil(_Node);

	push	DWORD PTR __Node$[ebp]
	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Destroy_if_not_nil

; 1847 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN686@Insert_at:
$LN5@Insert_at:

; 1848 : 			}
; 1849 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1850 : 			_STD forward<_Valty>(_Val));
; 1851 : 
; 1852 : 		++this->_Mysize();
; 1853 : 		_Newnode->_Parent = _Wherenode;

	mov	ebx, DWORD PTR __Node$[ebp]
	inc	eax
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ebx+4], eax

; 1854 : 
; 1855 : 		if (_Wherenode == this->_Myhead())

	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	jne	SHORT $LN6@Insert_at

; 1856 : 			{	// first node in tree, just set head values
; 1857 : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], ebx

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1858 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1859 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1860 : 			}
; 1861 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[ebp], 0
	je	SHORT $LN8@Insert_at

; 1862 : 			{	// add to left of _Wherenode
; 1863 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax], ebx

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	ecx, DWORD PTR [edi]

; 1864 : 			if (_Wherenode == _Lmost())

	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert_at

; 1865 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 1866 : 			}
; 1867 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1868 : 			{	// add to right of _Wherenode
; 1869 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax+8], ebx

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	ecx, DWORD PTR [edi]

; 1870 : 			if (_Wherenode == _Rmost())

	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert_at

; 1871 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1872 : 			}
; 1873 : 
; 1874 : 		for (_Nodeptr _Pnode = _Newnode;
; 1875 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
$LL2@Insert_at:

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1876 : 			if (this->_Parent(_Pnode)
; 1877 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1878 : 				{	// fixup red-red in left subtree
; 1879 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1880 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1881 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN684@Insert_at

; 1882 : 					{	// parent has two red children, blacken both
; 1883 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1884 : 					this->_Color(_Wherenode) = this->_Black;
; 1885 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1886 : 						= this->_Red;
; 1887 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1888 : 					}
; 1889 : 				else
; 1890 : 					{	// parent has red and black children
; 1891 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1892 : 						{	// rotate right child to left
; 1893 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1894 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lrotate
$LN16@Insert_at:

; 1895 : 						}
; 1896 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1897 : 						this->_Black;	// propagate red up
; 1898 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1899 : 						this->_Red;
; 1900 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2128 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2129 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2131 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN330@Insert_at

; 2132 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN330@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2135 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN331@Insert_at

; 2136 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1901 : 					}
; 1902 : 				}
; 1903 : 			else

	jmp	$LN683@Insert_at
$LN331@Insert_at:

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2137 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN333@Insert_at

; 2138 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1901 : 					}
; 1902 : 				}
; 1903 : 			else

	jmp	$LN683@Insert_at
$LN333@Insert_at:

; 2140 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1901 : 					}
; 1902 : 				}
; 1903 : 			else

	jmp	SHORT $LN683@Insert_at
$LN12@Insert_at:

; 1904 : 				{	// fixup red-red in right subtree
; 1905 : 				_Wherenode =
; 1906 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1907 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN684@Insert_at:

; 1908 : 					{	// parent has two red children, blacken both
; 1909 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1910 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1911 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1912 : 						this->_Red;
; 1913 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1914 : 					}
; 1915 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1916 : 					{	// parent has red and black children
; 1917 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1918 : 						{	// rotate left child to right
; 1919 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1920 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rrotate
$LN19@Insert_at:

; 1921 : 						}
; 1922 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1923 : 						this->_Black;	// propagate red up
; 1924 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1925 : 						this->_Red;
; 1926 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2098 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2099 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2101 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN529@Insert_at

; 2102 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN529@Insert_at:

; 2103 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2105 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN530@Insert_at

; 2106 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2107 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN533@Insert_at
$LN530@Insert_at:

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2107 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN532@Insert_at

; 2108 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2109 : 		else

	jmp	SHORT $LN533@Insert_at
$LN532@Insert_at:

; 2110 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN533@Insert_at:

; 2111 : 
; 2112 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN683@Insert_at:

; 2113 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1872 : 			}
; 1873 : 
; 1874 : 		for (_Nodeptr _Pnode = _Newnode;
; 1875 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1927 : 					}
; 1928 : 				}
; 1929 : 
; 1930 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 1931 : 		return (iterator(_Newnode, _STD addressof(this->_Get_data())));
; 1932 : 		}

	pop	ebp
	ret	20					; 00000014H
$LN685@Insert_at:
??$_Insert_at@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@_NPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ1@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_at<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@P6GXXZAAP6GXXZ@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAP6GXXZAAP6GXXZ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@P6GXXZAAP6GXXZ@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAP6GXXZAAP6GXXZ@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@P6GXXZAAP6GXXZ@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAP6GXXZAAP6GXXZ@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<void (__stdcall*)(void),void (__stdcall*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUIUnknown@@PAPAU1@V?$allocator@PAUIUnknown@@@std@@@std@@YAPAPAUIUnknown@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUIUnknown@@PAPAU1@V?$allocator@PAUIUnknown@@@std@@@std@@YAPAPAUIUnknown@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@@Z PROC ; std::_Uninitialized_move<IUnknown * *,IUnknown * *,std::allocator<IUnknown *> >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 176  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAUIUnknown@@PAPAU1@V?$allocator@PAUIUnknown@@@std@@@std@@YAPAPAUIUnknown@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<IUnknown * *,IUnknown * *,std::allocator<IUnknown *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@P6GXXZPAX@std@@@std@@YAAAPAU?$_Tree_node@P6GXXZPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@P6GXXZPAX@std@@@std@@YAAAPAU?$_Tree_node@P6GXXZPAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<void (__stdcall*)(void),void *> * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAU?$_Tree_node@P6GXXZPAX@std@@@std@@YAAAPAU?$_Tree_node@P6GXXZPAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<void (__stdcall*)(void),void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@P6GXXZ@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAP6GXXZ@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@P6GXXZ@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAP6GXXZ@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<void (__stdcall*)(void)>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@P6GXXZ@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAP6GXXZ@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<void (__stdcall*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAD@std@@YA$$QADAAD@Z PROC			; std::move<char &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAD@std@@YA$$QADAAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 561  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABU?$less@P6GXXZ@std@@@std@@YAABU?$less@P6GXXZ@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$less@P6GXXZ@std@@@std@@YAABU?$less@P6GXXZ@0@ABU10@@Z PROC ; std::forward<std::less<void (__stdcall*)(void)> const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABU?$less@P6GXXZ@std@@@std@@YAABU?$less@P6GXXZ@0@ABU10@@Z ENDP ; std::forward<std::less<void (__stdcall*)(void)> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAPAU?$_Tree_node@P6GXXZPAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAPAU?$_Tree_node@P6GXXZPAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@1@PAPAU?$_Tree_node@P6GXXZPAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAUIUnknown@@@std@@PAPAUIUnknown@@@std@@YAXPAPAUIUnknown@@0AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@PAUIUnknown@@@std@@PAPAUIUnknown@@@std@@YAXPAPAUIUnknown@@0AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<IUnknown *>,IUnknown * *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@PAUIUnknown@@@std@@PAPAUIUnknown@@@std@@YAXPAPAUIUnknown@@0AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<IUnknown *>,IUnknown * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@0@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > ><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@0@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > ><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > &,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAUIUnknown@@@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAUIUnknown@@@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@@Z PROC ; std::_Wrap_alloc<std::allocator<IUnknown *> >::destroy<IUnknown *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAUIUnknown@@@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@@Z ENDP ; std::_Wrap_alloc<std::allocator<IUnknown *> >::destroy<IUnknown *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAUIUnknown@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@ABQAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUIUnknown@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@ABQAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<IUnknown *> >::construct<IUnknown *,IUnknown * const &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PAUIUnknown@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@ABQAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<IUnknown *> >::construct<IUnknown *,IUnknown * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@PAUIUnknown@@@std@@YAPAPAUIUnknown@@PAPAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAUIUnknown@@@std@@YAPAPAUIUnknown@@PAPAU1@@Z PROC ; std::_Unfancy<IUnknown *>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@PAUIUnknown@@@std@@YAPAPAUIUnknown@@PAPAU1@@Z ENDP ; std::_Unfancy<IUnknown *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXABQAUIUnknown@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXABQAUIUnknown@@@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Emplace_back_with_unused_capacity<IUnknown * const &>, COMDAT
; _this$ = ecx

; 898  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $LN71@Emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN71@Emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 902  : 		++this->_Mylast();

	add	DWORD PTR [ecx+4], 4

; 903  : 		}

	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXABQAUIUnknown@@@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Emplace_back_with_unused_capacity<IUnknown * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABQAUIUnknown@@@std@@YAABQAUIUnknown@@ABQAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAUIUnknown@@@std@@YAABQAUIUnknown@@ABQAU1@@Z PROC ; std::forward<IUnknown * const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABQAUIUnknown@@@std@@YAABQAUIUnknown@@ABQAU1@@Z ENDP ; std::forward<IUnknown * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0Uinput_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0Uinput_iterator_tag@0@@Z PROC ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >, COMDAT

; 1094 : 	{	// return distance between iterators; input

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 331  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN56@Distance1
$LL14@Distance1:

; 1097 : 		++_Off;

	inc	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN49@Distance1

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN46@Distance1

; 63   : 			_Ptr = _Mytree::_Min(

	mov	eax, edx

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN26@Distance1
	npad	4
$LL25@Distance1:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	eax, edx

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL25@Distance1

; 65   : 		else

	jmp	SHORT $LN26@Distance1
$LN46@Distance1:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN57@Distance1
$LL9@Distance1:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN57@Distance1

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[ebp], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL9@Distance1
$LN57@Distance1:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	eax, edx
$LN26@Distance1:
	mov	DWORD PTR __First$[ebp], eax
$LN49@Distance1:

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL14@Distance1
$LN56@Distance1:

; 1098 : 
; 1099 : 	return (_Off);

	mov	eax, esi
	pop	esi

; 1100 : 	}

	pop	ebp
	ret	0
??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ENDP ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
__Where$4 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_nohint<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>, COMDAT
; _this$ = ecx

; 1784 : 		{	// try to insert node, on left if _Leftish

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edx, DWORD PTR [ecx]

; 1784 : 		{	// try to insert node, on left if _Leftish

	push	ebx
	mov	ebx, DWORD PTR __Val$[ebp]
	push	esi

; 1785 : 		_TRY_BEGIN
; 1786 : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR [edx+4]
	push	edi

; 1787 : 		_Nodeptr _Wherenode = this->_Myhead();

	mov	edi, edx
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1788 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	dl, 1
	mov	DWORD PTR _this$[ebp], ecx

; 1789 : 
; 1790 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [eax+13], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	BYTE PTR __Addleft$2[ebp], dl
	jne	SHORT $LN3@Insert_noh
	mov	ecx, DWORD PTR [ebx]
	mov	dh, BYTE PTR __Leftish$[ebp]
$LL2@Insert_noh:

; 1791 : 			{	// look for leaf to insert before (_Addleft) or after
; 1792 : 			_Wherenode = _Trynode;

	mov	edi, eax

; 1793 : 			if (_Leftish)

	test	dh, dh
	je	SHORT $LN5@Insert_noh
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	cmp	DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1794 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

	setae	dl

; 1795 : 					this->_Key(_Trynode),
; 1796 : 					this->_Kfn(_Val));	// favor left end
; 1797 : 			else

	jmp	SHORT $LN276@Insert_noh
$LN5@Insert_noh:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	cmp	ecx, DWORD PTR [eax+16]
	setb	dl
$LN276@Insert_noh:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1798 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

	mov	BYTE PTR __Addleft$2[ebp], dl

; 1799 : 					this->_Kfn(_Val),
; 1800 : 					this->_Key(_Trynode));	// favor right end
; 1801 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	test	dl, dl
	je	SHORT $LN16@Insert_noh
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@Insert_noh
$LN16@Insert_noh:
	mov	eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1789 : 
; 1790 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Insert_noh
	mov	ecx, DWORD PTR _this$[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	esi, edi
	mov	DWORD PTR __Where$4[ebp], esi

; 1802 : 				: this->_Right(_Trynode);
; 1803 : 			}
; 1804 : 
; 1805 : #pragma warning(push)
; 1806 : #pragma warning(disable: 4127)	// conditional expression is constant
; 1807 : 		if (this->_Multi)
; 1808 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1809 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1810 : 		else
; 1811 : 			{	// insert only if unique
; 1812 : 			iterator _Where = iterator(_Wherenode, _STD addressof(this->_Get_data()));
; 1813 : 			if (!_Addleft)

	test	dl, dl
	je	SHORT $LN12@Insert_noh

; 331  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	cmp	edi, DWORD PTR [eax]

; 1814 : 				;	// need to test if insert after is okay
; 1815 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1816 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ebx
	push	edi
	push	1
$LN278@Insert_noh:
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$_Insert_at@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@1@_NPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ1@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_at<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1837 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 306  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator--
	mov	esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1821 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

	jae	SHORT $LN13@Insert_noh

; 1822 : 				this->_Key(_Where._Mynode()),
; 1823 : 				this->_Kfn(_Val)))
; 1824 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ebx
	push	edi
	push	DWORD PTR __Addleft$2[ebp]
	jmp	SHORT $LN278@Insert_noh
__catch$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z$0:

; 1825 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1826 : 			else
; 1827 : 				{	// duplicate, don't insert
; 1828 : 				_Destroy_if_not_nil(_Newnode);
; 1829 : 				return (_Pairib(_Where, false));
; 1830 : 				}
; 1831 : 			}
; 1832 : #pragma warning(pop)
; 1833 : 		_CATCH_ALL
; 1834 : 		_Destroy_if_not_nil(_Newnode);

	push	DWORD PTR __Newnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Destroy_if_not_nil

; 1835 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN279@Insert_noh:
$LN13@Insert_noh:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR __Newnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1837 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1837 : 		}

	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1837 : 		}

	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN275@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_nohint<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Buynode@AAP6GXXZ@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@AAP6GXXZ@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode<void (__stdcall*&)(void)>, COMDAT
; _this$ = ecx

; 895  : 		{	// allocate a node with defaults and set links and value

	npad	2
	push	ebp
	mov	ebp, esp

; 896  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode0

; 596  : 		return ((reference)_Pnode->_Myval);

	lea	edx, DWORD PTR [eax+16]

; 897  : 
; 898  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [eax+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN47@Buynode
	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
$LN47@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 911  : 		}

	pop	ebp
	ret	4
??$_Buynode@AAP6GXXZ@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode<void (__stdcall*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAP6GXXZ@std@@YAAAP6GXXZAAP6GXXZ@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAP6GXXZ@std@@YAAAP6GXXZAAP6GXXZ@Z PROC	; std::forward<void (__stdcall*&)(void)>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAP6GXXZ@std@@YAAAP6GXXZAAP6GXXZ@Z ENDP	; std::forward<void (__stdcall*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@P6GXXZPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::construct<std::_Tree_node<void (__stdcall*)(void),void *> *,std::_Tree_node<void (__stdcall*)(void),void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@P6GXXZ@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAP6GXXZ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@P6GXXZ@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAP6GXXZ@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<void (__stdcall*)(void)>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@P6GXXZ@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAP6GXXZ@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<void (__stdcall*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@P6GXXZ@std@@YAPAP6GXXZAAP6GXXZ@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@P6GXXZ@std@@YAPAP6GXXZAAP6GXXZ@Z PROC	; std::addressof<void (__stdcall*)(void)>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@P6GXXZ@std@@YAPAP6GXXZAAP6GXXZ@Z ENDP	; std::addressof<void (__stdcall*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$swap@DX@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@DX@std@@YAXAAD0@Z PROC				; std::swap<char,void>, COMDAT

; 65   : 	{	// exchange values stored at _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 66   : 	_Ty _Tmp = _STD move(_Left);
; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Left$[ebp]
	push	ebx
	mov	al, BYTE PTR [ecx]
	mov	bl, BYTE PTR [edx]
	mov	BYTE PTR [edx], al

; 68   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ecx], bl
	pop	ebx

; 69   : 	}

	pop	ebp
	ret	0
??$swap@DX@std@@YAXAAD0@Z ENDP				; std::swap<char,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABU?$less@P6GXXZ@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@P6GXXZ@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@P6GXXZ@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@P6GXXZ@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1><std::less<void (__stdcall*)(void)> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 561  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@P6GXXZ@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@P6GXXZ@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1><std::less<void (__stdcall*)(void)> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@P6GXXZPAX@std@@@std@@YAPAPAU?$_Tree_node@P6GXXZPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@P6GXXZPAX@std@@@std@@YAPAPAU?$_Tree_node@P6GXXZPAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<void (__stdcall*)(void),void *> *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAU?$_Tree_node@P6GXXZPAX@std@@@std@@YAPAPAU?$_Tree_node@P6GXXZPAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<void (__stdcall*)(void),void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAUIUnknown@@@std@@PAPAUIUnknown@@@std@@YAXPAPAUIUnknown@@0AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUIUnknown@@@std@@PAPAUIUnknown@@@std@@YAXPAPAUIUnknown@@0AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<IUnknown *>,IUnknown * *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAUIUnknown@@@std@@PAPAUIUnknown@@@std@@YAXPAPAUIUnknown@@0AAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<IUnknown *>,IUnknown * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z
_TEXT	SEGMENT
tv444 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>, COMDAT
; _this$ = ecx

; 2004 : 		{	// find leftmost node not less than _Keyval

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))

	mov	ebx, DWORD PTR __Keyval$[ebp]
	push	edi

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [ecx]

; 2006 : 		_Nodeptr _Lonode = this->_Myhead();	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead();	// end() if search fails

	mov	ecx, edi

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [edi+4]
	mov	DWORD PTR tv444[ebp], eax

; 2005 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax]

; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@Eqrange
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	mov	esi, DWORD PTR [ebx]
$LL2@Eqrange:
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

	jae	SHORT $LN6@Eqrange

; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 2012 : 			else

	jmp	SHORT $LN7@Eqrange
$LN6@Eqrange:

; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN8@Eqrange
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	cmp	esi, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

	cmovb	ecx, eax
$LN8@Eqrange:

; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;

	mov	edi, eax

; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]
$LN7@Eqrange:

; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Eqrange
	pop	esi
$LN3@Eqrange:

; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()

	cmp	BYTE PTR [ecx+13], 0
	mov	eax, ecx
	cmovne	eax, DWORD PTR tv444[ebp]
	mov	eax, DWORD PTR [eax]

; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN5@Eqrange
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	mov	edx, DWORD PTR [ebx]
$LL4@Eqrange:
	cmp	edx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

	jae	SHORT $LN9@Eqrange

; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;

	mov	ecx, eax

; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]

; 2029 : 				}
; 2030 : 			else

	jmp	SHORT $LN10@Eqrange
$LN9@Eqrange:

; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]
$LN10@Eqrange:

; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Eqrange
$LN5@Eqrange:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR [eax+4], ecx
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2036 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>, COMDAT
; _this$ = ecx

; 2040 : 		{	// find leftmost node not less than _Keyval

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2041 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	call	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Ans$[ebp]
	mov	DWORD PTR [eax], ecx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR __Ans$[ebp+4]
	mov	DWORD PTR [eax+4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2045 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$emplace_back@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z
_TEXT	SEGMENT
__Newcapacity$1$ = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::emplace_back<IUnknown * const &>, COMDAT
; _this$ = ecx

; 908  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi

; 1731 : 		return (this->_Myend() != this->_Mylast());

	mov	ecx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [esi+4]
	cmp	ecx, edi

; 909  : 		if (_Has_unused_capacity())

	je	SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN70@emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi], eax
$LN70@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 902  : 		++this->_Mylast();

	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi

; 929  : 			_Emplaced = true;
; 930  : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 931  : 			_CATCH_ALL
; 932  : 			if (_Emplaced)
; 933  : 				{
; 934  : 				this->_Getal().destroy(_Unfancy(_Newvec + _Oldsize));
; 935  : 				}
; 936  : 
; 937  : 			this->_Getal().deallocate(_Newvec, _Newcapacity);
; 938  : 			_RERAISE;
; 939  : 			_CATCH_END
; 940  : 
; 941  : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 942  : 			}
; 943  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@emplace_ba:

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi]
	sub	edi, eax
	sar	edi, 2

; 910  : 			{
; 911  : 			_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 912  : 			}
; 913  : 		else
; 914  : 			{	// reallocate
; 915  : 			const size_type _Oldsize = size();
; 916  : 
; 917  : 			if (_Oldsize == max_size())

	cmp	edi, 1073741823				; 3fffffffH
	je	$LN365@emplace_ba

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	ecx, eax

; 920  : 				}
; 921  : 
; 922  : 			const size_type _Newsize = _Oldsize + 1;

	lea	edx, DWORD PTR [edi+1]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	ecx, 2

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 1073741823				; 3fffffffH
	push	ebx
	mov	ebx, ecx
	shr	ebx, 1
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN146@emplace_ba

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, edx
	mov	DWORD PTR __Newcapacity$1$[ebp], edx
	jmp	SHORT $LN147@emplace_ba
$LN146@emplace_ba:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, edx
	cmovb	eax, edx
	mov	DWORD PTR __Newcapacity$1$[ebp], eax
$LN147@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	mov	ecx, esi
	call	?allocate@?$allocator@PAUIUnknown@@@std@@QAEPAPAUIUnknown@@I@Z ; std::allocator<IUnknown *>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 925  : 			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	ebx, eax

; 926  : 
; 927  : 			_TRY_BEGIN
; 928  : 			this->_Getal().construct(_Unfancy(_Newvec + _Oldsize), _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR [ebx+edi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN219@emplace_ba
	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN219@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ecx, DWORD PTR [esi]

; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR [esi+4]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN271@emplace_ba

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN271@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [esi], ebx
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 929  : 			_Emplaced = true;
; 930  : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 931  : 			_CATCH_ALL
; 932  : 			if (_Emplaced)
; 933  : 				{
; 934  : 				this->_Getal().destroy(_Unfancy(_Newvec + _Oldsize));
; 935  : 				}
; 936  : 
; 937  : 			this->_Getal().deallocate(_Newvec, _Newcapacity);
; 938  : 			_RERAISE;
; 939  : 			_CATCH_END
; 940  : 
; 941  : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 942  : 			}
; 943  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN365@emplace_ba:

; 918  : 				{
; 919  : 				_Xlength();

	call	?_Xlength@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@CAXXZ ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Xlength
$LN367@emplace_ba:
$LN364@emplace_ba:
	int	3
??$emplace_back@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::emplace_back<IUnknown * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<IUnknown *> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<IUnknown *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0@Z PROC ; std::distance<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >, COMDAT

; 1112 : 	{	// return distance between iterators

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
	add	esp, 12					; 0000000cH

; 1114 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0@Z ENDP ; std::distance<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_auto_bool$ = -32					; size = 8
_auto_bool$1$ = -24					; size = 4
_pDevCtx$ = -20						; size = 4
_pDev$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_This$ = 8						; size = 4
_BufferCount$ = 12					; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_NewFormat$ = 24					; size = 4
_SwapChainFlags$ = 28					; size = 4
?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z PROC ; ImGui_ImplDX11_Resize

; 868  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 869  :   UNREFERENCED_PARAMETER (BufferCount);
; 870  :   UNREFERENCED_PARAMETER (NewFormat);
; 871  :   UNREFERENCED_PARAMETER (SwapChainFlags);
; 872  :   UNREFERENCED_PARAMETER (Width);
; 873  :   UNREFERENCED_PARAMETER (Height);
; 874  :   UNREFERENCED_PARAMETER (This);
; 875  : 
; 876  : 
; 877  :   SK_RenderBackend& rb =

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	ebx, eax

; 878  :     SK_GetCurrentRenderBackend ();
; 879  : 
; 880  :   if (! rb.device)

	cmp	DWORD PTR [ebx+36], 0
	je	$LN42@ImGui_Impl

; 883  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	push	esi
	push	edi
	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 139  :     bOrig_ = *pBool;

	mov	esi, DWORD PTR [eax+48]
	mov	DWORD PTR _auto_bool$1$[ebp], esi
	mov	DWORD PTR _auto_bool$[ebp+4], esi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 883  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	lea	edi, DWORD PTR [eax+48]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 138  :     pBool_ =  pBool;

	mov	DWORD PTR _auto_bool$[ebp], edi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 883  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 884  : 
; 885  :   // Do not dump ImGui font textures
; 886  :   SK_TLS_Bottom ()->imgui.drawing = true;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	mov	DWORD PTR [eax+48], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	xor	eax, eax
	mov	DWORD PTR _pDev$[ebp], eax
	xor	ecx, ecx
	mov	DWORD PTR _pDevCtx$[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 892  :   CComPtr <ID3D11DeviceContext> pDevCtx = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 893  : 
; 894  :   if (rb.d3d11.immediate_ctx != nullptr)

	cmp	DWORD PTR [ebx+68], ecx
	je	SHORT $LN4@ImGui_Impl

; 895  :   {
; 896  :     HRESULT hr0 = rb.device->QueryInterface              <ID3D11Device>        (&pDev);

	mov	eax, DWORD PTR [ebx+36]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pDev$[ebp]
	push	edx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 897  :     HRESULT hr1 = rb.d3d11.immediate_ctx->QueryInterface <ID3D11DeviceContext> (&pDevCtx);

	mov	ecx, DWORD PTR [ebx+68]
	mov	esi, eax
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	eax, DWORD PTR _pDevCtx$[ebp]
	push	eax
	push	OFFSET __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 899  :     if (SUCCEEDED (hr0) && SUCCEEDED (hr1))

	test	esi, esi
	js	SHORT $LN44@ImGui_Impl
	test	eax, eax
	js	SHORT $LN44@ImGui_Impl

; 900  :     {
; 901  :       ImGui_ImplDX11_InvalidateDeviceObjects ();

	call	?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ ; ImGui_ImplDX11_InvalidateDeviceObjects
$LN44@ImGui_Impl:
	mov	esi, DWORD PTR _auto_bool$1$[ebp]
	mov	ecx, DWORD PTR _pDevCtx$[ebp]
	mov	eax, DWORD PTR _pDev$[ebp]
$LN4@ImGui_Impl:

; 904  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN33@ImGui_Impl

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _pDev$[ebp]
$LN33@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 904  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN39@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN39@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	DWORD PTR [edi], esi
	pop	edi
	pop	esi
$LN42@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 904  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z$0:
	lea	ecx, DWORD PTR _auto_bool$[ebp]
	jmp	??1SK_ScopedBool@@QAE@XZ		; SK_ScopedBool::~SK_ScopedBool
__unwindfunclet$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z$1:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z$2:
	lea	ecx, DWORD PTR _pDevCtx$[ebp]
	jmp	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
__ehhandler$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_ImplDX11_Resize@@YAXPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z ENDP ; ImGui_ImplDX11_Resize
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator++, COMDAT
; _this$ = ecx

; 107  : 		++_Ptr;

	add	DWORD PTR [ecx], 4

; 332  : 		++*(_Mybase *)this;
; 333  : 		return (*this);

	mov	eax, ecx

; 334  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEAAPAUIUnknown@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEAAPAUIUnknown@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 323  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEAAPAUIUnknown@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAE@PAPAUIUnknown@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAE@PAPAUIUnknown@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 305  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAE@PAPAUIUnknown@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator!=, COMDAT
; _this$ = ecx

; 210  : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 211  : 		return (!(*this == _Right));
; 212  : 		}

	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator==, COMDAT
; _this$ = ecx

; 204  : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 205  : 		_Compat(_Right);
; 206  : 		return (_Ptr == _Right._Ptr);
; 207  : 		}

	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator++, COMDAT
; _this$ = ecx

; 91   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 92   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 93   : 		if (_Mycont == 0
; 94   : 			|| _Ptr == nullptr_t{}
; 95   : 			|| _Mycont->_Mylast <= _Ptr)
; 96   : 			{	// report error
; 97   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 98   : 			}
; 99   : 
; 100  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 101  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 102  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 103  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 104  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 105  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 106  : 
; 107  : 		++_Ptr;

	add	DWORD PTR [ecx], 4

; 108  : 		return (*this);

	mov	eax, ecx

; 109  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEABQAUIUnknown@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEABQAUIUnknown@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator*, COMDAT
; _this$ = ecx

; 62   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 63   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 64   : 		if (_Mycont == 0
; 65   : 			|| _Ptr == _Tptr()
; 66   : 			|| _Ptr < _Mycont->_Myfirst
; 67   : 			|| _Mycont->_Mylast <= _Ptr)
; 68   : 			{	// report error
; 69   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 70   : 			}
; 71   : 
; 72   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 73   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 74   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 75   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 77   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 78   : 
; 79   : 		_Analysis_assume_(_Ptr != _Tptr());
; 80   : 
; 81   : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 82   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QBEABQAUIUnknown@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAE@PAPAUIUnknown@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAE@PAPAUIUnknown@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 44   : 		this->_Adopt(_Pvector);
; 45   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@std@@QAE@PAPAUIUnknown@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IUnknown *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
?SK_ImGui_ResetExternal@@YAXXZ PROC			; SK_ImGui_ResetExternal

; 690  : {

	npad	2
	push	ebx
	mov	ebx, DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+4
	xor	ecx, ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1645 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));

	mov	esi, DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A
	sub	ebx, esi
	add	ebx, 3
	shr	ebx, 2
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+4
	cmova	ebx, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 691  :   for ( auto it : external_resources )

	test	ebx, ebx
	je	SHORT $LN3@SK_ImGui_R
	npad	6
$LL4@SK_ImGui_R:
	mov	eax, DWORD PTR [esi]

; 692  :   {
; 693  :     it->Release ();

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 107  : 		++_Ptr;

	inc	edi
	lea	esi, DWORD PTR [esi+4]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 691  :   for ( auto it : external_resources )

	cmp	edi, ebx
	jne	SHORT $LL4@SK_ImGui_R
	mov	esi, DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A
$LN3@SK_ImGui_R:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	edi, DWORD PTR ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+4, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	esi, DWORD PTR [edi]

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 698  :   for ( auto reset_fn : reset_callbacks )

	je	SHORT $LN6@SK_ImGui_R
$LL196@SK_ImGui_R:

; 699  :   {
; 700  :     reset_fn ();

	mov	eax, DWORD PTR [esi+16]
	call	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN237@SK_ImGui_R

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN233@SK_ImGui_R

; 63   : 			_Ptr = _Mytree::_Min(

	mov	esi, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN237@SK_ImGui_R
$LL207@SK_ImGui_R:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	esi, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL207@SK_ImGui_R

; 65   : 		else

	jmp	SHORT $LN237@SK_ImGui_R
$LN233@SK_ImGui_R:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN246@SK_ImGui_R
	npad	5
$LL191@SK_ImGui_R:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN246@SK_ImGui_R

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL191@SK_ImGui_R
$LN246@SK_ImGui_R:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	esi, eax
$LN237@SK_ImGui_R:

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 698  :   for ( auto reset_fn : reset_callbacks )

	jne	SHORT $LL196@SK_ImGui_R
$LN6@SK_ImGui_R:
	pop	edi
	pop	esi
	pop	ebx

; 701  :   }
; 702  : }

	ret	0
?SK_ImGui_ResetExternal@@YAXXZ ENDP			; SK_ImGui_ResetExternal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
__Ans$1 = -8						; size = 8
__Ans$2 = -8						; size = 8
$T3 = 8							; size = 4
$T4 = 8							; size = 1
_pCallback$ = 8						; size = 4
?SKX_ImGui_UnregisterResetCallback@@YGXP6GXXZ@Z PROC	; SKX_ImGui_UnregisterResetCallback

; 683  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1603 : 		return (_Eqrange(_Keyval));

	lea	eax, DWORD PTR _pCallback$[ebp]
	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	eax
	lea	eax, DWORD PTR __Ans$2[ebp]
	push	eax
	call	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T4[ebp]
	push	DWORD PTR __Ans$2[ebp+4]
	push	DWORD PTR __Ans$2[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 684  :   if (reset_callbacks.count (pCallback))

	test	eax, eax
	je	SHORT $LN2@SKX_ImGui_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2041 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	lea	eax, DWORD PTR _pCallback$[ebp]
	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	eax
	lea	eax, DWORD PTR __Ans$1[ebp]
	push	eax
	call	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>

; 1470 : 		erase(_Where.first, _Where.second);

	push	DWORD PTR __Ans$1[ebp+4]
	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	DWORD PTR __Ans$1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
$LN2@SKX_ImGui_:
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 686  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SKX_ImGui_UnregisterResetCallback@@YGXP6GXXZ@Z ENDP	; SKX_ImGui_UnregisterResetCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator!=, COMDAT
; _this$ = ecx

; 335  : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 336  : 		return (!(*this == _Right));
; 337  : 		}

	pop	ebp
	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator==, COMDAT
; _this$ = ecx

; 320  : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 321  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 322  : 		if (this->_Getcont() != _Right._Getcont())
; 323  : 			{	// report error
; 324  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 325  : 			}
; 326  : 
; 327  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 328  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 329  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 330  : 
; 331  : 		return (this->_Ptr == _Right._Ptr);
; 332  : 		}

	pop	ebp
	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

	npad	2
	push	esi
	mov	esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == nullptr_t{})
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			}
; 290  : 
; 291  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 292  : 		--static_cast<_Mybase&>(*this);
; 293  : 		if (_Ptrsav == this->_Ptr)
; 294  : 			{	// report error
; 295  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 296  : 			}
; 297  : 
; 298  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 299  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 300  : 
; 301  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 302  : 		--static_cast<_Mybase&>(*this);
; 303  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 304  : 
; 305  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 306  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator--

; 307  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 308  : 
; 309  : 		return (*this);

	mov	eax, esi
	pop	esi

; 310  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

	npad	2
	push	ebp
	mov	ebp, esp

; 277  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi], edx

; 271  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator++

; 278  : 		++*this;
; 279  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 280  : 		}

	pop	ebp
	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator++, COMDAT
; _this$ = ecx

; 257  : 		{	// preincrement

	npad	2
	push	esi
	mov	esi, ecx

; 258  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 259  : 		if (this->_Getcont() == 0
; 260  : 			|| this->_Ptr == nullptr_t{}
; 261  : 			|| _Mytree::_Isnil(this->_Ptr))
; 262  : 			{	// report error
; 263  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

	mov	eax, esi
	pop	esi

; 273  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBEABQ6GXXZXZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBEABQ6GXXZXZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator*, COMDAT
; _this$ = ecx

; 596  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 243  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 244  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 245  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 246  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 247  : 
; 248  : 		return (_Mytree::_Myval(this->_Ptr));
; 249  : 		}

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QBEABQ6GXXZXZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAE@PAU?$_Tree_node@P6GXXZPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAE@PAU?$_Tree_node@P6GXXZPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@QAE@PAU?$_Tree_node@P6GXXZPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@P6GXXZPAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@P6GXXZPAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@P6GXXZPAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@P6GXXZPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@P6GXXZPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@P6GXXZPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$emplace@AAP6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@AAP6GXXZ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Val_0>$ = 12						; size = 4
??$emplace@AAP6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@AAP6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::emplace<void (__stdcall*&)(void)>, COMDAT
; _this$ = ecx

; 1083 : 		{	// try to insert value_type(_Val...), favoring right side

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[ebp]
	mov	edi, ecx
	call	??$_Buynode@AAP6GXXZ@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode<void (__stdcall*&)(void)>

; 1085 : 		return (_Insert_nohint(false,

	push	eax

; 596  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_nohint(false,

	mov	ecx, edi
	push	eax
	push	0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_nohint<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi

; 1086 : 			this->_Myval(_Newnode), _Newnode));
; 1087 : 		}

	pop	ebp
	ret	8
??$emplace@AAP6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@AAP6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::emplace<void (__stdcall*&)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_pCallback$ = 8						; size = 4
?SKX_ImGui_RegisterResetCallback@@YGXP6GXXZ@Z PROC	; SKX_ImGui_RegisterResetCallback

; 675  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _pCallback$[ebp]
	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	eax
	call	??$_Buynode@AAP6GXXZ@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@1@AAP6GXXZ@Z ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode<void (__stdcall*&)(void)>

; 1085 : 		return (_Insert_nohint(false,

	push	eax

; 596  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_nohint(false,

	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	eax
	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$_Insert_nohint@AAP6GXXZPAU?$_Tree_node@P6GXXZPAX@std@@@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@_N@1@_NAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Insert_nohint<void (__stdcall*&)(void),std::_Tree_node<void (__stdcall*)(void),void *> *>
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 677  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SKX_ImGui_RegisterResetCallback@@YGXP6GXXZ@Z ENDP	; SKX_ImGui_RegisterResetCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_pRes$ = 8						; size = 4
?SKX_ImGui_RegisterResource@@YGXPAUIUnknown@@@Z PROC	; SKX_ImGui_RegisterResource

; 666  : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	lea	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, OFFSET ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A ; external_resources
	push	eax
	call	??$emplace_back@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::emplace_back<IUnknown * const &>
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 668  : }

	pop	ebp
	ret	4
?SKX_ImGui_RegisterResource@@YGXPAUIUnknown@@@Z ENDP	; SKX_ImGui_RegisterResource
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??__Freset_callbacks@@YAXXZ
text$yd	SEGMENT
$T1 = -4						; size = 4
??__Freset_callbacks@@YAXXZ PROC			; `dynamic atexit destructor for 'reset_callbacks'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A

; 2184 : 		erase(begin(), end());

	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	esi
	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase

; 719  : 		_Freeheadnode(_Myhead());

	mov	esi, DWORD PTR ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A

; 854  : 		_Getal().destroy(

	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	esi
	call	??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [esi+4]

; 856  : 		_Getal().destroy(

	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	eax
	call	??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [esi+8]

; 858  : 		_Getal().destroy(

	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	push	eax
	call	??$destroy@PAU?$_Tree_node@P6GXXZPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@P6GXXZPAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::destroy<std::_Tree_node<void (__stdcall*)(void),void *> *>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	esi
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??__Freset_callbacks@@YAXXZ ENDP			; `dynamic atexit destructor for 'reset_callbacks''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
;	COMDAT ??__Ereset_callbacks@@YAXXZ
text$di	SEGMENT
??__Ereset_callbacks@@YAXXZ PROC			; `dynamic initializer for 'reset_callbacks'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks
	call	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 714  : 		_Myhead() = _Buyheadnode();

	mov	ecx, OFFSET ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A ; reset_callbacks

; 560  : 		: _Myhead(),

	mov	DWORD PTR ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A, 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A+4, 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buyheadnode
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 660  : std::set    <SK_ImGui_ResetCallback_pfn> reset_callbacks;

	push	OFFSET ??__Freset_callbacks@@YAXXZ	; `dynamic atexit destructor for 'reset_callbacks''
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 714  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR ?reset_callbacks@@3V?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@A, eax
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 660  : std::set    <SK_ImGui_ResetCallback_pfn> reset_callbacks;

	call	_atexit
	pop	ecx
	ret	0
??__Ereset_callbacks@@YAXXZ ENDP			; `dynamic initializer for 'reset_callbacks''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??1?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@QAE@XZ PROC ; std::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >::~set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2184 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@QAE@XZ ENDP ; std::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >::~set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
;	COMDAT ??0?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@QAE@XZ PROC ; std::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >, COMDAT
; _this$ = ecx

; 70   : 		{	// construct empty set from defaults

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 71   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$set@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@@std@@QAE@XZ ENDP ; std::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >::set<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEABQ6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEABQ6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Key, COMDAT
; _this$ = ecx

; 2193 : 		{	// return reference to key in node

	npad	2
	push	ebp
	mov	ebp, esp

; 596  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 2194 : 		return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
; 2195 : 		}

	pop	ebp
	ret	4
?_Key@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEABQ6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEABQ6GXXZABQ6GXXZ@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEABQ6GXXZABQ6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2188 : 		{	// get key from value

	npad	2
	push	ebp
	mov	ebp, esp

; 2189 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 2190 : 		}

	pop	ebp
	ret	4
?_Kfn@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEABQ6GXXZABQ6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2183 : 		{	// free all storage

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2184 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase

; 2185 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote left node to root of subtree

	npad	2
	push	ebp
	mov	ebp, esp

; 2128 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2129 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2132 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2136 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2144 : 		}

	pop	ebp
	ret	4
$LN3@Rrotate:

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2138 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2144 : 		}

	pop	ebp
	ret	4
$LN5@Rrotate:

; 2139 : 		else
; 2140 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2144 : 		}

	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Root, COMDAT
; _this$ = ecx

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2123 : 		return (this->_Parent(this->_Myhead()));
; 2124 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2118 : 		return (this->_Right(this->_Myhead()));
; 2119 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2097 : 		{	// promote right node to root of subtree

	npad	2
	push	ebp
	mov	ebp, esp

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi

; 2098 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2099 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2100 : 
; 2101 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2102 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2103 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2104 : 
; 2105 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2106 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2111 : 
; 2112 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2113 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2114 : 		}

	pop	ebp
	ret	4
$LN3@Lrotate:

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2107 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2108 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2111 : 
; 2112 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2113 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2114 : 		}

	pop	ebp
	ret	4
$LN5@Lrotate:

; 2109 : 		else
; 2110 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2111 : 
; 2112 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2113 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2114 : 		}

	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2093 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2094 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Erase, COMDAT
; _this$ = ecx

; 2048 : 		{	// free entire subtree, recursively

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 2049 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	edi, DWORD PTR __Rootnode$[ebp]
	mov	ebx, ecx
	mov	esi, edi

; 2050 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN3@Erase
$LL4@Erase:

; 2051 : 			{	// free subtrees, then node
; 2052 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Erase

; 2053 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2050 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL4@Erase
$LN3@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 2054 : 			this->_Getal().destroy(
; 2055 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2056 : 
; 2057 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2058 : 			}
; 2059 : 		}

	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1648 : 		{	// node exists, destroy it

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR __Newnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1653 : 		}

	pop	ebp
	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@2@ABQ6GXXZ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@2@ABQ6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::equal_range, COMDAT
; _this$ = ecx

; 1602 : 		{	// find range equivalent to _Keyval in nonmutable tree

	npad	2
	push	ebp
	mov	ebp, esp

; 1603 : 		return (_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1604 : 		}

	pop	ebp
	ret	8
?equal_range@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@2@ABQ6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@2@ABQ6GXXZ@Z
_TEXT	SEGMENT
__Ans$1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@2@ABQ6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::equal_range, COMDAT
; _this$ = ecx

; 1597 : 		{	// find range equivalent to _Keyval in mutable tree

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2041 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$1[ebp]
	push	eax
	call	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Ans$1[ebp]
	mov	DWORD PTR [eax], ecx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR __Ans$1[ebp+4]
	mov	DWORD PTR [eax+4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1599 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?equal_range@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@2@ABQ6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?count@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEIABQ6GXXZ@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
$T1 = 8							; size = 1
__Keyval$ = 8						; size = 4
?count@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEIABQ6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::count, COMDAT
; _this$ = ecx

; 1530 : 		{	// count all elements that match _Keyval

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1603 : 		return (_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	call	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Ans$[ebp+4]
	push	DWORD PTR __Ans$[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?count@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEIABQ6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::clear, COMDAT
; _this$ = ecx

; 1475 : 		{	// erase all

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1476 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1477 : 		this->_Orphan_ptr(nullptr_t{});
; 1478 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1479 : 
; 1480 : 		_Erase(_Root());

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+4]

; 2049 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	esi, ebx

; 2050 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN23@clear
	npad	4
$LL24@clear:

; 2051 : 			{	// free subtrees, then node
; 2052 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Erase

; 2053 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2050 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL24@clear
$LN23@clear:

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1485 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1481 : 		_Root() = this->_Myhead();
; 1482 : 		_Lmost() = this->_Myhead();
; 1483 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1484 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1485 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEIABQ6GXXZ@Z
_TEXT	SEGMENT
__Ans$1 = -12						; size = 8
_this$1$ = -4						; size = 4
$T2 = 8							; size = 1
$T3 = 8							; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEIABQ6GXXZ@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase and count all that match _Keyval

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 2041 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]

; 1467 : 		{	// erase and count all that match _Keyval

	mov	eax, ecx

; 2041 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	lea	ecx, DWORD PTR __Ans$1[ebp]
	push	ecx
	mov	ecx, eax

; 1467 : 		{	// erase and count all that match _Keyval

	mov	DWORD PTR _this$1$[ebp], eax

; 2041 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	call	??$_Eqrange@P6GXXZ@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@V12@@1@ABQ6GXXZ@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Eqrange<void (__stdcall*)(void)>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T2[ebp]
	push	DWORD PTR __Ans$1[ebp+4]
	push	DWORD PTR __Ans$1[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1470 : 		erase(_Where.first, _Where.second);

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1469 : 		size_type _Num = _STD distance(_Where.first, _Where.second);

	mov	ebx, eax

; 1470 : 		erase(_Where.first, _Where.second);

	lea	eax, DWORD PTR $T3[ebp]
	push	DWORD PTR __Ans$1[ebp+4]
	push	DWORD PTR __Ans$1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase

; 1471 : 		return (_Num);

	mov	eax, ebx
	pop	ebx

; 1472 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEIABQ6GXXZ@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase, COMDAT
; _this$ = ecx

; 1452 : 		{	// erase [_First, _Last)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 331  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]

; 1453 : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[ebp]
	push	esi
	push	edi
	mov	edi, ecx

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	esi, DWORD PTR [edi]

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]

; 1453 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN180@erase

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	edx, esi

; 1453 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN180@erase

; 1454 : 			{	// erase all
; 1455 : 			clear();

	call	?clear@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::clear

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1463 : 			}
; 1464 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN180@erase:

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1456 : 			return (begin());
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// partial erase, one at a time
; 1460 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 277  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN136@erase

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN182@erase

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN192@erase
	npad	3
$LL147@erase:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL147@erase

; 65   : 		else

	jmp	SHORT $LN192@erase
$LN182@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN192@erase
$LL131@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN192@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[ebp], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL131@erase
$LN192@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[ebp], edx
$LN136@erase:

; 1461 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T1[ebp]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase

; 331  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]

; 1456 : 			return (begin());
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// partial erase, one at a time
; 1460 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax

; 1462 : 			return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));

	mov	eax, ecx

; 1463 : 			}
; 1464 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@@Z
_TEXT	SEGMENT
tv1196 = -16						; size = 4
tv1197 = -12						; size = 4
tv1195 = -8						; size = 4
tv1191 = -8						; size = 4
tv1171 = -8						; size = 4
__Erasednode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase, COMDAT
; _this$ = ecx

; 1264 : 		{	// erase element at _Where

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	esi

; 1264 : 		{	// erase element at _Where

	mov	ebx, ecx

; 123  : 		return (_Ptr);

	mov	DWORD PTR __Erasednode$1$[ebp], eax
	push	edi

; 271  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,std::_Iterator_base0>::operator++

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Erasednode$1$[ebp]
	mov	esi, DWORD PTR [ecx]

; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 		if (_Where._Getcont() != _STD addressof(this->_Get_data())
; 1267 : 			|| this->_Isnil(_Where._Mynode()))
; 1268 : 			{
; 1269 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1270 : 			}
; 1271 : 
; 1272 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1273 : 		++_Where;	// save successor iterator for return
; 1274 : 		_Orphan_ptr(_Erasednode);
; 1275 : 
; 1276 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1277 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1278 : 		++_Where;	// save successor iterator for return
; 1279 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1280 : 
; 1281 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1282 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1283 : 		_Nodeptr _Pnode = _Erasednode;
; 1284 : 
; 1285 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LN5@erase

; 1286 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ecx+8]

; 1287 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN692@erase
$LN5@erase:
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1288 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, esi

; 1289 : 		else

	jmp	SHORT $LN692@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[ebp]

; 1290 : 			{	// two subtrees, must lift successor node to replace erased
; 1291 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1292 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1293 : 			}
; 1294 : 
; 1295 : 		if (_Pnode == _Erasednode)

	cmp	edx, ecx
	jne	$LN9@erase
$LN692@erase:

; 1296 : 			{	// at most one subtree, relink it
; 1297 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1298 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN11@erase

; 1299 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1300 : 
; 1301 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN12@erase

; 1302 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1303 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ecx
	jne	SHORT $LN14@erase

; 1304 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1305 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1306 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebx]

; 1307 : 					_Fixnode;	// link down to right
; 1308 : 
; 1309 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN16@erase

; 1310 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	edx, esi
	jmp	SHORT $LN43@erase
$LN42@erase:

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 691  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	edx, edi

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
$LL165@erase:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:
	mov	eax, DWORD PTR [ebx]
$LN43@erase:

; 1310 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax], edx
$LN16@erase:

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ebx]

; 1311 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1312 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1313 : 
; 1314 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [eax+8], ecx
	jne	$LN373@erase

; 1315 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	edx, esi
	mov	DWORD PTR [eax+8], edx

; 1316 : 					? _Fixnodeparent	// largest is parent of erased node
; 1317 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1318 : 			}
; 1319 : 		else

	jmp	SHORT $LN373@erase
$LN44@erase:

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 686  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	edx, edi

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
$LL217@erase:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	edx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:
	mov	eax, DWORD PTR [ebx]

; 1315 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax+8], edx

; 1316 : 					? _Fixnodeparent	// largest is parent of erased node
; 1317 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1318 : 			}
; 1319 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1320 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1321 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [esi+4], edx

; 1322 : 				_Pnode;	// link left up
; 1323 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1324 : 				this->_Left(_Erasednode);	// link successor down
; 1325 : 
; 1326 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN18@erase

; 1327 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1328 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1329 : 				{	// successor further down, link in place of erased
; 1330 : 				_Fixnodeparent =
; 1331 : 					this->_Parent(_Pnode);	// parent is successor's
; 1332 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1333 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1334 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1335 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 1336 : 					this->_Right(_Erasednode);	// link next down
; 1337 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1338 : 					_Pnode;	// right up
; 1339 : 				}
; 1340 : 
; 1341 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN21@erase

; 1342 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1343 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 1343 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN23@erase

; 1344 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1345 : 					_Pnode;	// link down to left
; 1346 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1347 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1348 : 					_Pnode;	// link down to right
; 1349 : 
; 1350 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR __Erasednode$1$[ebp]
	mov	cl, BYTE PTR [edx+12]
	mov	al, BYTE PTR [eax+12]
	mov	BYTE PTR [edx+12], al

; 68   : 	_Right = _STD move(_Tmp);

	mov	eax, DWORD PTR __Erasednode$1$[ebp]
	mov	BYTE PTR [eax+12], cl
	mov	ecx, eax
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1356 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ecx+12], 1
	jne	$LN25@erase

; 1357 : 			{	// erasing black link, must recolor/rebalance tree
; 1358 : 			for (; _Fixnode != _Root()
; 1359 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	7
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	edx, esi
	mov	DWORD PTR tv1195[ebp], edx
	mov	DWORD PTR tv1197[ebp], esi
	mov	DWORD PTR tv1196[ebp], esi
	jne	$LN695@erase

; 1361 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1362 : 					{	// fixup left subtree
; 1363 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1364 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1365 : 						{	// rotate red up from right subtree
; 1366 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1367 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1368 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lrotate

; 1369 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, esi
$LN28@erase:

; 1370 : 						}
; 1371 : 
; 1372 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1373 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1374 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1375 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN696@erase
$LN31@erase:

; 1376 : 						{	// redden right subtree with black children
; 1377 : 						this->_Color(_Pnode) = this->_Red;
; 1378 : 						_Fixnode = _Fixnodeparent;
; 1379 : 						}
; 1380 : 					else
; 1381 : 						{	// must rearrange right subtree
; 1382 : 						if (this->_Color(this->_Right(_Pnode))
; 1383 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1384 : 							{	// rotate red up from left sub-subtree
; 1385 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1386 : 							this->_Color(_Pnode) = this->_Red;
; 1387 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rrotate

; 1388 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1389 : 							}
; 1390 : 
; 1391 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1392 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1393 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1394 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lrotate

; 1395 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN695@erase
$LN26@erase:

; 1396 : 						}
; 1397 : 					}
; 1398 : 				else
; 1399 : 					{	// fixup right subtree
; 1400 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1401 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1402 : 						{	// rotate red up from left subtree
; 1403 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1404 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1405 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rrotate

; 1406 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR tv1195[ebp]
$LN34@erase:

; 1407 : 						}
; 1408 : 
; 1409 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1410 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1411 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1412 : 						this->_Black
; 1413 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN696@erase:

; 1414 : 						{	// redden left subtree with black children
; 1415 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1357 : 			{	// erasing black link, must recolor/rebalance tree
; 1358 : 			for (; _Fixnode != _Root()
; 1359 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]

; 1360 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1197[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1196[ebp]
$LN695@erase:
	mov	ecx, DWORD PTR __Erasednode$1$[ebp]
$LN3@erase:

; 1432 : 						break;	// tree now recolored/rebalanced
; 1433 : 						}
; 1434 : 					}
; 1435 : 
; 1436 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1444 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[ebp]

; 1444 : 		if (0 < this->_Mysize())

	test	eax, eax
	je	SHORT $LN694@erase

; 1445 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN694@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx

; 1446 : 
; 1447 : 		return (iterator(_Where._Ptr,
; 1448 : 			_STD addressof(this->_Get_data())));	// return successor iterator
; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN37@erase:

; 1416 : 						_Fixnode = _Fixnodeparent;
; 1417 : 						}
; 1418 : 					else
; 1419 : 						{	// must rearrange left subtree
; 1420 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1421 : 							{	// rotate red up from right sub-subtree
; 1422 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1423 : 							this->_Color(_Pnode) = this->_Red;
; 1424 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Lrotate

; 1425 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1426 : 							}
; 1427 : 
; 1428 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1429 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1430 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1431 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Rrotate
	jmp	SHORT $LN695@erase
?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::max_size, COMDAT
; _this$ = ecx

; 1181 : 		return (this->_Getal().max_size());

	mov	eax, 214748364				; 0cccccccH

; 1182 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::end, COMDAT
; _this$ = ecx

; 1125 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1126 : 		return (iterator(this->_Myhead(), _STD addressof(this->_Get_data())));
; 1127 : 		}

	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1116 : 		return (iterator(_Lmost(), _STD addressof(this->_Get_data())));
; 1117 : 		}

	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::~_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >, COMDAT
; _this$ = ecx

; 1098 : 		{	// destroy tree

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2184 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1100 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::~_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@ABU?$less@P6GXXZ@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@ABU?$less@P6GXXZ@1@@Z PROC ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >, COMDAT
; _this$ = ecx

; 1019 : 		{	// construct empty tree from comparator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 560  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1020 : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@ABU?$less@P6GXXZ@1@@Z ENDP ; std::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tree<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QBEABU?$less@P6GXXZ@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QBEABU?$less@P6GXXZ@2@XZ PROC ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QBEABU?$less@P6GXXZ@2@XZ ENDP ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAEAAU?$less@P6GXXZ@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAEAAU?$less@P6GXXZ@2@XZ PROC ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@P6GXXZ@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@2@$00@std@@QAEAAU?$less@P6GXXZ@2@XZ ENDP ; std::_Compressed_pair<std::less<void (__stdcall*)(void)>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >,std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Min, COMDAT

; 607  : 		{	// return leftmost node in subtree at _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
$LL2@Min:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Max, COMDAT

; 600  : 		{	// return rightmost node in subtree at _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
$LL2@Max:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 603  : 		return (_Pnode);

	mov	eax, ecx

; 604  : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Myval, COMDAT

; 595  : 		{	// return reference to value in node

	npad	2
	push	ebp
	mov	ebp, esp

; 596  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 597  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Right, COMDAT

; 590  : 		{	// return reference to right pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 592  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Parent, COMDAT

; 585  : 		{	// return reference to parent pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 587  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Left, COMDAT

; 580  : 		{	// return reference to left pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 582  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Isnil, COMDAT

; 575  : 		{	// return reference to nil flag in node

	npad	2
	push	ebp
	mov	ebp, esp

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 577  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Color, COMDAT

; 570  : 		{	// return reference to color in node

	npad	2
	push	ebp
	mov	ebp, esp

; 571  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 572  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >, COMDAT
; _this$ = ecx

; 560  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 563  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >::_Tree_val<std::_Tree_simple_types<void (__stdcall*)(void)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$less@P6GXXZ@std@@QBE_NABQ6GXXZ0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@P6GXXZ@std@@QBE_NABQ6GXXZ0@Z PROC		; std::less<void (__stdcall*)(void)>::operator(), COMDAT
; _this$ = ecx

; 233  : 		{	// apply operator< to operands

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	setb	al

; 234  : 		return (_Left < _Right);
; 235  : 		}

	pop	ebp
	ret	8
??R?$less@P6GXXZ@std@@QBE_NABQ6GXXZ0@Z ENDP		; std::less<void (__stdcall*)(void)>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Mysize, COMDAT
; _this$ = ecx

; 955  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 956  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@P6GXXZPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@P6GXXZPAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myhead, COMDAT
; _this$ = ecx

; 950  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 951  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@P6GXXZPAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myhead, COMDAT
; _this$ = ecx

; 945  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 946  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@P6GXXZPAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Get_data, COMDAT
; _this$ = ecx

; 940  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 941  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Get_data, COMDAT
; _this$ = ecx

; 935  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@P6GXXZ@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getal, COMDAT
; _this$ = ecx

; 930  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getal, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABU?$less@P6GXXZ@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABU?$less@P6GXXZ@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QBEABU?$less@P6GXXZ@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAU?$less@P6GXXZ@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAU?$less@P6GXXZ@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEAAU?$less@P6GXXZ@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Freenode0, COMDAT
; _this$ = ecx

; 883  : 		{	// free non-value node using current allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 891  : 		}

	pop	ebp
	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 864  : 		{	// allocate a non-value node

	npad	2
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 864  : 		{	// allocate a non-value node

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edx, edx
	jne	SHORT $LN174@Buynode0
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN177@Buynode0:
$LN174@Buynode0:

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], eax
	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN167@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN167@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 879  : 		return (_Pnode);

	mov	eax, edx
	pop	esi

; 880  : 		}

	ret	0
$LN176@Buynode0:
?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Freeheadnode, COMDAT
; _this$ = ecx

; 853  : 		{	// free head node using current allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 861  : 		}

	pop	ebp
	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buyheadnode, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN146@Buyheadnod
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN146@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], eax
	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 847  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 848  : 		_Isnil(_Pnode) = true;
; 849  : 		return (_Pnode);
; 850  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::~_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 720  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::~_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Construct, COMDAT
; _this$ = ecx

; 713  : 		{	// construct head node

	npad	2
	push	esi
	mov	esi, ecx

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 715  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@ABU?$less@P6GXXZ@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
??0?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@ABU?$less@P6GXXZ@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >, COMDAT
; _this$ = ecx

; 697  : 		{	// construct from comparator

	npad	2
	push	esi
	mov	esi, ecx

; 560  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 698  : 		_Construct();
; 699  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@QAE@ABU?$less@P6GXXZ@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Min, COMDAT

; 690  : 		{	// return leftmost node in subtree at _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 691  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
$LL4@Min:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 691  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 692  : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Max, COMDAT

; 685  : 		{	// return rightmost node in subtree at _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 686  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
$LL4@Max:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 686  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 687  : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myval, COMDAT

; 680  : 		{	// return reference to value in node

	npad	2
	push	ebp
	mov	ebp, esp

; 596  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 681  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 682  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAP6GXXZPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Right, COMDAT

; 675  : 		{	// return reference to right pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 676  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 677  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Parent, COMDAT

; 670  : 		{	// return reference to parent pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 671  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 672  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Left, COMDAT

; 665  : 		{	// return reference to left pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 666  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, DWORD PTR __Pnode$[ebp]

; 667  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@P6GXXZPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Isnil, COMDAT

; 660  : 		{	// return reference to nil flag in node

	npad	2
	push	ebp
	mov	ebp, esp

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 661  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 662  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Color, COMDAT

; 655  : 		{	// return reference to color in node

	npad	2
	push	ebp
	mov	ebp, esp

; 571  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 656  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 657  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@P6GXXZPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 214748364				; 0cccccccH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 214748364				; 0cccccccH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 214748364				; 0cccccccH

; 852  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z PROC ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 214748364				; 0cccccccH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEPAU?$_Tree_node@P6GXXZPAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@I@Z PROC ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAEXPAU?$_Tree_node@P6GXXZPAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@P6GXXZPAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >::allocator<std::_Tree_node<void (__stdcall*)(void),void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@SAABQ6GXXZABQ6GXXZ@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@SAABQ6GXXZABQ6GXXZ@Z PROC ; std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0>::_Kfn, COMDAT

; 34   : 		{	// extract key from element value

	npad	2
	push	ebp
	mov	ebp, esp

; 35   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 36   : 		}

	pop	ebp
	ret	0
?_Kfn@?$_Tset_traits@P6GXXZU?$less@P6GXXZ@std@@V?$allocator@P6GXXZ@2@$0A@@std@@SAABQ6GXXZABQ6GXXZ@Z ENDP ; std::_Tset_traits<void (__stdcall*)(void),std::less<void (__stdcall*)(void)>,std::allocator<void (__stdcall*)(void)>,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??__Fexternal_resources@@YAXXZ
text$yd	SEGMENT
??__Fexternal_resources@@YAXXZ PROC			; `dynamic atexit destructor for 'external_resources'', COMDAT

; 1947 : 		this->_Orphan_all();

	mov	ecx, OFFSET ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A ; external_resources
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Orphan_all

; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A
	test	eax, eax
	je	SHORT $LN7@dynamic

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	push	DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+4
	mov	ecx, OFFSET ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A ; external_resources
	push	eax
	call	?_Destroy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@0@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Destroy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+8
	mov	ecx, DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A, 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+4, 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+8, 0
$LN7@dynamic:
	ret	0
??__Fexternal_resources@@YAXXZ ENDP			; `dynamic atexit destructor for 'external_resources''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
;	COMDAT ??__Eexternal_resources@@YAXXZ
text$di	SEGMENT
??__Eexternal_resources@@YAXXZ PROC			; `dynamic initializer for 'external_resources'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A ; external_resources
	call	??0?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<IUnknown *> >::_Wrap_alloc<std::allocator<IUnknown *> >
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 659  : std::vector <IUnknown *>                 external_resources;

	push	OFFSET ??__Fexternal_resources@@YAXXZ	; `dynamic atexit destructor for 'external_resources''
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A, 0

; 477  : 		_Mylast(),

	mov	DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+4, 0

; 478  : 		_Myend()

	mov	DWORD PTR ?external_resources@@3V?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@A+8, 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 659  : std::vector <IUnknown *>                 external_resources;

	call	_atexit
	pop	ecx
	ret	0
??__Eexternal_resources@@YAXXZ ENDP			; `dynamic initializer for 'external_resources''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABEXPAPAUIUnknown@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABEXPAPAUIUnknown@@0@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1996 : 		}

	ret	8
?_Orphan_range@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABEXPAPAUIUnknown@@0@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@CAXXZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@CAXXZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXXZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXXZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXQAPAUIUnknown@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXQAPAUIUnknown@@II@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXQAPAUIUnknown@@II@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABEII@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 1073741823				; 3fffffffH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 2

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABEII@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@0@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@0@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@00@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@00@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@AAEXPAPAUIUnknown@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_Has_unused_capacity@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABE_NXZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Has_unused_capacity, COMDAT
; _this$ = ecx

; 1730 : 		{	// micro-optimization for capacity() != size()

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [ecx+4]
	setne	al

; 1731 : 		return (this->_Myend() != this->_Mylast());
; 1732 : 		}

	ret	0
?_Has_unused_capacity@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@ABE_NXZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1721 : 		}

	ret	0
?capacity@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1716 : 		}

	ret	0
?max_size@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1711 : 		}

	ret	0
?size@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIXZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?end@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@2@XZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::end, COMDAT
; _this$ = ecx

; 1654 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1655 : 		return (iterator(this->_Mylast(), _STD addressof(this->_Get_data())));
; 1656 : 		}

	pop	ebp
	ret	4
?end@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@2@XZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?begin@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@2@XZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::begin, COMDAT
; _this$ = ecx

; 1644 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1645 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
; 1646 : 		}

	pop	ebp
	ret	4
?begin@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@@2@XZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?clear@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXXZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::clear, COMDAT
; _this$ = ecx

; 1615 : 		this->_Orphan_all();
; 1616 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1618 : 		}

	ret	0
?clear@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXXZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?push_back@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::push_back, COMDAT
; _this$ = ecx

; 946  : 		{	// insert element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 948  : 		}

	pop	ebp

; 947  : 		emplace_back(_Val);

	jmp	??$emplace_back@ABQAUIUnknown@@@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z ; std::vector<IUnknown *,std::allocator<IUnknown *> >::emplace_back<IUnknown * const &>
?push_back@?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXABQAUIUnknown@@@Z ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::~vector<IUnknown *,std::allocator<IUnknown *> >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::~vector<IUnknown *,std::allocator<IUnknown *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ PROC ; std::vector<IUnknown *,std::allocator<IUnknown *> >::vector<IUnknown *,std::allocator<IUnknown *> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 723  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 723  : 		}

	ret	0
??0?$vector@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ ENDP ; std::vector<IUnknown *,std::allocator<IUnknown *> >::vector<IUnknown *,std::allocator<IUnknown *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<IUnknown *> >,std::_Vector_val<std::_Simple_types<IUnknown *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<IUnknown *> >::_Vector_val<std::_Simple_types<IUnknown *> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<IUnknown *> >::_Vector_val<std::_Simple_types<IUnknown *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABQAPAUIUnknown@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAPAPAUIUnknown@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUIUnknown@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 509  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 509  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@PAUIUnknown@@V?$allocator@PAUIUnknown@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >::_Vector_alloc<std::_Vec_base_types<IUnknown *,std::allocator<IUnknown *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<IUnknown *> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<IUnknown *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@I@Z PROC ; std::_Wrap_alloc<std::allocator<IUnknown *> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEXPAPAUIUnknown@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<IUnknown *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEPAPAUIUnknown@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEPAPAUIUnknown@@I@Z PROC ; std::_Wrap_alloc<std::allocator<IUnknown *> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@PAUIUnknown@@@std@@QAEPAPAUIUnknown@@I@Z ; std::allocator<IUnknown *>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAEPAPAUIUnknown@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<IUnknown *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<IUnknown *> >::_Wrap_alloc<std::allocator<IUnknown *> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAUIUnknown@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<IUnknown *> >::_Wrap_alloc<std::allocator<IUnknown *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAIABV?$allocator@PAUIUnknown@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAIABV?$allocator@PAUIUnknown@@@2@@Z PROC ; std::allocator_traits<std::allocator<IUnknown *> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@PAUIUnknown@@@std@@@std@@SAIABV?$allocator@PAUIUnknown@@@2@@Z ENDP ; std::allocator_traits<std::allocator<IUnknown *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAUIUnknown@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAUIUnknown@@@std@@QBEIXZ PROC	; std::allocator<IUnknown *>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@PAUIUnknown@@@std@@QBEIXZ ENDP	; std::allocator<IUnknown *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAUIUnknown@@@std@@QAEPAPAUIUnknown@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUIUnknown@@@std@@QAEPAPAUIUnknown@@I@Z PROC ; std::allocator<IUnknown *>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@PAUIUnknown@@@std@@QAEPAPAUIUnknown@@I@Z ENDP ; std::allocator<IUnknown *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@I@Z PROC ; std::allocator<IUnknown *>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@PAUIUnknown@@@std@@QAEXPAPAUIUnknown@@I@Z ENDP ; std::allocator<IUnknown *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@PAUIUnknown@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAUIUnknown@@@std@@QAE@XZ PROC		; std::allocator<IUnknown *>::allocator<IUnknown *>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@PAUIUnknown@@@std@@QAE@XZ ENDP		; std::allocator<IUnknown *>::allocator<IUnknown *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_desc$2 = -136						; size = 52
_desc$3 = -128						; size = 44
_srvDesc$4 = -84					; size = 24
_subResource$5 = -60					; size = 12
_auto_bool1$ = -48					; size = 8
_auto_bool0$ = -40					; size = 8
_auto_bool0$1$ = -32					; size = 4
_auto_bool1$1$ = -28					; size = 4
_io$1$ = -24						; size = 4
_pTexture$6 = -20					; size = 4
_pDev$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ PROC		; ImGui_ImplDX11_CreateFontsTexture

; 369  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 124				; 0000007cH
	push	esi
	push	edi

; 370  :   SK_ScopedBool auto_bool0 (&SK_TLS_Bottom ()->texture_management.injection_thread);

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	lea	esi, DWORD PTR [eax+16]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 139  :     bOrig_ = *pBool;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _auto_bool0$[ebp], esi
	mov	DWORD PTR _auto_bool0$1$[ebp], eax
	mov	DWORD PTR _auto_bool0$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 370  :   SK_ScopedBool auto_bool0 (&SK_TLS_Bottom ()->texture_management.injection_thread);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 371  :   SK_ScopedBool auto_bool1 (&SK_TLS_Bottom ()->imgui.drawing                      );

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	lea	edi, DWORD PTR [eax+48]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 139  :     bOrig_ = *pBool;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _auto_bool1$[ebp], edi
	mov	DWORD PTR _auto_bool1$1$[ebp], eax
	mov	DWORD PTR _auto_bool1$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 371  :   SK_ScopedBool auto_bool1 (&SK_TLS_Bottom ()->imgui.drawing                      );

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 372  : 
; 373  :   // Do not dump ImGui font textures
; 374  :   SK_TLS_Bottom ()->texture_management.injection_thread = true;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	mov	DWORD PTR [eax+16], 1

; 375  :   SK_TLS_Bottom ()->imgui.drawing                       = true;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	mov	DWORD PTR [eax+48], 1

; 376  : 
; 377  :   // Build texture atlas
; 378  :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 379  : 
; 380  :   static bool           init   = false;
; 381  :   static unsigned char* pixels = nullptr;
; 382  :   static int            width  = 0,
; 383  :                         height = 0;
; 384  : 
; 385  :   // Only needs to be done once, the raw pixels are API agnostic
; 386  :   if (! init)

	cmp	BYTE PTR ?init@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4_NA, 0
	mov	DWORD PTR _io$1$[ebp], eax
	jne	SHORT $LN2@ImGui_Impl

; 387  :   {
; 388  :     SK_ImGui_LoadFonts ();

	call	?SK_ImGui_LoadFonts@@YAXXZ		; SK_ImGui_LoadFonts

; 389  : 
; 390  :     io.Fonts->GetTexDataAsRGBA32 (&pixels, &width, &height);

	mov	ecx, DWORD PTR _io$1$[ebp]
	push	0
	push	OFFSET ?height@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4HA
	push	OFFSET ?width@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4HA
	mov	ecx, DWORD PTR [ecx+128]
	push	OFFSET ?pixels@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4PAEA
	call	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32

; 391  : 
; 392  :     init = true;

	mov	BYTE PTR ?init@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4_NA, 1
$LN2@ImGui_Impl:

; 393  :   }
; 394  : 
; 395  :   SK_RenderBackend& rb =

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 399  :   rb.device->QueryInterface <ID3D11Device> (&pDev);

	mov	eax, DWORD PTR [eax+36]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pDev$[ebp]
	push	edx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	eax
	mov	ecx, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 398  :   CComPtr                   <ID3D11Device>   pDev = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 403  :     D3D11_TEXTURE2D_DESC desc

	push	44					; 0000002cH
	lea	eax, DWORD PTR _desc$3[ebp]
	push	0
	push	eax
	call	_memset

; 404  :                           = { };
; 405  : 
; 406  :     desc.Width            = width;

	mov	ecx, DWORD PTR ?width@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4HA

; 407  :     desc.Height           = height;
; 408  :     desc.MipLevels        = 1;
; 409  :     desc.ArraySize        = 1;
; 410  :     desc.Format           = DXGI_FORMAT_R8G8B8A8_UNORM;
; 411  :     desc.SampleDesc.Count = 1;
; 412  :     desc.Usage            = D3D11_USAGE_DEFAULT;
; 413  :     desc.BindFlags        = D3D11_BIND_SHADER_RESOURCE;
; 414  :     desc.CPUAccessFlags   = 0;
; 415  : 
; 416  :     ID3D11Texture2D        *pTexture    = nullptr;
; 417  :     D3D11_SUBRESOURCE_DATA  subResource = { };
; 418  : 
; 419  :     subResource.pSysMem          = pixels;
; 420  :     subResource.SysMemPitch      = desc.Width * 4;
; 421  :     subResource.SysMemSlicePitch = 0;
; 422  : 
; 423  :     pDev->CreateTexture2D (&desc, &subResource, &pTexture);

	lea	edx, DWORD PTR _pTexture$6[ebp]
	mov	eax, DWORD PTR ?height@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4HA
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _desc$3[ebp+4], eax
	xorps	xmm0, xmm0
	mov	eax, DWORD PTR ?pixels@?1??ImGui_ImplDX11_CreateFontsTexture@@YAXXZ@4PAEA
	movq	QWORD PTR _subResource$5[ebp], xmm0
	mov	DWORD PTR _subResource$5[ebp], eax
	lea	eax, DWORD PTR [ecx*4]
	push	edx
	mov	DWORD PTR _subResource$5[ebp+4], eax
	lea	edx, DWORD PTR _subResource$5[ebp]
	mov	eax, DWORD PTR _pDev$[ebp]
	push	edx
	mov	DWORD PTR _subResource$5[ebp+8], 0
	lea	edx, DWORD PTR _desc$3[ebp]
	mov	DWORD PTR _desc$3[ebp], ecx
	mov	DWORD PTR _desc$3[ebp+8], 1
	mov	DWORD PTR _desc$3[ebp+12], 1
	mov	DWORD PTR _desc$3[ebp+16], 28		; 0000001cH
	mov	DWORD PTR _desc$3[ebp+20], 1
	mov	DWORD PTR _desc$3[ebp+28], 0
	mov	DWORD PTR _desc$3[ebp+32], 8
	mov	DWORD PTR _desc$3[ebp+36], 0
	mov	DWORD PTR _pTexture$6[ebp], 0
	mov	DWORD PTR _subResource$5[ebp+8], 0
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+20]

; 424  : 
; 425  :     // Create texture view
; 426  :     D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc = { };
; 427  : 
; 428  :     srvDesc.Format                    = DXGI_FORMAT_R8G8B8A8_UNORM;
; 429  :     srvDesc.ViewDimension             = D3D11_SRV_DIMENSION_TEXTURE2D;
; 430  :     srvDesc.Texture2D.MipLevels       = desc.MipLevels;

	mov	eax, DWORD PTR _desc$3[ebp+8]

; 431  :     srvDesc.Texture2D.MostDetailedMip = 0;
; 432  : 
; 433  :     pDev->CreateShaderResourceView (pTexture, &srvDesc, &g_pFontTextureView);

	lea	edx, DWORD PTR _srvDesc$4[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _srvDesc$4[ebp], xmm0
	mov	DWORD PTR _srvDesc$4[ebp+12], eax
	mov	eax, DWORD PTR _pDev$[ebp]
	push	OFFSET ?g_pFontTextureView@@3PAUID3D11ShaderResourceView@@A
	push	edx
	push	DWORD PTR _pTexture$6[ebp]
	movq	QWORD PTR _srvDesc$4[ebp+16], xmm0
	mov	DWORD PTR _srvDesc$4[ebp], 28		; 0000001cH
	mov	DWORD PTR _srvDesc$4[ebp+4], 4
	mov	DWORD PTR _srvDesc$4[ebp+8], 0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+28]

; 434  : 
; 435  :     pTexture->Release ();

	mov	eax, DWORD PTR _pTexture$6[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 436  :   }
; 437  : 
; 438  :   // Store our identifier
; 439  :   io.Fonts->TexID =

	mov	eax, DWORD PTR _io$1$[ebp]

; 440  :     static_cast <void *> (g_pFontTextureView);
; 441  : 
; 442  :   // Create texture sampler
; 443  :   {
; 444  :     D3D11_SAMPLER_DESC desc = { };

	push	52					; 00000034H
	push	0
	mov	ecx, DWORD PTR [eax+128]
	mov	eax, DWORD PTR ?g_pFontTextureView@@3PAUID3D11ShaderResourceView@@A
	mov	DWORD PTR [ecx], eax
	lea	eax, DWORD PTR _desc$2[ebp]
	push	eax
	call	_memset
	movaps	xmm0, XMMWORD PTR __xmm@00000003000000030000000300000015
	add	esp, 12					; 0000000cH
	movups	XMMWORD PTR _desc$2[ebp], xmm0

; 445  : 
; 446  :     desc.Filter         = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
; 447  :     desc.AddressU       = D3D11_TEXTURE_ADDRESS_CLAMP;    //WRAP
; 448  :     desc.AddressV       = D3D11_TEXTURE_ADDRESS_CLAMP;    //WRAP
; 449  :     desc.AddressW       = D3D11_TEXTURE_ADDRESS_CLAMP;    //WRAP
; 450  :     desc.MipLODBias     = 0.f;

	mov	DWORD PTR _desc$2[ebp+16], 0

; 451  :     desc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;

	mov	DWORD PTR _desc$2[ebp+24], 8

; 452  :     desc.MinLOD         = 0.f;
; 453  :     desc.MaxLOD         = 0.f;
; 454  : 
; 455  :     pDev->CreateSamplerState (&desc, &g_pFontSampler);

	mov	eax, DWORD PTR _pDev$[ebp]
	lea	edx, DWORD PTR _desc$2[ebp]
	push	OFFSET ?g_pFontSampler@@3PAUID3D11SamplerState@@A
	mov	DWORD PTR _desc$2[ebp+44], 0
	mov	DWORD PTR _desc$2[ebp+48], 0
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+92]

; 456  :   }
; 457  : 
; 458  :   SK_TLS_Bottom ()->texture_management.injection_thread = false;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom

; 459  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR [eax+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDev$[ebp]
	test	eax, eax
	je	SHORT $LN38@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN38@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	eax, DWORD PTR _auto_bool1$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 459  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _auto_bool0$1$[ebp]
	mov	DWORD PTR [esi], eax
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 459  : }

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ$0:
	lea	ecx, DWORD PTR _auto_bool0$[ebp]
	jmp	??1SK_ScopedBool@@QAE@XZ		; SK_ScopedBool::~SK_ScopedBool
__unwindfunclet$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ$1:
	lea	ecx, DWORD PTR _auto_bool1$[ebp]
	jmp	??1SK_ScopedBool@@QAE@XZ		; SK_ScopedBool::~SK_ScopedBool
__unwindfunclet$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ$2:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__ehhandler$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ ENDP		; ImGui_ImplDX11_CreateFontsTexture
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11RenderTargetView>::~CComPtr<ID3D11RenderTargetView>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11RenderTargetView>::~CComPtr<ID3D11RenderTargetView>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@PAUID3D11RenderTargetView@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@PAUID3D11RenderTargetView@@@Z PROC ; ATL::CComPtr<ID3D11RenderTargetView>::CComPtr<ID3D11RenderTargetView>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@PAUID3D11RenderTargetView@@@Z ENDP ; ATL::CComPtr<ID3D11RenderTargetView>::CComPtr<ID3D11RenderTargetView>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAEPAPAUID3D11RenderTargetView@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAEPAPAUID3D11RenderTargetView@@XZ PROC ; ATL::CComPtrBase<ID3D11RenderTargetView>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAEPAPAUID3D11RenderTargetView@@XZ ENDP ; ATL::CComPtrBase<ID3D11RenderTargetView>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAE@XZ PROC ; ATL::CComPtrBase<ID3D11RenderTargetView>::~CComPtrBase<ID3D11RenderTargetView>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAE@XZ ENDP ; ATL::CComPtrBase<ID3D11RenderTargetView>::~CComPtrBase<ID3D11RenderTargetView>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@IAE@PAUID3D11RenderTargetView@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@IAE@PAUID3D11RenderTargetView@@@Z PROC ; ATL::CComPtrBase<ID3D11RenderTargetView>::CComPtrBase<ID3D11RenderTargetView>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@IAE@PAUID3D11RenderTargetView@@@Z ENDP ; ATL::CComPtrBase<ID3D11RenderTargetView>::CComPtrBase<ID3D11RenderTargetView>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\combaseapi.h
;	COMDAT ??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z PROC ; IID_PPV_ARGS_Helper<ID3D11Texture2D>, COMDAT

; 227  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  : #pragma prefast(suppress: 6269, "Tool issue with unused static_cast")
; 229  :         static_cast<IUnknown*>(*pp);    // make sure everyone derives from IUnknown
; 230  :         return reinterpret_cast<void**>(pp);

	mov	eax, DWORD PTR _pp$[ebp]

; 231  :     }    

	pop	ebp
	ret	0
??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z ENDP ; IID_PPV_ARGS_Helper<ID3D11Texture2D>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11Texture2D>::~CComPtr<ID3D11Texture2D>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11Texture2D>::~CComPtr<ID3D11Texture2D>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@PAUID3D11Texture2D@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@PAUID3D11Texture2D@@@Z PROC ; ATL::CComPtr<ID3D11Texture2D>::CComPtr<ID3D11Texture2D>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@PAUID3D11Texture2D@@@Z ENDP ; ATL::CComPtr<ID3D11Texture2D>::CComPtr<ID3D11Texture2D>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Texture2D@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Texture2D@@@1@XZ PROC ; ATL::CComPtrBase<ID3D11Texture2D>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Texture2D@@@1@XZ ENDP ; ATL::CComPtrBase<ID3D11Texture2D>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAEPAPAUID3D11Texture2D@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAEPAPAUID3D11Texture2D@@XZ PROC ; ATL::CComPtrBase<ID3D11Texture2D>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAEPAPAUID3D11Texture2D@@XZ ENDP ; ATL::CComPtrBase<ID3D11Texture2D>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAUID3D11Texture2D@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAUID3D11Texture2D@@XZ PROC ; ATL::CComPtrBase<ID3D11Texture2D>::operator ID3D11Texture2D *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAUID3D11Texture2D@@XZ ENDP ; ATL::CComPtrBase<ID3D11Texture2D>::operator ID3D11Texture2D *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<ID3D11Texture2D>::~CComPtrBase<ID3D11Texture2D>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ID3D11Texture2D>::~CComPtrBase<ID3D11Texture2D>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11Texture2D@@@ATL@@IAE@PAUID3D11Texture2D@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11Texture2D@@@ATL@@IAE@PAUID3D11Texture2D@@@Z PROC ; ATL::CComPtrBase<ID3D11Texture2D>::CComPtrBase<ID3D11Texture2D>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11Texture2D@@@ATL@@IAE@PAUID3D11Texture2D@@@Z ENDP ; ATL::CComPtrBase<ID3D11Texture2D>::CComPtrBase<ID3D11Texture2D>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UID3D11DeviceContext@@@IUnknown@@QAGJPAPAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UID3D11DeviceContext@@@IUnknown@@QAGJPAPAUID3D11DeviceContext@@@Z PROC ; IUnknown::QueryInterface<ID3D11DeviceContext>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UID3D11DeviceContext@@@IUnknown@@QAGJPAPAUID3D11DeviceContext@@@Z ENDP ; IUnknown::QueryInterface<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11DeviceContext>::~CComPtr<ID3D11DeviceContext>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11DeviceContext>::~CComPtr<ID3D11DeviceContext>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@PAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@PAUID3D11DeviceContext@@@Z PROC ; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@PAUID3D11DeviceContext@@@Z ENDP ; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11DeviceContext@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11DeviceContext@@@1@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11DeviceContext@@@1@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAEPAPAUID3D11DeviceContext@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAEPAPAUID3D11DeviceContext@@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAEPAPAUID3D11DeviceContext@@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAE@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::~CComPtrBase<ID3D11DeviceContext>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAE@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::~CComPtrBase<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@PAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@PAUID3D11DeviceContext@@@Z PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@PAUID3D11DeviceContext@@@Z ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UID3D11Device@@@IUnknown@@QAGJPAPAUID3D11Device@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UID3D11Device@@@IUnknown@@QAGJPAPAUID3D11Device@@@Z PROC ; IUnknown::QueryInterface<ID3D11Device>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UID3D11Device@@@IUnknown@@QAGJPAPAUID3D11Device@@@Z ENDP ; IUnknown::QueryInterface<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ID3D11Device>::~CComPtr<ID3D11Device>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ID3D11Device>::~CComPtr<ID3D11Device>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11Device@@@ATL@@QAE@PAUID3D11Device@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11Device@@@ATL@@QAE@PAUID3D11Device@@@Z PROC ; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11Device@@@ATL@@QAE@PAUID3D11Device@@@Z ENDP ; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device@@@1@XZ PROC ; ATL::CComPtrBase<ID3D11Device>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device@@@1@XZ ENDP ; ATL::CComPtrBase<ID3D11Device>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11Device@@@ATL@@QAEPAPAUID3D11Device@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11Device@@@ATL@@QAEPAPAUID3D11Device@@XZ PROC ; ATL::CComPtrBase<ID3D11Device>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11Device@@@ATL@@QAEPAPAUID3D11Device@@XZ ENDP ; ATL::CComPtrBase<ID3D11Device>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11Device@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11Device@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<ID3D11Device>::~CComPtrBase<ID3D11Device>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11Device@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ID3D11Device>::~CComPtrBase<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@PAUID3D11Device@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@PAUID3D11Device@@@Z PROC ; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@PAUID3D11Device@@@Z ENDP ; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGISwapChain@@@IUnknown@@QAGJPAPAUIDXGISwapChain@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGISwapChain@@@IUnknown@@QAGJPAPAUIDXGISwapChain@@@Z PROC ; IUnknown::QueryInterface<IDXGISwapChain>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGISwapChain@@@IUnknown@@QAGJPAPAUIDXGISwapChain@@@Z ENDP ; IUnknown::QueryInterface<IDXGISwapChain>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGISwapChain>::~CComPtr<IDXGISwapChain>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGISwapChain>::~CComPtr<IDXGISwapChain>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@PAUIDXGISwapChain@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@PAUIDXGISwapChain@@@Z PROC ; ATL::CComPtr<IDXGISwapChain>::CComPtr<IDXGISwapChain>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@PAUIDXGISwapChain@@@Z ENDP ; ATL::CComPtr<IDXGISwapChain>::CComPtr<IDXGISwapChain>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIDXGISwapChain@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGISwapChain@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UIDXGISwapChain@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGISwapChain@@@1@XZ PROC ; ATL::CComPtrBase<IDXGISwapChain>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UIDXGISwapChain@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGISwapChain@@@1@XZ ENDP ; ATL::CComPtrBase<IDXGISwapChain>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAEPAPAUIDXGISwapChain@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAEPAPAUIDXGISwapChain@@XZ PROC ; ATL::CComPtrBase<IDXGISwapChain>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAEPAPAUIDXGISwapChain@@XZ ENDP ; ATL::CComPtrBase<IDXGISwapChain>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGISwapChain>::~CComPtrBase<IDXGISwapChain>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGISwapChain>::~CComPtrBase<IDXGISwapChain>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGISwapChain@@@ATL@@IAE@PAUIDXGISwapChain@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGISwapChain@@@ATL@@IAE@PAUIDXGISwapChain@@@Z PROC ; ATL::CComPtrBase<IDXGISwapChain>::CComPtrBase<IDXGISwapChain>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGISwapChain@@@ATL@@IAE@PAUIDXGISwapChain@@@Z ENDP ; ATL::CComPtrBase<IDXGISwapChain>::CComPtrBase<IDXGISwapChain>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_tex2d_desc$ = -324					; size = 44
_blend_factor$ = -280					; size = 16
_backbuffer_desc$ = -264				; size = 44
_mvp$2 = -220						; size = 64
_idx_resource$ = -156					; size = 12
_vtx_resource$ = -144					; size = 12
_vp$ = -132						; size = 24
_auto_bool$ = -108					; size = 8
_stride$ = -100						; size = 4
_offset$ = -96						; size = 4
_cmd_list$1$ = -92					; size = 4
tv2475 = -92						; size = 4
_pSwapChain$ = -88					; size = 4
tv2318 = -84						; size = 4
_desc$3 = -80						; size = 24
_desc$4 = -80						; size = 24
_rtdesc$5 = -76						; size = 20
_rtdesc$6 = -76						; size = 20
_rtdesc$7 = -76						; size = 20
_r$8 = -72						; size = 16
_mapped_resource$9 = -68				; size = 12
_i$1$ = -56						; size = 4
tv2469 = -56						; size = 4
_a$1$ = -52						; size = 4
_n$1$ = -52						; size = 4
_auto_bool$1$ = -48					; size = 4
_pRenderTargetView$ = -44				; size = 4
_cmd_i$1$ = -40						; size = 4
_n$1$ = -40						; size = 4
_io$1$ = -40						; size = 4
_idx_offset$1$ = -36					; size = 4
_idx_dst$1$ = -36					; size = 4
_vtx_offset$1$ = -32					; size = 4
_vtx_dst$1$ = -32					; size = 4
_alpha$1$ = -25						; size = 1
_pDevice$ = -24						; size = 4
_pBackBuffer$ = -20					; size = 4
_pDevCtx$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_draw_data$ = 8						; size = 4
?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z PROC ; ImGui_ImplDX11_RenderDrawLists

; 67   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 312				; 00000138H
	push	esi
	push	edi

; 68   :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	lea	edi, DWORD PTR [eax+48]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 139  :     bOrig_ = *pBool;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _auto_bool$[ebp], edi
	mov	DWORD PTR _auto_bool$1$[ebp], eax
	mov	DWORD PTR _auto_bool$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 68   :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 69   : 
; 70   :   SK_TLS_Bottom ()->imgui.drawing = true;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	mov	DWORD PTR [eax+48], 1

; 71   : 
; 72   :   ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	DWORD PTR _io$1$[ebp], eax

; 73   :     ImGui::GetIO ();
; 74   : 
; 75   :   SK_RenderBackend& rb =

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	esi, eax

; 76   :     SK_GetCurrentRenderBackend ();
; 77   : 
; 78   :   if (! rb.swapchain)

	cmp	DWORD PTR [esi+40], 0
	je	$LN396@ImGui_Impl

; 79   :     return;
; 80   : 
; 81   :   if (! rb.device)

	cmp	DWORD PTR [esi+36], 0
	je	$LN396@ImGui_Impl

; 82   :     return;
; 83   : 
; 84   :   if (! rb.d3d11.immediate_ctx)

	cmp	DWORD PTR [esi+68], 0
	je	$LN396@ImGui_Impl

; 85   :     return;
; 86   : 
; 87   :   if (! g_pVertexConstantBuffer)

	cmp	DWORD PTR ?g_pVertexConstantBuffer@@3PAUID3D11Buffer@@A, 0
	je	$LN396@ImGui_Impl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 92   :   rb.swapchain->QueryInterface <IDXGISwapChain> (&pSwapChain);

	mov	eax, DWORD PTR [esi+40]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pSwapChain$[ebp]
	push	edx
	push	OFFSET __GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a
	push	eax
	mov	ecx, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 91   :   CComPtr                      <IDXGISwapChain>   pSwapChain = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevice$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 95   :   rb.device->QueryInterface <ID3D11Device> (&pDevice);

	mov	eax, DWORD PTR [esi+36]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pDevice$[ebp]
	push	edx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	eax
	mov	ecx, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 94   :   CComPtr                   <ID3D11Device>   pDevice = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevCtx$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 98   :   rb.d3d11.immediate_ctx->QueryInterface <ID3D11DeviceContext> (&pDevCtx);

	mov	eax, DWORD PTR [esi+68]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pDevCtx$[ebp]
	push	edx
	push	OFFSET __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
	push	eax
	mov	ecx, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 97   :   CComPtr                                <ID3D11DeviceContext>   pDevCtx = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pBackBuffer$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 102  :   pSwapChain->GetBuffer (0, IID_PPV_ARGS (&pBackBuffer));

	mov	esi, DWORD PTR _pSwapChain$[ebp]
	lea	eax, DWORD PTR _pBackBuffer$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edi, DWORD PTR [esi]
	call	??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z ; IID_PPV_ARGS_Helper<ID3D11Texture2D>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
	push	0
	push	esi
	call	DWORD PTR [edi+36]

; 103  : 
; 104  :   D3D11_TEXTURE2D_DESC   backbuffer_desc = { };

	push	44					; 0000002cH
	lea	eax, DWORD PTR _backbuffer_desc$[ebp]
	push	0
	push	eax
	call	_memset

; 105  :   pBackBuffer->GetDesc (&backbuffer_desc);

	mov	eax, DWORD PTR _pBackBuffer$[ebp]
	lea	edx, DWORD PTR _backbuffer_desc$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+40]

; 106  : 
; 107  :   io.DisplaySize.x             = static_cast <float> (backbuffer_desc.Width);

	mov	eax, DWORD PTR _backbuffer_desc$[ebp]
	mov	ecx, DWORD PTR _io$1$[ebp]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [ecx], xmm0

; 108  :   io.DisplaySize.y             = static_cast <float> (backbuffer_desc.Height);

	mov	eax, DWORD PTR _backbuffer_desc$[ebp+4]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [ecx+4], xmm0

; 109  : 
; 110  :   io.DisplayFramebufferScale.x = static_cast <float> (backbuffer_desc.Width);

	mov	eax, DWORD PTR _backbuffer_desc$[ebp]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [ecx+144], xmm0

; 111  :   io.DisplayFramebufferScale.y = static_cast <float> (backbuffer_desc.Height);

	mov	eax, DWORD PTR _backbuffer_desc$[ebp+4]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0

; 112  : 
; 113  : 
; 114  :   // Create and grow vertex/index buffers if needed
; 115  :   if ((! g_pVB) || g_VertexBufferSize < draw_data->TotalVtxCount)

	mov	edi, DWORD PTR _draw_data$[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [ecx+148], xmm0
	cmp	DWORD PTR ?g_pVB@@3PAUID3D11Buffer@@A, 0
	je	SHORT $LN21@ImGui_Impl
	mov	eax, DWORD PTR ?g_VertexBufferSize@@3HA
	cmp	eax, DWORD PTR [edi+12]
	jge	SHORT $LN22@ImGui_Impl
$LN21@ImGui_Impl:

; 116  :   {
; 117  :     SK_COM_ValidateRelease ((IUnknown **)&g_pVB);

	push	OFFSET ?g_pVB@@3PAUID3D11Buffer@@A
	call	?SK_COM_ValidateRelease@@YAPAUIUnknown@@PAPAU1@@Z ; SK_COM_ValidateRelease

; 118  : 
; 119  :     g_VertexBufferSize  =

	mov	eax, DWORD PTR [edi+12]

; 120  :       draw_data->TotalVtxCount + 5000;
; 121  : 
; 122  :     D3D11_BUFFER_DESC desc
; 123  :                         = { };
; 124  : 
; 125  :     desc.Usage          = D3D11_USAGE_DYNAMIC;
; 126  :     desc.ByteWidth      = g_VertexBufferSize * sizeof (ImDrawVert);
; 127  :     desc.BindFlags      = D3D11_BIND_VERTEX_BUFFER;
; 128  :     desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
; 129  :     desc.MiscFlags      = 0;
; 130  : 
; 131  :     if (pDevice->CreateBuffer (&desc, nullptr, &g_pVB) < 0)

	lea	edx, DWORD PTR _desc$4[ebp]
	add	eax, 5000				; 00001388H
	add	esp, 4
	mov	DWORD PTR ?g_VertexBufferSize@@3HA, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _desc$4[ebp], xmm0
	mov	DWORD PTR _desc$4[ebp+4], 2
	lea	eax, DWORD PTR [eax+eax*4]
	movq	QWORD PTR _desc$4[ebp+16], xmm0
	shl	eax, 2
	mov	DWORD PTR _desc$4[ebp], eax
	mov	eax, DWORD PTR _pDevice$[ebp]
	push	OFFSET ?g_pVB@@3PAUID3D11Buffer@@A
	push	0
	mov	DWORD PTR _desc$4[ebp+8], 1
	mov	DWORD PTR _desc$4[ebp+12], 65536	; 00010000H
	mov	DWORD PTR _desc$4[ebp+16], 0
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN329@ImGui_Impl
$LN22@ImGui_Impl:

; 132  :       return;
; 133  :   }
; 134  : 
; 135  :   if ((! g_pIB) || g_IndexBufferSize < draw_data->TotalIdxCount)

	cmp	DWORD PTR ?g_pIB@@3PAUID3D11Buffer@@A, 0
	je	SHORT $LN24@ImGui_Impl
	mov	eax, DWORD PTR ?g_IndexBufferSize@@3HA
	cmp	eax, DWORD PTR [edi+16]
	jge	SHORT $LN25@ImGui_Impl
$LN24@ImGui_Impl:

; 136  :   {
; 137  :     SK_COM_ValidateRelease ((IUnknown **)&g_pIB);

	push	OFFSET ?g_pIB@@3PAUID3D11Buffer@@A
	call	?SK_COM_ValidateRelease@@YAPAUIUnknown@@PAPAU1@@Z ; SK_COM_ValidateRelease

; 138  : 
; 139  :     g_IndexBufferSize   =

	mov	eax, DWORD PTR [edi+16]

; 140  :       draw_data->TotalIdxCount + 10000;
; 141  : 
; 142  :     D3D11_BUFFER_DESC desc
; 143  :                         = { };
; 144  : 
; 145  :     desc.Usage          = D3D11_USAGE_DYNAMIC;
; 146  :     desc.ByteWidth      = g_IndexBufferSize * sizeof (ImDrawIdx);
; 147  :     desc.BindFlags      = D3D11_BIND_INDEX_BUFFER;
; 148  :     desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
; 149  : 
; 150  :     if (pDevice->CreateBuffer (&desc, nullptr, &g_pIB) < 0)

	lea	edx, DWORD PTR _desc$3[ebp]
	add	eax, 10000				; 00002710H
	add	esp, 4
	mov	DWORD PTR ?g_IndexBufferSize@@3HA, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _desc$3[ebp], xmm0
	add	eax, eax
	mov	DWORD PTR _desc$3[ebp+4], 2
	movq	QWORD PTR _desc$3[ebp+16], xmm0
	mov	DWORD PTR _desc$3[ebp], eax
	mov	eax, DWORD PTR _pDevice$[ebp]
	push	OFFSET ?g_pIB@@3PAUID3D11Buffer@@A
	push	0
	mov	DWORD PTR _desc$3[ebp+8], 2
	mov	DWORD PTR _desc$3[ebp+12], 65536	; 00010000H
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN329@ImGui_Impl
$LN25@ImGui_Impl:

; 151  :       return;
; 152  :   }
; 153  : 
; 154  :   // Copy and convert all vertices into a single contiguous buffer
; 155  :   D3D11_MAPPED_SUBRESOURCE vtx_resource = { },
; 156  :                            idx_resource = { };
; 157  : 
; 158  :   if (pDevCtx->Map (g_pVB, 0, D3D11_MAP_WRITE_DISCARD, 0, &vtx_resource) != S_OK)

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	lea	edx, DWORD PTR _vtx_resource$[ebp]
	push	edx
	push	0
	push	4
	xorps	xmm0, xmm0
	mov	DWORD PTR _vtx_resource$[ebp+8], 0
	push	0
	push	DWORD PTR ?g_pVB@@3PAUID3D11Buffer@@A
	movq	QWORD PTR _vtx_resource$[ebp], xmm0
	movq	QWORD PTR _idx_resource$[ebp], xmm0
	mov	DWORD PTR _idx_resource$[ebp+8], 0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+56]
	test	eax, eax
	jne	$LN329@ImGui_Impl

; 159  :     return;
; 160  : 
; 161  :   if (pDevCtx->Map (g_pIB, 0, D3D11_MAP_WRITE_DISCARD, 0, &idx_resource) != S_OK)

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	lea	edx, DWORD PTR _idx_resource$[ebp]
	push	edx
	push	0
	push	4
	mov	ecx, DWORD PTR [eax]
	push	0
	push	DWORD PTR ?g_pIB@@3PAUID3D11Buffer@@A
	push	eax
	call	DWORD PTR [ecx+56]
	test	eax, eax
	je	SHORT $LN27@ImGui_Impl

; 162  :   {
; 163  :     // If for some reason the first one succeeded, but this one failed.... unmap the first one
; 164  :     //   then abandon all hope.
; 165  :     pDevCtx->Unmap (g_pVB, 0);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	0
	push	DWORD PTR ?g_pVB@@3PAUID3D11Buffer@@A
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+60]
	jmp	$LN329@ImGui_Impl
$LN27@ImGui_Impl:

; 166  :     return;
; 167  :   }
; 168  : 
; 169  :   auto* vtx_dst = static_cast <ImDrawVert *> (vtx_resource.pData);

	mov	edx, DWORD PTR _vtx_resource$[ebp]

; 170  :   auto* idx_dst = static_cast <ImDrawIdx  *> (idx_resource.pData);
; 171  : 
; 172  :   for (int n = 0; n < draw_data->CmdListsCount; n++)

	xor	ecx, ecx
	mov	eax, DWORD PTR _idx_resource$[ebp]
	mov	DWORD PTR _vtx_dst$1$[ebp], edx
	mov	DWORD PTR _idx_dst$1$[ebp], eax
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	DWORD PTR [edi+8], ecx
	jle	$LN3@ImGui_Impl
$LL4@ImGui_Impl:

; 173  :   {
; 174  :     const ImDrawList* cmd_list =
; 175  :       draw_data->CmdLists [n];
; 176  : 
; 177  :     if (config.imgui.render.disable_alpha)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+312, 0
	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _cmd_list$1$[ebp], esi
	je	$LN6@ImGui_Impl

; 178  :     {
; 179  :       for (INT i = 0; i < cmd_list->VtxBuffer.Size; i++)

	cmp	DWORD PTR [esi+24], 0
	mov	DWORD PTR _i$1$[ebp], 0
	jle	$LN6@ImGui_Impl
	xor	edi, edi
	npad	5
$LL7@ImGui_Impl:

; 180  :       {
; 181  :         ImU32& color =

	mov	esi, DWORD PTR [esi+32]
	mov	DWORD PTR tv2318[ebp], esi

; 182  :           cmd_list->VtxBuffer.Data [i].col;
; 183  : 
; 184  :         uint8_t alpha = (((color & 0xFF000000U) >> 24U) & 0xFFU);

	mov	cl, BYTE PTR [edi+esi+19]
	mov	BYTE PTR _alpha$1$[ebp], cl

; 185  : 
; 186  :         // Boost alpha for visibility
; 187  :         if (alpha < 93 && alpha != 0)

	cmp	cl, 93					; 0000005dH
	jae	SHORT $LN29@ImGui_Impl
	test	cl, cl
	je	SHORT $LN29@ImGui_Impl

; 188  :           alpha += (93  - alpha) / 2;

	movzx	ecx, cl
	mov	eax, 93					; 0000005dH
	sub	eax, ecx
	mov	cl, BYTE PTR _alpha$1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	cl, al
$LN29@ImGui_Impl:

; 189  : 
; 190  :         float a = ((float)                       alpha / 255.0f);

	movzx	eax, cl
	movd	xmm1, eax

; 191  :         float r = ((float)((color & 0xFF0000U) >> 16U) / 255.0f);
; 192  :         float g = ((float)((color & 0x00FF00U) >>  8U) / 255.0f);
; 193  :         float b = ((float)((color & 0x0000FFU)       ) / 255.0f);
; 194  : 
; 195  :         color =                    0xFF000000U  |

	movzx	eax, BYTE PTR [edi+esi+18]
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	mulss	xmm1, DWORD PTR __real@3b808081
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _a$1$[ebp], xmm1
	mulss	xmm0, xmm1
	call	__ftoui3
	mov	esi, eax
	mov	eax, DWORD PTR tv2318[ebp]
	or	esi, -256				; ffffff00H
	shl	esi, 8
	movzx	ecx, BYTE PTR [edi+eax+17]
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _a$1$[ebp]
	call	__ftoui3
	or	esi, eax
	mov	eax, DWORD PTR tv2318[ebp]
	shl	esi, 8
	movzx	eax, BYTE PTR [edi+eax+16]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _a$1$[ebp]
	call	__ftoui3
	or	esi, eax
	mov	eax, DWORD PTR tv2318[ebp]
	mov	DWORD PTR [edi+eax+16], esi
	add	edi, 20					; 00000014H
	mov	eax, DWORD PTR _i$1$[ebp]
	mov	esi, DWORD PTR _cmd_list$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+24]
	jl	$LL7@ImGui_Impl
	mov	edi, DWORD PTR _draw_data$[ebp]
	mov	edx, DWORD PTR _vtx_dst$1$[ebp]
$LN6@ImGui_Impl:

; 196  :                 ((UINT)((r * a) * 255U) << 16U) |
; 197  :                 ((UINT)((g * a) * 255U) <<  8U) |
; 198  :                 ((UINT)((b * a) * 255U)       );
; 199  :       }
; 200  :     }
; 201  : 
; 202  :     memcpy (vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof (ImDrawVert));

	mov	eax, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+32]
	push	edx
	call	_memcpy

; 203  :     memcpy (idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof (ImDrawIdx));

	mov	eax, DWORD PTR [esi+12]
	add	eax, eax
	push	eax
	push	DWORD PTR [esi+20]
	push	DWORD PTR _idx_dst$1$[ebp]
	call	_memcpy

; 204  : 
; 205  :     vtx_dst += cmd_list->VtxBuffer.Size;

	mov	eax, DWORD PTR [esi+24]
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _vtx_dst$1$[ebp]

; 206  :     idx_dst += cmd_list->IdxBuffer.Size;

	mov	ecx, DWORD PTR _idx_dst$1$[ebp]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _vtx_dst$1$[ebp], edx
	lea	ecx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _idx_dst$1$[ebp], ecx
	mov	ecx, DWORD PTR _n$1$[ebp]
	inc	ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+8]
	jl	$LL4@ImGui_Impl
$LN3@ImGui_Impl:

; 207  :   }
; 208  : 
; 209  :   pDevCtx->Unmap (g_pVB, 0);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	0
	push	DWORD PTR ?g_pVB@@3PAUID3D11Buffer@@A
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+60]

; 210  :   pDevCtx->Unmap (g_pIB, 0);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	0
	push	DWORD PTR ?g_pIB@@3PAUID3D11Buffer@@A
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+60]

; 211  : 
; 212  :   // Setup orthographic projection matrix into our constant buffer
; 213  :   {
; 214  :     D3D11_MAPPED_SUBRESOURCE mapped_resource;
; 215  : 
; 216  :     if (pDevCtx->Map (g_pVertexConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped_resource) != S_OK)

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	lea	edx, DWORD PTR _mapped_resource$9[ebp]
	push	edx
	push	0
	push	4
	mov	ecx, DWORD PTR [eax]
	push	0
	push	DWORD PTR ?g_pVertexConstantBuffer@@3PAUID3D11Buffer@@A
	push	eax
	call	DWORD PTR [ecx+56]
	test	eax, eax
	jne	$LN329@ImGui_Impl

; 217  :       return;
; 218  : 
; 219  :     auto* constant_buffer =
; 220  :       static_cast <VERTEX_CONSTANT_BUFFER *> (mapped_resource.pData);

	mov	esi, DWORD PTR _mapped_resource$9[ebp]

; 221  : 
; 222  :     float L = 0.0f;
; 223  :     float R = ImGui::GetIO ().DisplaySize.x;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR tv2475[ebp], xmm0

; 224  :     float B = ImGui::GetIO ().DisplaySize.y;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 225  :     float T = 0.0f;
; 226  : 
; 227  :     float mvp [4][4] =
; 228  :     {
; 229  :       { 2.0f/(R-L),   0.0f,           0.0f,       0.0f },

	movss	xmm3, DWORD PTR tv2475[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm3

; 230  :       { 0.0f,         2.0f/(T-B),     0.0f,       0.0f },
; 231  :       { 0.0f,         0.0f,           0.5f,       0.0f },

	mov	DWORD PTR _mvp$2[ebp+40], 1056964608	; 3f000000H
	mov	DWORD PTR _mvp$2[ebp+44], 0

; 232  :       { (R+L)/(L-R),  (T+B)/(B-T),    0.5f,       1.0f },

	mov	DWORD PTR _mvp$2[ebp+56], 1056964608	; 3f000000H
	mov	DWORD PTR _mvp$2[ebp+60], 1065353216	; 3f800000H

; 233  :     };
; 234  : 
; 235  :     memcpy         (&constant_buffer->mvp, mvp, sizeof (mvp));
; 236  :     pDevCtx->Unmap (g_pVertexConstantBuffer, 0);

	push	0
	movss	xmm2, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR __real@bf800000
	addss	xmm0, xmm0
	movss	DWORD PTR _mvp$2[ebp], xmm0
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _mvp$2[ebp+4], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, xmm2
	divss	xmm1, xmm3
	divss	xmm2, xmm2
	addss	xmm0, xmm0
	mulss	xmm1, xmm3
	movss	DWORD PTR _mvp$2[ebp+52], xmm2
	movss	DWORD PTR _mvp$2[ebp+48], xmm1
	movss	DWORD PTR _mvp$2[ebp+20], xmm0
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _mvp$2[ebp+24], xmm0
	movups	xmm0, XMMWORD PTR _mvp$2[ebp]
	movups	XMMWORD PTR [esi], xmm0
	movups	xmm0, XMMWORD PTR _mvp$2[ebp+16]
	movups	XMMWORD PTR [esi+16], xmm0
	movups	xmm0, XMMWORD PTR _mvp$2[ebp+32]
	movups	XMMWORD PTR [esi+32], xmm0
	movups	xmm0, XMMWORD PTR _mvp$2[ebp+48]
	movups	XMMWORD PTR [esi+48], xmm0
	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	DWORD PTR ?g_pVertexConstantBuffer@@3PAUID3D11Buffer@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+60]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pRenderTargetView$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 241  :   D3D11_TEXTURE2D_DESC   tex2d_desc = { };

	push	44					; 0000002cH
	lea	eax, DWORD PTR _tex2d_desc$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	0
	push	eax
	call	_memset

; 242  :   pBackBuffer->GetDesc (&tex2d_desc);

	mov	eax, DWORD PTR _pBackBuffer$[ebp]
	lea	edx, DWORD PTR _tex2d_desc$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+40]

; 243  : 
; 244  :   // SRGB Correction for UIs
; 245  :   switch (tex2d_desc.Format)

	mov	eax, DWORD PTR _tex2d_desc$[ebp+16]
	add	eax, -10				; fffffff6H
	cmp	eax, 81					; 00000051H
	ja	$LN34@ImGui_Impl
	movzx	eax, BYTE PTR $LN394@ImGui_Impl[eax]
	jmp	DWORD PTR $LN404@ImGui_Impl[eax*4]
$LN31@ImGui_Impl:

; 246  :   {
; 247  :     case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
; 248  :     case DXGI_FORMAT_R8G8B8A8_TYPELESS:
; 249  :     {
; 250  :       D3D11_RENDER_TARGET_VIEW_DESC rtdesc
; 251  :                            = { };
; 252  : 
; 253  :       rtdesc.Format        = DXGI_FORMAT_R8G8B8A8_UNORM;
; 254  :       rtdesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
; 255  : 
; 256  :       pDevice->CreateRenderTargetView (pBackBuffer, &rtdesc, &pRenderTargetView);

	lea	edx, DWORD PTR _pRenderTargetView$[ebp]
	mov	DWORD PTR _rtdesc$7[ebp+16], 0
	push	edx
	xorps	xmm0, xmm0
	lea	edx, DWORD PTR _rtdesc$7[ebp]
	movups	XMMWORD PTR _rtdesc$7[ebp], xmm0
	mov	DWORD PTR _rtdesc$7[ebp], 28		; 0000001cH
	mov	DWORD PTR _rtdesc$7[ebp+4], 4
	push	edx

; 257  :     } break;

	jmp	SHORT $LN402@ImGui_Impl
$LN32@ImGui_Impl:

; 258  : 
; 259  :     case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
; 260  :     case DXGI_FORMAT_B8G8R8A8_TYPELESS:
; 261  :     {
; 262  :       D3D11_RENDER_TARGET_VIEW_DESC rtdesc
; 263  :                            = { };
; 264  : 
; 265  :       rtdesc.Format        = DXGI_FORMAT_B8G8R8A8_UNORM;
; 266  :       rtdesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
; 267  : 
; 268  :       pDevice->CreateRenderTargetView (pBackBuffer, &rtdesc, &pRenderTargetView);

	lea	edx, DWORD PTR _pRenderTargetView$[ebp]
	mov	DWORD PTR _rtdesc$6[ebp+16], 0
	push	edx
	xorps	xmm0, xmm0
	lea	edx, DWORD PTR _rtdesc$6[ebp]
	movups	XMMWORD PTR _rtdesc$6[ebp], xmm0
	mov	DWORD PTR _rtdesc$6[ebp], 87		; 00000057H
	mov	DWORD PTR _rtdesc$6[ebp+4], 4
	push	edx

; 269  :     } break;

	jmp	SHORT $LN402@ImGui_Impl
$LN33@ImGui_Impl:

; 270  : 
; 271  :     case DXGI_FORMAT_R16G16B16A16_FLOAT:
; 272  :     {
; 273  :       D3D11_RENDER_TARGET_VIEW_DESC rtdesc
; 274  :                            = { };
; 275  : 
; 276  :       rtdesc.Format        = DXGI_FORMAT_R16G16B16A16_FLOAT;
; 277  :       rtdesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
; 278  : 
; 279  :       pDevice->CreateRenderTargetView (pBackBuffer, &rtdesc, &pRenderTargetView);

	lea	edx, DWORD PTR _pRenderTargetView$[ebp]
	mov	DWORD PTR _rtdesc$5[ebp+16], 0
	push	edx
	xorps	xmm0, xmm0
	lea	edx, DWORD PTR _rtdesc$5[ebp]
	movups	XMMWORD PTR _rtdesc$5[ebp], xmm0
	mov	DWORD PTR _rtdesc$5[ebp], 10		; 0000000aH
	mov	DWORD PTR _rtdesc$5[ebp+4], 4
	push	edx

; 280  :     } break;

	jmp	SHORT $LN402@ImGui_Impl
$LN34@ImGui_Impl:

; 281  : 
; 282  :     default:
; 283  :      pDevice->CreateRenderTargetView (pBackBuffer, nullptr, &pRenderTargetView);

	lea	edx, DWORD PTR _pRenderTargetView$[ebp]
	push	edx
	push	0
$LN402@ImGui_Impl:
	mov	eax, DWORD PTR _pDevice$[ebp]
	push	DWORD PTR _pBackBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+36]

; 284  :   }
; 285  : 
; 286  :   pDevCtx->OMSetRenderTargets ( 1,

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	lea	edx, DWORD PTR _pRenderTargetView$[ebp]
	push	0
	push	edx
	push	1
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+132]
	xorps	xmm0, xmm0

; 287  :                                   &pRenderTargetView,
; 288  :                                     nullptr );
; 289  : 
; 290  :   // Setup viewport
; 291  :   D3D11_VIEWPORT vp = { };

	movups	XMMWORD PTR _vp$[ebp], xmm0
	movq	QWORD PTR _vp$[ebp+16], xmm0

; 292  : 
; 293  :   vp.Height   = ImGui::GetIO ().DisplaySize.y;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR _vp$[ebp+12], xmm0

; 294  :   vp.Width    = ImGui::GetIO ().DisplaySize.x;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 295  :   vp.MinDepth = 0.0f;
; 296  :   vp.MaxDepth = 1.0f;
; 297  :   vp.TopLeftX = vp.TopLeftY = 0.0f;
; 298  : 
; 299  :   pDevCtx->RSSetViewports (1, &vp);

	lea	edx, DWORD PTR _vp$[ebp]
	push	edx
	push	1
	movss	xmm0, DWORD PTR [eax]
	mov	eax, DWORD PTR _pDevCtx$[ebp]
	movss	DWORD PTR _vp$[ebp+8], xmm0
	mov	DWORD PTR _vp$[ebp+16], 0
	mov	DWORD PTR _vp$[ebp+20], 1065353216	; 3f800000H
	mov	DWORD PTR _vp$[ebp+4], 0
	mov	DWORD PTR _vp$[ebp], 0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+176]

; 300  : 
; 301  :   // Bind shader and vertex buffers
; 302  :   unsigned int stride = sizeof (ImDrawVert);
; 303  :   unsigned int offset = 0;
; 304  : 
; 305  :   pDevCtx->IASetInputLayout       (g_pInputLayout);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	DWORD PTR ?g_pInputLayout@@3PAUID3D11InputLayout@@A
	mov	DWORD PTR _stride$[ebp], 20		; 00000014H
	mov	DWORD PTR _offset$[ebp], 0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+68]

; 306  :   pDevCtx->IASetVertexBuffers     (0, 1, &g_pVB, &stride, &offset);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	lea	edx, DWORD PTR _stride$[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ?g_pVB@@3PAUID3D11Buffer@@A
	push	1
	push	0
	push	eax
	call	DWORD PTR [ecx+72]

; 307  :   pDevCtx->IASetIndexBuffer       ( g_pIB, sizeof (ImDrawIdx) == 2 ?

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	0
	push	57					; 00000039H
	push	DWORD PTR ?g_pIB@@3PAUID3D11Buffer@@A
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+76]

; 308  :                                              DXGI_FORMAT_R16_UINT  :
; 309  :                                              DXGI_FORMAT_R32_UINT,
; 310  :                                                0 );
; 311  :   pDevCtx->IASetPrimitiveTopology (D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+96]

; 312  : 
; 313  :   pDevCtx->VSSetShader            (g_pVertexShader, nullptr, 0);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	0
	push	0
	push	DWORD PTR ?g_pVertexShader@@3PAUID3D11VertexShader@@A
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+44]

; 314  :   pDevCtx->VSSetConstantBuffers   (0, 1, &g_pVertexConstantBuffer);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	OFFSET ?g_pVertexConstantBuffer@@3PAUID3D11Buffer@@A
	push	1
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+28]

; 315  : 
; 316  : 
; 317  :   pDevCtx->PSSetShader            (g_pPixelShader, nullptr, 0);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	0
	push	0
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR ?g_pPixelShader@@3PAUID3D11PixelShader@@A
	push	eax
	call	DWORD PTR [ecx+36]

; 318  :   pDevCtx->PSSetSamplers          (0, 1, &g_pFontSampler);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	OFFSET ?g_pFontSampler@@3PAUID3D11SamplerState@@A
	push	1
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+40]

; 319  : 
; 320  :   // Setup render state
; 321  :   const float blend_factor [4] = { 0.f, 0.f,
; 322  :                                    0.f, 0.f };
; 323  : 
; 324  :   pDevCtx->OMSetBlendState        (g_pBlendState, blend_factor, 0xffffffff);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	lea	edx, DWORD PTR _blend_factor$[ebp]
	push	-1
	xorps	xmm0, xmm0
	push	edx
	push	DWORD PTR ?g_pBlendState@@3PAUID3D11BlendState@@A
	movups	XMMWORD PTR _blend_factor$[ebp], xmm0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+140]

; 325  :   pDevCtx->OMSetDepthStencilState (g_pDepthStencilState,        0);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	0
	push	DWORD PTR ?g_pDepthStencilState@@3PAUID3D11DepthStencilState@@A
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+144]

; 326  :   pDevCtx->RSSetState             (g_pRasterizerState);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	DWORD PTR ?g_pRasterizerState@@3PAUID3D11RasterizerState@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+172]

; 327  : 
; 328  :   // Render command lists
; 329  :   int vtx_offset = 0;

	xor	ecx, ecx

; 330  :   int idx_offset = 0;
; 331  : 
; 332  :   for (int n = 0; n < draw_data->CmdListsCount; n++)

	xor	edx, edx
	mov	DWORD PTR _vtx_offset$1$[ebp], ecx
	mov	DWORD PTR _idx_offset$1$[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	DWORD PTR [edi+8], ecx
	jle	$LN11@ImGui_Impl
$LL12@ImGui_Impl:

; 333  :   {
; 334  :     const ImDrawList* cmd_list =
; 335  :       draw_data->CmdLists [n];

	mov	eax, DWORD PTR [edi+4]

; 336  : 
; 337  :     for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	mov	DWORD PTR _cmd_i$1$[ebp], 0
	mov	edi, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [edi], 0
	jle	$LN14@ImGui_Impl

; 333  :   {
; 334  :     const ImDrawList* cmd_list =
; 335  :       draw_data->CmdLists [n];

	xor	ecx, ecx
	mov	DWORD PTR tv2469[ebp], ecx
	npad	5
$LL15@ImGui_Impl:

; 336  : 
; 337  :     for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	mov	esi, DWORD PTR [edi+8]
	add	esi, ecx

; 338  :     {
; 339  :       const ImDrawCmd* pcmd =
; 340  :         &cmd_list->CmdBuffer [cmd_i];
; 341  : 
; 342  :       if (pcmd->UserCallback)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN35@ImGui_Impl

; 343  :         pcmd->UserCallback (cmd_list, pcmd);

	push	esi
	push	edi
	call	eax
	add	esp, 8

; 344  : 
; 345  :       else

	jmp	SHORT $LN36@ImGui_Impl
$LN35@ImGui_Impl:

; 346  :       {
; 347  :         const D3D11_RECT r = {
; 348  :           static_cast <LONG> (pcmd->ClipRect.x), static_cast <LONG> (pcmd->ClipRect.y),

	xor	ecx, ecx
	lea	edx, DWORD PTR [esi+4]
	npad	6
$LL368@ImGui_Impl:
	cvttss2si eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR _r$8[ebp+ecx*4], eax
	inc	ecx
	cmp	ecx, 4
	jl	SHORT $LL368@ImGui_Impl

; 349  :           static_cast <LONG> (pcmd->ClipRect.z), static_cast <LONG> (pcmd->ClipRect.w)
; 350  :         };
; 351  : 
; 352  :         pDevCtx->PSSetShaderResources (0, 1, (ID3D11ShaderResourceView **)&pcmd->TextureId);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	lea	ecx, DWORD PTR [esi+20]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [edx+32]

; 353  :         pDevCtx->RSSetScissorRects    (1, &r);

	mov	eax, DWORD PTR _pDevCtx$[ebp]
	lea	edx, DWORD PTR _r$8[ebp]
	push	edx
	push	1
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+180]

; 354  : 
; 355  :         pDevCtx->DrawIndexed (pcmd->ElemCount, idx_offset, vtx_offset);

	push	DWORD PTR _vtx_offset$1$[ebp]
	mov	eax, DWORD PTR _pDevCtx$[ebp]
	push	DWORD PTR _idx_offset$1$[ebp]
	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+48]
$LN36@ImGui_Impl:

; 356  :       }
; 357  : 
; 358  :       idx_offset += pcmd->ElemCount;

	mov	eax, DWORD PTR _cmd_i$1$[ebp]
	mov	edx, DWORD PTR _idx_offset$1$[ebp]
	inc	eax
	mov	ecx, DWORD PTR tv2469[ebp]
	add	edx, DWORD PTR [esi]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _idx_offset$1$[ebp], edx
	mov	DWORD PTR _cmd_i$1$[ebp], eax
	mov	DWORD PTR tv2469[ebp], ecx
	cmp	eax, DWORD PTR [edi]
	jl	$LL15@ImGui_Impl
	mov	ecx, DWORD PTR _vtx_offset$1$[ebp]
	mov	edx, DWORD PTR _n$1$[ebp]
$LN14@ImGui_Impl:

; 359  :     }
; 360  : 
; 361  :     vtx_offset += cmd_list->VtxBuffer.Size;

	add	ecx, DWORD PTR [edi+24]
	inc	edx
	mov	edi, DWORD PTR _draw_data$[ebp]
	mov	DWORD PTR _vtx_offset$1$[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	edx, DWORD PTR [edi+8]
	jl	$LL12@ImGui_Impl
$LN11@ImGui_Impl:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pRenderTargetView$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 363  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN329@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN329@ImGui_Impl:

; 176  :         if (p)

	mov	eax, DWORD PTR _pBackBuffer$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 363  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN335@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN335@ImGui_Impl:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevCtx$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 363  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN341@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN341@ImGui_Impl:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 363  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN347@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN347@ImGui_Impl:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 363  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN395@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN395@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	eax, DWORD PTR _auto_bool$[ebp]
	mov	ecx, DWORD PTR _auto_bool$1$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 363  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN396@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	ecx, DWORD PTR _auto_bool$1$[ebp]
	mov	DWORD PTR [edi], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 363  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN404@ImGui_Impl:
	DD	$LN33@ImGui_Impl
	DD	$LN31@ImGui_Impl
	DD	$LN32@ImGui_Impl
	DD	$LN34@ImGui_Impl
$LN394@ImGui_Impl:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$0:
	lea	ecx, DWORD PTR _auto_bool$[ebp]
	jmp	??1SK_ScopedBool@@QAE@XZ		; SK_ScopedBool::~SK_ScopedBool
__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$1:
	lea	ecx, DWORD PTR _pSwapChain$[ebp]
	jmp	??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ
__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$2:
	lea	ecx, DWORD PTR _pDevice$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$3:
	lea	ecx, DWORD PTR _pDevCtx$[ebp]
	jmp	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$4:
	lea	ecx, DWORD PTR _pBackBuffer$[ebp]
	jmp	??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
__unwindfunclet$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z$5:
	lea	ecx, DWORD PTR _pRenderTargetView$[ebp]
	jmp	??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ
__ehhandler$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z ENDP ; ImGui_ImplDX11_RenderDrawLists
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
;	COMDAT ??1SK_ScopedBool@@QAE@XZ
_TEXT	SEGMENT
??1SK_ScopedBool@@QAE@XZ PROC				; SK_ScopedBool::~SK_ScopedBool, COMDAT
; _this$ = ecx

; 144  :     *pBool_ = bOrig_;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 145  :   }

	ret	0
??1SK_ScopedBool@@QAE@XZ ENDP				; SK_ScopedBool::~SK_ScopedBool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
;	COMDAT ??0SK_ScopedBool@@QAE@PAH@Z
_TEXT	SEGMENT
_pBool$ = 8						; size = 4
??0SK_ScopedBool@@QAE@PAH@Z PROC			; SK_ScopedBool::SK_ScopedBool, COMDAT
; _this$ = ecx

; 136  :   SK_ScopedBool (BOOL* pBool)

	npad	2
	push	ebp
	mov	ebp, esp

; 137  :   {
; 138  :     pBool_ =  pBool;

	mov	eax, DWORD PTR _pBool$[ebp]
	mov	DWORD PTR [ecx], eax

; 139  :     bOrig_ = *pBool;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 140  :   }

	mov	eax, ecx
	pop	ebp
	ret	4
??0SK_ScopedBool@@QAE@PAH@Z ENDP			; SK_ScopedBool::SK_ScopedBool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
	test	eax, eax
	je	SHORT $LN29@dynamic

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN29@dynamic:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
	ret	0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2979 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET ??__F_AtlWinModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlWinModule''
	call	_atexit
	pop	ecx
	ret	0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	ecx
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2965 : 	}

	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2958 : 	{

	npad	2
	push	esi

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4

; 2958 : 	{

	mov	esi, ecx

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	esi
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN26@CAtlWinMod

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN26@CAtlWinMod:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2960 : 	}

	ret	0
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2944 : 	CAtlWinModule()

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [esi+4], xmm0
	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2944 : 	CAtlWinModule()

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2946 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	DWORD PTR [esi], 44			; 0000002cH

; 8412 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN26@CAtlWinMod

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN27@CAtlWinMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2948 : 		if (FAILED(hr))

	test	eax, eax
$LN27@CAtlWinMod:

; 2953 : 			return;
; 2954 : 		}
; 2955 : 	}

	mov	eax, esi

; 2948 : 		if (FAILED(hr))

	jns	SHORT $LN2@CAtlWinMod

; 2949 : 		{
; 2950 : 			ATLASSERT(0);
; 2951 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2952 : 			cbSize = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 2953 : 			return;
; 2954 : 		}
; 2955 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@CAtlWinMod:
	mov	eax, esi
$LN2@CAtlWinMod:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__F_AtlComModule@ATL@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 2615 : 		Term();

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2616 : 	}

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__F_AtlComModule@ATL@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN4@dynamic

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN20@dynamic
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2602 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN20@dynamic:
	jns	SHORT $LN4@dynamic

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2606 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
$LN4@dynamic:
	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2610 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2620 : 	{

	npad	2
	push	edi
	mov	edi, ecx

; 2621 : 		if (cbSize == 0)

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN1@Term

; 2622 : 			return;
; 2623 : 
; 2624 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	push	esi
	mov	esi, DWORD PTR [edi+8]
	cmp	esi, DWORD PTR [edi+12]
	jae	SHORT $LN3@Term
	push	ebx
$LL4@Term:

; 2625 : 		{
; 2626 : 			if (*ppEntry != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Term

; 2627 : 			{
; 2628 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

	mov	ebx, DWORD PTR [eax+16]

; 2629 : 
; 2630 : 				if (pCache->pCF != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN2@Term

; 2631 : 				{
; 2632 : 					// Decode factory pointer if it's not null
; 2633 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

	push	eax
	call	DWORD PTR __imp__DecodePointer@4

; 2634 : 					_Analysis_assume_(factory != nullptr);
; 2635 : 					factory->Release();

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 2636 : 					pCache->pCF = NULL;

	mov	DWORD PTR [ebx], 0
$LN2@Term:

; 2622 : 			return;
; 2623 : 
; 2624 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	add	esi, 4
	cmp	esi, DWORD PTR [edi+12]
	jb	SHORT $LL4@Term
	pop	ebx
$LN3@Term:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2644 : 		cbSize = 0;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN1@Term:
	pop	edi

; 2645 : 	}

	ret	0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2614 : 	{

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1CAtlComModule@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 2615 : 		Term();

	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2616 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2593 : 	CAtlComModule() throw()

	npad	2
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [eax], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2595 : 		cbSize = 0;

	mov	DWORD PTR [esi], 0

; 2596 : 
; 2597 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

	mov	DWORD PTR [esi+4], OFFSET ___ImageBase

; 2598 : 
; 2599 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

	mov	DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4

; 2600 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

	mov	DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN2@CAtlComMod

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN18@CAtlComMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2602 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN18@CAtlComMod:
	jns	SHORT $LN2@CAtlComMod

; 2611 : 	}

	mov	eax, esi
	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
	pop	esi
	ret	0
$LN2@CAtlComMod:

; 2603 : 		{
; 2604 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2605 : 			ATLASSERT(0);
; 2606 : 			CAtlBaseModule::m_bInitFailed = true;
; 2607 : 			return;
; 2608 : 		}
; 2609 : 		// Set cbSize on success.
; 2610 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR [esi], 40			; 00000028H

; 2611 : 	}

	mov	eax, esi
	pop	esi
	ret	0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7660 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 7661 : 	if (pWinModule == NULL)

	mov	esi, DWORD PTR _pWinModule$[ebp]
	test	esi, esi
	jne	SHORT $LN5@AtlWinModu
$LN35@AtlWinModu:

; 7662 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	pop	esi

; 7674 : }

	pop	ebp
	ret	8
$LN5@AtlWinModu:

; 7663 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN34@AtlWinModu

; 7664 : 		return S_OK;
; 7665 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN35@AtlWinModu

; 7666 : 		return E_INVALIDARG;
; 7667 : 
; 7668 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+36], edi
	jle	SHORT $LN3@AtlWinModu

; 7669 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	push	ebx
	mov	ebx, DWORD PTR _hInst$[ebp]
	npad	2
$LL4@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

	test	edi, edi
	js	SHORT $LN36@AtlWinModu
	cmp	edi, DWORD PTR [esi+36]
	jge	SHORT $LN36@AtlWinModu
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 7669 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	eax, DWORD PTR [esi+32]
	push	ebx
	movzx	eax, WORD PTR [eax+edi*2]
	push	eax
	call	DWORD PTR __imp__UnregisterClassW@8
	inc	edi
	cmp	edi, DWORD PTR [esi+36]
	jl	SHORT $LL4@AtlWinModu
	pop	ebx
$LN3@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	pop	edi
	test	eax, eax
	je	SHORT $LN20@AtlWinModu

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN20@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 223  : 		m_nSize = 0;

	mov	DWORD PTR [esi+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 7672 : 	pWinModule->cbSize = 0;

	mov	DWORD PTR [esi], 0
$LN34@AtlWinModu:

; 7673 : 	return S_OK;

	xor	eax, eax
	pop	esi

; 7674 : }

	pop	ebp
	ret	8
$LN36@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN37@AtlWinModu:
$LN33@AtlWinModu:
	int	3
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8404 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8405 : 	if (pWinModule == NULL)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	test	eax, eax
	jne	SHORT $LN2@AtlWinModu
$LN15@AtlWinModu:

; 8406 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 8421 : }

	pop	ebp
	ret	4
$LN2@AtlWinModu:

; 8407 : 
; 8408 : 	// check only in the DLL
; 8409 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	DWORD PTR [eax], 44			; 0000002cH
	jne	SHORT $LN15@AtlWinModu
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 170  : 		HRESULT hRes = S_OK;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 8412 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	esi
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN14@AtlWinModu

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	esi, eax
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	esi, esi
	jle	SHORT $LN14@AtlWinModu
	movzx	esi, si
	or	esi, -2147024896			; 80070000H
$LN14@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 8420 : 	return hr;

	mov	eax, esi
	pop	esi

; 8421 : }

	pop	ebp
	ret	4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN19@ATL_WIN_MO

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN19@ATL_WIN_MO:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [ecx+4], xmm0
	mov	eax, ecx
	movq	QWORD PTR [ecx+20], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

	npad	2
	push	ebp
	mov	ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

	mov	edx, DWORD PTR _nIndex$[ebp]
	test	edx, edx
	js	SHORT $LN6@operator
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN6@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*2]

; 243  : 	}

	pop	ebp
	ret	4
$LN6@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN7@operator:
$LN5@operator:
	int	3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN11@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 225  :     }

	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 161  : 		return m_nSize;

	mov	eax, DWORD PTR [ecx+4]

; 162  : 	}

	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@CSimpleArr

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN13@CSimpleArr:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 311  : 	RemoveAll();
; 312  : }

	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [ecx], 0

; 121  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	ret	0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	mov	eax, ecx

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [ecx+16], xmm0
	movq	QWORD PTR [ecx+32], xmm0
	ret	0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 316  : 		return m_hInst;

	mov	eax, DWORD PTR [ecx+4]

; 317  : 	}

	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 180  : 	{

	npad	2

; 181  : 		DeleteCriticalSection(&m_sec);

	push	ecx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 182  : 		return S_OK;

	xor	eax, eax

; 183  : 	}

	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	ecx
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN10@Init

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN9@Init
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 177  : 	}

	ret	0
$LN10@Init:

; 174  : 		}
; 175  : 
; 176  : 		return hRes;

	xor	eax, eax
$LN9@Init:

; 177  : 	}

	ret	0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 156  : 	}

	ret	0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 149  : 	CComCriticalSection() throw()

	xorps	xmm0, xmm0

; 150  : 	{
; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
; 152  : 	}

	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	DWORD PTR _Flags$[ebp]
	push	DWORD PTR _dwSpinCount$[ebp]
	push	DWORD PTR _lpCriticalSection$[ebp]
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

	pop	ebp
	ret	0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	push	0
	push	0
	push	DWORD PTR _dwExceptionFlags$[ebp]
	push	DWORD PTR _dwExceptionCode$[ebp]
	call	DWORD PTR __imp__RaiseException@16

; 32   : }

	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	jle	SHORT $LN4@HRESULT_FR
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
$LN4@HRESULT_FR:
	pop	ebp
	ret	0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_desc$2 = -432						; size = 264
_local_layout$3 = -168					; size = 84
_desc$4 = -84						; size = 52
_desc$5 = -72						; size = 40
_desc$6 = -56						; size = 24
_auto_bool$ = -32					; size = 8
_auto_bool$1$ = -24					; size = 4
_pDev$ = -20						; size = 4
$T7 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ PROC	; ImGui_ImplDX11_CreateDeviceObjects

; 463  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 420				; 000001a4H
	push	esi
	push	edi

; 464  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 139  :     bOrig_ = *pBool;

	mov	edi, DWORD PTR [eax+48]
	mov	DWORD PTR _auto_bool$1$[ebp], edi
	mov	DWORD PTR _auto_bool$[ebp+4], edi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 464  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	lea	esi, DWORD PTR [eax+48]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 138  :     pBool_ =  pBool;

	mov	DWORD PTR _auto_bool$[ebp], esi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 464  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 465  : 
; 466  :   // Do not dump ImGui font textures
; 467  :   SK_TLS_Bottom ()->imgui.drawing = true;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	mov	DWORD PTR [eax+48], 1

; 468  : 
; 469  :   if (g_pFontSampler)

	cmp	DWORD PTR ?g_pFontSampler@@3PAUID3D11SamplerState@@A, 0
	je	SHORT $LN2@ImGui_Impl

; 470  :     ImGui_ImplDX11_InvalidateDeviceObjects ();

	call	?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ ; ImGui_ImplDX11_InvalidateDeviceObjects
$LN2@ImGui_Impl:

; 471  : 
; 472  :   SK_RenderBackend& rb =

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend

; 473  :     SK_GetCurrentRenderBackend ();
; 474  : 
; 475  :   if (! rb.device)

	cmp	DWORD PTR [eax+36], 0
	je	$LN15@ImGui_Impl

; 476  :     return false;
; 477  : 
; 478  :   if (! rb.d3d11.immediate_ctx)

	cmp	DWORD PTR [eax+68], 0
	je	$LN15@ImGui_Impl

; 479  :     return false;
; 480  : 
; 481  :   if (! rb.swapchain)

	cmp	DWORD PTR [eax+40], 0
	je	$LN15@ImGui_Impl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 485  :   rb.device->QueryInterface <ID3D11Device> (&pDev);

	mov	eax, DWORD PTR [eax+36]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pDev$[ebp]
	push	edx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	eax
	mov	ecx, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 484  :   CComPtr                   <ID3D11Device>   pDev = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 517  :     D3DCompile ( vertexShader,

	mov	edx, DWORD PTR ?vertexShader@?L@??ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ@4PBDB
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL110@ImGui_Impl:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL110@ImGui_Impl
	push	0
	push	OFFSET ?g_pVertexShaderBlob@@3PAUID3D10Blob@@A
	push	0
	push	0
	push	OFFSET $SG244100
	push	OFFSET $SG244101
	push	0
	push	0
	push	0
	sub	ecx, esi
	push	ecx
	push	edx
	call	_D3DCompile@44

; 518  :                    strlen (vertexShader),
; 519  :                      nullptr, nullptr, nullptr,
; 520  :                        "main", "vs_4_0",
; 521  :                          0, 0,
; 522  :                            &g_pVertexShaderBlob,
; 523  :                              nullptr );
; 524  : 
; 525  :     // NB: Pass ID3D10Blob* pErrorBlob to D3DCompile() to get error showing in
; 526  :     //       (const char*)pErrorBlob->GetBufferPointer(). Make sure to Release() the blob!
; 527  :     if (g_pVertexShaderBlob == nullptr)

	mov	ecx, DWORD PTR ?g_pVertexShaderBlob@@3PAUID3D10Blob@@A
	test	ecx, ecx
	je	$LN20@ImGui_Impl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	esi, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 533  :                                           &g_pVertexShader ) != S_OK )

	mov	eax, DWORD PTR [ecx]
	push	OFFSET ?g_pVertexShader@@3PAUID3D11VertexShader@@A
	push	0
	mov	edi, DWORD PTR [esi]
	push	ecx
	call	DWORD PTR [eax+16]
	push	eax
	mov	eax, DWORD PTR ?g_pVertexShaderBlob@@3PAUID3D10Blob@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	push	eax
	push	esi
	call	DWORD PTR [edi+48]
	test	eax, eax
	jne	$LN20@ImGui_Impl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	esi, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 538  :       { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT,   0, (size_t)(&((ImDrawVert *)nullptr)->pos), D3D11_INPUT_PER_VERTEX_DATA, 0 },

	mov	DWORD PTR _local_layout$3[ebp+4], eax
	mov	DWORD PTR _local_layout$3[ebp+12], eax
	mov	DWORD PTR _local_layout$3[ebp+16], eax
	mov	DWORD PTR _local_layout$3[ebp+20], eax
	mov	DWORD PTR _local_layout$3[ebp+24], eax

; 539  :       { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,   0, (size_t)(&((ImDrawVert *)nullptr)->uv),  D3D11_INPUT_PER_VERTEX_DATA, 0 },

	mov	DWORD PTR _local_layout$3[ebp+32], eax
	mov	DWORD PTR _local_layout$3[ebp+40], eax
	mov	DWORD PTR _local_layout$3[ebp+48], eax
	mov	DWORD PTR _local_layout$3[ebp+52], eax

; 540  :       { "COLOR",    0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, (size_t)(&((ImDrawVert *)nullptr)->col), D3D11_INPUT_PER_VERTEX_DATA, 0 },

	mov	DWORD PTR _local_layout$3[ebp+60], eax
	mov	DWORD PTR _local_layout$3[ebp+68], eax
	mov	DWORD PTR _local_layout$3[ebp+76], eax
	mov	DWORD PTR _local_layout$3[ebp+80], eax

; 541  :     };
; 542  : 
; 543  :     if ( pDev->CreateInputLayout ( local_layout, 3,
; 544  :                                      g_pVertexShaderBlob->GetBufferPointer (),
; 545  :                                        g_pVertexShaderBlob->GetBufferSize  (),
; 546  :                                          &g_pInputLayout ) != S_OK )

	mov	eax, DWORD PTR ?g_pVertexShaderBlob@@3PAUID3D10Blob@@A
	mov	DWORD PTR _local_layout$3[ebp], OFFSET $SG244106
	mov	DWORD PTR _local_layout$3[ebp+8], 16	; 00000010H
	mov	DWORD PTR _local_layout$3[ebp+28], OFFSET $SG244107
	mov	DWORD PTR _local_layout$3[ebp+36], 16	; 00000010H
	mov	DWORD PTR _local_layout$3[ebp+44], 8
	mov	DWORD PTR _local_layout$3[ebp+56], OFFSET $SG244108
	mov	DWORD PTR _local_layout$3[ebp+64], 28	; 0000001cH
	mov	DWORD PTR _local_layout$3[ebp+72], 16	; 00000010H
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [esi]
	push	OFFSET ?g_pInputLayout@@3PAUID3D11InputLayout@@A
	push	eax
	call	DWORD PTR [ecx+16]
	push	eax
	mov	eax, DWORD PTR ?g_pVertexShaderBlob@@3PAUID3D10Blob@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	push	eax
	push	3
	lea	eax, DWORD PTR _local_layout$3[ebp]
	push	eax
	push	esi
	call	DWORD PTR [edi+44]
	test	eax, eax
	jne	$LN20@ImGui_Impl

; 547  :     {
; 548  :       return false;
; 549  :     }
; 550  : 
; 551  :     // Create the constant buffer
; 552  :     {
; 553  :       D3D11_BUFFER_DESC desc = { };
; 554  : 
; 555  :       desc.ByteWidth         = sizeof (VERTEX_CONSTANT_BUFFER);
; 556  :       desc.Usage             = D3D11_USAGE_DYNAMIC;
; 557  :       desc.BindFlags         = D3D11_BIND_CONSTANT_BUFFER;
; 558  :       desc.CPUAccessFlags    = D3D11_CPU_ACCESS_WRITE;
; 559  :       desc.MiscFlags         = 0;
; 560  : 
; 561  :       pDev->CreateBuffer (&desc, nullptr, &g_pVertexConstantBuffer);

	xorps	xmm0, xmm0
	lea	edx, DWORD PTR _desc$6[ebp]
	movq	QWORD PTR _desc$6[ebp+16], xmm0
	mov	DWORD PTR _desc$6[ebp+16], eax
	mov	eax, DWORD PTR _pDev$[ebp]
	movups	XMMWORD PTR _desc$6[ebp], xmm0
	push	OFFSET ?g_pVertexConstantBuffer@@3PAUID3D11Buffer@@A
	push	0
	mov	DWORD PTR _desc$6[ebp], 64		; 00000040H
	mov	DWORD PTR _desc$6[ebp+4], 2
	mov	DWORD PTR _desc$6[ebp+8], 4
	mov	DWORD PTR _desc$6[ebp+12], 65536	; 00010000H
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+12]

; 562  :     }
; 563  :   }
; 564  : 
; 565  :   // Create the pixel shader
; 566  :   {
; 567  :     static const char* pixelShader =
; 568  :       "struct PS_INPUT\
; 569  :       {\
; 570  :       float4 pos : SV_POSITION;\
; 571  :       float4 col : COLOR0;\
; 572  :       float2 uv  : TEXCOORD0;\
; 573  :       };\
; 574  :       sampler sampler0;\
; 575  :       Texture2D texture0;\
; 576  :       \
; 577  :       float4 main(PS_INPUT input) : SV_Target\
; 578  :       {\
; 579  :       float4 out_col = input.col * texture0.Sample(sampler0, input.uv); \
; 580  :       return out_col; \
; 581  :       }";
; 582  : 
; 583  :     D3DCompile ( pixelShader,

	mov	edx, DWORD PTR ?pixelShader@?BE@??ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ@4PBDB
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL111@ImGui_Impl:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL111@ImGui_Impl
	push	0
	push	OFFSET ?g_pPixelShaderBlob@@3PAUID3D10Blob@@A
	push	0
	push	0
	push	OFFSET $SG244111
	push	OFFSET $SG244112
	push	0
	push	0
	push	0
	sub	ecx, esi
	push	ecx
	push	edx
	call	_D3DCompile@44

; 584  :                    strlen (pixelShader),
; 585  :                      nullptr, nullptr, nullptr,
; 586  :                        "main", "ps_4_0",
; 587  :                          0, 0,
; 588  :                            &g_pPixelShaderBlob,
; 589  :                              nullptr );
; 590  : 
; 591  :     // NB: Pass ID3D10Blob* pErrorBlob to D3DCompile() to get error showing in 
; 592  :     //       (const char*)pErrorBlob->GetBufferPointer(). Make sure to Release() the blob!
; 593  :     if (g_pPixelShaderBlob == nullptr)

	mov	ecx, DWORD PTR ?g_pPixelShaderBlob@@3PAUID3D10Blob@@A
	test	ecx, ecx
	je	$LN20@ImGui_Impl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	esi, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 599  :                                          &g_pPixelShader ) != S_OK )

	mov	eax, DWORD PTR [ecx]
	push	OFFSET ?g_pPixelShader@@3PAUID3D11PixelShader@@A
	push	0
	mov	edi, DWORD PTR [esi]
	push	ecx
	call	DWORD PTR [eax+16]
	push	eax
	mov	eax, DWORD PTR ?g_pPixelShaderBlob@@3PAUID3D10Blob@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	push	eax
	push	esi
	call	DWORD PTR [edi+60]
	test	eax, eax
	jne	$LN20@ImGui_Impl

; 600  :     {
; 601  :       return false;
; 602  :     }
; 603  :   }
; 604  : 
; 605  :   // Create the blending setup
; 606  :   {
; 607  :     D3D11_BLEND_DESC desc                       = {   };

	push	264					; 00000108H
	push	eax
	lea	eax, DWORD PTR _desc$2[ebp]
	push	eax
	call	_memset

; 608  : 
; 609  :     desc.AlphaToCoverageEnable                  = false;
; 610  :     desc.RenderTarget [0].BlendEnable           =  true;
; 611  :     desc.RenderTarget [0].SrcBlend              = D3D11_BLEND_SRC_ALPHA;
; 612  :     desc.RenderTarget [0].DestBlend             = D3D11_BLEND_INV_SRC_ALPHA;
; 613  :     desc.RenderTarget [0].BlendOp               = D3D11_BLEND_OP_ADD;
; 614  :     desc.RenderTarget [0].SrcBlendAlpha         = D3D11_BLEND_ONE;
; 615  :     desc.RenderTarget [0].DestBlendAlpha        = D3D11_BLEND_ZERO;
; 616  :     desc.RenderTarget [0].BlendOpAlpha          = D3D11_BLEND_OP_ADD;
; 617  :     desc.RenderTarget [0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
; 618  : 
; 619  :     pDev->CreateBlendState (&desc, &g_pBlendState);

	mov	eax, DWORD PTR _pDev$[ebp]
	lea	edx, DWORD PTR _desc$2[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000001000000060000000500000001
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _desc$2[ebp], 0
	movups	XMMWORD PTR _desc$2[ebp+8], xmm0
	mov	DWORD PTR _desc$2[ebp+24], 2
	push	OFFSET ?g_pBlendState@@3PAUID3D11BlendState@@A
	mov	DWORD PTR _desc$2[ebp+28], 1
	mov	DWORD PTR _desc$2[ebp+32], 1
	mov	BYTE PTR _desc$2[ebp+36], 15		; 0000000fH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+80]

; 620  :   }
; 621  : 
; 622  :   // Create the rasterizer state
; 623  :   {
; 624  :     D3D11_RASTERIZER_DESC desc = { };
; 625  : 
; 626  :     desc.FillMode        = D3D11_FILL_SOLID;
; 627  :     desc.CullMode        = D3D11_CULL_NONE;
; 628  :     desc.ScissorEnable   = true;
; 629  :     desc.DepthClipEnable = true;
; 630  : 
; 631  :     pDev->CreateRasterizerState (&desc, &g_pRasterizerState);

	mov	eax, DWORD PTR _pDev$[ebp]
	lea	edx, DWORD PTR _desc$5[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _desc$5[ebp], xmm0
	push	OFFSET ?g_pRasterizerState@@3PAUID3D11RasterizerState@@A
	movups	XMMWORD PTR _desc$5[ebp+16], xmm0
	mov	DWORD PTR _desc$5[ebp], 3
	movq	QWORD PTR _desc$5[ebp+32], xmm0
	mov	DWORD PTR _desc$5[ebp+4], 1
	mov	DWORD PTR _desc$5[ebp+28], 1
	mov	DWORD PTR _desc$5[ebp+24], 1
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+88]

; 632  :   }
; 633  : 
; 634  :   // Create depth-stencil State
; 635  :   {
; 636  :     D3D11_DEPTH_STENCIL_DESC desc = { };

	push	52					; 00000034H
	lea	eax, DWORD PTR _desc$4[ebp]
	push	0
	push	eax
	call	_memset
	movaps	xmm0, XMMWORD PTR __xmm@00000000000000080000000100000000

; 637  : 
; 638  :     desc.DepthEnable              = false;
; 639  :     desc.DepthWriteMask           = D3D11_DEPTH_WRITE_MASK_ALL;
; 640  :     desc.DepthFunc                = D3D11_COMPARISON_ALWAYS;
; 641  :     desc.StencilEnable            = false;
; 642  :     desc.FrontFace.StencilFailOp  = desc.FrontFace.StencilDepthFailOp =
; 643  :                                     desc.FrontFace.StencilPassOp      =
; 644  :                                     D3D11_STENCIL_OP_KEEP;
; 645  :     desc.FrontFace.StencilFunc    = D3D11_COMPARISON_ALWAYS;
; 646  :     desc.BackFace                 = desc.FrontFace;
; 647  : 
; 648  :     pDev->CreateDepthStencilState (&desc, &g_pDepthStencilState);

	lea	edx, DWORD PTR _desc$4[ebp]
	mov	eax, DWORD PTR _pDev$[ebp]
	add	esp, 12					; 0000000cH
	movups	XMMWORD PTR _desc$4[ebp], xmm0
	mov	DWORD PTR _desc$4[ebp+28], 1
	mov	DWORD PTR _desc$4[ebp+24], 1
	mov	DWORD PTR _desc$4[ebp+20], 1
	mov	DWORD PTR _desc$4[ebp+32], 8
	movups	xmm0, XMMWORD PTR _desc$4[ebp+20]
	push	OFFSET ?g_pDepthStencilState@@3PAUID3D11DepthStencilState@@A
	push	edx
	movups	XMMWORD PTR _desc$4[ebp+36], xmm0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+84]

; 649  :   }
; 650  : 
; 651  :   ImGui_ImplDX11_CreateFontsTexture ();

	call	?ImGui_ImplDX11_CreateFontsTexture@@YAXXZ ; ImGui_ImplDX11_CreateFontsTexture

; 653  :   return true;

	mov	dl, 1
	jmp	SHORT $LN114@ImGui_Impl
$LN20@ImGui_Impl:
	xor	dl, dl
$LN114@ImGui_Impl:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	ecx, DWORD PTR _pDev$[ebp]
	mov	BYTE PTR $T7[ebp], dl
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 653  :   return true;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN112@ImGui_Impl

; 177  :             p->Release();

	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	eax, DWORD PTR _auto_bool$[ebp]
	mov	ecx, DWORD PTR _auto_bool$1$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 653  :   return true;

	mov	al, BYTE PTR $T7[ebp]

; 654  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN112@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	eax, DWORD PTR _auto_bool$[ebp]
	mov	ecx, DWORD PTR _auto_bool$1$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 653  :   return true;

	mov	al, dl

; 654  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@ImGui_Impl:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	al, al
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 654  : }

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ$0:
	lea	ecx, DWORD PTR _auto_bool$[ebp]
	jmp	??1SK_ScopedBool@@QAE@XZ		; SK_ScopedBool::~SK_ScopedBool
__unwindfunclet$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ$1:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__ehhandler$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ ENDP	; ImGui_ImplDX11_CreateDeviceObjects
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_auto_bool$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ PROC	; ImGui_ImplDX11_InvalidateDeviceObjects

; 707  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi

; 711  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 139  :     bOrig_ = *pBool;

	mov	edi, DWORD PTR [eax+48]
	mov	DWORD PTR _auto_bool$[ebp+4], edi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 711  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	lea	esi, DWORD PTR [eax+48]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 138  :     pBool_ =  pBool;

	mov	DWORD PTR _auto_bool$[ebp], esi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 711  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 712  : 
; 713  :   // Do not dump ImGui font textures
; 714  :   SK_TLS_Bottom ()->imgui.drawing = true;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	mov	DWORD PTR [eax+48], 1

; 715  : 
; 716  :   SK_ImGui_ResetExternal ();

	call	?SK_ImGui_ResetExternal@@YAXXZ		; SK_ImGui_ResetExternal

; 717  : 
; 718  :   if (g_pFontSampler)          { g_pFontSampler->Release     ();     g_pFontSampler = nullptr; }

	mov	ecx, DWORD PTR ?g_pFontSampler@@3PAUID3D11SamplerState@@A
	test	ecx, ecx
	je	SHORT $LN2@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pFontSampler@@3PAUID3D11SamplerState@@A, 0
$LN2@ImGui_Impl:

; 719  :   if (g_pFontTextureView)      { g_pFontTextureView->Release (); g_pFontTextureView = nullptr; ImGui::GetIO ().Fonts->TexID = nullptr; }

	mov	ecx, DWORD PTR ?g_pFontTextureView@@3PAUID3D11ShaderResourceView@@A
	test	ecx, ecx
	je	SHORT $LN3@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pFontTextureView@@3PAUID3D11ShaderResourceView@@A, 0
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	eax, DWORD PTR [eax+128]
	mov	DWORD PTR [eax], 0
$LN3@ImGui_Impl:

; 720  :   if (g_pIB)                   { g_pIB->Release              ();              g_pIB = nullptr; }

	mov	ecx, DWORD PTR ?g_pIB@@3PAUID3D11Buffer@@A
	test	ecx, ecx
	je	SHORT $LN4@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pIB@@3PAUID3D11Buffer@@A, 0
$LN4@ImGui_Impl:

; 721  :   if (g_pVB)                   { g_pVB->Release              ();              g_pVB = nullptr; }

	mov	ecx, DWORD PTR ?g_pVB@@3PAUID3D11Buffer@@A
	test	ecx, ecx
	je	SHORT $LN5@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pVB@@3PAUID3D11Buffer@@A, 0
$LN5@ImGui_Impl:

; 722  : 
; 723  :   if (g_pBlendState)           { g_pBlendState->Release           ();           g_pBlendState = nullptr; }

	mov	ecx, DWORD PTR ?g_pBlendState@@3PAUID3D11BlendState@@A
	test	ecx, ecx
	je	SHORT $LN6@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pBlendState@@3PAUID3D11BlendState@@A, 0
$LN6@ImGui_Impl:

; 724  :   if (g_pDepthStencilState)    { g_pDepthStencilState->Release    ();    g_pDepthStencilState = nullptr; }

	mov	ecx, DWORD PTR ?g_pDepthStencilState@@3PAUID3D11DepthStencilState@@A
	test	ecx, ecx
	je	SHORT $LN7@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pDepthStencilState@@3PAUID3D11DepthStencilState@@A, 0
$LN7@ImGui_Impl:

; 725  :   if (g_pRasterizerState)      { g_pRasterizerState->Release      ();      g_pRasterizerState = nullptr; }

	mov	ecx, DWORD PTR ?g_pRasterizerState@@3PAUID3D11RasterizerState@@A
	test	ecx, ecx
	je	SHORT $LN8@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pRasterizerState@@3PAUID3D11RasterizerState@@A, 0
$LN8@ImGui_Impl:

; 726  :   if (g_pPixelShader)          { g_pPixelShader->Release          ();          g_pPixelShader = nullptr; }

	mov	ecx, DWORD PTR ?g_pPixelShader@@3PAUID3D11PixelShader@@A
	test	ecx, ecx
	je	SHORT $LN9@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pPixelShader@@3PAUID3D11PixelShader@@A, 0
$LN9@ImGui_Impl:

; 727  :   if (g_pPixelShaderBlob)      { g_pPixelShaderBlob->Release      ();      g_pPixelShaderBlob = nullptr; }

	mov	ecx, DWORD PTR ?g_pPixelShaderBlob@@3PAUID3D10Blob@@A
	test	ecx, ecx
	je	SHORT $LN10@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pPixelShaderBlob@@3PAUID3D10Blob@@A, 0
$LN10@ImGui_Impl:

; 728  :   if (g_pVertexConstantBuffer) { g_pVertexConstantBuffer->Release (); g_pVertexConstantBuffer = nullptr; }

	mov	ecx, DWORD PTR ?g_pVertexConstantBuffer@@3PAUID3D11Buffer@@A
	test	ecx, ecx
	je	SHORT $LN11@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pVertexConstantBuffer@@3PAUID3D11Buffer@@A, 0
$LN11@ImGui_Impl:

; 729  :   if (g_pInputLayout)          { g_pInputLayout->Release          ();          g_pInputLayout = nullptr; }

	mov	ecx, DWORD PTR ?g_pInputLayout@@3PAUID3D11InputLayout@@A
	test	ecx, ecx
	je	SHORT $LN12@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pInputLayout@@3PAUID3D11InputLayout@@A, 0
$LN12@ImGui_Impl:

; 730  :   if (g_pVertexShader)         { g_pVertexShader->Release         ();         g_pVertexShader = nullptr; }

	mov	ecx, DWORD PTR ?g_pVertexShader@@3PAUID3D11VertexShader@@A
	test	ecx, ecx
	je	SHORT $LN13@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pVertexShader@@3PAUID3D11VertexShader@@A, 0
$LN13@ImGui_Impl:

; 731  :   if (g_pVertexShaderBlob)     { g_pVertexShaderBlob->Release     ();     g_pVertexShaderBlob = nullptr; }

	mov	ecx, DWORD PTR ?g_pVertexShaderBlob@@3PAUID3D10Blob@@A
	test	ecx, ecx
	je	SHORT $LN22@ImGui_Impl
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?g_pVertexShaderBlob@@3PAUID3D10Blob@@A, 0
$LN22@ImGui_Impl:

; 732  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 732  : }

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ$0:
	lea	ecx, DWORD PTR _auto_bool$[ebp]
	jmp	??1SK_ScopedBool@@QAE@XZ		; SK_ScopedBool::~SK_ScopedBool
__ehhandler$?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ ENDP	; ImGui_ImplDX11_InvalidateDeviceObjects
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_current_time$ = -12					; size = 8
tv179 = -4						; size = 4
?ImGui_ImplDX11_NewFrame@@YAXXZ PROC			; ImGui_ImplDX11_NewFrame

; 812  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 813  :   if (! SK_GetCurrentRenderBackend ().device)

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	cmp	DWORD PTR [eax+36], 0
	je	$LN1@ImGui_Impl

; 814  :     return;
; 815  : 
; 816  :   if (! g_pFontSampler)

	cmp	DWORD PTR ?g_pFontSampler@@3PAUID3D11SamplerState@@A, 0
	jne	SHORT $LN3@ImGui_Impl

; 817  :     ImGui_ImplDX11_CreateDeviceObjects ();

	call	?ImGui_ImplDX11_CreateDeviceObjects@@YA_NXZ ; ImGui_ImplDX11_CreateDeviceObjects
$LN3@ImGui_Impl:
	push	esi

; 818  :   
; 819  :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	esi, eax

; 820  : 
; 821  :   // Setup display size (every frame to accommodate for window resizing)
; 822  :   //io.DisplaySize =
; 823  :     //ImVec2 ( g_frameBufferWidth,
; 824  :                //g_frameBufferHeight );
; 825  : 
; 826  :   // Setup time step
; 827  :   INT64 current_time;
; 828  : 
; 829  :   QueryPerformanceCounter_Original (

	lea	eax, DWORD PTR _current_time$[ebp]
	push	eax
	call	DWORD PTR ?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA ; QueryPerformanceCounter_Original

; 830  :     reinterpret_cast <LARGE_INTEGER *> (&current_time)
; 831  :   );
; 832  : 
; 833  :   io.DeltaTime = static_cast <float> (current_time - g_Time) /

	mov	ecx, DWORD PTR _current_time$[ebp]
	sub	ecx, DWORD PTR ?g_Time@@3_JA
	mov	edx, DWORD PTR _current_time$[ebp+4]
	sbb	edx, DWORD PTR ?g_Time@@3_JA+4
	call	__ltod3
	mov	edx, DWORD PTR ?g_TicksPerSecond@@3_JA+4
	mov	ecx, DWORD PTR ?g_TicksPerSecond@@3_JA
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv179[ebp], xmm0
	call	__ltod3
	movss	xmm1, DWORD PTR tv179[ebp]
	cvtsd2ss xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [esi+8], xmm1

; 834  :                  static_cast <float> (g_TicksPerSecond);
; 835  :   g_Time       =                      current_time;

	mov	eax, DWORD PTR _current_time$[ebp]
	mov	DWORD PTR ?g_Time@@3_JA, eax
	mov	eax, DWORD PTR _current_time$[ebp+4]
	mov	DWORD PTR ?g_Time@@3_JA+4, eax

; 836  : 
; 837  :   // Read keyboard modifiers inputs
; 838  :   io.KeyCtrl   = (io.KeysDown [VK_CONTROL]) != 0;

	cmp	BYTE PTR [esi+246], 0
	setne	al
	mov	BYTE PTR [esi+225], al

; 839  :   io.KeyShift  = (io.KeysDown [VK_SHIFT])   != 0;

	cmp	BYTE PTR [esi+245], 0
	setne	al
	mov	BYTE PTR [esi+226], al

; 840  :   io.KeyAlt    = (io.KeysDown [VK_MENU])    != 0;

	cmp	BYTE PTR [esi+247], 0

; 841  : 
; 842  :   io.KeySuper  = false;

	mov	BYTE PTR [esi+228], 0
	setne	al
	mov	BYTE PTR [esi+227], al

; 843  : 
; 844  :   // For games that hijack the mouse cursor using Direct Input 8.
; 845  :   //
; 846  :   //  -- Acquire actually means release their exclusive ownership : )
; 847  :   //
; 848  :   //if (SK_ImGui_WantMouseCapture ())
; 849  :   //  SK_Input_DI8Mouse_Acquire ();
; 850  :   //else
; 851  :   //  SK_Input_DI8Mouse_Release ();
; 852  : 
; 853  : 
; 854  :   SK_ImGui_PollGamepad ();

	call	?SK_ImGui_PollGamepad@@YAXXZ		; SK_ImGui_PollGamepad

; 855  : 
; 856  : 
; 857  :   // Start the frame
; 858  :   ImGui::NewFrame ();

	call	?NewFrame@ImGui@@YAXXZ			; ImGui::NewFrame
	pop	esi
$LN1@ImGui_Impl:

; 859  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplDX11_NewFrame@@YAXXZ ENDP			; ImGui_ImplDX11_NewFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_auto_bool$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ImGui_ImplDX11_Shutdown@@YAXXZ PROC			; ImGui_ImplDX11_Shutdown

; 793  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ImGui_ImplDX11_Shutdown@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi

; 794  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 139  :     bOrig_ = *pBool;

	mov	esi, DWORD PTR [eax+48]
	mov	DWORD PTR _auto_bool$[ebp+4], esi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 794  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	lea	edi, DWORD PTR [eax+48]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 138  :     pBool_ =  pBool;

	mov	DWORD PTR _auto_bool$[ebp], edi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 794  :   SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 795  : 
; 796  :   // Do not dump ImGui font textures
; 797  :   SK_TLS_Bottom ()->imgui.drawing = true;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	mov	DWORD PTR [eax+48], 1

; 798  : 
; 799  :   ImGui_ImplDX11_InvalidateDeviceObjects ();

	call	?ImGui_ImplDX11_InvalidateDeviceObjects@@YAXXZ ; ImGui_ImplDX11_InvalidateDeviceObjects

; 800  :   ImGui::Shutdown                        ();

	call	?Shutdown@ImGui@@YAXXZ			; ImGui::Shutdown

; 803  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 144  :     *pBool_ = bOrig_;

	mov	DWORD PTR [edi], esi
	pop	edi
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp

; 802  :   g_hWnd              = HWND_DESKTOP;

	mov	DWORD PTR ?g_hWnd@@3PAUHWND__@@A, 0
	pop	esi

; 803  : }

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_ImplDX11_Shutdown@@YAXXZ$0:
	lea	ecx, DWORD PTR _auto_bool$[ebp]
	jmp	??1SK_ScopedBool@@QAE@XZ		; SK_ScopedBool::~SK_ScopedBool
__ehhandler$?ImGui_ImplDX11_Shutdown@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_ImplDX11_Shutdown@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_ImplDX11_Shutdown@@YAXXZ ENDP			; ImGui_ImplDX11_Shutdown
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
_TEXT	SEGMENT
_swap_desc$ = -60					; size = 60
_pSwapChain$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z PROC ; ImGui_ImplDX11_Init

; 738  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 739  :   static bool first = true;
; 740  : 
; 741  :   if (first)

	cmp	BYTE PTR ?first@?1??ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z@4_NA, 0
	je	SHORT $LN2@ImGui_Impl

; 742  :   {
; 743  :     if (! QueryPerformanceFrequency        (reinterpret_cast <LARGE_INTEGER *> (&g_TicksPerSecond)))

	push	OFFSET ?g_TicksPerSecond@@3_JA
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	test	eax, eax
	jne	SHORT $LN3@ImGui_Impl
$LN6@ImGui_Impl:

; 744  :       return false;

	xor	al, al

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ImGui_Impl:

; 745  : 
; 746  :     if (! QueryPerformanceCounter_Original (reinterpret_cast <LARGE_INTEGER *> (&g_Time)))

	push	OFFSET ?g_Time@@3_JA
	call	DWORD PTR ?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA ; QueryPerformanceCounter_Original
	test	eax, eax
	je	SHORT $LN6@ImGui_Impl

; 747  :       return false;
; 748  : 
; 749  :     first = false;

	mov	BYTE PTR ?first@?1??ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z@4_NA, 0
$LN2@ImGui_Impl:

; 750  :   }
; 751  : 
; 752  :   DXGI_SWAP_CHAIN_DESC  swap_desc  = { };

	push	60					; 0000003cH
	lea	eax, DWORD PTR _swap_desc$[ebp]
	push	0
	push	eax
	call	_memset

; 753  :   pSwapChain->GetDesc (&swap_desc);

	mov	eax, DWORD PTR _pSwapChain$[ebp]
	lea	edx, DWORD PTR _swap_desc$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+48]

; 754  : 
; 755  :   g_hWnd              = swap_desc.OutputWindow;

	mov	eax, DWORD PTR _swap_desc$[ebp+44]
	mov	DWORD PTR ?g_hWnd@@3PAUHWND__@@A, eax

; 756  : 
; 757  :   g_frameBufferWidth  = swap_desc.BufferDesc.Width;

	mov	eax, DWORD PTR _swap_desc$[ebp]
	mov	DWORD PTR ?g_frameBufferWidth@@3IA, eax

; 758  :   g_frameBufferHeight = swap_desc.BufferDesc.Height;

	mov	eax, DWORD PTR _swap_desc$[ebp+4]
	mov	DWORD PTR ?g_frameBufferHeight@@3IA, eax

; 759  : 
; 760  :   ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	ecx, eax

; 761  :     ImGui::GetIO ();
; 762  : 
; 763  :   // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array that we will update during the application lifetime.
; 764  :   io.KeyMap [ImGuiKey_Tab]        = VK_TAB;
; 765  :   io.KeyMap [ImGuiKey_LeftArrow]  = VK_LEFT;
; 766  :   io.KeyMap [ImGuiKey_RightArrow] = VK_RIGHT;
; 767  :   io.KeyMap [ImGuiKey_UpArrow]    = VK_UP;
; 768  :   io.KeyMap [ImGuiKey_DownArrow]  = VK_DOWN;
; 769  :   io.KeyMap [ImGuiKey_PageUp]     = VK_PRIOR;
; 770  :   io.KeyMap [ImGuiKey_PageDown]   = VK_NEXT;
; 771  :   io.KeyMap [ImGuiKey_Home]       = VK_HOME;
; 772  :   io.KeyMap [ImGuiKey_End]        = VK_END;
; 773  :   io.KeyMap [ImGuiKey_Delete]     = VK_DELETE;
; 774  :   io.KeyMap [ImGuiKey_Backspace]  = VK_BACK;
; 775  :   io.KeyMap [ImGuiKey_Enter]      = VK_RETURN;
; 776  :   io.KeyMap [ImGuiKey_Escape]     = VK_ESCAPE;
; 777  :   io.KeyMap [ImGuiKey_A]          = 'A';
; 778  :   io.KeyMap [ImGuiKey_C]          = 'C';
; 779  :   io.KeyMap [ImGuiKey_V]          = 'V';
; 780  :   io.KeyMap [ImGuiKey_X]          = 'X';
; 781  :   io.KeyMap [ImGuiKey_Y]          = 'Y';
; 782  :   io.KeyMap [ImGuiKey_Z]          = 'Z';
; 783  : 
; 784  :   // Alternatively you can set this to NULL and call ImGui::GetDrawData() after ImGui::Render() to get the same ImDrawData pointer.
; 785  :   io.RenderDrawListsFn = ImGui_ImplDX11_RenderDrawLists;
; 786  :   io.ImeWindowHandle   = g_hWnd;

	mov	eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A
	mov	DWORD PTR [ecx+36], 9
	mov	DWORD PTR [ecx+48], 37			; 00000025H
	mov	DWORD PTR [ecx+52], 39			; 00000027H
	mov	DWORD PTR [ecx+40], 38			; 00000026H
	mov	DWORD PTR [ecx+44], 40			; 00000028H
	mov	DWORD PTR [ecx+56], 33			; 00000021H
	mov	DWORD PTR [ecx+60], 34			; 00000022H
	mov	DWORD PTR [ecx+64], 36			; 00000024H
	mov	DWORD PTR [ecx+68], 35			; 00000023H
	mov	DWORD PTR [ecx+72], 46			; 0000002eH
	mov	DWORD PTR [ecx+76], 8
	mov	DWORD PTR [ecx+80], 13			; 0000000dH
	mov	DWORD PTR [ecx+84], 27			; 0000001bH
	mov	DWORD PTR [ecx+88], 65			; 00000041H
	mov	DWORD PTR [ecx+92], 67			; 00000043H
	mov	DWORD PTR [ecx+96], 86			; 00000056H
	mov	DWORD PTR [ecx+100], 88			; 00000058H
	mov	DWORD PTR [ecx+104], 89			; 00000059H
	mov	DWORD PTR [ecx+108], 90			; 0000005aH
	mov	DWORD PTR [ecx+172], OFFSET ?ImGui_ImplDX11_RenderDrawLists@@YAXPAUImDrawData@@@Z ; ImGui_ImplDX11_RenderDrawLists
	mov	DWORD PTR [ecx+200], eax

; 787  : 
; 788  :   return SK_GetCurrentRenderBackend ().device != nullptr;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	cmp	DWORD PTR [eax+36], 0
	setne	al

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z ENDP ; ImGui_ImplDX11_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 905  : }

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d11.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 905  : }

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
