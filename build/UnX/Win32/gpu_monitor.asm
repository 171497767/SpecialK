; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\gpu_monitor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?current_gpu_stat@@3KC				; current_gpu_stat
PUBLIC	?gpu_stats@@3AAUgpu_sensors_t@@A		; gpu_stats
_BSS	SEGMENT
?hPollEvent@@3PAXA DD 01H DUP (?)			; hPollEvent
?hShutdownEvent@@3PAXA DD 01H DUP (?)			; hShutdownEvent
?hPollThread@@3PAXA DD 01H DUP (?)			; hPollThread
?current_gpu_stat@@3KC DD 01H DUP (?)			; current_gpu_stat
_BSS	ENDS
_DATA	SEGMENT
?gpu_stats@@3AAUgpu_sensors_t@@A DD FLAT:?gpu_stats_buffers@@3PAUgpu_sensors_t@@A ; gpu_stats
_DATA	ENDS
CONST	SEGMENT
$SG126278 DB	'[', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'p', 00H, 'l', 00H
	DB	'a', 00H, 'y', 00H, 'L', 00H, 'i', 00H, 'b', 00H, ']', 00H, ' '
	DB	00H, 'I', 00H, 'N', 00H, 'V', 00H, 'A', 00H, 'L', 00H, 'I', 00H
	DB	'D', 00H, ' ', 00H, 'A', 00H, 'D', 00H, 'L', 00H, ' ', 00H, 'A'
	DB	00H, 'D', 00H, 'A', 00H, 'P', 00H, 'T', 00H, 'E', 00H, 'R', 00H
	DB	':', 00H, ' ', 00H, '%', 00H, 'i', 00H, 00H, 00H
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?_InterlockedCompareExchange@@YAKPCKKK@Z	; _InterlockedCompareExchange
PUBLIC	??0<unnamed-type-loads_percent>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-loads_percent>::<unnamed-type-loads_percent>
PUBLIC	??0<unnamed-type-clocks_kHz>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-clocks_kHz>::<unnamed-type-clocks_kHz>
PUBLIC	??0<unnamed-type-volts_mV>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-volts_mV>::<unnamed-type-volts_mV>
PUBLIC	??0<unnamed-type-temps_c>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-temps_c>::<unnamed-type-temps_c>
PUBLIC	??0<unnamed-type-fans_rpm>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-fans_rpm>::<unnamed-type-fans_rpm>
PUBLIC	??0<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ	; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-gpus>
PUBLIC	??0gpu_sensors_t@@QAE@XZ			; gpu_sensors_t::gpu_sensors_t
PUBLIC	?SK_GPU_GetClockRateInkHz@@YGIH@Z		; SK_GPU_GetClockRateInkHz
PUBLIC	?SK_GPU_GetMemClockRateInkHz@@YGIH@Z		; SK_GPU_GetMemClockRateInkHz
PUBLIC	?SK_GPU_GetMemoryBandwidth@@YG_KH@Z		; SK_GPU_GetMemoryBandwidth
PUBLIC	?SK_GPU_GetMemoryLoad@@YGMH@Z			; SK_GPU_GetMemoryLoad
PUBLIC	?SK_GPU_GetGPULoad@@YGMH@Z			; SK_GPU_GetGPULoad
PUBLIC	?SK_GPU_GetTempInC@@YGMH@Z			; SK_GPU_GetTempInC
PUBLIC	?SK_GPU_GetFanSpeedRPM@@YGIH@Z			; SK_GPU_GetFanSpeedRPM
PUBLIC	?SK_GPU_GetVRAMUsed@@YG_KH@Z			; SK_GPU_GetVRAMUsed
PUBLIC	?SK_GPU_GetVRAMShared@@YG_KH@Z			; SK_GPU_GetVRAMShared
PUBLIC	?SK_GPU_GetVRAMCapacity@@YG_KH@Z		; SK_GPU_GetVRAMCapacity
PUBLIC	?SK_GPU_GetVRAMBudget@@YG_KH@Z			; SK_GPU_GetVRAMBudget
PUBLIC	?SK_PollGPU@@YAXXZ				; SK_PollGPU
PUBLIC	?SK_EndGPUPolling@@YAXXZ			; SK_EndGPUPolling
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?SK_GPUPollingThread@@YGKPAX@Z			; SK_GPUPollingThread
PUBLIC	??0?$allocator@K@std@@QAE@XZ			; std::allocator<unsigned long>::allocator<unsigned long>
PUBLIC	?deallocate@?$allocator@K@std@@QAEXPAKI@Z	; std::allocator<unsigned long>::deallocate
PUBLIC	?allocate@?$allocator@K@std@@QAEPAKI@Z		; std::allocator<unsigned long>::allocate
PUBLIC	?max_size@?$allocator@K@std@@QBEIXZ		; std::allocator<unsigned long>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z ; std::allocator_traits<std::allocator<unsigned long> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
PUBLIC	?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
PUBLIC	?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::end
PUBLIC	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
PUBLIC	?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
PUBLIC	?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
PUBLIC	?_Has_unused_capacity@?$vector@KV?$allocator@K@std@@@std@@ABE_NXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Has_unused_capacity
PUBLIC	??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
PUBLIC	?_Umove_if_noexcept1@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@ABEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEPAKXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Unchecked
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@K@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned long> > >
PUBLIC	??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ; std::_Destroy_range<std::allocator<unsigned long>,unsigned long *>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0U?$less@X@0@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >,std::less<void> >
PUBLIC	??$forward@ABK@std@@YAABKABK@Z			; std::forward<unsigned long const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long const &>
PUBLIC	??$_Unfancy@K@std@@YAPAKPAK@Z			; std::_Unfancy<unsigned long>
PUBLIC	??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
PUBLIC	??$destroy@K@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAK@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long>
PUBLIC	??$_Destroy_range1@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned long>,unsigned long *>
PUBLIC	??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPAKV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<unsigned long> > >
PUBLIC	??$_Sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ; std::_Sort_unchecked<unsigned long *,std::less<void> >
PUBLIC	??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
PUBLIC	??$destroy@K@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAK@Z ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long>
PUBLIC	??$_Unchecked@PAK@std@@YAPAKPAK@Z		; std::_Unchecked<unsigned long *>
PUBLIC	??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ; std::_Ptr_move_cat<unsigned long,unsigned long>
PUBLIC	??$move@AAK@std@@YA$$QAKAAK@Z			; std::move<unsigned long &>
PUBLIC	??$_Uninitialized_move_al_unchecked@KKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned long,unsigned long,std::allocator<unsigned long> >
PUBLIC	??$_Rechecked@PAKPAK@std@@YAAAPAKAAPAKPAK@Z	; std::_Rechecked<unsigned long *,unsigned long *>
PUBLIC	??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >
PUBLIC	??$construct@KABK@?$allocator@K@std@@QAEXPAKABK@Z ; std::allocator<unsigned long>::construct<unsigned long,unsigned long const &>
PUBLIC	??$destroy@K@?$allocator@K@std@@QAEXPAK@Z	; std::allocator<unsigned long>::destroy<unsigned long>
PUBLIC	??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z	; std::_Copy_memmove<unsigned long *,unsigned long *>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAKU?$less@X@std@@@std@@YA?AU?$pair@PAKPAK@0@PAK0AAU?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<unsigned long *,std::less<void> >
PUBLIC	??$_Make_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ; std::_Make_heap_unchecked<unsigned long *,std::less<void> >
PUBLIC	??$_Sort_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ; std::_Sort_heap_unchecked<unsigned long *,std::less<void> >
PUBLIC	??$_Insertion_sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ; std::_Insertion_sort_unchecked<unsigned long *,std::less<void> >
PUBLIC	??$_Guess_median_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z ; std::_Guess_median_unchecked<unsigned long *,std::less<void> >
PUBLIC	??$?RAAKAAK@?$less@X@std@@QBE_NAAK0@Z		; std::less<void>::operator()<unsigned long &,unsigned long &>
PUBLIC	??$iter_swap@PAKPAK@std@@YAXPAK0@Z		; std::iter_swap<unsigned long *,unsigned long *>
PUBLIC	??$?0AAPAKAAPAKX$0A@@?$pair@PAKPAK@std@@QAE@AAPAK0@Z ; std::pair<unsigned long *,unsigned long *>::pair<unsigned long *,unsigned long *><unsigned long * &,unsigned long * &,void,0>
PUBLIC	??$_Pop_heap_hole_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<unsigned long *,int,unsigned long,std::less<void> >
PUBLIC	??$_Pop_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ; std::_Pop_heap_unchecked<unsigned long *,std::less<void> >
PUBLIC	??$_Move_backward_unchecked@PAKPAK@std@@YAPAKPAK00@Z ; std::_Move_backward_unchecked<unsigned long *,unsigned long *>
PUBLIC	??$_Med3_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z ; std::_Med3_unchecked<unsigned long *,std::less<void> >
PUBLIC	??$swap@KX@std@@YAXAAK0@Z			; std::swap<unsigned long,void>
PUBLIC	??$forward@AAPAK@std@@YAAAPAKAAPAK@Z		; std::forward<unsigned long * &>
PUBLIC	??$_Push_heap_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z ; std::_Push_heap_by_index<unsigned long *,int,unsigned long,std::less<void> >
PUBLIC	??$_Pop_heap_hole_unchecked@PAKKU?$less@X@std@@@std@@YAXPAK00$$QAKAAU?$less@X@0@@Z ; std::_Pop_heap_hole_unchecked<unsigned long *,unsigned long,std::less<void> >
PUBLIC	??$_Move_backward_unchecked1@PAKPAK@std@@YAPAKPAK00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<unsigned long *,unsigned long *>
PUBLIC	??$_Copy_backward_memmove@PAKPAK@std@@YAPAKPAK00@Z ; std::_Copy_backward_memmove<unsigned long *,unsigned long *>
PUBLIC	?gpu_stats_buffers@@3PAUgpu_sensors_t@@A	; gpu_stats_buffers
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__real@3a83126f
PUBLIC	__real@3e7ad7f29abcaf48
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateEventW@16:PROC
EXTRN	__imp__SignalObjectAndWait@16:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__GetSystemTime@4:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
EXTRN	__imp__SystemTimeToFileTime@8:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	_NvAPI_GPU_GetMemoryInfo:PROC
EXTRN	_NvAPI_EnumPhysicalGPUs:PROC
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	_NvAPI_GPU_GetCurrentPCIEDownstreamWidth:PROC
EXTRN	_NvAPI_GPU_GetAllClockFrequencies:PROC
EXTRN	_NvAPI_GPU_GetPstates20:PROC
EXTRN	_NvAPI_GPU_GetCurrentPstate:PROC
EXTRN	_NvAPI_GPU_GetDynamicPstatesInfoEx:PROC
EXTRN	_NvAPI_GPU_GetThermalSettings:PROC
EXTRN	_NvAPI_GPU_GetTachReading:PROC
EXTRN	_NvAPI_GPU_GetPerfDecreaseInfo:PROC
EXTRN	?SK_ADL_CountActiveGPUs@@YAHXZ:PROC		; SK_ADL_CountActiveGPUs
EXTRN	?SK_ADL_GetActiveAdapter@@YAPAUAdapterInfo@@H@Z:PROC ; SK_ADL_GetActiveAdapter
EXTRN	__CxxThrowException@8:PROC
EXTRN	__allmul:PROC
EXTRN	__chkstk:PROC
EXTRN	__ultod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	_NvAPI_GPU_GetRamType:DWORD
EXTRN	_NvAPI_GPU_GetFBWidthAndLocation:DWORD
EXTRN	_NvAPI_GPU_GetPCIEInfo:DWORD
EXTRN	_NvAPI_GetPhysicalGPUFromGPUID:DWORD
EXTRN	_NvAPI_GetGPUIDFromPhysicalGPU:DWORD
EXTRN	?nvapi_init@@3HA:DWORD				; nvapi_init
EXTRN	?ADL_init@@3HA:DWORD				; ADL_init
EXTRN	?ADL_Overdrive5_Temperature_Get@@3P6AHHHPAUADLTemperature@@@ZA:DWORD ; ADL_Overdrive5_Temperature_Get
EXTRN	?ADL_Overdrive5_FanSpeed_Get@@3P6AHHHPAUADLFanSpeedValue@@@ZA:DWORD ; ADL_Overdrive5_FanSpeed_Get
EXTRN	?ADL_Overdrive5_CurrentActivity_Get@@3P6AHHPAUADLPMActivity@@@ZA:DWORD ; ADL_Overdrive5_CurrentActivity_Get
EXTRN	?mem_info@@3PAUmem_info_t@@A:BYTE		; mem_info
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
?gpu_stats_buffers@@3PAUgpu_sensors_t@@A DB 04020H DUP (?) ; gpu_stats_buffers
_BSS	ENDS
;	COMDAT ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
_BSS	SEGMENT
?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A DB 0cH DUP (?) ; `SK_GPUPollingThread'::`12'::gpu_ids
_BSS	ENDS
;	COMDAT ?$TSS0@?M@??SK_GPUPollingThread@@YGKPAX@Z@4HA
_BSS	SEGMENT
?$TSS0@?M@??SK_GPUPollingThread@@YGKPAX@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-12',unsigned __int16 volatile * const volatile,void [ ?? ]>
_BSS	ENDS
;	COMDAT ?init@?M@??SK_GPUPollingThread@@YGKPAX@Z@4_NA
_BSS	SEGMENT
?init@?M@??SK_GPUPollingThread@@YGKPAX@Z@4_NA DB 01H DUP (?) ; `SK_GPUPollingThread'::`12'::init
_BSS	ENDS
;	COMDAT ?iter@?BF@??SK_GPUPollingThread@@YGKPAX@Z@4HA
_BSS	SEGMENT
?iter@?BF@??SK_GPUPollingThread@@YGKPAX@Z@4HA DD 01H DUP (?) ; `SK_GPUPollingThread'::`21'::iter
_BSS	ENDS
;	COMDAT ?init@?1??SK_PollGPU@@YAXXZ@4KC
_BSS	SEGMENT
?init@?1??SK_PollGPU@@YAXXZ@4KC DD 01H DUP (?)		; `SK_PollGPU'::`2'::init
_BSS	ENDS
CRT$XCU	SEGMENT
?gpu_stats_buffers$initializer$@@3P6AXXZA DD FLAT:??__Egpu_stats_buffers@@YAXXZ ; gpu_stats_buffers$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@3e7ad7f29abcaf48
CONST	SEGMENT
__real@3e7ad7f29abcaf48 DQ 03e7ad7f29abcaf48r	; 1e-07
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAKPAK@std@@YAPAKPAK00@Z PROC	; std::_Copy_backward_memmove<unsigned long *,unsigned long *>, COMDAT

; 2486 : 	{	// implement copy_backward-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2487 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2488 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2489 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2490 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax

; 2491 : 	return (static_cast<_BidIt2>(

	push	ecx
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2492 : 		_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count)));
; 2493 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_memmove@PAKPAK@std@@YAPAKPAK00@Z ENDP	; std::_Copy_backward_memmove<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Move_backward_unchecked1@PAKPAK@std@@YAPAKPAK00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward_unchecked1@PAKPAK@std@@YAPAKPAK00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward_unchecked1<unsigned long *,unsigned long *>, COMDAT

; 2607 : 	{	// move [_First, _Last) backwards to [..., _Dest), memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2490 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax

; 2491 : 	return (static_cast<_BidIt2>(

	push	ecx
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2608 : 	return (_Copy_backward_memmove(_First, _Last, _Dest));
; 2609 : 	}

	pop	ebp
	ret	0
??$_Move_backward_unchecked1@PAKPAK@std@@YAPAKPAK00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward_unchecked1<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAKKU?$less@X@std@@@std@@YAXPAK00$$QAKAAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Pop_heap_hole_unchecked@PAKKU?$less@X@std@@@std@@YAXPAK00$$QAKAAU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_unchecked<unsigned long *,unsigned long,std::less<void> >, COMDAT

; 2199 : 	{	// pop *_First to *_Dest and reheap, using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2200 : 		// precondition: _First != _Last
; 2201 : 		// precondition: _First != _Dest
; 2202 : 	*_Dest = _STD move(*_First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 2203 : 	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	sar	eax, 2
	mov	DWORD PTR __Dest$[ebp], eax
	mov	DWORD PTR __Last$[ebp], 0
	mov	DWORD PTR __First$[ebp], edx

; 2204 : 		_STD move(_Val), _Pred);
; 2205 : 	}

	pop	ebp

; 2203 : 	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),

	jmp	??$_Pop_heap_hole_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<unsigned long *,int,unsigned long,std::less<void> >
??$_Pop_heap_hole_unchecked@PAKKU?$less@X@std@@@std@@YAXPAK00$$QAKAAU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_unchecked<unsigned long *,unsigned long,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Push_heap_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z PROC ; std::_Push_heap_by_index<unsigned long *,int,unsigned long,std::less<void> >, COMDAT

; 2121 : 	{	// percolate _Hole to _Top or where _Val belongs, using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2123 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);

	mov	ecx, DWORD PTR __Hole$[ebp]
	push	edi
	mov	edi, DWORD PTR __Top$[ebp]
	cmp	edi, ecx
	jge	SHORT $LN18@Push_heap_
	push	ebx
	mov	ebx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
$LL4@Push_heap_:

; 2122 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	edx, DWORD PTR [esi+eax*4]
	cmp	edx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2123 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);

	jae	SHORT $LN19@Push_heap_

; 2124 : 		_Idx = (_Hole - 1) / 2)
; 2125 : 		{	// move _Hole up to parent
; 2126 : 		*(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	DWORD PTR [esi+ecx*4], edx

; 2127 : 		_Hole = _Idx;

	mov	ecx, eax
	cmp	edi, eax
	jl	SHORT $LL4@Push_heap_
$LN19@Push_heap_:

; 2128 : 		}
; 2129 : 
; 2130 : 	*(_First + _Hole) = _STD move(_Val);	// drop _Val into final hole

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+ecx*4], eax
	pop	esi
	pop	ebx
	pop	edi

; 2131 : 	}

	pop	ebp
	ret	0
$LN18@Push_heap_:

; 2128 : 		}
; 2129 : 
; 2130 : 	*(_First + _Hole) = _STD move(_Val);	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[ebp]
	pop	edi
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 2131 : 	}

	pop	ebp
	ret	0
??$_Push_heap_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z ENDP ; std::_Push_heap_by_index<unsigned long *,int,unsigned long,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAK@std@@YAAAPAKAAPAK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAK@std@@YAAAPAKAAPAK@Z PROC		; std::forward<unsigned long * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAK@std@@YAAAPAKAAPAK@Z ENDP		; std::forward<unsigned long * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$swap@KX@std@@YAXAAK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@KX@std@@YAXAAK0@Z PROC				; std::swap<unsigned long,void>, COMDAT

; 65   : 	{	// exchange values stored at _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR __Left$[ebp]

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], esi
	pop	esi

; 69   : 	}

	pop	ebp
	ret	0
??$swap@KX@std@@YAXAAK0@Z ENDP				; std::swap<unsigned long,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Med3_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z PROC ; std::_Med3_unchecked<unsigned long *,std::less<void> >, COMDAT

; 2785 : 	{	// sort median of three elements to middle

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	esi
	push	edi
	mov	esi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2786 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN11@Med3_unche
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
$LN11@Med3_unche:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	edi, DWORD PTR __Last$[ebp]
	mov	esi, DWORD PTR [edi]
	cmp	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2788 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	jae	SHORT $LN43@Med3_unche
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR [edx]
	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2791 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN43@Med3_unche
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
$LN43@Med3_unche:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2794 : 	}

	pop	ebp
	ret	0
??$_Med3_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z ENDP ; std::_Med3_unchecked<unsigned long *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward_unchecked@PAKPAK@std@@YAPAKPAK00@Z PROC ; std::_Move_backward_unchecked<unsigned long *,unsigned long *>, COMDAT

; 2615 : 	{	// move [_First, _Last) backwards to [..., _Dest), choose optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2490 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax

; 2491 : 	return (static_cast<_BidIt2>(

	push	ecx
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2616 : 		// note: _Move_backward_unchecked is called directly from elsewhere in the STL
; 2617 : 	return (_Move_backward_unchecked1(_First, _Last,
; 2618 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2619 : 	}

	pop	ebp
	ret	0
??$_Move_backward_unchecked@PAKPAK@std@@YAPAKPAK00@Z ENDP ; std::_Move_backward_unchecked<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Val$1 = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z PROC ; std::_Pop_heap_unchecked<unsigned long *,std::less<void> >, COMDAT

; 2210 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2211 : 	if (2 <= _Last - _First)

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	eax, ecx
	mov	edx, DWORD PTR __First$[ebp]
	sub	eax, edx
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN2@Pop_heap_u

; 2212 : 		{
; 2213 : 		--_Last;
; 2214 : 		_Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [ecx-4]
	sub	ecx, 4

; 2203 : 	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),

	push	DWORD PTR __Pred$[ebp]

; 2212 : 		{
; 2213 : 		--_Last;
; 2214 : 		_Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[ebp], eax

; 2202 : 	*_Dest = _STD move(*_First);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 2203 : 	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),

	lea	eax, DWORD PTR __Val$1[ebp]
	push	eax
	sub	ecx, edx
	sar	ecx, 2
	push	ecx
	push	0
	push	edx
	call	??$_Pop_heap_hole_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<unsigned long *,int,unsigned long,std::less<void> >
	add	esp, 20					; 00000014H
$LN2@Pop_heap_u:

; 2215 : 		_Pop_heap_hole_unchecked(_First, _Last, _Last,
; 2216 : 			_STD move(_Val), _Pred);
; 2217 : 		}
; 2218 : 	}

	pop	ebp
	ret	0
??$_Pop_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ENDP ; std::_Pop_heap_unchecked<unsigned long *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z
_TEXT	SEGMENT
__Top$1$ = -4						; size = 4
__First$ = 8						; size = 4
tv266 = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Pop_heap_hole_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<unsigned long *,int,unsigned long,std::less<void> >, COMDAT

; 2168 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2169 : 		// precondition: _Bottom != 0
; 2170 : 	const _Diff _Top = _Hole;
; 2171 : 	_Diff _Idx = _Hole;
; 2172 : 
; 2173 : 	// Check whether _Idx can have a child before calculating that child's index, since
; 2174 : 	// calculating the child's index can trigger integer overflows
; 2175 : 	const _Diff _Max_sequence_non_leaf = (_Bottom - 1) / 2;

	mov	eax, DWORD PTR __Bottom$[ebp]
	push	ebx
	dec	eax
	push	esi
	mov	esi, DWORD PTR __Hole$[ebp]
	mov	ecx, esi
	mov	DWORD PTR tv266[ebp], eax
	cdq
	sub	eax, edx
	mov	DWORD PTR __Top$1$[ebp], esi
	mov	ebx, eax
	sar	ebx, 1
	push	edi

; 2176 : 	while (_Idx < _Max_sequence_non_leaf)

	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, ebx
	jge	SHORT $LN3@Pop_heap_h
	npad	10
$LL2@Pop_heap_h:
	mov	eax, DWORD PTR [edi+ecx*8+4]

; 2177 : 		{	// move _Hole down to larger child
; 2178 : 		_Idx = 2 * _Idx + 2;

	lea	edx, DWORD PTR [ecx*2+2]
	cmp	DWORD PTR [edi+edx*4], eax
	lea	ecx, DWORD PTR [edx-1]
	cmovae	ecx, edx

; 2179 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))
; 2180 : 			--_Idx;
; 2181 : 		*(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [edi+esi*4], eax

; 2182 : 		_Hole = _Idx;

	mov	esi, ecx
	cmp	ecx, ebx
	jl	SHORT $LL2@Pop_heap_h
$LN3@Pop_heap_h:

; 2183 : 		}
; 2184 : 
; 2185 : 	if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0)

	cmp	ecx, ebx
	jne	SHORT $LN5@Pop_heap_h
	mov	eax, DWORD PTR __Bottom$[ebp]
	test	al, 1
	jne	SHORT $LN5@Pop_heap_h

; 2186 : 		{	// only child at bottom, move _Hole down to it
; 2187 : 		*(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [edi+eax*4-4]
	mov	DWORD PTR [edi+esi*4], eax

; 2188 : 		_Hole = _Bottom - 1;

	mov	esi, DWORD PTR tv266[ebp]
$LN5@Pop_heap_h:

; 2189 : 		}
; 2190 : 
; 2191 : 	_Push_heap_by_index(_First, _Hole, _Top, _STD move(_Val), _Pred);

	push	DWORD PTR __Pred$[ebp]
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Top$1$[ebp]
	push	esi
	push	edi
	call	??$_Push_heap_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z ; std::_Push_heap_by_index<unsigned long *,int,unsigned long,std::less<void> >
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 2192 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_hole_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<unsigned long *,int,unsigned long,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0AAPAKAAPAKX$0A@@?$pair@PAKPAK@std@@QAE@AAPAK0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAKAAPAKX$0A@@?$pair@PAKPAK@std@@QAE@AAPAK0@Z PROC ; std::pair<unsigned long *,unsigned long *>::pair<unsigned long *,unsigned long *><unsigned long * &,unsigned long * &,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAPAKAAPAKX$0A@@?$pair@PAKPAK@std@@QAE@AAPAK0@Z ENDP ; std::pair<unsigned long *,unsigned long *>::pair<unsigned long *,unsigned long *><unsigned long * &,unsigned long * &,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$iter_swap@PAKPAK@std@@YAXPAK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAKPAK@std@@YAXPAK0@Z PROC			; std::iter_swap<unsigned long *,unsigned long *>, COMDAT

; 39   : 	{	// swap *_Left and *_Right

	npad	2
	push	ebp
	mov	ebp, esp

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR __Left$[ebp]

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi

; 42   : 
; 43   : 		// TEMPLATE FUNCTION swap
; 44   : template<class _Ty,
; 45   : 	size_t _Size,
; 46   : 	class> inline
; 47   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 48   : 		_NOEXCEPT_OP(_Is_nothrow_swappable<_Ty>::value)
; 49   : 	{	// exchange arrays stored at _Left and _Right
; 50   : 	if (&_Left != &_Right)
; 51   : 		{	// worth swapping, swap ranges
; 52   : 		_Ty *_First1 = _Left;
; 53   : 		_Ty *_Last1 = _First1 + _Size;
; 54   : 		_Ty *_First2 = _Right;
; 55   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 56   : 			_STD iter_swap(_First1, _First2);
; 57   : 		}
; 58   : 	}
; 59   : 
; 60   : template<class _Ty,
; 61   : 	class> inline
; 62   : 	void swap(_Ty& _Left, _Ty& _Right)
; 63   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 64   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 65   : 	{	// exchange values stored at _Left and _Right
; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	esi, DWORD PTR [edx]

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], esi
	pop	esi

; 40   : 	swap(*_Left, *_Right);
; 41   : 	}

	pop	ebp
	ret	0
??$iter_swap@PAKPAK@std@@YAXPAK0@Z ENDP			; std::iter_swap<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$?RAAKAAK@?$less@X@std@@QBE_NAAK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RAAKAAK@?$less@X@std@@QBE_NAAK0@Z PROC		; std::less<void>::operator()<unsigned long &,unsigned long &>, COMDAT
; _this$ = ecx

; 317  : 		{	// transparently apply operator< to operands

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	setb	al

; 318  : 		return (static_cast<_Ty1&&>(_Left)
; 319  : 			< static_cast<_Ty2&&>(_Right));
; 320  : 		}

	pop	ebp
	ret	8
??$?RAAKAAK@?$less@X@std@@QBE_NAAK0@Z ENDP		; std::less<void>::operator()<unsigned long &,unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z
_TEXT	SEGMENT
tv574 = -4						; size = 4
tv573 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Tmp$1$ = 16						; size = 4
__Tmp$1$ = 16						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Guess_median_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<unsigned long *,std::less<void> >, COMDAT

; 2799 : 	{	// sort median element to middle

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2800 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	mov	eax, edi
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, 40					; 00000028H
	jle	$LN2@Guess_medi

; 2801 : 		{	// median of nine
; 2802 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	push	ebx

; 2803 : 		_Med3_unchecked(_First, _First + _Step, _First + 2 * _Step, _Pred);

	lea	ebx, DWORD PTR [eax*4]
	lea	edx, DWORD PTR [eax*8]
	mov	DWORD PTR tv573[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2803 : 		_Med3_unchecked(_First, _First + _Step, _First + 2 * _Step, _Pred);

	lea	esi, DWORD PTR [ebx+ecx]
	mov	DWORD PTR tv574[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	edx, DWORD PTR [esi]
	cmp	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2786 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN15@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [esi], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], edx
$LN15@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR tv574[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	cmp	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2788 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	jae	SHORT $LN47@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	edi, DWORD PTR tv574[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2791 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	edi, DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR [ecx]
	cmp	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2791 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN47@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [esi], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], edx
$LN47@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2804 : 		_Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, ecx
	sub	edx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	ebx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	cmp	ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2786 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN68@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edx], ebx
$LN68@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR tv573[ebp]
	mov	ebx, DWORD PTR [eax+ecx]
	cmp	ebx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2788 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	jae	SHORT $LN100@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	edi, DWORD PTR tv573[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2791 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	edi, DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR [edx]
	cmp	ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2791 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN100@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edx], ebx
$LN100@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2805 : 		_Med3_unchecked(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

	mov	edx, edi
	mov	ebx, edi
	sub	edx, DWORD PTR tv573[ebp]
	sub	ebx, DWORD PTR tv574[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$1$[ebp], eax
	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR __Tmp$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2786 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN121@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [edx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	eax, DWORD PTR __Tmp$1$[ebp]
	mov	DWORD PTR [ebx], eax
$LN121@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$1$[ebp], eax
	cmp	eax, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2788 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	jae	SHORT $LN153@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	eax, DWORD PTR __Tmp$1$[ebp]
	mov	DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	edi, DWORD PTR [ebx]
	cmp	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2791 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN153@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [edx], edi

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ebx], eax
$LN153@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	edi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi]
	pop	ebx
	cmp	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2786 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN174@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [esi], edi
$LN174@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	edi, DWORD PTR [edx]
	cmp	edi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2788 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	jae	SHORT $LN259@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2791 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN259@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2810 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	esi, DWORD PTR [edx]
	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2786 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN227@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [edx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], esi
$LN227@Guess_medi:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	esi, DWORD PTR [edi]
	cmp	esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2788 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	jae	SHORT $LN259@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	eax, DWORD PTR [ecx]
	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2791 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	jae	SHORT $LN259@Guess_medi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [edx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], esi
$LN259@Guess_medi:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2810 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Guess_median_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<unsigned long *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z
_TEXT	SEGMENT
tv256 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z PROC ; std::_Insertion_sort_unchecked<unsigned long *,std::less<void> >, COMDAT

; 2759 : 	{	// insertion sort [_First, _Last), using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2760 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[ebp]
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
	cmp	edi, eax
	je	SHORT $LN3@Insertion_

; 2761 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	je	SHORT $LN3@Insertion_
	mov	edx, 4
	lea	eax, DWORD PTR [ecx-4]
	sub	edx, edi
	push	ebx
	mov	DWORD PTR tv256[ebp], edx
	push	esi
$LL2@Insertion_:

; 2762 : 			{	// order next element
; 2763 : 			_BidIt _Next1 = _Next;
; 2764 : 			_Iter_value_t<_BidIt> _Val = _STD move(*_Next);

	mov	esi, DWORD PTR [eax+4]
	lea	ebx, DWORD PTR [eax+4]
	mov	edx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	cmp	esi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2766 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	jae	SHORT $LN9@Insertion_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2491 : 	return (static_cast<_BidIt2>(

	add	eax, DWORD PTR tv256[ebp]
	push	eax
	push	edi
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2769 : 				*_First = _STD move(_Val);

	mov	DWORD PTR [edi], esi

; 2770 : 				}
; 2771 : 			else

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	ecx, DWORD PTR [eax]
	cmp	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2774 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);

	jae	SHORT $LN6@Insertion_
	npad	5
$LL7@Insertion_:

; 2775 : 					_Next1 = _First1)
; 2776 : 					*_Next1 = _STD move(*_First1);	// move hole down

	mov	DWORD PTR [edx], ecx
	mov	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	ecx, DWORD PTR [eax-4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2774 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);

	sub	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	cmp	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2774 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);

	jb	SHORT $LL7@Insertion_
$LN6@Insertion_:

; 2777 : 				*_Next1 = _STD move(_Val);	// insert element in hole

	mov	DWORD PTR [edx], esi
$LN10@Insertion_:

; 2761 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	eax, ebx
	lea	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR __Last$[ebp]
	lea	ecx, DWORD PTR [edi+4]
	jne	SHORT $LL2@Insertion_
	pop	esi
	pop	ebx
$LN3@Insertion_:
	pop	edi

; 2778 : 				}
; 2779 : 			}
; 2780 : 	}

	pop	ebp
	ret	0
??$_Insertion_sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ENDP ; std::_Insertion_sort_unchecked<unsigned long *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Val$1 = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z PROC ; std::_Sort_heap_unchecked<unsigned long *,std::less<void> >, COMDAT

; 2273 : 	{	// order heap by repeatedly popping, using _Pred

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 2274 : 	for (; 2 <= _Last - _First; --_Last)

	mov	esi, DWORD PTR __Last$[ebp]
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
	sub	esi, edi
	mov	eax, esi
	sar	eax, 2
	cmp	eax, 2
	jl	SHORT $LN3@Sort_heap_
	push	ebx
	mov	ebx, DWORD PTR __Pred$[ebp]
$LN28@Sort_heap_:

; 2214 : 		_Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi+esi-4]
	mov	DWORD PTR __Val$1[ebp], eax

; 2202 : 	*_Dest = _STD move(*_First);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+esi-4], eax

; 2203 : 	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),

	lea	eax, DWORD PTR __Val$1[ebp]
	push	ebx
	push	eax
	lea	eax, DWORD PTR [esi-4]
	sar	eax, 2
	push	eax
	push	0
	push	edi
	call	??$_Pop_heap_hole_by_index@PAKHKU?$less@X@std@@@std@@YAXPAKHH$$QAKAAU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<unsigned long *,int,unsigned long,std::less<void> >

; 2274 : 	for (; 2 <= _Last - _First; --_Last)

	sub	esi, 4

; 2203 : 	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),

	add	esp, 20					; 00000014H

; 2274 : 	for (; 2 <= _Last - _First; --_Last)

	mov	eax, esi
	sar	eax, 2
	cmp	eax, 2
	jge	SHORT $LN28@Sort_heap_
	pop	ebx
$LN3@Sort_heap_:
	pop	edi
	pop	esi

; 2275 : 		_Pop_heap_unchecked(_First, _Last, _Pred);
; 2276 : 	}

	pop	ebp
	ret	0
??$_Sort_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ENDP ; std::_Sort_heap_unchecked<unsigned long *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__Hole$1$ = -8						; size = 4
__Val$1$ = -4						; size = 4
__Max_sequence_non_leaf$1$ = 8				; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Make_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z PROC ; std::_Make_heap_unchecked<unsigned long *,std::less<void> >, COMDAT

; 2240 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2241 : 	_Iter_diff_t<_RanIt> _Bottom = _Last - _First;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	sub	ecx, esi
	sar	ecx, 2
	mov	DWORD PTR __Last$[ebp], ecx

; 2242 : 	if (2 <= _Bottom)

	cmp	ecx, 2
	jl	$LN3@Make_heap_

; 2243 : 		{
; 2244 : 		for (_Iter_diff_t<_RanIt> _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ecx
	cdq
	sub	eax, edx
	push	ebx
	mov	ebx, eax
	sar	ebx, 1
	test	ebx, ebx
	jle	$LN56@Make_heap_
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[ebp], eax
	push	edi
	npad	2
$LL2@Make_heap_:

; 2247 : 			_Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	eax, DWORD PTR [esi+ebx*4-4]
	dec	ebx
	mov	DWORD PTR __Val$1$[ebp], eax

; 2248 : 			_Pop_heap_hole_by_index(_First, _Hole, _Bottom,

	mov	edi, ebx

; 2176 : 	while (_Idx < _Max_sequence_non_leaf)

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
	mov	edx, ebx

; 2245 : 			{	// reheap top half, bottom to top
; 2246 : 			--_Hole;

	mov	DWORD PTR __Hole$1$[ebp], ebx

; 2176 : 	while (_Idx < _Max_sequence_non_leaf)

	cmp	ebx, eax
	jge	SHORT $LN15@Make_heap_
	mov	ebx, eax
	npad	8
$LL14@Make_heap_:
	mov	eax, DWORD PTR [esi+edx*8+4]

; 2177 : 		{	// move _Hole down to larger child
; 2178 : 		_Idx = 2 * _Idx + 2;

	lea	ecx, DWORD PTR [edx*2+2]
	cmp	DWORD PTR [esi+ecx*4], eax
	lea	edx, DWORD PTR [ecx-1]
	cmovae	edx, ecx

; 2179 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))
; 2180 : 			--_Idx;
; 2181 : 		*(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [esi+edi*4], eax

; 2182 : 		_Hole = _Idx;

	mov	edi, edx
	cmp	edx, ebx
	jl	SHORT $LL14@Make_heap_
	mov	ebx, DWORD PTR __Hole$1$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
$LN15@Make_heap_:

; 2183 : 		}
; 2184 : 
; 2185 : 	if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0)

	cmp	edx, eax
	jne	SHORT $LN17@Make_heap_
	test	cl, 1
	jne	SHORT $LN17@Make_heap_

; 2186 : 		{	// only child at bottom, move _Hole down to it
; 2187 : 		*(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [esi+ecx*4-4]
	mov	DWORD PTR [esi+edi*4], eax

; 2188 : 		_Hole = _Bottom - 1;

	lea	edi, DWORD PTR [ecx-1]
$LN17@Make_heap_:

; 2122 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
	sar	eax, 1

; 2123 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);

	cmp	ebx, edi
	jge	SHORT $LN55@Make_heap_
$LL33@Make_heap_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	ecx, DWORD PTR [esi+eax*4]
	cmp	ecx, DWORD PTR __Val$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2123 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);

	jae	SHORT $LN55@Make_heap_

; 2124 : 		_Idx = (_Hole - 1) / 2)
; 2125 : 		{	// move _Hole up to parent
; 2126 : 		*(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	DWORD PTR [esi+edi*4], ecx

; 2127 : 		_Hole = _Idx;

	mov	edi, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ebx, edi
	jl	SHORT $LL33@Make_heap_
$LN55@Make_heap_:

; 2128 : 		}
; 2129 : 
; 2130 : 	*(_First + _Hole) = _STD move(_Val);	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$1$[ebp]

; 2243 : 		{
; 2244 : 		for (_Iter_diff_t<_RanIt> _Hole = _Bottom / 2; 0 < _Hole; )

	mov	ecx, DWORD PTR __Last$[ebp]

; 2130 : 	*(_First + _Hole) = _STD move(_Val);	// drop _Val into final hole

	mov	DWORD PTR [esi+edi*4], eax

; 2243 : 		{
; 2244 : 		for (_Iter_diff_t<_RanIt> _Hole = _Bottom / 2; 0 < _Hole; )

	test	ebx, ebx
	jg	$LL2@Make_heap_
	pop	edi
$LN56@Make_heap_:
	pop	ebx
$LN3@Make_heap_:
	pop	esi

; 2249 : 				_STD move(_Val), _Pred);
; 2250 : 			}
; 2251 : 		}
; 2252 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ENDP ; std::_Make_heap_unchecked<unsigned long *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAKU?$less@X@std@@@std@@YA?AU?$pair@PAKPAK@0@PAK0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__Gfirst$1$ = -12					; size = 4
tv482 = -8						; size = 4
__Glast$1$ = -8						; size = 4
__Plast$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Partition_by_median_guess_unchecked@PAKU?$less@X@std@@@std@@YA?AU?$pair@PAKPAK@0@PAK0AAU?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<unsigned long *,std::less<void> >, COMDAT

; 2816 : 	{	// partition [_First, _Last), using _Pred

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2817 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	eax, ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
	sub	eax, edi

; 2818 : 	_Guess_median_unchecked(_First, _Mid, _Last - 1, _Pred);

	push	DWORD PTR __Pred$[ebp]
	sar	eax, 2
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ebx, DWORD PTR [edi+eax*4]
	lea	eax, DWORD PTR [ecx-4]
	push	eax
	push	ebx
	push	edi
	call	??$_Guess_median_unchecked@PAKU?$less@X@std@@@std@@YAXPAK00AAU?$less@X@0@@Z ; std::_Guess_median_unchecked<unsigned long *,std::less<void> >
	add	esp, 16					; 00000010H

; 2819 : 	_RanIt _Pfirst = _Mid;
; 2820 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR __Plast$1$[ebp], esi

; 2824 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	cmp	edi, ebx
	jae	SHORT $LN181@Partition_
	npad	5
$LL2@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	ecx, DWORD PTR [ebx-4]
	mov	edx, DWORD PTR [ebx]
	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2824 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	jb	SHORT $LN181@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	cmp	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2824 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	jb	SHORT $LN181@Partition_

; 2825 : 		--_Pfirst;

	add	ebx, -4					; fffffffcH
	cmp	edi, ebx
	jb	SHORT $LL2@Partition_
$LN181@Partition_:

; 2828 : 		&& !_Pred(*_Pfirst, *_Plast))

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	esi, ecx
	jae	SHORT $LN5@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	edx, DWORD PTR [ebx]
	npad	3
$LL4@Partition_:
	mov	eax, DWORD PTR [esi]
	cmp	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2828 : 		&& !_Pred(*_Pfirst, *_Plast))

	jb	SHORT $LN182@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	cmp	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2828 : 		&& !_Pred(*_Pfirst, *_Plast))

	jb	SHORT $LN182@Partition_

; 2829 : 		++_Plast;

	add	esi, 4
	cmp	esi, ecx
	jb	SHORT $LL4@Partition_
$LN182@Partition_:
	mov	DWORD PTR __Plast$1$[ebp], esi
$LN5@Partition_:

; 2832 : 	_RanIt _Glast = _Pfirst;

	mov	edi, ebx
	mov	eax, esi
	mov	DWORD PTR __Glast$1$[ebp], edi
$LN186@Partition_:

; 2830 : 
; 2831 : 	_RanIt _Gfirst = _Plast;

	mov	DWORD PTR __Gfirst$1$[ebp], eax
	npad	2
$LL6@Partition_:

; 2836 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, ecx
	jae	SHORT $LN162@Partition_
	mov	edi, DWORD PTR __Last$[ebp]
$LL11@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2837 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

	jb	SHORT $LN9@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	cmp	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2839 : 			else if (_Pred(*_Gfirst, *_Pfirst))

	jb	SHORT $LN183@Partition_

; 2840 : 				break;
; 2841 : 			else if (_Plast++ != _Gfirst)

	mov	ecx, esi
	add	esi, 4
	cmp	ecx, eax
	je	SHORT $LN9@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi-4]

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [esi-4], edx

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [eax], ecx
$LN9@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2836 : 		for (; _Gfirst < _Last; ++_Gfirst)

	add	eax, 4
	cmp	eax, edi
	jb	SHORT $LL11@Partition_
$LN183@Partition_:
	mov	edi, DWORD PTR __Glast$1$[ebp]
	mov	DWORD PTR __Plast$1$[ebp], esi
	mov	DWORD PTR __Gfirst$1$[ebp], eax
$LN162@Partition_:

; 2843 : 		for (; _First < _Glast; --_Glast)

	mov	ecx, DWORD PTR __First$[ebp]
	cmp	edi, ecx
	jbe	SHORT $LN185@Partition_
	lea	edx, DWORD PTR [edi-4]
	mov	eax, ecx
$LL14@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	mov	ecx, DWORD PTR [edx]
	mov	esi, DWORD PTR [ebx]
	cmp	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2844 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

	jb	SHORT $LN12@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 318  : 		return (static_cast<_Ty1&&>(_Left)

	cmp	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2846 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

	jb	SHORT $LN184@Partition_

; 2847 : 				break;
; 2848 : 			else if (--_Pfirst != _Glast - 1)

	sub	ebx, 4
	cmp	ebx, edx
	je	SHORT $LN12@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 67   : 	_Left = _STD move(_Right);

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ebx], esi

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edx], ecx
$LN12@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2843 : 		for (; _First < _Glast; --_Glast)

	sub	edi, 4
	sub	edx, 4
	cmp	eax, edi
	jb	SHORT $LL14@Partition_
$LN184@Partition_:
	mov	ecx, DWORD PTR __First$[ebp]

; 2849 : 				_STD iter_swap(_Pfirst, _Glast - 1);
; 2850 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	edi, ecx
	mov	eax, DWORD PTR __Gfirst$1$[ebp]
	mov	esi, DWORD PTR __Plast$1$[ebp]
	mov	DWORD PTR __Glast$1$[ebp], edi
$LN185@Partition_:
	jne	SHORT $LN26@Partition_
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN164@Partition_

; 2851 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
; 2852 : 
; 2853 : 		if (_Glast == _First)
; 2854 : 			{	// no room at bottom, rotate pivot upward
; 2855 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN89@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR [ebx]

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [esi], edx
$LN89@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2857 : 			++_Plast;

	add	esi, 4

; 2858 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

	mov	edi, eax
	mov	DWORD PTR __Plast$1$[ebp], esi
	mov	esi, ebx
	add	ebx, 4
	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx

; 41   : 	}

	mov	esi, DWORD PTR __Plast$1$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edi], edx

; 41   : 	}

	mov	edi, DWORD PTR __Glast$1$[ebp]
	jmp	$LN186@Partition_
$LN26@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2862 : 			if (--_Glast != --_Pfirst)

	sub	edi, 4
	mov	DWORD PTR __Glast$1$[ebp], edi
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN29@Partition_
	sub	ebx, 4
	cmp	edi, ebx
	je	SHORT $LN117@Partition_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR [edi]

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [edi], ecx

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ebx], edx
$LN117@Partition_:

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR [esi-4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2864 : 			_STD iter_swap(_Pfirst, --_Plast);

	sub	esi, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR [ebx]

; 67   : 	_Left = _STD move(_Right);

	mov	DWORD PTR [ebx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2866 : 		else

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Plast$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2866 : 		else

	jmp	$LL6@Partition_
$LN29@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR [eax]

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2867 : 			_STD iter_swap(_Gfirst++, --_Glast);

	add	eax, 4

; 2868 : 		}

	mov	ecx, DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edi], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2868 : 		}

	jmp	$LN186@Partition_
$LN164@Partition_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR [eax+4], esi
	pop	esi

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], ebx
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2869 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Partition_by_median_guess_unchecked@PAKU?$less@X@std@@@std@@YA?AU?$pair@PAKPAK@0@PAK0AAU?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<unsigned long *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z PROC		; std::_Copy_memmove<unsigned long *,unsigned long *>, COMDAT

; 2295 : 	{	// implement copy-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2302 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ENDP		; std::_Copy_memmove<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@K@?$allocator@K@std@@QAEXPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@K@?$allocator@K@std@@QAEXPAK@Z PROC		; std::allocator<unsigned long>::destroy<unsigned long>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@K@?$allocator@K@std@@QAEXPAK@Z ENDP		; std::allocator<unsigned long>::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@KABK@?$allocator@K@std@@QAEXPAKABK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@KABK@?$allocator@K@std@@QAEXPAKABK@Z PROC	; std::allocator<unsigned long>::construct<unsigned long,unsigned long const &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@KABK@?$allocator@K@std@@QAEXPAKABK@Z ENDP	; std::allocator<unsigned long>::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z
_TEXT	SEGMENT
__Mid$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z PROC ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >, COMDAT

; 2875 : 	{	// order [_First, _Last), using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2876 : 	_Diff _Count;
; 2877 : 	while (_ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal)

	mov	eax, DWORD PTR __Pred$[ebp]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __First$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	mov	ecx, edi
	sub	ecx, ebx
	sar	ecx, 2
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN6@Sort_unche
	mov	esi, DWORD PTR __Ideal$[ebp]
$LL2@Sort_unche:
	test	esi, esi
	jle	SHORT $LN3@Sort_unche

; 2878 : 		{	// divide and conquer by quicksort
; 2879 : 		pair<_RanIt, _RanIt> _Mid =
; 2880 : 			_Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	eax
	push	edi
	lea	eax, DWORD PTR __Mid$1[ebp]
	push	ebx
	push	eax
	call	??$_Partition_by_median_guess_unchecked@PAKU?$less@X@std@@@std@@YA?AU?$pair@PAKPAK@0@PAK0AAU?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<unsigned long *,std::less<void> >

; 2881 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, esi

; 2882 : 
; 2883 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, edi
	cdq
	add	esp, 16					; 00000010H
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __Mid$1[ebp+4]
	sar	eax, 1
	sub	ecx, edx
	add	esi, eax
	and	ecx, -4					; fffffffcH
	mov	eax, DWORD PTR __Mid$1[ebp]
	sub	eax, ebx
	and	eax, -4					; fffffffcH
	cmp	eax, ecx

; 2884 : 			{	// loop on second half
; 2885 : 			_Sort_unchecked1(_First, _Mid.first, _Ideal, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	push	esi
	jge	SHORT $LN4@Sort_unche
	mov	eax, DWORD PTR __Mid$1[ebp]
	push	eax
	push	ebx
	call	??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >

; 2886 : 			_First = _Mid.second;

	mov	ebx, DWORD PTR __Mid$1[ebp+4]

; 2887 : 			}
; 2888 : 		else

	jmp	SHORT $LN13@Sort_unche
$LN4@Sort_unche:

; 2889 : 			{	// loop on first half
; 2890 : 			_Sort_unchecked1(_Mid.second, _Last, _Ideal, _Pred);

	push	edi
	push	edx
	call	??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >

; 2891 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$1[ebp]
$LN13@Sort_unche:

; 2876 : 	_Diff _Count;
; 2877 : 	while (_ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal)

	mov	eax, DWORD PTR __Pred$[ebp]
	mov	ecx, edi
	sub	ecx, ebx

; 2889 : 			{	// loop on first half
; 2890 : 			_Sort_unchecked1(_Mid.second, _Last, _Ideal, _Pred);

	add	esp, 16					; 00000010H
	sar	ecx, 2
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LL2@Sort_unche
$LN6@Sort_unche:

; 2899 : 		}
; 2900 : 	else if (2 <= _Count)

	cmp	ecx, 2
	jl	SHORT $LN8@Sort_unche

; 2901 : 		_Insertion_sort_unchecked(_First, _Last, _Pred);	// small

	push	eax
	push	edi
	push	ebx
	call	??$_Insertion_sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ; std::_Insertion_sort_unchecked<unsigned long *,std::less<void> >
	add	esp, 12					; 0000000cH
$LN8@Sort_unche:
	pop	edi
	pop	esi
	pop	ebx

; 2902 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@Sort_unche:

; 2892 : 			}
; 2893 : 		}
; 2894 : 
; 2895 : 	if (_ISORT_MAX < _Count)

	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN6@Sort_unche

; 2896 : 		{	// heap sort if too many divisions
; 2897 : 		_Make_heap_unchecked(_First, _Last, _Pred);

	push	eax
	push	edi
	push	ebx
	call	??$_Make_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ; std::_Make_heap_unchecked<unsigned long *,std::less<void> >

; 2898 : 		_Sort_heap_unchecked(_First, _Last, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	push	edi
	push	ebx
	call	??$_Sort_heap_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ; std::_Sort_heap_unchecked<unsigned long *,std::less<void> >
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 2902 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z ENDP ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAKPAK@std@@YAAAPAKAAPAKPAK@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAKPAK@std@@YAAAPAKAAPAKPAK@Z PROC	; std::_Rechecked<unsigned long *,unsigned long *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAKPAK@std@@YAAAPAKAAPAKPAK@Z ENDP	; std::_Rechecked<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@KKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@KKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned long,unsigned long,std::allocator<unsigned long> >, COMDAT

; 157  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 159  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@KKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned long,unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAK@std@@YA$$QAKAAK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAK@std@@YA$$QAKAAK@Z PROC			; std::move<unsigned long &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAK@std@@YA$$QAKAAK@Z ENDP			; std::move<unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z PROC ; std::_Ptr_move_cat<unsigned long,unsigned long>, COMDAT

; 892  : 	{	// return pointer move optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 893  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 894  : 	}

	pop	ebp
	ret	0
??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ENDP ; std::_Ptr_move_cat<unsigned long,unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAK@std@@YAPAKPAK@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAK@std@@YAPAKPAK@Z PROC			; std::_Unchecked<unsigned long *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAK@std@@YAPAKPAK@Z ENDP			; std::_Unchecked<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@K@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@K@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAK@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@K@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAK@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z PROC ; std::_Sort_unchecked<unsigned long *,std::less<void> >, COMDAT

; 2907 : 	{	// order [_First, _Last), using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2908 : 	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, edx
	mov	ecx, DWORD PTR __First$[ebp]
	sub	eax, ecx
	push	DWORD PTR __Pred$[ebp]
	sar	eax, 2
	push	eax
	push	edx
	push	ecx
	call	??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >
	add	esp, 16					; 00000010H

; 2909 : 	}

	pop	ebp
	ret	0
??$_Sort_unchecked@PAKU?$less@X@std@@@std@@YAXPAK0AAU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<unsigned long *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPAKV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPAKV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT

; 393  : 	{	// convert to unchecked

	npad	2
	push	ebp
	mov	ebp, esp

; 394  : 	return (_Iter._Unchecked());

	mov	eax, DWORD PTR __Iter$[ebp]

; 395  : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPAKV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 176  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned long>,unsigned long *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned long>,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@K@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@K@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAK@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@K@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAK@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@K@std@@YAPAKPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@K@std@@YAPAKPAK@Z PROC			; std::_Unfancy<unsigned long>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@K@std@@YAPAKPAK@Z ENDP			; std::_Unfancy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long const &>, COMDAT
; _this$ = ecx

; 898  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $LN71@Emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN71@Emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 902  : 		++this->_Mylast();

	add	DWORD PTR [ecx+4], 4

; 903  : 		}

	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABK@std@@YAABKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABK@std@@YAABKABK@Z PROC			; std::forward<unsigned long const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABK@std@@YAABKABK@Z ENDP			; std::forward<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0U?$less@X@0@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >,std::less<void> >, COMDAT

; 2914 : 	{	// order [_First, _Last), using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2908 : 	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);

	mov	ecx, DWORD PTR __Last$[ebp]
	lea	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 2
	push	edx
	push	ecx
	push	eax
	call	??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >
	add	esp, 16					; 00000010H

; 2915 : 	_DEBUG_RANGE(_First, _Last);
; 2916 : 	_Sort_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
; 2917 : 	}

	pop	ebp
	ret	0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0U?$less@X@0@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned long>,unsigned long *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned long>,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT
__Newcapacity$1$ = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>, COMDAT
; _this$ = ecx

; 908  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi

; 1731 : 		return (this->_Myend() != this->_Mylast());

	mov	ecx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [esi+4]
	cmp	ecx, edi

; 909  : 		if (_Has_unused_capacity())

	je	SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN70@emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi], eax
$LN70@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 902  : 		++this->_Mylast();

	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi

; 929  : 			_Emplaced = true;
; 930  : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 931  : 			_CATCH_ALL
; 932  : 			if (_Emplaced)
; 933  : 				{
; 934  : 				this->_Getal().destroy(_Unfancy(_Newvec + _Oldsize));
; 935  : 				}
; 936  : 
; 937  : 			this->_Getal().deallocate(_Newvec, _Newcapacity);
; 938  : 			_RERAISE;
; 939  : 			_CATCH_END
; 940  : 
; 941  : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 942  : 			}
; 943  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@emplace_ba:

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi]
	sub	edi, eax
	sar	edi, 2

; 910  : 			{
; 911  : 			_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 912  : 			}
; 913  : 		else
; 914  : 			{	// reallocate
; 915  : 			const size_type _Oldsize = size();
; 916  : 
; 917  : 			if (_Oldsize == max_size())

	cmp	edi, 1073741823				; 3fffffffH
	je	$LN365@emplace_ba

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	ecx, eax

; 920  : 				}
; 921  : 
; 922  : 			const size_type _Newsize = _Oldsize + 1;

	lea	edx, DWORD PTR [edi+1]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	ecx, 2

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 1073741823				; 3fffffffH
	push	ebx
	mov	ebx, ecx
	shr	ebx, 1
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN146@emplace_ba

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, edx
	mov	DWORD PTR __Newcapacity$1$[ebp], edx
	jmp	SHORT $LN147@emplace_ba
$LN146@emplace_ba:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, edx
	cmovb	eax, edx
	mov	DWORD PTR __Newcapacity$1$[ebp], eax
$LN147@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	mov	ecx, esi
	call	?allocate@?$allocator@K@std@@QAEPAKI@Z	; std::allocator<unsigned long>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 925  : 			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	ebx, eax

; 926  : 
; 927  : 			_TRY_BEGIN
; 928  : 			this->_Getal().construct(_Unfancy(_Newvec + _Oldsize), _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR [ebx+edi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN219@emplace_ba
	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN219@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ecx, DWORD PTR [esi]

; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR [esi+4]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN271@emplace_ba

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN271@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [esi], ebx
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 929  : 			_Emplaced = true;
; 930  : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 931  : 			_CATCH_ALL
; 932  : 			if (_Emplaced)
; 933  : 				{
; 934  : 				this->_Getal().destroy(_Unfancy(_Newvec + _Oldsize));
; 935  : 				}
; 936  : 
; 937  : 			this->_Getal().deallocate(_Newvec, _Newcapacity);
; 938  : 			_RERAISE;
; 939  : 			_CATCH_END
; 940  : 
; 941  : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 942  : 			}
; 943  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN365@emplace_ba:

; 918  : 				{
; 919  : 				_Xlength();

	call	?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
$LN367@emplace_ba:
$LN364@emplace_ba:
	int	3
??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@K@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@K@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@K@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Pred$ = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T1 = 15						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > > >, COMDAT

; 2922 : 	{	// order [_First, _Last), using operator<

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2923 : 	_STD sort(_First, _Last, less<>());

	mov	al, BYTE PTR $T1[ebp]

; 2908 : 	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, ecx

; 2923 : 	_STD sort(_First, _Last, less<>());

	mov	BYTE PTR __Pred$[ebp], al

; 2908 : 	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);

	lea	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	sub	edx, eax
	sar	edx, 2
	push	edx
	push	ecx
	push	eax
	call	??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >
	add	esp, 16					; 00000010H

; 2924 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEPAKXZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEPAKXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Unchecked, COMDAT
; _this$ = ecx

; 317  : 		return (this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 318  : 		}

	ret	0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEPAKXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 305  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 44   : 		this->_Adopt(_Pvector);
; 45   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??__Fgpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@YAXXZ
text$yd	SEGMENT
??__Fgpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@YAXXZ PROC ; `SK_GPUPollingThread'::`12'::`dynamic atexit destructor for 'gpu_ids'', COMDAT

; 1947 : 		this->_Orphan_all();

	mov	ecx, OFFSET ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all

; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
	test	eax, eax
	je	SHORT $LN7@dynamic

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	push	DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A+4
	mov	ecx, OFFSET ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
	push	eax
	call	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A+8
	mov	ecx, DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A, 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A+4, 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A+8, 0
$LN7@dynamic:
	ret	0
??__Fgpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@YAXXZ ENDP ; `SK_GPUPollingThread'::`12'::`dynamic atexit destructor for 'gpu_ids''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@ABEXPAK0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@ABEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1996 : 		}

	ret	8
?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@ABEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 1073741823				; 3fffffffH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 2

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[], COMDAT
; _this$ = ecx

; 1736 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1737 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1738 : 		if (size() <= _Pos)
; 1739 : 			{	// report error
; 1740 : 			_DEBUG_ERROR("vector subscript out of range");
; 1741 : 			}
; 1742 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1743 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1744 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1745 : 
; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1747 : 		}

	pop	ebp
	ret	4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@KV?$allocator@K@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_Has_unused_capacity@?$vector@KV?$allocator@K@std@@@std@@ABE_NXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Has_unused_capacity, COMDAT
; _this$ = ecx

; 1730 : 		{	// micro-optimization for capacity() != size()

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [ecx+4]
	setne	al

; 1731 : 		return (this->_Myend() != this->_Mylast());
; 1732 : 		}

	ret	0
?_Has_unused_capacity@?$vector@KV?$allocator@K@std@@@std@@ABE_NXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1721 : 		}

	ret	0
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1716 : 		}

	ret	0
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1711 : 		}

	ret	0
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::end, COMDAT
; _this$ = ecx

; 1654 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1655 : 		return (iterator(this->_Mylast(), _STD addressof(this->_Get_data())));
; 1656 : 		}

	pop	ebp
	ret	4
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 1644 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1645 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
; 1646 : 		}

	pop	ebp
	ret	4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back, COMDAT
; _this$ = ecx

; 946  : 		{	// insert element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 948  : 		}

	pop	ebp

; 947  : 		emplace_back(_Val);

	jmp	??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 723  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 723  : 		}

	ret	0
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 509  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 509  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@K@std@@QAEPAKI@Z	; std::allocator<unsigned long>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@K@std@@QBEIXZ PROC		; std::allocator<unsigned long>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@K@std@@QBEIXZ ENDP		; std::allocator<unsigned long>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@K@std@@QAEPAKI@Z PROC		; std::allocator<unsigned long>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@K@std@@QAEPAKI@Z ENDP		; std::allocator<unsigned long>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@K@std@@QAEXPAKI@Z PROC		; std::allocator<unsigned long>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@K@std@@QAEXPAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@K@std@@QAE@XZ PROC			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@K@std@@QAE@XZ ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
_ps20info$1 = -8404					; size = 7416
_gpus$2 = -988						; size = 256
_freq$3 = -732						; size = 264
_pcieinfo$4 = -468					; size = 164
_thermal$5 = -304					; size = 68
_psinfoex$6 = -236					; size = 72
_meminfo$7 = -164					; size = 32
$T8 = -132						; size = 4
$T9 = -128						; size = 4
_activity$10 = -124					; size = 40
_fanspeed$11 = -84					; size = 16
_hEvents$ = -68						; size = 8
_temp$12 = -60						; size = 8
_mem_loc$13 = -52					; size = 4
_gpu_id$14 = -48					; size = 4
_stats$1$ = -44						; size = 4
_current_pstate$15 = -40				; size = 4
_perf_decrease_info$16 = -36				; size = 4
_tach$17 = -32						; size = 4
_mem_type$18 = -28					; size = 4
_mem_width$19 = -24					; size = 4
_pcie_lanes$20 = -20					; size = 4
_gpu_count$21 = -16					; size = 4
_i$1$ = -12						; size = 4
_i$1$ = -12						; size = 4
__Pred$ = -8						; size = 1
$T22 = -8						; size = 1
_gpu$23 = -4						; size = 4
_user$ = 8						; size = 4
?SK_GPUPollingThread@@YGKPAX@Z PROC			; SK_GPUPollingThread

; 54   : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, 8404				; 000020d4H
	call	__chkstk

; 55   :   UNREFERENCED_PARAMETER (user);
; 56   : 
; 57   :   const HANDLE hEvents [2] = {
; 58   :     hPollEvent,

	mov	eax, DWORD PTR ?hPollEvent@@3PAXA
	push	esi
	push	edi
	mov	DWORD PTR _hEvents$[ebp], eax

; 59   :     hShutdownEvent

	mov	eax, DWORD PTR ?hShutdownEvent@@3PAXA

; 60   :   };
; 61   : 
; 62   :   while (true)
; 63   :   {
; 64   :     DWORD dwWait =
; 65   :       WaitForMultipleObjects (2, hEvents, FALSE, INFINITE);

	push	-1
	mov	DWORD PTR _hEvents$[ebp+4], eax
	lea	eax, DWORD PTR _hEvents$[ebp]
	push	0
	push	eax
	push	2
	call	DWORD PTR __imp__WaitForMultipleObjects@16

; 66   : 
; 67   :     if (dwWait == WAIT_OBJECT_0 + 1)

	cmp	eax, 1
	je	$LN182@SK_GPUPoll
	npad	6
$LL2@SK_GPUPoll:

; 68   :       break;
; 69   : 
; 70   :     else if (dwWait != WAIT_OBJECT_0)

	test	eax, eax
	jne	$LN182@SK_GPUPoll

; 71   :       break;
; 72   : 
; 73   :     current_gpu_stat = (! current_gpu_stat);

	mov	eax, DWORD PTR ?current_gpu_stat@@3KC	; current_gpu_stat
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	DWORD PTR ?current_gpu_stat@@3KC, eax	; current_gpu_stat

; 74   : 
; 75   :     gpu_sensors_t& stats = gpu_stats_buffers [current_gpu_stat];

	imul	edi, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	add	edi, OFFSET ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A ; gpu_stats_buffers

; 76   : 
; 77   :     if (nvapi_init)

	cmp	DWORD PTR ?nvapi_init@@3HA, 0		; nvapi_init
	mov	DWORD PTR _stats$1$[ebp], edi
	je	$LN29@SK_GPUPoll

; 78   :     {
; 79   :       NvPhysicalGpuHandle gpus [NVAPI_MAX_PHYSICAL_GPUS] = { };

	push	256					; 00000100H
	lea	eax, DWORD PTR _gpus$2[ebp]
	push	0
	push	eax
	call	_memset

; 80   :       NvU32               gpu_count                      =  0;
; 81   : 
; 82   :       if (NVAPI_OK != NvAPI_EnumPhysicalGPUs (gpus, &gpu_count))

	lea	eax, DWORD PTR _gpu_count$21[ebp]
	mov	DWORD PTR _gpu_count$21[ebp], 0
	push	eax
	lea	eax, DWORD PTR _gpus$2[ebp]
	push	eax
	call	_NvAPI_EnumPhysicalGPUs
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN184@SK_GPUPoll

; 83   :         return 0;
; 84   : 
; 85   :       NV_GPU_DYNAMIC_PSTATES_INFO_EX psinfoex;
; 86   :       psinfoex.version = NV_GPU_DYNAMIC_PSTATES_INFO_EX_VER;
; 87   : 
; 88   :       stats.num_gpus = gpu_count;

	mov	eax, DWORD PTR _gpu_count$21[ebp]

; 89   : 
; 90   :       static std::vector <NvU32> gpu_ids;

	mov	ecx, DWORD PTR fs:__tls_array
	mov	DWORD PTR [edi+8192], eax
	mov	eax, DWORD PTR __tls_index
	mov	DWORD PTR _psinfoex$6[ebp], 65608	; 00010048H
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?$TSS0@?M@??SK_GPUPollingThread@@YGKPAX@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jg	$LN215@SK_GPUPoll
$LN4@SK_GPUPoll:

; 91   :       static bool init = false;
; 92   : 
; 93   :       if (! init)

	cmp	BYTE PTR ?init@?M@??SK_GPUPollingThread@@YGKPAX@Z@4_NA, 0
	jne	SHORT $LN32@SK_GPUPoll

; 95   :         for (int i = 0; i < stats.num_gpus; i++)

	xor	esi, esi
	cmp	DWORD PTR [edi+8192], esi
	jle	SHORT $LN6@SK_GPUPoll
$LL7@SK_GPUPoll:

; 96   :         {
; 97   :           NvU32 gpu_id;
; 98   :           NvAPI_GetGPUIDFromPhysicalGPU ( gpus [i], &gpu_id );

	lea	eax, DWORD PTR _gpu_id$14[ebp]
	push	eax
	push	DWORD PTR _gpus$2[ebp+esi*4]
	call	DWORD PTR _NvAPI_GetGPUIDFromPhysicalGPU
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	lea	eax, DWORD PTR _gpu_id$14[ebp]
	mov	ecx, OFFSET ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
	push	eax
	call	??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp

; 95   :         for (int i = 0; i < stats.num_gpus; i++)

	inc	esi
	cmp	esi, DWORD PTR [edi+8192]
	jl	SHORT $LL7@SK_GPUPoll
$LN6@SK_GPUPoll:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2923 : 	_STD sort(_First, _Last, less<>());

	mov	al, BYTE PTR $T22[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 42   : 		: _Ptr(_Parg)

	mov	edx, DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A+4
	mov	ecx, DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2923 : 	_STD sort(_First, _Last, less<>());

	mov	BYTE PTR __Pred$[ebp], al

; 2908 : 	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);

	lea	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 42   : 		: _Ptr(_Parg)

	mov	DWORD PTR $T9[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2908 : 	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);

	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 42   : 		: _Ptr(_Parg)

	mov	DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 2908 : 	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);

	sar	eax, 2
	push	eax
	push	edx
	push	ecx
	call	??$_Sort_unchecked1@PAKHU?$less@X@std@@@std@@YAXPAK0HAAU?$less@X@0@@Z ; std::_Sort_unchecked1<unsigned long *,int,std::less<void> >
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp

; 104  :         init = true;

	mov	BYTE PTR ?init@?M@??SK_GPUPollingThread@@YGKPAX@Z@4_NA, 1
$LN32@SK_GPUPoll:

; 105  :       }
; 106  : 
; 107  :       for (int i = 0; i < stats.num_gpus; i++)

	xor	esi, esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	DWORD PTR [edi+8192], esi
	jle	$LN24@SK_GPUPoll
	add	edi, 40					; 00000028H
	npad	7
$LL10@SK_GPUPoll:

; 108  :       {
; 109  :         NvPhysicalGpuHandle gpu;
; 110  : 
; 111  :         // In order for DXGI Adapter info to match up... don't just assign
; 112  :         //   these GPUs willy-nilly, use the high 24-bits of the GPUID as
; 113  :         //     a bitmask.
; 114  :         //NvAPI_GetPhysicalGPUFromGPUID (1 << (i + 8), &gpu);
; 115  :         //stats.gpus [i].nv_gpuid = (1 << (i + 8));
; 116  : 
; 117  :         NvAPI_GetPhysicalGPUFromGPUID (gpu_ids [i], &gpu);

	lea	eax, DWORD PTR _gpu$23[ebp]
	push	eax
	mov	eax, DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
	push	DWORD PTR [eax+esi*4]
	call	DWORD PTR _NvAPI_GetPhysicalGPUFromGPUID

; 118  :         stats.gpus [i].nv_gpuid = gpu_ids [i];

	mov	eax, DWORD PTR ?gpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@4V?$vector@KV?$allocator@K@std@@@std@@A
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edi+76], eax

; 119  : 
; 120  :         NvAPI_Status        status =
; 121  :           NvAPI_GPU_GetDynamicPstatesInfoEx (gpu, &psinfoex);

	lea	eax, DWORD PTR _psinfoex$6[ebp]
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	call	_NvAPI_GPU_GetDynamicPstatesInfoEx
	add	esp, 16					; 00000010H

; 122  : 
; 123  :         if (status == NVAPI_OK)

	test	eax, eax
	jne	SHORT $LN33@SK_GPUPoll

; 124  :         {
; 125  : #ifdef SMOOTH_GPU_UPDATES
; 126  :           stats.gpus [i].loads_percent.gpu = (stats.gpus [i].loads_percent.gpu +
; 127  :            psinfoex.utilization [NVAPI_GPU_UTILIZATION_DOMAIN_GPU].percentage) / 2;
; 128  :           stats.gpus [i].loads_percent.fb  = (stats.gpus [i].loads_percent.fb +
; 129  :             psinfoex.utilization [NVAPI_GPU_UTILIZATION_DOMAIN_FB].percentage) / 2;
; 130  :           stats.gpus [i].loads_percent.vid = (stats.gpus [i].loads_percent.vid +
; 131  :             psinfoex.utilization [NVAPI_GPU_UTILIZATION_DOMAIN_VID].percentage) / 2;
; 132  :           stats.gpus [i].loads_percent.bus = (stats.gpus [i].loads_percent.bus +
; 133  :             psinfoex.utilization [NVAPI_GPU_UTILIZATION_DOMAIN_BUS].percentage) / 2;
; 134  : #else
; 135  :           stats.gpus [i].loads_percent.gpu =

	mov	eax, DWORD PTR _psinfoex$6[ebp+12]
	mov	DWORD PTR [edi-40], eax

; 136  :             psinfoex.utilization [NVAPI_GPU_UTILIZATION_DOMAIN_GPU].percentage;
; 137  :           stats.gpus [i].loads_percent.fb =

	mov	eax, DWORD PTR _psinfoex$6[ebp+20]
	mov	DWORD PTR [edi-36], eax

; 138  :             psinfoex.utilization [NVAPI_GPU_UTILIZATION_DOMAIN_FB].percentage;
; 139  :           stats.gpus [i].loads_percent.vid =

	mov	eax, DWORD PTR _psinfoex$6[ebp+28]
	mov	DWORD PTR [edi-32], eax

; 140  :             psinfoex.utilization [NVAPI_GPU_UTILIZATION_DOMAIN_VID].percentage;
; 141  :           stats.gpus [i].loads_percent.bus =

	mov	eax, DWORD PTR _psinfoex$6[ebp+36]
	mov	DWORD PTR [edi-28], eax
$LN33@SK_GPUPoll:

; 142  :             psinfoex.utilization [NVAPI_GPU_UTILIZATION_DOMAIN_BUS].percentage;
; 143  : #endif
; 144  :         }
; 145  : 
; 146  :         NV_GPU_THERMAL_SETTINGS thermal;
; 147  :         thermal.version = NV_GPU_THERMAL_SETTINGS_VER;
; 148  : 
; 149  :         status = NvAPI_GPU_GetThermalSettings (gpu,

	lea	eax, DWORD PTR _thermal$5[ebp]
	mov	DWORD PTR _thermal$5[ebp], 131140	; 00020044H
	push	eax
	push	15					; 0000000fH
	push	DWORD PTR _gpu$23[ebp]
	call	_NvAPI_GPU_GetThermalSettings
	add	esp, 12					; 0000000cH

; 150  :                                                NVAPI_THERMAL_TARGET_ALL,
; 151  :                                                &thermal);
; 152  : 
; 153  :         if (status == NVAPI_OK)

	test	eax, eax
	jne	SHORT $LN12@SK_GPUPoll

; 154  :         {
; 155  :           for (NvU32 j = 0; j < thermal.count; j++)

	mov	esi, DWORD PTR _thermal$5[ebp+4]
	test	esi, esi
	je	SHORT $LN12@SK_GPUPoll
	lea	ecx, DWORD PTR _thermal$5[ebp+20]
	npad	7
$LL13@SK_GPUPoll:

; 156  :           {
; 157  : #ifdef SMOOTH_GPU_UPDATES
; 158  :             if (thermal.sensor [j].target == NVAPI_THERMAL_TARGET_GPU)
; 159  :               stats.gpus [i].temps_c.gpu = (stats.gpus[i].temps_c.gpu + thermal.sensor [j].currentTemp) / 2;
; 160  : #else
; 161  :             if (thermal.sensor [j].target == NVAPI_THERMAL_TARGET_GPU)

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, 1
	jne	SHORT $LN35@SK_GPUPoll

; 162  :               stats.gpus [i].temps_c.gpu = thermal.sensor [j].currentTemp;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi-4], eax
$LN35@SK_GPUPoll:

; 163  :             if (thermal.sensor [j].target == NVAPI_THERMAL_TARGET_MEMORY)

	cmp	edx, 2
	jne	SHORT $LN36@SK_GPUPoll

; 164  :               stats.gpus [i].temps_c.ram = thermal.sensor [j].currentTemp;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi], eax
$LN36@SK_GPUPoll:

; 165  :             if (thermal.sensor [j].target == NVAPI_THERMAL_TARGET_POWER_SUPPLY)

	cmp	edx, 4
	jne	SHORT $LN37@SK_GPUPoll

; 166  :               stats.gpus [i].temps_c.psu = thermal.sensor [j].currentTemp;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+4], eax
$LN37@SK_GPUPoll:

; 167  :             if (thermal.sensor [j].target == NVAPI_THERMAL_TARGET_BOARD)

	cmp	edx, 8
	jne	SHORT $LN11@SK_GPUPoll

; 168  :               stats.gpus [i].temps_c.pcb = thermal.sensor [j].currentTemp;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+8], eax
$LN11@SK_GPUPoll:

; 154  :         {
; 155  :           for (NvU32 j = 0; j < thermal.count; j++)

	add	ecx, 20					; 00000014H
	sub	esi, 1
	jne	SHORT $LL13@SK_GPUPoll
$LN12@SK_GPUPoll:

; 169  : #endif
; 170  :           }
; 171  :         }
; 172  : 
; 173  :         NvU32 pcie_lanes = 0;
; 174  :         if (NVAPI_OK == NvAPI_GPU_GetCurrentPCIEDownstreamWidth (gpu, &pcie_lanes))

	lea	eax, DWORD PTR _pcie_lanes$20[ebp]
	mov	DWORD PTR _pcie_lanes$20[ebp], 0
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	call	_NvAPI_GPU_GetCurrentPCIEDownstreamWidth
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN39@SK_GPUPoll

; 175  :         {
; 176  :           stats.gpus [i].hwinfo.pcie_lanes = pcie_lanes;

	mov	eax, DWORD PTR _pcie_lanes$20[ebp]
	mov	DWORD PTR [edi+64], eax
$LN39@SK_GPUPoll:

; 177  :         }
; 178  : 
; 179  :         NV_PCIE_INFO pcieinfo         = {              };

	push	164					; 000000a4H
	lea	eax, DWORD PTR _pcieinfo$4[ebp]
	push	0
	push	eax
	call	_memset

; 180  :                      pcieinfo.version = NV_PCIE_INFO_VER;
; 181  : 
; 182  :         if (NVAPI_OK == NvAPI_GPU_GetPCIEInfo (gpu, &pcieinfo))

	lea	eax, DWORD PTR _pcieinfo$4[ebp]
	mov	DWORD PTR _pcieinfo$4[ebp], 131236	; 000200a4H
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	call	DWORD PTR _NvAPI_GPU_GetPCIEInfo
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN40@SK_GPUPoll

; 183  :         {
; 184  :           stats.gpus [i].hwinfo.pcie_gen   =

	mov	eax, DWORD PTR _pcieinfo$4[ebp+24]
	mov	DWORD PTR [edi+68], eax

; 185  :             pcieinfo.info [0].unknown5;//states [pstate].pciLinkRate;
; 186  :           stats.gpus [i].hwinfo.pcie_lanes =

	mov	eax, DWORD PTR _pcieinfo$4[ebp+28]
	mov	DWORD PTR [edi+64], eax

; 187  :             pcieinfo.info [0].unknown6;//pstates [pstate].pciLinkWidth;
; 188  :           stats.gpus [i].hwinfo.pcie_transfer_rate =

	mov	eax, DWORD PTR _pcieinfo$4[ebp+4]
	mov	DWORD PTR [edi+72], eax
$LN40@SK_GPUPoll:

; 189  :             pcieinfo.info [0].unknown0;//pstates [pstate].pciLinkTransferRate;
; 190  :         }
; 191  : 
; 192  :         NvU32 mem_width = 0,
; 193  :               mem_loc   = 0,
; 194  :               mem_type  = 0;
; 195  : 
; 196  :         if (NVAPI_OK == NvAPI_GPU_GetFBWidthAndLocation (gpu, &mem_width, &mem_loc))

	lea	eax, DWORD PTR _mem_loc$13[ebp]
	mov	DWORD PTR _mem_width$19[ebp], 0
	push	eax
	lea	eax, DWORD PTR _mem_width$19[ebp]
	mov	DWORD PTR _mem_loc$13[ebp], 0
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	mov	DWORD PTR _mem_type$18[ebp], 0
	call	DWORD PTR _NvAPI_GPU_GetFBWidthAndLocation
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN41@SK_GPUPoll

; 197  :         {
; 198  :           stats.gpus [i].hwinfo.mem_bus_width = mem_width;

	mov	eax, DWORD PTR _mem_width$19[ebp]
	mov	DWORD PTR [edi+60], eax
$LN41@SK_GPUPoll:

; 199  :         }
; 200  : 
; 201  :         if (NVAPI_OK == NvAPI_GPU_GetRamType (gpu, &mem_type))

	lea	eax, DWORD PTR _mem_type$18[ebp]
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	call	DWORD PTR _NvAPI_GPU_GetRamType
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN42@SK_GPUPoll

; 202  :         {
; 203  :           stats.gpus [i].hwinfo.mem_type = mem_type;

	mov	eax, DWORD PTR _mem_type$18[ebp]
	mov	DWORD PTR [edi+56], eax
$LN42@SK_GPUPoll:

; 204  :         }
; 205  : 
; 206  :         NV_DISPLAY_DRIVER_MEMORY_INFO meminfo = { };
; 207  :                                       meminfo.version = NV_DISPLAY_DRIVER_MEMORY_INFO_VER;
; 208  : 
; 209  :         if (NVAPI_OK == NvAPI_GPU_GetMemoryInfo (gpu, &meminfo))

	lea	eax, DWORD PTR _meminfo$7[ebp]
	xorps	xmm0, xmm0
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	movups	XMMWORD PTR _meminfo$7[ebp], xmm0
	mov	DWORD PTR _meminfo$7[ebp], 196640	; 00030020H
	movups	XMMWORD PTR _meminfo$7[ebp+16], xmm0
	call	_NvAPI_GPU_GetMemoryInfo
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN43@SK_GPUPoll

; 210  :         {
; 211  :           int64_t local =
; 212  :             (meminfo.availableDedicatedVideoMemory) -

	mov	eax, DWORD PTR _meminfo$7[ebp+8]

; 213  :             (meminfo.curAvailableDedicatedVideoMemory);
; 214  : 
; 215  :           stats.gpus [i].memory_B.local    = local                        * 1024LL;

	mov	ecx, 1024				; 00000400H
	sub	eax, DWORD PTR _meminfo$7[ebp+20]
	mul	ecx

; 216  :           stats.gpus [i].memory_B.capacity = meminfo.dedicatedVideoMemory * 1024LL;

	mov	ecx, DWORD PTR _meminfo$7[ebp+4]
	mov	DWORD PTR [edi+24], eax
	mov	eax, ecx

; 217  : 
; 218  :           stats.gpus [i].memory_B.total =

	sub	ecx, DWORD PTR _meminfo$7[ebp+20]
	mov	DWORD PTR [edi+28], edx
	mov	edx, 1024				; 00000400H
	mul	edx
	mov	DWORD PTR [edi+48], eax
	mov	eax, ecx
	mov	ecx, 1024				; 00000400H
	mov	DWORD PTR [edi+52], edx
	mul	ecx

; 219  :             ((meminfo.dedicatedVideoMemory) -
; 220  :              (meminfo.curAvailableDedicatedVideoMemory)) * 1024LL;
; 221  : 
; 222  :           // Compute Non-Local
; 223  :           stats.gpus [i].memory_B.nonlocal =

	mov	ecx, eax
	mov	DWORD PTR [edi+40], eax
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, edx
	mov	DWORD PTR [edi+44], edx
	sbb	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [edi+32], ecx
	mov	DWORD PTR [edi+36], eax
$LN43@SK_GPUPoll:

; 224  :             stats.gpus [i].memory_B.total - stats.gpus [i].memory_B.local;
; 225  :         }
; 226  : 
; 227  :         NV_GPU_CLOCK_FREQUENCIES freq           = {                          };

	push	264					; 00000108H
	lea	eax, DWORD PTR _freq$3[ebp]
	push	0
	push	eax
	call	_memset

; 228  :                                  freq.version   = NV_GPU_CLOCK_FREQUENCIES_VER;
; 229  :                                  freq.ClockType = NV_GPU_CLOCK_FREQUENCIES_CURRENT_FREQ;

	and	DWORD PTR _freq$3[ebp+4], -4		; fffffffcH

; 230  : 
; 231  :         if (NVAPI_OK == NvAPI_GPU_GetAllClockFrequencies (gpu, &freq))

	lea	eax, DWORD PTR _freq$3[ebp]
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	mov	DWORD PTR _freq$3[ebp], 196872		; 00030108H
	call	_NvAPI_GPU_GetAllClockFrequencies
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN44@SK_GPUPoll

; 232  :         {
; 233  :           stats.gpus [i].clocks_kHz.gpu    =

	mov	eax, DWORD PTR _freq$3[ebp+12]
	mov	DWORD PTR [edi-24], eax

; 234  :             freq.domain [NVAPI_GPU_PUBLIC_CLOCK_GRAPHICS].frequency;
; 235  :           stats.gpus [i].clocks_kHz.ram    =

	mov	eax, DWORD PTR _freq$3[ebp+44]
	mov	DWORD PTR [edi-20], eax
$LN44@SK_GPUPoll:

; 236  :             freq.domain [NVAPI_GPU_PUBLIC_CLOCK_MEMORY].frequency;
; 237  :           ////stats.gpus [i].clocks_kHz.shader =
; 238  :             ////freq.domain [NVAPI_GPU_PUBLIC_CLOCK_PROCESSOR].frequency;
; 239  :         }
; 240  : 
; 241  :         NvU32 tach = 0;
; 242  : 
; 243  :         stats.gpus [i].fans_rpm.supported = false;
; 244  : 
; 245  :         if (NVAPI_OK == NvAPI_GPU_GetTachReading (gpu, &tach))

	lea	eax, DWORD PTR _tach$17[ebp]
	mov	DWORD PTR _tach$17[ebp], 0
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	mov	BYTE PTR [edi+16], 0
	call	_NvAPI_GPU_GetTachReading
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@SK_GPUPoll

; 246  :         {
; 247  :           stats.gpus [i].fans_rpm.gpu       = tach;

	mov	eax, DWORD PTR _tach$17[ebp]
	mov	DWORD PTR [edi+12], eax

; 248  :           stats.gpus [i].fans_rpm.supported = true;

	mov	BYTE PTR [edi+16], 1
$LN45@SK_GPUPoll:

; 249  :         }
; 250  : 
; 251  :         static int iter = 0;
; 252  :         
; 253  :         // This is an expensive operation for very little gain,
; 254  :         //   it rarely changes, but it eats CPU time.
; 255  :         if (iter++ % 6 == 0 && config.gpu.print_slowdown)

	mov	esi, DWORD PTR ?iter@?BF@??SK_GPUPollingThread@@YGKPAX@Z@4HA
	mov	eax, 715827883				; 2aaaaaabH
	imul	esi
	mov	ecx, esi
	inc	esi
	mov	eax, edx
	mov	DWORD PTR ?iter@?BF@??SK_GPUPollingThread@@YGKPAX@Z@4HA, esi
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	sub	ecx, eax
	jne	SHORT $LN46@SK_GPUPoll
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+121, cl
	je	SHORT $LN46@SK_GPUPoll

; 256  :         {
; 257  :           NvU32 perf_decrease_info = 0;
; 258  :           NvAPI_GPU_GetPerfDecreaseInfo (gpu, &perf_decrease_info);

	lea	eax, DWORD PTR _perf_decrease_info$16[ebp]
	mov	DWORD PTR _perf_decrease_info$16[ebp], ecx
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	call	_NvAPI_GPU_GetPerfDecreaseInfo

; 259  : 
; 260  :           stats.gpus [i].nv_perf_state = perf_decrease_info;

	mov	eax, DWORD PTR _perf_decrease_info$16[ebp]
	add	esp, 8
	mov	DWORD PTR [edi+80], eax
$LN46@SK_GPUPoll:

; 261  :         }
; 262  : 
; 263  :         NV_GPU_PERF_PSTATES20_INFO ps20info = {                            };

	push	7416					; 00001cf8H
	lea	eax, DWORD PTR _ps20info$1[ebp]
	push	0
	push	eax
	call	_memset

; 264  :         ps20info.version                    = NV_GPU_PERF_PSTATES20_INFO_VER;
; 265  : 
; 266  :         stats.gpus [i].volts_mV.supported   = false;
; 267  : 
; 268  :         if (NVAPI_OK == NvAPI_GPU_GetPstates20 (gpu, &ps20info))

	lea	eax, DWORD PTR _ps20info$1[ebp]
	mov	DWORD PTR _ps20info$1[ebp], 204024	; 00031cf8H
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	mov	BYTE PTR [edi-7], 0
	call	_NvAPI_GPU_GetPstates20
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN8@SK_GPUPoll

; 269  :         {
; 270  :           NV_GPU_PERF_PSTATE_ID current_pstate = { };

	mov	DWORD PTR _current_pstate$15[ebp], eax

; 271  : 
; 272  :           if (NVAPI_OK == NvAPI_GPU_GetCurrentPstate (gpu, &current_pstate))

	lea	eax, DWORD PTR _current_pstate$15[ebp]
	push	eax
	push	DWORD PTR _gpu$23[ebp]
	call	_NvAPI_GPU_GetCurrentPstate
	add	esp, 8
	test	eax, eax
	jne	$LN8@SK_GPUPoll

; 273  :           {
; 274  :             for (NvU32 pstate = 0; pstate < ps20info.numPstates; pstate++)

	mov	ecx, DWORD PTR _ps20info$1[ebp+8]
	xor	edx, edx
	test	ecx, ecx
	je	$LN8@SK_GPUPoll
	mov	esi, DWORD PTR _current_pstate$15[ebp]
	lea	eax, DWORD PTR _ps20info$1[ebp+20]
	npad	6
$LL16@SK_GPUPoll:

; 275  :             {
; 276  :               if (ps20info.pstates [pstate].pstateId == current_pstate)

	cmp	DWORD PTR [eax], esi
	je	SHORT $LN178@SK_GPUPoll

; 273  :           {
; 274  :             for (NvU32 pstate = 0; pstate < ps20info.numPstates; pstate++)

	inc	edx
	add	eax, 456				; 000001c8H
	cmp	edx, ecx
	jb	SHORT $LL16@SK_GPUPoll

; 80   :       NvU32               gpu_count                      =  0;
; 81   : 
; 82   :       if (NVAPI_OK != NvAPI_EnumPhysicalGPUs (gpus, &gpu_count))

	jmp	$LN8@SK_GPUPoll
$LN178@SK_GPUPoll:

; 277  :               {
; 278  : #if 1
; 279  :                 // First, check for over-voltage...
; 280  :                 if (stats.gpus [i].volts_mV.supported == false)

	cmp	BYTE PTR [edi-7], 0
	jne	SHORT $LN210@SK_GPUPoll

; 281  :                 {
; 282  :                   for (NvU32 volt = 0; volt < ps20info.ov.numVoltages; volt++)

	mov	esi, DWORD PTR _ps20info$1[ebp+7316]
	xor	eax, eax
	test	esi, esi
	je	SHORT $LN210@SK_GPUPoll
	lea	ecx, DWORD PTR _ps20info$1[ebp+7320]
	npad	5
$LL19@SK_GPUPoll:

; 283  :                   {
; 284  :                     if ( ps20info.ov.voltages [volt].domainId ==

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN179@SK_GPUPoll

; 281  :                 {
; 282  :                   for (NvU32 volt = 0; volt < ps20info.ov.numVoltages; volt++)

	inc	eax
	add	ecx, 24					; 00000018H
	cmp	eax, esi
	jb	SHORT $LL19@SK_GPUPoll
$LN210@SK_GPUPoll:
	movss	xmm1, DWORD PTR __real@3a83126f
$LN211@SK_GPUPoll:
	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
$LN54@SK_GPUPoll:

; 307  :                       break;
; 308  :                     }
; 309  :                   }
; 310  :                 }
; 311  : 
; 312  :                 // If that fails, look through the normal voltages.
; 313  : #endif
; 314  :                 for (NvU32 volt = 0; volt < ps20info.numBaseVoltages; volt++)

	mov	esi, DWORD PTR _ps20info$1[ebp+16]
	xor	ecx, ecx
	test	esi, esi
	je	$LN8@SK_GPUPoll
	imul	eax, edx, 456
	lea	eax, DWORD PTR _ps20info$1[ebp+eax+380]
	npad	6
$LL22@SK_GPUPoll:

; 315  :                 {
; 316  :                   if ( ps20info.pstates [pstate].baseVoltages [volt].domainId ==

	cmp	DWORD PTR [eax], 0
	je	$LN180@SK_GPUPoll

; 307  :                       break;
; 308  :                     }
; 309  :                   }
; 310  :                 }
; 311  : 
; 312  :                 // If that fails, look through the normal voltages.
; 313  : #endif
; 314  :                 for (NvU32 volt = 0; volt < ps20info.numBaseVoltages; volt++)

	inc	ecx
	add	eax, 24					; 00000018H
	cmp	ecx, esi
	jb	SHORT $LL22@SK_GPUPoll

; 80   :       NvU32               gpu_count                      =  0;
; 81   : 
; 82   :       if (NVAPI_OK != NvAPI_EnumPhysicalGPUs (gpus, &gpu_count))

	jmp	$LN8@SK_GPUPoll
$LN179@SK_GPUPoll:

; 285  :                          NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE )
; 286  :                     {
; 287  :                       stats.gpus [i].volts_mV.supported = true;
; 288  :                       stats.gpus [i].volts_mV.over      = true;
; 289  : 
; 290  :                       NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1* voltage =
; 291  :                         &ps20info.ov.voltages [volt];

	lea	ecx, DWORD PTR [eax+eax*2]

; 292  : 
; 293  :                       stats.gpus [i].volts_mV.core = voltage->volt_uV/1000.0f;

	movss	xmm1, DWORD PTR __real@3a83126f
	mov	eax, DWORD PTR _ps20info$1[ebp+ecx*8+7328]
	mov	WORD PTR [edi-8], 257			; 00000101H
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 294  : 
; 295  :                       int over  =
; 296  :                         voltage->voltDelta_uV.value -

	mov	eax, DWORD PTR _ps20info$1[ebp+ecx*8+7332]
	mov	esi, eax
	sub	esi, DWORD PTR _ps20info$1[ebp+ecx*8+7340]

; 297  :                         voltage->voltDelta_uV.valueRange.max;
; 298  : 
; 299  :                       int under =
; 300  :                         voltage->voltDelta_uV.valueRange.min -

	mov	ecx, DWORD PTR _ps20info$1[ebp+ecx*8+7336]
	sub	ecx, eax
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [edi-16], xmm0

; 301  :                         voltage->voltDelta_uV.value;
; 302  : 
; 303  :                       if (over > 0)

	test	esi, esi
	jle	SHORT $LN52@SK_GPUPoll

; 304  :                         stats.gpus [i].volts_mV.ov =   over  / 1000.0f;

	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [edi-12], xmm0
	jmp	$LN211@SK_GPUPoll
$LN52@SK_GPUPoll:

; 305  :                       else if (under > 0)

	test	ecx, ecx
	jle	$LN211@SK_GPUPoll

; 306  :                         stats.gpus [i].volts_mV.ov = -(under / 1000.0f);

	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	xorps	xmm0, xmm2
	movss	DWORD PTR [edi-12], xmm0
	jmp	$LN54@SK_GPUPoll
$LN180@SK_GPUPoll:

; 317  :                        NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE )
; 318  :                   {
; 319  :                     stats.gpus [i].volts_mV.supported = true;
; 320  :                     stats.gpus [i].volts_mV.over      = false;
; 321  : 
; 322  :                     NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1* voltage =
; 323  :                       &ps20info.pstates [pstate].baseVoltages [volt];

	imul	eax, edx, 19
	mov	WORD PTR [edi-8], 256			; 00000100H
	add	eax, ecx
	lea	ecx, DWORD PTR [eax+eax*2]

; 324  : 
; 325  :                     stats.gpus [i].volts_mV.core = voltage->volt_uV/1000.0f;

	mov	eax, DWORD PTR _ps20info$1[ebp+ecx*8+388]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 326  : 
; 327  :                     int over  =
; 328  :                       voltage->voltDelta_uV.value -

	mov	eax, DWORD PTR _ps20info$1[ebp+ecx*8+392]
	mov	edx, eax
	sub	edx, DWORD PTR _ps20info$1[ebp+ecx*8+400]

; 329  :                       voltage->voltDelta_uV.valueRange.max;
; 330  : 
; 331  :                     int under =
; 332  :                       voltage->voltDelta_uV.valueRange.min -

	mov	ecx, DWORD PTR _ps20info$1[ebp+ecx*8+396]
	sub	ecx, eax
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [edi-16], xmm0

; 333  :                       voltage->voltDelta_uV.value;
; 334  : 
; 335  :                     if (over > 0)

	test	edx, edx
	jle	SHORT $LN56@SK_GPUPoll
	movd	xmm0, edx

; 336  :                     {
; 337  :                       stats.gpus [i].volts_mV.ov   =   over  / 1000.0f;
; 338  :                       stats.gpus [i].volts_mV.over = true;

	jmp	SHORT $LN212@SK_GPUPoll
$LN56@SK_GPUPoll:

; 339  :                     }
; 340  : 
; 341  :                     else if (under > 0)

	test	ecx, ecx
	jle	SHORT $LN58@SK_GPUPoll

; 342  :                     {
; 343  :                       stats.gpus [i].volts_mV.ov   = -(under / 1000.0f);

	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	xorps	xmm0, xmm2

; 344  :                       stats.gpus [i].volts_mV.over = true;

	jmp	SHORT $LN213@SK_GPUPoll
$LN58@SK_GPUPoll:

; 345  :                     }
; 346  : 
; 347  :                     else if (over != 0)

	test	edx, edx
	je	SHORT $LN8@SK_GPUPoll

; 348  :                     {
; 349  :                       if (over > under)

	cmp	ecx, edx
	jge	SHORT $LN214@SK_GPUPoll

; 350  :                          stats.gpus [i].volts_mV.ov =  -(over  / 1000.0f);

	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	xorps	xmm0, xmm2
	jmp	SHORT $LN213@SK_GPUPoll
$LN214@SK_GPUPoll:

; 351  :                       else if (under > over)

	jle	SHORT $LN63@SK_GPUPoll
	movd	xmm0, ecx
$LN212@SK_GPUPoll:

; 352  :                         stats.gpus [i].volts_mV.ov  =   (under / 1000.0f);

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
$LN213@SK_GPUPoll:
	movss	DWORD PTR [edi-12], xmm0
$LN63@SK_GPUPoll:

; 353  : 
; 354  :                       stats.gpus [i].volts_mV.over  = true;

	mov	BYTE PTR [edi-8], 1
$LN8@SK_GPUPoll:

; 105  :       }
; 106  : 
; 107  :       for (int i = 0; i < stats.num_gpus; i++)

	mov	esi, DWORD PTR _i$1$[ebp]
	sub	edi, -128				; ffffff80H
	mov	eax, DWORD PTR _stats$1$[ebp]
	inc	esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR [eax+8192]
	jl	$LL10@SK_GPUPoll

; 355  :                     }
; 356  :                     break;
; 357  :                   }
; 358  :                 }
; 359  :                 break;
; 360  :               }
; 361  :             }
; 362  :           }
; 363  :         }
; 364  :       }
; 365  :     }
; 366  : 
; 367  :     else if (ADL_init == ADL_TRUE)

	jmp	$LN24@SK_GPUPoll
$LN29@SK_GPUPoll:
	cmp	DWORD PTR ?ADL_init@@3HA, 1		; ADL_init
	jne	$LN24@SK_GPUPoll

; 368  :     {
; 369  :       stats.num_gpus = SK_ADL_CountActiveGPUs ();

	call	?SK_ADL_CountActiveGPUs@@YAHXZ		; SK_ADL_CountActiveGPUs

; 370  : 
; 371  :       //dll_log.Log (L"[DisplayLib] AMD GPUs: %i", stats.num_gpus);
; 372  :       for (int i = 0; i < stats.num_gpus; i++)

	xor	ecx, ecx
	mov	DWORD PTR [edi+8192], eax
	mov	DWORD PTR _i$1$[ebp], ecx
	test	eax, eax
	jle	$LN24@SK_GPUPoll

; 368  :     {
; 369  :       stats.num_gpus = SK_ADL_CountActiveGPUs ();

	add	edi, 104				; 00000068H
	npad	6
$LL25@SK_GPUPoll:

; 373  :       {
; 374  :         AdapterInfo* pAdapter = SK_ADL_GetActiveAdapter (i);

	push	ecx
	call	?SK_ADL_GetActiveAdapter@@YAPAUAdapterInfo@@H@Z ; SK_ADL_GetActiveAdapter
	mov	esi, eax
	add	esp, 4

; 375  : 
; 376  :         if (pAdapter->iAdapterIndex >= ADL_MAX_ADAPTERS || pAdapter->iAdapterIndex < 0)

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 250				; 000000faH
	jge	$LN181@SK_GPUPoll
	test	ecx, ecx
	js	$LN181@SK_GPUPoll

; 379  :           break;
; 380  :         }
; 381  : 
; 382  :         ADLPMActivity activity       = {                  };
; 383  :                       activity.iSize = sizeof ADLPMActivity;
; 384  : 
; 385  :         ADL_Overdrive5_CurrentActivity_Get (pAdapter->iAdapterIndex, &activity);

	xorps	xmm0, xmm0
	lea	eax, DWORD PTR _activity$10[ebp]
	movups	XMMWORD PTR _activity$10[ebp], xmm0
	push	eax
	movups	XMMWORD PTR _activity$10[ebp+16], xmm0
	mov	DWORD PTR _activity$10[ebp], 40		; 00000028H
	movq	QWORD PTR _activity$10[ebp+32], xmm0
	push	DWORD PTR [esi+4]
	call	DWORD PTR ?ADL_Overdrive5_CurrentActivity_Get@@3P6AHHPAUADLPMActivity@@@ZA ; ADL_Overdrive5_CurrentActivity_Get

; 386  : 
; 387  :         stats.gpus [i].loads_percent.gpu = activity.iActivityPercent;

	mov	eax, DWORD PTR _activity$10[ebp+16]
	movd	xmm0, DWORD PTR _activity$10[ebp+12]
	mov	DWORD PTR [edi-104], eax

; 388  :         stats.gpus [i].hwinfo.pcie_gen   = activity.iCurrentBusSpeed;

	mov	eax, DWORD PTR _activity$10[ebp+24]
	mov	DWORD PTR [edi+4], eax

; 389  :         stats.gpus [i].hwinfo.pcie_lanes = activity.iCurrentBusLanes;

	mov	eax, DWORD PTR _activity$10[ebp+28]
	mov	DWORD PTR [edi], eax

; 390  : 
; 391  :         stats.gpus [i].clocks_kHz.gpu    = activity.iEngineClock * 10UL;

	mov	eax, DWORD PTR _activity$10[ebp+4]

; 392  :         stats.gpus [i].clocks_kHz.ram    = activity.iMemoryClock * 10UL;
; 393  : 
; 394  :         stats.gpus [i].volts_mV.supported = true;
; 395  :         stats.gpus [i].volts_mV.over      = false;
; 396  :         stats.gpus [i].volts_mV.core      = static_cast <float> (activity.iVddc); // mV?

	cvtdq2ps xmm0, xmm0
	mov	WORD PTR [edi-72], 256			; 00000100H
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	mov	DWORD PTR [edi-88], eax
	mov	eax, DWORD PTR _activity$10[ebp+8]
	movss	DWORD PTR [edi-80], xmm0
	xorps	xmm0, xmm0

; 397  : 
; 398  :         ADLTemperature temp       = {                   };

	movq	QWORD PTR _temp$12[ebp], xmm0

; 399  :                        temp.iSize = sizeof ADLTemperature;

	mov	DWORD PTR _temp$12[ebp], 8
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	mov	DWORD PTR [edi-84], eax

; 400  : 
; 401  :         ADL_Overdrive5_Temperature_Get (pAdapter->iAdapterIndex, 0, &temp);

	lea	eax, DWORD PTR _temp$12[ebp]
	push	eax
	push	0
	push	DWORD PTR [esi+4]
	call	DWORD PTR ?ADL_Overdrive5_Temperature_Get@@3P6AHHHPAUADLTemperature@@@ZA ; ADL_Overdrive5_Temperature_Get

; 402  : 
; 403  :         stats.gpus [i].temps_c.gpu = temp.iTemperature / 1000UL;

	mov	eax, 274877907				; 10624dd3H
	xorps	xmm0, xmm0
	mul	DWORD PTR _temp$12[ebp+4]

; 404  : 
; 405  :         ADLFanSpeedValue fanspeed            = {                           };

	movups	XMMWORD PTR _fanspeed$11[ebp], xmm0

; 406  :                          fanspeed.iSize      = sizeof ADLFanSpeedValue;
; 407  :                          fanspeed.iSpeedType = ADL_DL_FANCTRL_SPEED_TYPE_RPM;
; 408  : 
; 409  :         ADL_Overdrive5_FanSpeed_Get (pAdapter->iAdapterIndex, 0, &fanspeed);

	lea	eax, DWORD PTR _fanspeed$11[ebp]
	mov	DWORD PTR _fanspeed$11[ebp], 16		; 00000010H
	push	eax
	shr	edx, 6
	mov	DWORD PTR [edi-68], edx
	mov	DWORD PTR _fanspeed$11[ebp+4], 2
	push	0
	push	DWORD PTR [esi+4]
	call	DWORD PTR ?ADL_Overdrive5_FanSpeed_Get@@3P6AHHHPAUADLFanSpeedValue@@@ZA ; ADL_Overdrive5_FanSpeed_Get

; 410  : 
; 411  :         stats.gpus [i].fans_rpm.gpu       = fanspeed.iFanSpeed;

	mov	eax, DWORD PTR _fanspeed$11[ebp+8]
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	DWORD PTR [edi-52], eax
	inc	ecx
	mov	eax, DWORD PTR _stats$1$[ebp]

; 412  :         stats.gpus [i].fans_rpm.supported = true;

	mov	BYTE PTR [edi-48], 1
	sub	edi, -128				; ffffff80H
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+8192]
	jl	$LL25@SK_GPUPoll

; 80   :       NvU32               gpu_count                      =  0;
; 81   : 
; 82   :       if (NVAPI_OK != NvAPI_EnumPhysicalGPUs (gpus, &gpu_count))

	jmp	SHORT $LN24@SK_GPUPoll
$LN181@SK_GPUPoll:

; 377  :         {
; 378  :           dll_log.Log (L"[DisplayLib] INVALID ADL ADAPTER: %i", pAdapter->iAdapterIndex);

	push	ecx
	push	OFFSET $SG126278
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN24@SK_GPUPoll:

; 413  :       }
; 414  :     }
; 415  : 
; 416  :     gpu_stats = gpu_stats_buffers [current_gpu_stat];

	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	push	8208					; 00002010H
	add	eax, OFFSET ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A ; gpu_stats_buffers
	push	eax
	push	DWORD PTR ?gpu_stats@@3AAUgpu_sensors_t@@A ; gpu_stats
	call	_memcpy
	add	esp, 12					; 0000000cH

; 417  :     ResetEvent (hPollEvent);

	push	DWORD PTR ?hPollEvent@@3PAXA
	call	DWORD PTR __imp__ResetEvent@4
	push	-1
	push	0
	lea	eax, DWORD PTR _hEvents$[ebp]
	push	eax
	push	2
	call	DWORD PTR __imp__WaitForMultipleObjects@16
	cmp	eax, 1
	jne	$LL2@SK_GPUPoll
$LN182@SK_GPUPoll:

; 418  :   }
; 419  : 
; 420  :   hPollThread = nullptr;

	mov	DWORD PTR ?hPollThread@@3PAXA, 0

; 421  : 
; 422  :   CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN184@SK_GPUPoll:

; 423  : 
; 424  :   return 0;

	pop	edi
	xor	eax, eax
	pop	esi

; 425  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN215@SK_GPUPoll:

; 89   : 
; 90   :       static std::vector <NvU32> gpu_ids;

	push	OFFSET ?$TSS0@?M@??SK_GPUPollingThread@@YGKPAX@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?M@??SK_GPUPollingThread@@YGKPAX@Z@4HA, -1
	jne	$LN4@SK_GPUPoll
	push	OFFSET ??__Fgpu_ids@?M@??SK_GPUPollingThread@@YGKPAX@Z@YAXXZ ; `SK_GPUPollingThread'::`12'::`dynamic atexit destructor for 'gpu_ids''
	call	_atexit
	push	OFFSET ?$TSS0@?M@??SK_GPUPollingThread@@YGKPAX@Z@4HA
	call	__Init_thread_footer
	add	esp, 8
	jmp	$LN4@SK_GPUPoll
?SK_GPUPollingThread@@YGKPAX@Z ENDP			; SK_GPUPollingThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
;	COMDAT ??__Egpu_stats_buffers@@YAXXZ
text$di	SEGMENT
??__Egpu_stats_buffers@@YAXXZ PROC			; `dynamic initializer for 'gpu_stats_buffers'', COMDAT

; 31   :          gpu_sensors_t  gpu_stats_buffers [2] = { };

	npad	2
	push	esi
	push	edi
	mov	edi, OFFSET ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A ; gpu_stats_buffers
	mov	esi, 2
	npad	2
$LL4@dynamic:
	mov	ecx, edi
	call	??0gpu_sensors_t@@QAE@XZ
	add	edi, 8208				; 00002010H
	sub	esi, 1
	jne	SHORT $LL4@dynamic
	pop	edi
	pop	esi
	ret	0
??__Egpu_stats_buffers@@YAXXZ ENDP			; `dynamic initializer for 'gpu_stats_buffers''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
?SK_EndGPUPolling@@YAXXZ PROC				; SK_EndGPUPolling

; 430  :   if (hShutdownEvent != nullptr && hPollThread != nullptr)

	mov	eax, DWORD PTR ?hShutdownEvent@@3PAXA
	test	eax, eax
	je	SHORT $LN2@SK_EndGPUP
	mov	ecx, DWORD PTR ?hPollThread@@3PAXA
	test	ecx, ecx
	je	SHORT $LN2@SK_EndGPUP

; 431  :   {
; 432  :     if (SignalObjectAndWait (hShutdownEvent, hPollThread, 333UL, TRUE) != WAIT_OBJECT_0)

	push	1
	push	333					; 0000014dH
	push	ecx
	push	eax
	call	DWORD PTR __imp__SignalObjectAndWait@16
	test	eax, eax
	je	SHORT $LN3@SK_EndGPUP

; 433  :     {
; 434  :       TerminateThread (hPollThread, 0x00);

	push	0
	push	DWORD PTR ?hPollThread@@3PAXA
	call	DWORD PTR __imp__TerminateThread@8
$LN3@SK_EndGPUP:

; 435  :     }
; 436  : 
; 437  :     hShutdownEvent = nullptr;

	mov	DWORD PTR ?hShutdownEvent@@3PAXA, 0

; 438  :     hPollThread    = nullptr;

	mov	DWORD PTR ?hPollThread@@3PAXA, 0
$LN2@SK_EndGPUP:

; 439  :   }
; 440  : }

	ret	0
?SK_EndGPUPolling@@YAXXZ ENDP				; SK_EndGPUPolling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
_update_time$ = -24					; size = 16
_update_ftime$ = -8					; size = 8
?SK_PollGPU@@YAXXZ PROC					; SK_PollGPU

; 444  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 445  :   if (! nvapi_init)

	cmp	DWORD PTR ?nvapi_init@@3HA, 0		; nvapi_init
	jne	SHORT $LN3@SK_PollGPU

; 446  :   {
; 447  :     if (! ADL_init)

	cmp	DWORD PTR ?ADL_init@@3HA, 0		; ADL_init
	jne	SHORT $LN3@SK_PollGPU

; 448  :     {
; 449  :       gpu_stats.num_gpus = 0;

	mov	eax, DWORD PTR ?gpu_stats@@3AAUgpu_sensors_t@@A ; gpu_stats
	mov	DWORD PTR [eax+8192], 0

; 483  :     }
; 484  :   }
; 485  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@SK_PollGPU:
	push	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	ecx, 1
	mov	edx, OFFSET ?init@?1??SK_PollGPU@@YAXXZ@4KC
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp

; 456  :   if (! InterlockedCompareExchange (&init, TRUE, FALSE))

	test	eax, eax
	jne	SHORT $LN4@SK_PollGPU

; 457  :   {
; 458  :     hShutdownEvent = CreateEvent  (nullptr, FALSE, FALSE, nullptr);

	mov	esi, DWORD PTR __imp__CreateEventW@16
	push	eax
	push	eax
	push	eax
	push	eax
	call	esi

; 459  :     hPollEvent     = CreateEvent  (nullptr, TRUE,  FALSE, nullptr);

	push	0
	push	0
	push	1
	push	0
	mov	DWORD PTR ?hShutdownEvent@@3PAXA, eax
	call	esi

; 460  :     hPollThread    = CreateThread (nullptr, 0, SK_GPUPollingThread, nullptr, 0x00, nullptr);

	push	0
	push	0
	push	0
	push	OFFSET ?SK_GPUPollingThread@@YGKPAX@Z	; SK_GPUPollingThread
	push	0
	push	0
	mov	DWORD PTR ?hPollEvent@@3PAXA, eax
	call	DWORD PTR __imp__CreateThread@24
	mov	DWORD PTR ?hPollThread@@3PAXA, eax
$LN4@SK_PollGPU:

; 461  :   }
; 462  : 
; 463  :   SYSTEMTIME     update_time;
; 464  :   FILETIME       update_ftime;
; 465  :   ULARGE_INTEGER update_ul;
; 466  : 
; 467  :   GetSystemTime        (&update_time);

	push	edi
	lea	eax, DWORD PTR _update_time$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemTime@4

; 468  :   SystemTimeToFileTime (&update_time, &update_ftime);

	lea	eax, DWORD PTR _update_ftime$[ebp]
	push	eax
	lea	eax, DWORD PTR _update_time$[ebp]
	push	eax
	call	DWORD PTR __imp__SystemTimeToFileTime@8

; 469  : 
; 470  :   update_ul.HighPart = update_ftime.dwHighDateTime;
; 471  :   update_ul.LowPart  = update_ftime.dwLowDateTime;

	mov	edi, DWORD PTR _update_ftime$[ebp]

; 472  : 
; 473  :   double dt = (update_ul.QuadPart - gpu_stats_buffers [0].last_update.QuadPart) * 1.0e-7;

	mov	ecx, edi
	sub	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A+8200
	mov	esi, DWORD PTR _update_ftime$[ebp+4]
	mov	edx, esi
	sbb	edx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A+8204
	call	__ultod3
	movss	xmm1, DWORD PTR ?config@@3Usk_config_t@@A+124
	mulsd	xmm0, QWORD PTR __real@3e7ad7f29abcaf48

; 474  : 
; 475  :   if (dt > config.gpu.interval)

	cvtps2pd xmm1, xmm1
	comisd	xmm0, xmm1
	jbe	SHORT $LN12@SK_PollGPU

; 476  :   {
; 477  :     if (WaitForSingleObject (hPollEvent, 0) == WAIT_TIMEOUT)

	push	0
	push	DWORD PTR ?hPollEvent@@3PAXA
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN12@SK_PollGPU

; 478  :     {
; 479  :       gpu_stats_buffers [0].last_update.QuadPart = update_ul.QuadPart;
; 480  : 
; 481  :       if (hPollEvent != nullptr)

	mov	eax, DWORD PTR ?hPollEvent@@3PAXA
	mov	DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A+8200, edi
	mov	DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A+8204, esi
	test	eax, eax
	je	SHORT $LN12@SK_PollGPU

; 482  :       SetEvent (hPollEvent);

	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN12@SK_PollGPU:
	pop	edi
	pop	esi

; 483  :     }
; 484  :   }
; 485  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_PollGPU@@YAXXZ ENDP					; SK_PollGPU
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
tv86 = -8						; size = 8
_gpu$ = 8						; size = 4
?SK_GPU_GetVRAMBudget@@YG_KH@Z PROC			; SK_GPU_GetVRAMBudget

; 592  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 593  :   buffer_t buffer = mem_info [0].buffer;
; 594  :   int      nodes  = mem_info [buffer].nodes;

	imul	edx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A+272, 280
	sub	esp, 8

; 595  : 
; 596  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	mov	ecx, DWORD PTR _gpu$[ebp]
	push	esi
	mov	esi, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[edx+276]
	cmp	ecx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	cmp	esi, ecx
	jl	SHORT $LN4@SK_GPU_Get
	shl	ecx, 5
	pop	esi
	mov	eax, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[ecx+edx]
	mov	edx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[ecx+edx+4]

; 597  :          ( nodes >= gpu ?  mem_info [buffer].local [gpu].Budget                  :
; 598  :                             SK_GPU_GetVRAMCapacity (gpu) )                       :
; 599  :                                      0;
; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@SK_GPU_Get:

; 595  : 
; 596  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	push	ecx
	call	?SK_GPU_GetVRAMCapacity@@YG_KH@Z	; SK_GPU_GetVRAMCapacity
	pop	esi

; 597  :          ( nodes >= gpu ?  mem_info [buffer].local [gpu].Budget                  :
; 598  :                             SK_GPU_GetVRAMCapacity (gpu) )                       :
; 599  :                                      0;
; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@SK_GPU_Get:
	xorps	xmm0, xmm0

; 595  : 
; 596  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	movlpd	QWORD PTR tv86[ebp], xmm0
	mov	eax, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR tv86[ebp+4]
	pop	esi

; 597  :          ( nodes >= gpu ?  mem_info [buffer].local [gpu].Budget                  :
; 598  :                             SK_GPU_GetVRAMCapacity (gpu) )                       :
; 599  :                                      0;
; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SK_GPU_GetVRAMBudget@@YG_KH@Z ENDP			; SK_GPU_GetVRAMBudget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
tv78 = -8						; size = 8
_gpu$ = 8						; size = 4
?SK_GPU_GetVRAMCapacity@@YG_KH@Z PROC			; SK_GPU_GetVRAMCapacity

; 583  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 584  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus)                    ?

	mov	ecx, DWORD PTR _gpu$[ebp]
	sub	esp, 8
	cmp	ecx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	imul	edx, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	shl	ecx, 7
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[edx+ecx+88]
	mov	edx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[edx+ecx+92]

; 585  :                             gpu_stats_buffers [current_gpu_stat].gpus [gpu].memory_B.capacity :
; 586  :                                               0;
; 587  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@SK_GPU_Get:
	xorps	xmm0, xmm0

; 584  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus)                    ?

	movlpd	QWORD PTR tv78[ebp], xmm0
	mov	eax, DWORD PTR tv78[ebp]
	mov	edx, DWORD PTR tv78[ebp+4]

; 585  :                             gpu_stats_buffers [current_gpu_stat].gpus [gpu].memory_B.capacity :
; 586  :                                               0;
; 587  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SK_GPU_GetVRAMCapacity@@YG_KH@Z ENDP			; SK_GPU_GetVRAMCapacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 8
_gpu$ = 8						; size = 4
?SK_GPU_GetVRAMShared@@YG_KH@Z PROC			; SK_GPU_GetVRAMShared

; 570  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 571  :   buffer_t buffer = mem_info [0].buffer;
; 572  :   int      nodes  = mem_info [buffer].nodes;

	imul	ecx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A+272, 280
	sub	esp, 8

; 573  : 
; 574  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	mov	edx, DWORD PTR _gpu$[ebp]
	push	esi
	mov	esi, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[ecx+276]
	cmp	edx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	edx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	cmp	esi, edx
	jl	SHORT $LN4@SK_GPU_Get
	shl	edx, 5
	pop	esi
	mov	eax, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[edx+ecx+136]
	mov	edx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[edx+ecx+140]

; 575  :          ( nodes >= gpu ?  mem_info [buffer].nonlocal [gpu].CurrentUsage         :
; 576  :                   gpu_stats_buffers [current_gpu_stat].gpus->memory_B.nonlocal ) :
; 577  :                                      0;
; 578  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@SK_GPU_Get:

; 573  : 
; 574  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	imul	edx, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	pop	esi
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[edx+72]
	mov	edx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[edx+76]

; 575  :          ( nodes >= gpu ?  mem_info [buffer].nonlocal [gpu].CurrentUsage         :
; 576  :                   gpu_stats_buffers [current_gpu_stat].gpus->memory_B.nonlocal ) :
; 577  :                                      0;
; 578  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@SK_GPU_Get:
	xorps	xmm0, xmm0

; 573  : 
; 574  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	movlpd	QWORD PTR tv90[ebp], xmm0
	mov	eax, DWORD PTR tv90[ebp]
	mov	edx, DWORD PTR tv90[ebp+4]
	pop	esi

; 575  :          ( nodes >= gpu ?  mem_info [buffer].nonlocal [gpu].CurrentUsage         :
; 576  :                   gpu_stats_buffers [current_gpu_stat].gpus->memory_B.nonlocal ) :
; 577  :                                      0;
; 578  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SK_GPU_GetVRAMShared@@YG_KH@Z ENDP			; SK_GPU_GetVRAMShared
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 8
_gpu$ = 8						; size = 4
?SK_GPU_GetVRAMUsed@@YG_KH@Z PROC			; SK_GPU_GetVRAMUsed

; 557  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 558  :   buffer_t buffer = mem_info [0].buffer;
; 559  :   int      nodes  = mem_info [buffer].nodes;

	imul	ecx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A+272, 280
	sub	esp, 8

; 560  : 
; 561  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	mov	edx, DWORD PTR _gpu$[ebp]
	push	esi
	mov	esi, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[ecx+276]
	cmp	edx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	edx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	cmp	esi, edx
	jl	SHORT $LN4@SK_GPU_Get
	shl	edx, 5
	pop	esi
	mov	eax, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[edx+ecx+8]
	mov	edx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[edx+ecx+12]

; 562  :          ( nodes >= gpu ?  mem_info [buffer].local [gpu].CurrentUsage            :
; 563  :                   gpu_stats_buffers [current_gpu_stat].gpus->memory_B.local )    :
; 564  :                                      0;
; 565  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@SK_GPU_Get:

; 560  : 
; 561  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	imul	edx, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	pop	esi
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[edx+64]
	mov	edx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[edx+68]

; 562  :          ( nodes >= gpu ?  mem_info [buffer].local [gpu].CurrentUsage            :
; 563  :                   gpu_stats_buffers [current_gpu_stat].gpus->memory_B.local )    :
; 564  :                                      0;
; 565  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@SK_GPU_Get:
	xorps	xmm0, xmm0

; 560  : 
; 561  :   return ( gpu   > -1   && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus ) ?

	movlpd	QWORD PTR tv90[ebp], xmm0
	mov	eax, DWORD PTR tv90[ebp]
	mov	edx, DWORD PTR tv90[ebp+4]
	pop	esi

; 562  :          ( nodes >= gpu ?  mem_info [buffer].local [gpu].CurrentUsage            :
; 563  :                   gpu_stats_buffers [current_gpu_stat].gpus->memory_B.local )    :
; 564  :                                      0;
; 565  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SK_GPU_GetVRAMUsed@@YG_KH@Z ENDP			; SK_GPU_GetVRAMUsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
_gpu$ = 8						; size = 4
?SK_GPU_GetFanSpeedRPM@@YGIH@Z PROC			; SK_GPU_GetFanSpeedRPM

; 546  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 547  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus) ?

	mov	ecx, DWORD PTR _gpu$[ebp]
	cmp	ecx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	shl	ecx, 7
	cmp	BYTE PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+ecx+56], 0
	je	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+ecx+52]

; 548  :     gpu_stats_buffers   [current_gpu_stat].gpus [gpu].fans_rpm.supported   ?
; 549  :       gpu_stats_buffers [current_gpu_stat].gpus [gpu].fans_rpm.gpu : 0 : 0;
; 550  : }

	pop	ebp
	ret	4
$LN3@SK_GPU_Get:

; 547  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus) ?

	xor	eax, eax

; 548  :     gpu_stats_buffers   [current_gpu_stat].gpus [gpu].fans_rpm.supported   ?
; 549  :       gpu_stats_buffers [current_gpu_stat].gpus [gpu].fans_rpm.gpu : 0 : 0;
; 550  : }

	pop	ebp
	ret	4
?SK_GPU_GetFanSpeedRPM@@YGIH@Z ENDP			; SK_GPU_GetFanSpeedRPM
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
tv79 = 8						; size = 4
_gpu$ = 8						; size = 4
?SK_GPU_GetTempInC@@YGMH@Z PROC				; SK_GPU_GetTempInC

; 537  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 538  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus)               ?

	mov	ecx, DWORD PTR _gpu$[ebp]
	cmp	ecx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	shl	ecx, 7
	movd	xmm0, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+ecx+36]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]

; 539  :        static_cast <float> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].temps_c.gpu) :
; 540  :                                              0.0f;
; 541  : }

	pop	ebp
	ret	4
$LN3@SK_GPU_Get:

; 538  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus)               ?

	mov	DWORD PTR tv79[ebp], 0
	fld	DWORD PTR tv79[ebp]

; 539  :        static_cast <float> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].temps_c.gpu) :
; 540  :                                              0.0f;
; 541  : }

	pop	ebp
	ret	4
?SK_GPU_GetTempInC@@YGMH@Z ENDP				; SK_GPU_GetTempInC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
tv79 = 8						; size = 4
_gpu$ = 8						; size = 4
?SK_GPU_GetGPULoad@@YGMH@Z PROC				; SK_GPU_GetGPULoad

; 528  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 529  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus) ?

	mov	ecx, DWORD PTR _gpu$[ebp]
	cmp	ecx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	shl	ecx, 7
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+ecx]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]

; 530  :        static_cast <float> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].loads_percent.gpu) :
; 531  :                                              0.0f;
; 532  : }

	pop	ebp
	ret	4
$LN3@SK_GPU_Get:

; 529  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus) ?

	mov	DWORD PTR tv79[ebp], 0
	fld	DWORD PTR tv79[ebp]

; 530  :        static_cast <float> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].loads_percent.gpu) :
; 531  :                                              0.0f;
; 532  : }

	pop	ebp
	ret	4
?SK_GPU_GetGPULoad@@YGMH@Z ENDP				; SK_GPU_GetGPULoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
tv79 = 8						; size = 4
_gpu$ = 8						; size = 4
?SK_GPU_GetMemoryLoad@@YGMH@Z PROC			; SK_GPU_GetMemoryLoad

; 520  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 521  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus) ?

	mov	ecx, DWORD PTR _gpu$[ebp]
	cmp	ecx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	shl	ecx, 7
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+ecx+4]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]

; 522  :        static_cast <float> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].loads_percent.fb) :
; 523  :                                              0.0f;
; 524  : }

	pop	ebp
	ret	4
$LN3@SK_GPU_Get:

; 521  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus) ?

	mov	DWORD PTR tv79[ebp], 0
	fld	DWORD PTR tv79[ebp]

; 522  :        static_cast <float> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].loads_percent.fb) :
; 523  :                                              0.0f;
; 524  : }

	pop	ebp
	ret	4
?SK_GPU_GetMemoryLoad@@YGMH@Z ENDP			; SK_GPU_GetMemoryLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
tv92 = -8						; size = 8
_gpu$ = 8						; size = 4
?SK_GPU_GetMemoryBandwidth@@YG_KH@Z PROC		; SK_GPU_GetMemoryBandwidth

; 510  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 511  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus) ?

	mov	edx, DWORD PTR _gpu$[ebp]
	sub	esp, 8
	cmp	edx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	edx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	imul	ecx, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	shl	edx, 7
	push	0
	push	2000					; 000007d0H
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+edx+20]
	mul	DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[ecx+edx+100]
	push	edx
	push	eax
	call	__allmul
	shrd	eax, edx, 3
	shr	edx, 3

; 512  :       (static_cast <uint64_t> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].clocks_kHz.ram) * 2ULL * 1000ULL *
; 513  :        static_cast <uint64_t> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].hwinfo.mem_bus_width)) / 8 :
; 514  :                                                  0;
; 515  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@SK_GPU_Get:
	xorps	xmm0, xmm0

; 511  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus) ?

	movlpd	QWORD PTR tv92[ebp], xmm0
	mov	eax, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR tv92[ebp+4]

; 512  :       (static_cast <uint64_t> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].clocks_kHz.ram) * 2ULL * 1000ULL *
; 513  :        static_cast <uint64_t> (gpu_stats_buffers [current_gpu_stat].gpus [gpu].hwinfo.mem_bus_width)) / 8 :
; 514  :                                                  0;
; 515  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SK_GPU_GetMemoryBandwidth@@YG_KH@Z ENDP		; SK_GPU_GetMemoryBandwidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
_gpu$ = 8						; size = 4
?SK_GPU_GetMemClockRateInkHz@@YGIH@Z PROC		; SK_GPU_GetMemClockRateInkHz

; 501  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 502  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus)                  ?

	mov	ecx, DWORD PTR _gpu$[ebp]
	cmp	ecx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	shl	ecx, 7
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+ecx+20]

; 503  :                             gpu_stats_buffers [current_gpu_stat].gpus [gpu].clocks_kHz.ram  :
; 504  :                                               0;
; 505  : };

	pop	ebp
	ret	4
$LN3@SK_GPU_Get:

; 502  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus)                  ?

	xor	eax, eax

; 503  :                             gpu_stats_buffers [current_gpu_stat].gpus [gpu].clocks_kHz.ram  :
; 504  :                                               0;
; 505  : };

	pop	ebp
	ret	4
?SK_GPU_GetMemClockRateInkHz@@YGIH@Z ENDP		; SK_GPU_GetMemClockRateInkHz
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
_TEXT	SEGMENT
_gpu$ = 8						; size = 4
?SK_GPU_GetClockRateInkHz@@YGIH@Z PROC			; SK_GPU_GetClockRateInkHz

; 492  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 493  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus)                  ?

	mov	ecx, DWORD PTR _gpu$[ebp]
	cmp	ecx, -1
	jle	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	cmp	ecx, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+8192]
	jge	SHORT $LN3@SK_GPU_Get
	imul	eax, DWORD PTR ?current_gpu_stat@@3KC, 8208 ; current_gpu_stat
	shl	ecx, 7
	mov	eax, DWORD PTR ?gpu_stats_buffers@@3PAUgpu_sensors_t@@A[eax+ecx+16]

; 494  :                             gpu_stats_buffers [current_gpu_stat].gpus [gpu].clocks_kHz.gpu  :
; 495  :                                               0;
; 496  : }

	pop	ebp
	ret	4
$LN3@SK_GPU_Get:

; 493  :   return (gpu > -1 && gpu < gpu_stats_buffers [current_gpu_stat].num_gpus)                  ?

	xor	eax, eax

; 494  :                             gpu_stats_buffers [current_gpu_stat].gpus [gpu].clocks_kHz.gpu  :
; 495  :                                               0;
; 496  : }

	pop	ebp
	ret	4
?SK_GPU_GetClockRateInkHz@@YGIH@Z ENDP			; SK_GPU_GetClockRateInkHz
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0gpu_sensors_t@@QAE@XZ
_TEXT	SEGMENT
??0gpu_sensors_t@@QAE@XZ PROC				; gpu_sensors_t::gpu_sensors_t, COMDAT
; _this$ = ecx
	mov	edx, 64					; 00000040H
	lea	eax, DWORD PTR [ecx+28]
	npad	8
$LL4@gpu_sensor:
	mov	DWORD PTR [eax-24], 0
	lea	eax, DWORD PTR [eax+128]
	mov	DWORD PTR [eax-148], 0
	mov	DWORD PTR [eax-144], 0
	mov	DWORD PTR [eax-140], 0
	mov	DWORD PTR [eax-136], 0
	mov	DWORD PTR [eax-132], 0
	mov	DWORD PTR [eax-128], 0
	mov	WORD PTR [eax-124], 0
	mov	DWORD PTR [eax-120], 0
	mov	DWORD PTR [eax-116], 0
	mov	DWORD PTR [eax-112], 0
	mov	DWORD PTR [eax-108], 0
	mov	DWORD PTR [eax-104], 0
	mov	BYTE PTR [eax-100], 0
	sub	edx, 1
	jne	SHORT $LL4@gpu_sensor
	mov	DWORD PTR [ecx+8192], edx
	mov	eax, ecx
	mov	DWORD PTR [ecx+8200], edx
	mov	DWORD PTR [ecx+8204], edx
	ret	0
??0gpu_sensors_t@@QAE@XZ ENDP				; gpu_sensors_t::gpu_sensors_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ PROC	; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-gpus>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	WORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	BYTE PTR [ecx+56], 0
	ret	0
??0<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ENDP	; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-gpus>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-fans_rpm>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-fans_rpm>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ PROC ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-fans_rpm>::<unnamed-type-fans_rpm>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 0
	ret	0
??0<unnamed-type-fans_rpm>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ENDP ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-fans_rpm>::<unnamed-type-fans_rpm>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-temps_c>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-temps_c>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ PROC ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-temps_c>::<unnamed-type-temps_c>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0<unnamed-type-temps_c>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ENDP ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-temps_c>::<unnamed-type-temps_c>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-volts_mV>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-volts_mV>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ PROC ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-volts_mV>::<unnamed-type-volts_mV>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	WORD PTR [ecx+8], 0
	ret	0
??0<unnamed-type-volts_mV>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ENDP ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-volts_mV>::<unnamed-type-volts_mV>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-clocks_kHz>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-clocks_kHz>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ PROC ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-clocks_kHz>::<unnamed-type-clocks_kHz>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0<unnamed-type-clocks_kHz>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ENDP ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-clocks_kHz>::<unnamed-type-clocks_kHz>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-loads_percent>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-loads_percent>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ PROC ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-loads_percent>::<unnamed-type-loads_percent>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0<unnamed-type-loads_percent>@<unnamed-type-gpus>@gpu_sensors_t@@QAE@XZ ENDP ; gpu_sensors_t::<unnamed-type-gpus>::<unnamed-type-loads_percent>::<unnamed-type-loads_percent>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
;	COMDAT ?_InterlockedCompareExchange@@YAKPCKKK@Z
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Exchange$ = 12						; size = 4
_Comperand$ = 16					; size = 4
?_InterlockedCompareExchange@@YAKPCKKK@Z PROC		; _InterlockedCompareExchange, COMDAT

; 9002 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	edx, DWORD PTR _Exchange$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	eax, DWORD PTR _Comperand$[ebp]
	lock	 cmpxchg DWORD PTR [ecx], edx

; 9004 : }

	pop	ebp
	ret	0
?_InterlockedCompareExchange@@YAKPCKKK@Z ENDP		; _InterlockedCompareExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\gpu_monitor.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 601  : }

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
