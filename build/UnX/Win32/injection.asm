; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\injection\injection.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?count@SK_InjectionRecord_s@@2JC		; SK_InjectionRecord_s::count
PUBLIC	?rollovers@SK_InjectionRecord_s@@2JC		; SK_InjectionRecord_s::rollovers
PUBLIC	?g_hHookCBT@@3RAUHHOOK__@@A			; g_hHookCBT
PUBLIC	?g_hHookShell@@3RAUHHOOK__@@A			; g_hHookShell
PUBLIC	?g_hShutdown@@3RAXA				; g_hShutdown
PUBLIC	?g_sHookedPIDs@@3PAJA				; g_sHookedPIDs
PUBLIC	?whitelist_patterns@@3PA_WA			; whitelist_patterns
PUBLIC	?whitelist_count@@3HA				; whitelist_count
PUBLIC	?hModHookInstance@@3PAUHINSTANCE__@@A		; hModHookInstance
PUBLIC	?local_record@@3PAUSK_InjectionRecord_s@@A	; local_record
_BSS	SEGMENT
?hModHookInstance@@3PAUHINSTANCE__@@A DD 01H DUP (?)	; hModHookInstance
?local_record@@3PAUSK_InjectionRecord_s@@A DD 01H DUP (?) ; local_record
_BSS	ENDS
CONST	SEGMENT
$SG147563 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l'
	DB	00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG147632 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l'
	DB	00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG147661 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l'
	DB	00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG147664 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '_', 00H, 'R', 00H, 'e'
	DB	00H, 's', 00H, 'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG147666 DB	'r', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'l', 00H
	DB	'3', 00H, '2', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG147667 DB	'SpecialK32.dll,RunDLL_HookManager_D3D9 dump', 00H
$SG147668 DB	'open', 00H
	ORG $+3
$SG147669 DB	'r', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'l', 00H
	DB	'3', 00H, '2', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG147670 DB	'SpecialK32.dll,RunDLL_HookManager_DXGI dump', 00H
$SG147671 DB	'open', 00H
	ORG $+3
$SG147692 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l'
	DB	00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG147695 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '_', 00H, 'R', 00H, 'e'
	DB	00H, 's', 00H, 'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG147788 DB	'Install', 00H
$SG147790 DB	'w', 00H
	ORG $+2
$SG147791 DB	'SpecialK32.pid', 00H
	ORG $+1
$SG147793 DB	'%lu', 0aH, 00H
	ORG $+3
$SG147795 DB	'Remove', 00H
	ORG $+1
$SG147796 DB	'r', 00H
	ORG $+2
$SG147797 DB	'SpecialK32.pid', 00H
	ORG $+1
$SG147799 DB	'%lu', 00H
$SG147802 DB	'SpecialK32.pid', 00H
	ORG $+1
$SG147818 DB	'\', 00H, 'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H
	DB	'a', 00H, 'l', 00H, 'K', 00H, '.', 00H, 'c', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG147819 DB	'w', 00H, 00H, 00H
$SG147820 DB	' ', 00H, 00H, 00H
$SG147822 DB	'd', 00H, '3', 00H, 'd', 00H, '9', 00H, 00H, 00H
	ORG $+2
$SG147824 DB	'd', 00H, '3', 00H, 'd', 00H, '8', 00H, 00H, 00H
	ORG $+2
$SG147826 DB	'd', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 00H, 00H
$SG147828 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG147830 DB	'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'G', 00H, 'L', 00H
	DB	'3', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG147850 DB	'\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '9', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147852 DB	'\', 00H, 'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147854 DB	'\', 00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'G', 00H
	DB	'L', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG147856 DB	'\', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG147858 DB	'\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '8', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147860 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'p', 00H, 'd'
	DB	00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG147861 DB	'\', 00H, 'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H
	DB	'a', 00H, 'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'p'
	DB	00H, 'd', 00H, 'b', 00H, 00H, 00H
$SG147863 DB	'%ws\Version', 00H
$SG147866 DB	'\', 00H, 'V', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '.', 00H
	DB	'i', 00H, 'n', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG147867 DB	'\', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '.', 00H, 'i', 00H, 'n'
	DB	00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG147868 DB	'\', 00H, 'V', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'.', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 00H, 00H
$SG147869 DB	'\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o', 00H, 's', 00H
	DB	'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 00H, 00H
$SG147890 DB	'\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '9', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147892 DB	'\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '8', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147894 DB	'\', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG147896 DB	'\', 00H, 'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147898 DB	'\', 00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'G', 00H
	DB	'L', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG147900 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'p', 00H, 'd'
	DB	00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG147901 DB	'\', 00H, 'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H
	DB	'a', 00H, 'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'p'
	DB	00H, 'd', 00H, 'b', 00H, 00H, 00H
$SG147903 DB	'%ws\Version', 00H
$SG147906 DB	'\', 00H, 'V', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '.', 00H
	DB	'i', 00H, 'n', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG147907 DB	'\', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '.', 00H, 'i', 00H, 'n'
	DB	00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG147908 DB	'\', 00H, 'V', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'.', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 00H, 00H
$SG147909 DB	'\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o', 00H, 's', 00H
	DB	'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 00H, 00H
$SG147920 DB	'\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '9', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147922 DB	'\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '8', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147924 DB	'\', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG147926 DB	'\', 00H, 'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147928 DB	'\', 00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'G', 00H
	DB	'L', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG147929 DB	'S', 00H, 'K', 00H, 'I', 00H, 00H, 00H
$SG147930 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, 00H, 00H
	ORG $+2
$SG147940 DB	'\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '9', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147942 DB	'\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '8', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147944 DB	'\', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG147946 DB	'\', 00H, 'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG147948 DB	'\', 00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'G', 00H
	DB	'L', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG147949 DB	'S', 00H, 'K', 00H, 'I', 00H, 00H, 00H
$SG147950 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, 00H, 00H
	ORG $+2
$SG148199 DB	'r', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'l', 00H
	DB	'3', 00H, '2', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG157374 DB	'\', 00H, 'M', 00H, 'y', 00H, ' ', 00H, 'M', 00H, 'o', 00H
	DB	'd', 00H, 's', 00H, '\', 00H, 'S', 00H, 'p', 00H, 'e', 00H, 'c'
	DB	00H, 'i', 00H, 'a', 00H, 'l', 00H, 'K', 00H, '\', 00H, 'G', 00H
	DB	'l', 00H, 'o', 00H, 'b', 00H, 'a', 00H, 'l', 00H, '\', 00H, 'w'
	DB	00H, 'h', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'l', 00H, 'i', 00H
	DB	's', 00H, 't', 00H, '.', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 00H
	DB	00H
	ORG $+2
$SG148195 DB	'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'K', 00H, '3', 00H, '2', 00H, '.', 00H, 'd', 00H, 'l'
	DB	00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG148198 DB	'S', 00H, 'K', 00H, 'I', 00H, 'M', 00H, '6', 00H, '4', 00H
	DB	'.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG148200 DB	'SpecialK32.dll,RunDLL_InjectionManager Remove', 00H
	ORG $+2
$SG148201 DB	'open', 00H
	ORG $+3
$SG148202 DB	'r', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'l', 00H
	DB	'3', 00H, '2', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG148203 DB	'SpecialK64.dll,RunDLL_InjectionManager Remove', 00H
	ORG $+2
$SG148204 DB	'open', 00H
	ORG $+3
$SG148205 DB	'S', 00H, 'K', 00H, 'I', 00H, 'M', 00H, '_', 00H, 'F', 00H
	DB	'r', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'd'
	DB	00H, 00H, 00H
$SG148208 DB	'-Inject', 00H
$SG148209 DB	'SKIM64.exe', 00H
	ORG $+1
$SG148210 DB	'open', 00H
	ORG $+3
$SG148211 DB	'S', 00H, 'K', 00H, 'I', 00H, 'M', 00H, '6', 00H, '4', 00H
	DB	'.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG148230 DB	'S', 00H, 'K', 00H, 'I', 00H, 'M', 00H, '6', 00H, '4', 00H
	DB	'.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG148232 DB	'Remove', 00H
	ORG $+1
$SG148233 DB	'r', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'l', 00H
	DB	'3', 00H, '2', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG148234 DB	'SpecialK64.dll,RunDLL_InjectionManager Install', 00H
	ORG $+1
$SG148235 DB	'open', 00H
	ORG $+3
$SG148236 DB	'r', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'l', 00H
	DB	'3', 00H, '2', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG148237 DB	'SpecialK32.dll,RunDLL_InjectionManager Install', 00H
	ORG $+1
$SG148238 DB	'open', 00H
	ORG $+3
$SG148240 DB	'Remove', 00H
	ORG $+1
$SG148241 DB	'S', 00H, 'K', 00H, 'I', 00H, 'M', 00H, '_', 00H, 'F', 00H
	DB	'r', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'd'
	DB	00H, 00H, 00H
$SG148244 DB	'+Inject', 00H
$SG148245 DB	'SKIM64.exe', 00H
	ORG $+1
$SG148246 DB	'open', 00H
CONST	ENDS
SK_Hooks	SEGMENT
?count@SK_InjectionRecord_s@@2JC DD 00H			; SK_InjectionRecord_s::count
?rollovers@SK_InjectionRecord_s@@2JC DD 00H		; SK_InjectionRecord_s::rollovers
?g_hHookCBT@@3RAUHHOOK__@@A DD 00H			; g_hHookCBT
?g_hHookShell@@3RAUHHOOK__@@A DD 00H			; g_hHookShell
?g_hShutdown@@3RAXA DD 00H				; g_hShutdown
?whitelist_count@@3HA DD 00H				; whitelist_count
?g_sHookedPIDs@@3PAJA	ORG $+64				; g_sHookedPIDs
?whitelist_patterns@@3PA_WA DW 00H			; whitelist_patterns
	ORG $+8318
SK_Hooks	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_ReadAcquire
PUBLIC	?_Hash_seq@std@@YAIPBEI@Z			; std::_Hash_seq
PUBLIC	_wmemcmp
PUBLIC	_wmemcpy
PUBLIC	_wmemmove
PUBLIC	_wmemset
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?compare@?$char_traits@_W@std@@SAHQB_W0I@Z	; std::char_traits<wchar_t>::compare
PUBLIC	?length@?$char_traits@_W@std@@SAIQB_W@Z		; std::char_traits<wchar_t>::length
PUBLIC	?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z	; std::char_traits<wchar_t>::copy
PUBLIC	?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z	; std::char_traits<wchar_t>::move
PUBLIC	?assign@?$char_traits@_W@std@@SAPA_WQA_WI_W@Z	; std::char_traits<wchar_t>::assign
PUBLIC	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z	; std::char_traits<wchar_t>::assign
PUBLIC	?to_char_type@?$char_traits@_W@std@@SA_WABG@Z	; std::char_traits<wchar_t>::to_char_type
PUBLIC	?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z	; std::char_traits<wchar_t>::to_int_type
PUBLIC	?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z	; std::char_traits<wchar_t>::eq_int_type
PUBLIC	?not_eof@?$char_traits@_W@std@@SAGABG@Z		; std::char_traits<wchar_t>::not_eof
PUBLIC	?eof@?$char_traits@_W@std@@SAGXZ		; std::char_traits<wchar_t>::eof
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAPADQADID@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	?CBTProc@@YGJHIJ@Z				; CBTProc
PUBLIC	?SKX_InstallCBTHook@@YGXXZ			; SKX_InstallCBTHook
PUBLIC	?SKX_RemoveCBTHook@@YGXXZ			; SKX_RemoveCBTHook
PUBLIC	?SKX_IsHookingCBT@@YG_NXZ			; SKX_IsHookingCBT
PUBLIC	?SKX_GetInjectedPIDs@@YGIPAKI@Z			; SKX_GetInjectedPIDs
PUBLIC	?SK_Inject_SwitchToGlobalInjector@@YA_NXZ	; SK_Inject_SwitchToGlobalInjector
PUBLIC	?SK_Inject_SwitchToGlobalInjectorEx@@YA_NW4DLL_ROLE@@@Z ; SK_Inject_SwitchToGlobalInjectorEx
PUBLIC	?SK_Inject_SwitchToRenderWrapper@@YA_NXZ	; SK_Inject_SwitchToRenderWrapper
PUBLIC	?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z ; SK_Inject_SwitchToRenderWrapperEx
PUBLIC	?SK_Inject_ReleaseProcess@@YAXXZ		; SK_Inject_ReleaseProcess
PUBLIC	?SK_Inject_AcquireProcess@@YAXXZ		; SK_Inject_AcquireProcess
PUBLIC	??0<unnamed-type-process>@SK_InjectionRecord_s@@QAE@XZ ; SK_InjectionRecord_s::<unnamed-type-process>::<unnamed-type-process>
PUBLIC	??0<unnamed-type-render>@SK_InjectionRecord_s@@QAE@XZ ; SK_InjectionRecord_s::<unnamed-type-render>::<unnamed-type-render>
PUBLIC	??0<unnamed-type-input>@SK_InjectionRecord_s@@QAE@XZ ; SK_InjectionRecord_s::<unnamed-type-input>::<unnamed-type-input>
PUBLIC	??0SK_InjectionRecord_s@@QAE@XZ			; SK_InjectionRecord_s::SK_InjectionRecord_s
PUBLIC	?SK_Inject_GetRecord@@YAPAUSK_InjectionRecord_s@@H@Z ; SK_Inject_GetRecord
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?max@?$numeric_limits@_W@std@@SA_WXZ		; std::numeric_limits<wchar_t>::max
PUBLIC	?max@?$numeric_limits@G@std@@SAGXZ		; std::numeric_limits<unsigned short>::max
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ; std::_Wrap_alloc<std::allocator<char> >::address
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Assign_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??$_LStrcoll@_W@std@@YAHPB_W000PBU_Collvec@@@Z	; std::_LStrcoll<wchar_t>
PUBLIC	??$_LStrxfrm@_W@std@@YAIPA_W0PB_W1PBU_Collvec@@@Z ; std::_LStrxfrm<wchar_t>
PUBLIC	??0locale@std@@QAE@XZ				; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	??0?$allocator@_W@std@@QAE@ABV01@@Z		; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?max_size@?$allocator@_W@std@@QBEIXZ		; std::allocator<wchar_t>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::address
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
PUBLIC	??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::operator=
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Move_alloc
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	?_Assign_rv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
PUBLIC	?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
PUBLIC	??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
PUBLIC	?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
PUBLIC	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
PUBLIC	?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
PUBLIC	?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal
PUBLIC	?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
PUBLIC	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
PUBLIC	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
PUBLIC	?SK_Inject_ValidateProcesses@@YAXXZ		; SK_Inject_ValidateProcesses
PUBLIC	?SK_Inject_InvadingProcess@@YA_NK@Z		; SK_Inject_InvadingProcess
PUBLIC	?ShellProc@@YGJHIJ@Z				; ShellProc
PUBLIC	?SK_TerminatePID@@YAHKI@Z			; SK_TerminatePID
PUBLIC	?SKX_InstallShellHook@@YGXXZ			; SKX_InstallShellHook
PUBLIC	?SKX_RemoveShellHook@@YGXXZ			; SKX_RemoveShellHook
PUBLIC	?SKX_IsHookingShell@@YG_NXZ			; SKX_IsHookingShell
PUBLIC	?RunDLL_InjectionManager@@YGXPAUHWND__@@PAUHINSTANCE__@@PADH@Z ; RunDLL_InjectionManager
PUBLIC	?SK_Inject_EnableCentralizedConfig@@YAXXZ	; SK_Inject_EnableCentralizedConfig
PUBLIC	?SK_ExitRemoteProcess@@YA_NPB_WI@Z		; SK_ExitRemoteProcess
PUBLIC	?SK_Inject_Stop@@YAXXZ				; SK_Inject_Stop
PUBLIC	?SK_Inject_Start@@YAXXZ				; SK_Inject_Start
PUBLIC	??$_Fgetc@_W@std@@YA_NAA_WPAU_iobuf@@@Z		; std::_Fgetc<wchar_t>
PUBLIC	??$_Fputc@_W@std@@YA_N_WPAU_iobuf@@@Z		; std::_Fputc<wchar_t>
PUBLIC	??$_Ungetc@_W@std@@YA_NAB_WPAU_iobuf@@@Z	; std::_Ungetc<wchar_t>
PUBLIC	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform
PUBLIC	??0?$collate@_W@std@@QAE@ABV_Locinfo@1@I@Z	; std::collate<wchar_t>::collate<wchar_t>
PUBLIC	?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::collate<wchar_t>::_Getcat
PUBLIC	??1?$collate@_W@std@@MAE@XZ			; std::collate<wchar_t>::~collate<wchar_t>
PUBLIC	?_Init@?$collate@_W@std@@IAEXABV_Locinfo@2@@Z	; std::collate<wchar_t>::_Init
PUBLIC	?do_compare@?$collate@_W@std@@MBEHPB_W000@Z	; std::collate<wchar_t>::do_compare
PUBLIC	?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::do_transform
PUBLIC	?do_hash@?$collate@_W@std@@MBEJPB_W0@Z		; std::collate<wchar_t>::do_hash
PUBLIC	??_G?$collate@_W@std@@MAEPAXI@Z			; std::collate<wchar_t>::`scalar deleting destructor'
PUBLIC	??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ; std::regex_constants::operator&
PUBLIC	??_4regex_constants@std@@YAAAW4match_flag_type@01@AAW4201@W4201@@Z ; std::regex_constants::operator&=
PUBLIC	??_5regex_constants@std@@YAAAW4match_flag_type@01@AAW4201@W4201@@Z ; std::regex_constants::operator|=
PUBLIC	??Iregex_constants@std@@YA?AW4match_flag_type@01@W4201@0@Z ; std::regex_constants::operator&
PUBLIC	??Uregex_constants@std@@YA?AW4match_flag_type@01@W4201@0@Z ; std::regex_constants::operator|
PUBLIC	??Sregex_constants@std@@YA?AW4match_flag_type@01@W4201@@Z ; std::regex_constants::operator~
PUBLIC	??$_Get@_W@_Cl_names@std@@QBEPB_WXZ		; std::_Cl_names::_Get<wchar_t>
PUBLIC	?length@?$_Regex_traits@_W@std@@SAIPB_W@Z	; std::_Regex_traits<wchar_t>::length
PUBLIC	??0?$_Regex_traits@_W@std@@QAE@XZ		; std::_Regex_traits<wchar_t>::_Regex_traits<wchar_t>
PUBLIC	?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z	; std::_Regex_traits<wchar_t>::translate
PUBLIC	?translate_nocase@?$_Regex_traits@_W@std@@QBE_W_W@Z ; std::_Regex_traits<wchar_t>::translate_nocase
PUBLIC	?isctype@?$_Regex_traits@_W@std@@QBE_N_WF@Z	; std::_Regex_traits<wchar_t>::isctype
PUBLIC	?_Getcoll@?$_Regex_traits@_W@std@@QBEPBV?$collate@_W@2@XZ ; std::_Regex_traits<wchar_t>::_Getcoll
PUBLIC	?_Getctype@?$_Regex_traits@_W@std@@QBEPBV?$ctype@_W@2@XZ ; std::_Regex_traits<wchar_t>::_Getctype
PUBLIC	?_Cache_locale@?$_Regex_traits@_W@std@@AAEXXZ	; std::_Regex_traits<wchar_t>::_Cache_locale
PUBLIC	??1?$_Regex_traits@_W@std@@QAE@XZ		; std::_Regex_traits<wchar_t>::~_Regex_traits<wchar_t>
PUBLIC	?value@?$regex_traits@_W@std@@QBEH_WH@Z		; std::regex_traits<wchar_t>::value
PUBLIC	??0?$regex_traits@_W@std@@QAE@XZ		; std::regex_traits<wchar_t>::regex_traits<wchar_t>
PUBLIC	??1?$regex_traits@_W@std@@QAE@XZ		; std::regex_traits<wchar_t>::~regex_traits<wchar_t>
PUBLIC	?_Is_word@std@@YA_NE@Z				; std::_Is_word
PUBLIC	??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z	; std::operator|=
PUBLIC	??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z	; std::operator^=
PUBLIC	??0_Bitmap@std@@QAE@XZ				; std::_Bitmap::_Bitmap
PUBLIC	??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_base::_Node_base
PUBLIC	??1_Node_base@std@@UAE@XZ			; std::_Node_base::~_Node_base
PUBLIC	??_G_Node_base@std@@UAEPAXI@Z			; std::_Node_base::`scalar deleting destructor'
PUBLIC	?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z	; std::_Destroy_node
PUBLIC	??0_Root_node@std@@QAE@XZ			; std::_Root_node::_Root_node
PUBLIC	??1_Root_node@std@@UAE@XZ			; std::_Root_node::~_Root_node
PUBLIC	??_G_Root_node@std@@UAEPAXI@Z			; std::_Root_node::`scalar deleting destructor'
PUBLIC	??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z ; std::_Node_end_group::_Node_end_group
PUBLIC	??1_Node_end_group@std@@UAE@XZ			; std::_Node_end_group::~_Node_end_group
PUBLIC	??_G_Node_end_group@std@@UAEPAXI@Z		; std::_Node_end_group::`scalar deleting destructor'
PUBLIC	??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_assert::_Node_assert
PUBLIC	??1_Node_assert@std@@UAE@XZ			; std::_Node_assert::~_Node_assert
PUBLIC	??_G_Node_assert@std@@UAEPAXI@Z			; std::_Node_assert::`scalar deleting destructor'
PUBLIC	??0_Node_capture@std@@QAE@I@Z			; std::_Node_capture::_Node_capture
PUBLIC	??1_Node_capture@std@@UAE@XZ			; std::_Node_capture::~_Node_capture
PUBLIC	??_G_Node_capture@std@@UAEPAXI@Z		; std::_Node_capture::`scalar deleting destructor'
PUBLIC	??0_Node_back@std@@QAE@I@Z			; std::_Node_back::_Node_back
PUBLIC	??1_Node_back@std@@UAE@XZ			; std::_Node_back::~_Node_back
PUBLIC	??_G_Node_back@std@@UAEPAXI@Z			; std::_Node_back::`scalar deleting destructor'
PUBLIC	??0_Node_endif@std@@QAE@XZ			; std::_Node_endif::_Node_endif
PUBLIC	??1_Node_endif@std@@UAE@XZ			; std::_Node_endif::~_Node_endif
PUBLIC	??_G_Node_endif@std@@UAEPAXI@Z			; std::_Node_endif::`scalar deleting destructor'
PUBLIC	??0_Node_if@std@@QAE@PAV_Node_base@1@@Z		; std::_Node_if::_Node_if
PUBLIC	??1_Node_if@std@@UAE@XZ				; std::_Node_if::~_Node_if
PUBLIC	??_G_Node_if@std@@UAEPAXI@Z			; std::_Node_if::`scalar deleting destructor'
PUBLIC	??0_Node_end_rep@std@@QAE@XZ			; std::_Node_end_rep::_Node_end_rep
PUBLIC	??1_Node_end_rep@std@@UAE@XZ			; std::_Node_end_rep::~_Node_end_rep
PUBLIC	??_G_Node_end_rep@std@@UAEPAXI@Z		; std::_Node_end_rep::`scalar deleting destructor'
PUBLIC	??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z ; std::_Node_rep::_Node_rep
PUBLIC	??1_Node_rep@std@@UAE@XZ			; std::_Node_rep::~_Node_rep
PUBLIC	??_G_Node_rep@std@@UAEPAXI@Z			; std::_Node_rep::`scalar deleting destructor'
PUBLIC	??0?$allocator@_N@std@@QAE@XZ			; std::allocator<bool>::allocator<bool>
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
PUBLIC	?deallocate@?$allocator@I@std@@QAEXPAII@Z	; std::allocator<unsigned int>::deallocate
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::allocator_traits<std::allocator<unsigned int> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ; std::allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::max_size
PUBLIC	?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@I@std@@@2@@Z ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Copy_alloc
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second
PUBLIC	??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_N@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
PUBLIC	??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
PUBLIC	??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
PUBLIC	??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
PUBLIC	?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ; std::_Vb_val<std::allocator<bool> >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ; std::_Vb_val<std::allocator<bool> >::_Free_proxy
PUBLIC	?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
PUBLIC	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
PUBLIC	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
PUBLIC	??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<bool> >::~vector<unsigned int,std::allocator<bool> >
PUBLIC	??4?$vector@IV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::operator=
PUBLIC	?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<bool> >::resize
PUBLIC	?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<bool> >::erase
PUBLIC	?data@?$vector@IV?$allocator@_N@std@@@std@@QAEPAIXZ ; std::vector<unsigned int,std::allocator<bool> >::data
PUBLIC	?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<bool> >::begin
PUBLIC	?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<bool> >::end
PUBLIC	?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::size
PUBLIC	?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::max_size
PUBLIC	?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<bool> >::capacity
PUBLIC	??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<bool> >::operator[]
PUBLIC	?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@AAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Ufill
PUBLIC	?_Umove_if_noexcept1@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI00@Z ; std::vector<unsigned int,std::allocator<bool> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@IV?$allocator@_N@std@@@std@@ABEII@Z ; std::vector<unsigned int,std::allocator<bool> >::_Calculate_growth
PUBLIC	?_Buy@?$vector@IV?$allocator@_N@std@@@std@@AAE_NI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Buy
PUBLIC	?_Change_array@?$vector@IV?$allocator@_N@std@@@std@@AAEXQAIII@Z ; std::vector<unsigned int,std::allocator<bool> >::_Change_array
PUBLIC	?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Tidy
PUBLIC	?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@IV?$allocator@_N@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::_Orphan_range
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
PUBLIC	??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<bool,std::allocator<bool> >::operator=
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
PUBLIC	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
PUBLIC	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize
PUBLIC	?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
PUBLIC	?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
PUBLIC	?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ ; std::vector<bool,std::allocator<bool> >::empty
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
PUBLIC	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
PUBLIC	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
PUBLIC	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	??0?$allocator@U_Loop_vals_t@std@@@std@@QAE@XZ	; std::allocator<std::_Loop_vals_t>::allocator<std::_Loop_vals_t>
PUBLIC	?deallocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z ; std::allocator<std::_Loop_vals_t>::deallocate
PUBLIC	?allocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z ; std::allocator<std::_Loop_vals_t>::allocate
PUBLIC	?max_size@?$allocator@U_Loop_vals_t@std@@@std@@QBEIXZ ; std::allocator<std::_Loop_vals_t>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@SAIABV?$allocator@U_Loop_vals_t@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Loop_vals_t> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_second
PUBLIC	??0?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >
PUBLIC	??1?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::~vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >
PUBLIC	?resize@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAEXI@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::resize
PUBLIC	?size@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::size
PUBLIC	?max_size@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::max_size
PUBLIC	?capacity@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::capacity
PUBLIC	??A?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAEAAU_Loop_vals_t@1@I@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::operator[]
PUBLIC	?_Udefault@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEPAU_Loop_vals_t@2@PAU32@I@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Udefault
PUBLIC	?_Umove_if_noexcept1@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@00@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@0@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@ABEII@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXQAU_Loop_vals_t@2@II@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Change_array
PUBLIC	?_Tidy@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXXZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Tidy
PUBLIC	?_Xlength@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@CAXXZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@ABEXPAU_Loop_vals_t@2@0@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Orphan_range
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*
PUBLIC	??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator++
PUBLIC	??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator==
PUBLIC	??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator!=
PUBLIC	?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Compat
PUBLIC	?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ; std::_Calculate_loop_simplicity
PUBLIC	?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z	; SK_Inject_TestUserWhitelist
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::basic_ifstream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?is_open@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::is_open
PUBLIC	??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::basic_filebuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?is_open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::is_open
PUBLIC	?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::open
PUBLIC	?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close
PUBLIC	?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::underflow
PUBLIC	?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::setbuf
PUBLIC	?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::sync
PUBLIC	?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::imbue
PUBLIC	?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPBV?$codecvt@_WDU_Mbstatet@@@2@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Set_back
PUBLIC	??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unchecked
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*
PUBLIC	??E?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator++
PUBLIC	??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::basic_regex<wchar_t,std::regex_traits<wchar_t> >
PUBLIC	??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::~basic_regex<wchar_t,std::regex_traits<wchar_t> >
PUBLIC	?mark_count@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEIXZ ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::mark_count
PUBLIC	?flags@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBE?AW4syntax_option_type@regex_constants@2@XZ ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::flags
PUBLIC	?_Get@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEPAV_Root_node@2@XZ ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Get
PUBLIC	?_Empty@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBE_NXZ ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Empty
PUBLIC	?_Get_traits@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEABV?$regex_traits@_W@2@XZ ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Get_traits
PUBLIC	?_Tidy@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Tidy
PUBLIC	?_Reset@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPAV_Root_node@2@@Z ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Reset
PUBLIC	??$regex_search@_WV?$regex_traits@_W@std@@@std@@YA_NPB_WABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@@Z ; std::regex_search<wchar_t,std::regex_traits<wchar_t> >
PUBLIC	??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Reset<wchar_t const *>
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ	; std::fpos<_Mbstatet>::seekpos
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	??$_Unfancy@_W@std@@YAPA_WPA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z ; std::pointer_traits<wchar_t *>::pointer_to
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z		; std::addressof<wchar_t *>
PUBLIC	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$addressof@_W@std@@YAPA_WAA_W@Z		; std::addressof<wchar_t>
PUBLIC	??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z ; std::use_facet<std::collate<wchar_t> >
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
PUBLIC	??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >
PUBLIC	??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$move@AAV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@std@@YA$$QAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@@Z ; std::move<std::basic_istream<wchar_t,std::char_traits<wchar_t> > &>
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?deallocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z ; std::allocator<std::sub_match<wchar_t const *> >::deallocate
PUBLIC	?allocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z ; std::allocator<std::sub_match<wchar_t const *> >::allocate
PUBLIC	?max_size@?$allocator@V?$sub_match@PB_W@std@@@std@@QBEIXZ ; std::allocator<std::sub_match<wchar_t const *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAIABV?$allocator@V?$sub_match@PB_W@std@@@2@@Z ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::max_size
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myend
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_second
PUBLIC	?resize@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QAEXI@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::resize
PUBLIC	?size@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::size
PUBLIC	?max_size@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::max_size
PUBLIC	?capacity@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::capacity
PUBLIC	??A?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QAEAAV?$sub_match@PB_W@1@I@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::operator[]
PUBLIC	?_Udefault@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEPAV?$sub_match@PB_W@2@PAV32@I@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Udefault
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@00@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@0@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@ABEII@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXQAV?$sub_match@PB_W@2@II@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@CAXXZ ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@ABEXPAV?$sub_match@PB_W@2@0@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Orphan_range
PUBLIC	?_Resize@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXI@Z ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Resize
PUBLIC	?_Pfx@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Pfx
PUBLIC	?_Sfx@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Sfx
PUBLIC	?_Null@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Null
PUBLIC	?_At@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@I@Z ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_At
PUBLIC	??0?$sub_match@PB_W@std@@QAE@XZ			; std::sub_match<wchar_t const *>::sub_match<wchar_t const *>
PUBLIC	??$?0PB_WPB_WX@?$pair@PB_WPB_W@std@@QAE@XZ	; std::pair<wchar_t const *,wchar_t const *>::pair<wchar_t const *,wchar_t const *><wchar_t const *,wchar_t const *,void>
PUBLIC	??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z ; std::_Regex_search1<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> >,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>
PUBLIC	??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >
PUBLIC	?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Compile
PUBLIC	?_Mark_count@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QBEIXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Mark_count
PUBLIC	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
PUBLIC	?_Is_esc@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Is_esc
PUBLIC	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans
PUBLIC	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next
PUBLIC	?_Expect@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Expect
PUBLIC	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
PUBLIC	?_DecimalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_DecimalDigits
PUBLIC	?_HexDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_HexDigits
PUBLIC	?_OctalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_OctalDigits
PUBLIC	?_Do_ex_class@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ex_class
PUBLIC	?_CharacterClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_N@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClassEscape
PUBLIC	?_ClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassEscape
PUBLIC	?_ClassAtom@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@XZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassAtom
PUBLIC	?_ClassRanges@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassRanges
PUBLIC	?_CharacterClass@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClass
PUBLIC	?_IdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_IdentityEscape
PUBLIC	?_IsIdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_IsIdentityEscape
PUBLIC	?_Do_ffn@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffn
PUBLIC	?_Do_ffnx@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffnx
PUBLIC	?_CharacterEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterEscape
PUBLIC	?_AtomEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_AtomEscape
PUBLIC	?_Do_capture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_capture_group
PUBLIC	?_Do_noncapture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_noncapture_group
PUBLIC	?_Do_assert_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_N@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_assert_group
PUBLIC	?_Wrapped_disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Wrapped_disjunction
PUBLIC	?_Quantifier@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Quantifier
PUBLIC	?_Alternative@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Alternative
PUBLIC	?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Disjunction
PUBLIC	??0?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@W4syntax_option_type@regex_constants@1@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >
PUBLIC	?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBE_NXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Beg_expr
PUBLIC	?_Setlong@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Setlong
PUBLIC	?_Discard_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Discard_pattern
PUBLIC	?_Getmark@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBEPAV_Node_base@2@XZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Getmark
PUBLIC	?_Add_bol@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_bol
PUBLIC	?_Add_eol@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_eol
PUBLIC	?_Add_wbound@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_wbound
PUBLIC	?_Add_dot@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_dot
PUBLIC	?_Add_char@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char
PUBLIC	?_Add_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_class
PUBLIC	?_Add_char_to_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_class
PUBLIC	?_Add_range@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W0@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_range
PUBLIC	?_Add_named_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXF_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_named_class
PUBLIC	?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_equiv
PUBLIC	?_Add_coll@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_coll
PUBLIC	?_Begin_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@XZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_group
PUBLIC	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group
PUBLIC	?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_assert_group
PUBLIC	?_End_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_assert_group
PUBLIC	?_Begin_capture_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@I@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_capture_group
PUBLIC	?_Add_backreference@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXI@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_backreference
PUBLIC	?_Begin_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_if
PUBLIC	?_Else_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@0@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Else_if
PUBLIC	?_Add_rep@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXHH_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_rep
PUBLIC	?_Negate@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Negate
PUBLIC	?_Mark_final@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Mark_final
PUBLIC	?_End_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_pattern
PUBLIC	?_Link_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Link_node
PUBLIC	?_Insert_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@CAXPAV_Node_base@2@0@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Insert_node
PUBLIC	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node
PUBLIC	?_Add_str_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_str_node
PUBLIC	?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Beg_expr
PUBLIC	?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap
PUBLIC	?_Add_char_to_array@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_array
PUBLIC	?_Add_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPAV?$_Node_class@_WV?$regex_traits@_W@std@@@2@F_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_elts
PUBLIC	?_Char_to_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0HPAPAU?$_Sequence@_W@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Char_to_elts
PUBLIC	?_Get_bmax@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABEIXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Get_bmax
PUBLIC	?_Get_tmax@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABEIXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Get_tmax
PUBLIC	??1?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@XZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::~_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >
PUBLIC	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z		; std::forward<wchar_t * &>
PUBLIC	??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@PAI@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Destroy_range<std::allocator<unsigned int>,unsigned int *>
PUBLIC	??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z		; std::_Unchecked<wchar_t *>
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>
PUBLIC	?_Setf@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEXW4match_flag_type@regex_constants@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Setf
PUBLIC	?_Clearf@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEXW4match_flag_type@regex_constants@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Clearf
PUBLIC	?_Skip@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEPB_WPB_W0PAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Skip
PUBLIC	??0?$_Bt_state_t@PB_W@std@@QAE@XZ		; std::_Bt_state_t<wchar_t const *>::_Bt_state_t<wchar_t const *>
PUBLIC	??1?$_Bt_state_t@PB_W@std@@QAE@XZ		; std::_Bt_state_t<wchar_t const *>::~_Bt_state_t<wchar_t const *>
PUBLIC	??0?$_Bt_state_t@PB_W@std@@QAE@ABV01@@Z		; std::_Bt_state_t<wchar_t const *>::_Bt_state_t<wchar_t const *>
PUBLIC	??4?$_Bt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z	; std::_Bt_state_t<wchar_t const *>::operator=
PUBLIC	??0?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAE@XZ ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
PUBLIC	??0?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
PUBLIC	?deallocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::deallocate
PUBLIC	?allocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocate
PUBLIC	?max_size@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QBEIXZ ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SAIABV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SA?AV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
PUBLIC	?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Copy_alloc
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_second
PUBLIC	??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@XZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??1?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@XZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::~vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??4?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::operator=
PUBLIC	?resize@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEXI@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::resize
PUBLIC	?size@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::size
PUBLIC	?max_size@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size
PUBLIC	?capacity@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::capacity
PUBLIC	??A?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEAAU_Grp_t@?$_Tgt_state_t@PB_W@1@I@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::operator[]
PUBLIC	?_Udefault@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@PAU342@I@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Udefault
PUBLIC	?_Umove_if_noexcept1@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@00@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@0@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@ABEII@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Calculate_growth
PUBLIC	?_Buy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAE_NI@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Buy
PUBLIC	?_Change_array@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXQAU_Grp_t@?$_Tgt_state_t@PB_W@2@II@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Change_array
PUBLIC	?_Tidy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Tidy
PUBLIC	?_Xlength@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@CAXXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@ABEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@0@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Orphan_range
PUBLIC	??4?$_Tgt_state_t@PB_W@std@@QAEXABV?$_Bt_state_t@PB_W@1@@Z ; std::_Tgt_state_t<wchar_t const *>::operator=
PUBLIC	??0?$_Tgt_state_t@PB_W@std@@QAE@XZ		; std::_Tgt_state_t<wchar_t const *>::_Tgt_state_t<wchar_t const *>
PUBLIC	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ		; std::_Tgt_state_t<wchar_t const *>::~_Tgt_state_t<wchar_t const *>
PUBLIC	??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z	; std::_Tgt_state_t<wchar_t const *>::_Tgt_state_t<wchar_t const *>
PUBLIC	??4?$_Tgt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z	; std::_Tgt_state_t<wchar_t const *>::operator=
PUBLIC	?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_if
PUBLIC	?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep0
PUBLIC	?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep
PUBLIC	?_Do_class@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_class
PUBLIC	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
PUBLIC	?_Better_match@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NXZ ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Better_match
PUBLIC	?_Is_wbound@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABE_NXZ ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Is_wbound
PUBLIC	?_Get_ncap@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABEIXZ ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Get_ncap
PUBLIC	??1?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@XZ ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::~_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>
PUBLIC	??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >
PUBLIC	??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPB_WPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >
PUBLIC	??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$_Destroy_range1@V?$allocator@I@std@@PAI@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned int>,unsigned int *>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@PAU_Grp_t@?$_Tgt_state_t@PB_W@2@@std@@YAXPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@U_Loop_vals_t@std@@@std@@PAU_Loop_vals_t@2@@std@@YAXPAU_Loop_vals_t@0@0AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::_Loop_vals_t>,std::_Loop_vals_t *>
PUBLIC	??$_Uninitialized_default_fill_n@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z	; std::_Move_unchecked<unsigned int *,unsigned int *>
PUBLIC	??$?0ABV?$allocator@_N@std@@X@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::allocator<bool> const &,void>
PUBLIC	??$_Uninitialized_fill_n@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_fill_n<unsigned int *,unsigned int,std::allocator<unsigned int> >
PUBLIC	??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z ; std::forward<std::allocator<wchar_t> const &>
PUBLIC	??$prev@PB_W@std@@YAPB_WPB_WH@Z			; std::prev<wchar_t const *>
PUBLIC	??$find@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z ; std::find<wchar_t const *,enum std::_Meta_type>
PUBLIC	??0?$_Node_str@_W@std@@QAE@W4_Node_flags@1@@Z	; std::_Node_str<wchar_t>::_Node_str<wchar_t>
PUBLIC	??0?$_Buf@_W@std@@QAE@XZ			; std::_Buf<wchar_t>::_Buf<wchar_t>
PUBLIC	??1?$_Buf@_W@std@@QAE@XZ			; std::_Buf<wchar_t>::~_Buf<wchar_t>
PUBLIC	?_Size@?$_Buf@_W@std@@QBEIXZ			; std::_Buf<wchar_t>::_Size
PUBLIC	?_At@?$_Buf@_W@std@@QBE_WI@Z			; std::_Buf<wchar_t>::_At
PUBLIC	?_Str@?$_Buf@_W@std@@QBEPB_WXZ			; std::_Buf<wchar_t>::_Str
PUBLIC	?_Insert@?$_Buf@_W@std@@QAEX_W@Z		; std::_Buf<wchar_t>::_Insert
PUBLIC	?_Del@?$_Buf@_W@std@@QAE_WXZ			; std::_Buf<wchar_t>::_Del
PUBLIC	?_Expand@?$_Buf@_W@std@@AAEXI@Z			; std::_Buf<wchar_t>::_Expand
PUBLIC	??_G?$_Buf@_W@std@@QAEPAXI@Z			; std::_Buf<wchar_t>::`scalar deleting destructor'
PUBLIC	??1?$_Node_str@_W@std@@UAE@XZ			; std::_Node_str<wchar_t>::~_Node_str<wchar_t>
PUBLIC	??_G?$_Node_str@_W@std@@UAEPAXI@Z		; std::_Node_str<wchar_t>::`scalar deleting destructor'
PUBLIC	??$_Compare@PB_WPB_WV?$regex_traits@_W@std@@@std@@YAPB_WPB_W000ABV?$regex_traits@_W@0@W4syntax_option_type@regex_constants@0@@Z ; std::_Compare<wchar_t const *,wchar_t const *,std::regex_traits<wchar_t> >
PUBLIC	??0?$_Node_class@_WV?$regex_traits@_W@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::_Node_class<wchar_t,std::regex_traits<wchar_t> >
PUBLIC	??1?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAE@XZ ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::~_Node_class<wchar_t,std::regex_traits<wchar_t> >
PUBLIC	?_Tidy@?$_Node_class@_WV?$regex_traits@_W@std@@@std@@QAEXPAU?$_Sequence@_W@2@@Z ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::_Tidy
PUBLIC	??_G?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAEPAXI@Z ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??0?$_Sequence@_W@std@@QAE@I@Z			; std::_Sequence<wchar_t>::_Sequence<wchar_t>
PUBLIC	??1?$_Sequence@_W@std@@QAE@XZ			; std::_Sequence<wchar_t>::~_Sequence<wchar_t>
PUBLIC	??_G?$_Sequence@_W@std@@QAEPAXI@Z		; std::_Sequence<wchar_t>::`scalar deleting destructor'
PUBLIC	??$_Lookup_coll@PB_W_W@std@@YAPB_WPB_W0PBU?$_Sequence@_W@0@@Z ; std::_Lookup_coll<wchar_t const *,wchar_t>
PUBLIC	??$_Lookup_range@_W@std@@YA_NIPBU?$_Buf@_W@0@@Z	; std::_Lookup_range<wchar_t>
PUBLIC	??$_Find@G@_Bitmap@std@@QBE_NG@Z		; std::_Bitmap::_Find<unsigned short>
PUBLIC	??$find@PB_WG@std@@YAPB_WPB_W0ABG@Z		; std::find<wchar_t const *,unsigned short>
PUBLIC	??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z ; std::_Lookup_equiv<wchar_t,std::regex_traits<wchar_t> >
PUBLIC	??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
PUBLIC	??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
PUBLIC	??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
PUBLIC	??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
PUBLIC	?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
PUBLIC	?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
PUBLIC	??$_Destroy_range1@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@PAU_Grp_t@?$_Tgt_state_t@PB_W@2@@std@@YAXPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$_Destroy_range1@V?$allocator@U_Loop_vals_t@std@@@std@@PAU_Loop_vals_t@2@@std@@YAXPAU_Loop_vals_t@0@0AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<std::_Loop_vals_t>,std::_Loop_vals_t *>
PUBLIC	??$_Unfancy@U_Loop_vals_t@std@@@std@@YAPAU_Loop_vals_t@0@PAU10@@Z ; std::_Unfancy<std::_Loop_vals_t>
PUBLIC	??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
PUBLIC	??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z ; std::_Ptr_move_cat<unsigned int,unsigned int>
PUBLIC	??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<unsigned int *,unsigned int *>
PUBLIC	??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z ; std::forward<std::allocator<bool> const &>
PUBLIC	??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<bool> const &>
PUBLIC	??$_Unfancy@I@std@@YAPAIPAI@Z			; std::_Unfancy<unsigned int>
PUBLIC	??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
PUBLIC	??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
PUBLIC	??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
PUBLIC	??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
PUBLIC	??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator==
PUBLIC	??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=
PUBLIC	?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Compat
PUBLIC	?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Dec
PUBLIC	?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Inc
PUBLIC	??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
PUBLIC	??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
PUBLIC	??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
PUBLIC	??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
PUBLIC	??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
PUBLIC	??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
PUBLIC	??$_Uninitialized_default_fill_n@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??$_Uninitialized_move@PAU_Loop_vals_t@std@@PAU12@V?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::_Loop_vals_t *,std::_Loop_vals_t *,std::allocator<std::_Loop_vals_t> >
PUBLIC	??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ; std::fill<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
PUBLIC	??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$_Uninitialized_default_fill_n@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
PUBLIC	??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z	; std::_Unfancy_maybe_null<unsigned int>
PUBLIC	??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>
PUBLIC	??$advance@PB_WH@std@@YAXAAPB_WH@Z		; std::advance<wchar_t const *,int>
PUBLIC	??$_Unchecked@PB_W@std@@YAPB_WPB_W@Z		; std::_Unchecked<wchar_t const *>
PUBLIC	??$_Find_unchecked@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z ; std::_Find_unchecked<wchar_t const *,enum std::_Meta_type>
PUBLIC	??$_Rechecked@PB_WPB_W@std@@YAAAPB_WAAPB_WPB_W@Z ; std::_Rechecked<wchar_t const *,wchar_t const *>
PUBLIC	??0?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@@Z ; std::_Cmp_icase<std::regex_traits<wchar_t> >::_Cmp_icase<std::regex_traits<wchar_t> >
PUBLIC	??R?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z ; std::_Cmp_icase<std::regex_traits<wchar_t> >::operator()
PUBLIC	??$_Cmp_chrange@PB_WPB_WU?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_icase@V?$regex_traits@_W@std@@@0@@Z ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::regex_traits<wchar_t> > >
PUBLIC	??0?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@@Z ; std::_Cmp_collate<std::regex_traits<wchar_t> >::_Cmp_collate<std::regex_traits<wchar_t> >
PUBLIC	??R?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z ; std::_Cmp_collate<std::regex_traits<wchar_t> >::operator()
PUBLIC	??$_Cmp_chrange@PB_WPB_WU?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_collate@V?$regex_traits@_W@std@@@0@@Z ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_collate<std::regex_traits<wchar_t> > >
PUBLIC	??R?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z ; std::_Cmp_cs<std::regex_traits<wchar_t> >::operator()
PUBLIC	??$_Cmp_chrange@PB_WPB_WU?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_cs@V?$regex_traits@_W@std@@@0@@Z ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_cs<std::regex_traits<wchar_t> > >
PUBLIC	??$_Find_unchecked@PB_WG@std@@YAPB_WPB_W0ABG@Z	; std::_Find_unchecked<wchar_t const *,unsigned short>
PUBLIC	??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::_Regex_traits<wchar_t>::transform_primary<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
PUBLIC	??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$construct@U_Loop_vals_t@std@@$$V@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::construct<std::_Loop_vals_t>
PUBLIC	??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z	; std::_Copy_memmove<unsigned int *,unsigned int *>
PUBLIC	??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<bool> const &>
PUBLIC	??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
PUBLIC	??$_Unfancy@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@@Z ; std::_Unfancy<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
PUBLIC	??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??$_Unchecked@PAU_Loop_vals_t@std@@@std@@YAPAU_Loop_vals_t@0@PAU10@@Z ; std::_Unchecked<std::_Loop_vals_t *>
PUBLIC	??$_Ptr_move_cat@U_Loop_vals_t@std@@U12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Loop_vals_t@0@0@Z ; std::_Ptr_move_cat<std::_Loop_vals_t,std::_Loop_vals_t>
PUBLIC	??$_Uninitialized_move_al_unchecked@U_Loop_vals_t@std@@U12@V?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_Loop_vals_t,std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >
PUBLIC	??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
PUBLIC	??$_Rechecked@PAU_Loop_vals_t@std@@PAU12@@std@@YAAAPAU_Loop_vals_t@0@AAPAU10@PAU10@@Z ; std::_Rechecked<std::_Loop_vals_t *,std::_Loop_vals_t *>
PUBLIC	??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ; std::_Fill_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
PUBLIC	??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ; std::_Is_checked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::_Copy_no_deprecate<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$_Unfancy@V?$sub_match@PB_W@std@@@std@@YAPAV?$sub_match@PB_W@0@PAV10@@Z ; std::_Unfancy<std::sub_match<wchar_t const *> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
PUBLIC	??$_Idl_distance@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU_Distance_unknown@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z ; std::_Idl_distance<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$_Unchecked_n_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@U_Distance_unknown@2@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@U_Distance_unknown@0@@Z ; std::_Unchecked_n_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Distance_unknown>
PUBLIC	??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z ; std::_Ptr_copy_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z ; std::_Rechecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$addressof@$$CBV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@YAPBV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@0@ABV10@@Z ; std::addressof<std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > const >
PUBLIC	??$assign@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::assign<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$_Destroy_range@V?$allocator@V?$sub_match@PB_W@std@@@std@@PAV?$sub_match@PB_W@2@@std@@YAXPAV?$sub_match@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::sub_match<wchar_t const *> >,std::sub_match<wchar_t const *> *>
PUBLIC	??$addressof@$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@std@@YAPBV?$vector@_NV?$allocator@_N@std@@@0@ABV10@@Z ; std::addressof<std::vector<bool,std::allocator<bool> > const >
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
PUBLIC	??$_Uninitialized_move@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??$_Uninitialized_move@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >
PUBLIC	??$_Uninitialized_move@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$addressof@$$CBV?$vector@IV?$allocator@_N@std@@@std@@@std@@YAPBV?$vector@IV?$allocator@_N@std@@@0@ABV10@@Z ; std::addressof<std::vector<unsigned int,std::allocator<bool> > const >
PUBLIC	??$assign@PAI@?$vector@IV?$allocator@_N@std@@@std@@QAEXPAI0@Z ; std::vector<unsigned int,std::allocator<bool> >::assign<unsigned int *>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::_Wrap_alloc<std::allocator<unsigned int> >,void>
PUBLIC	??$_Ucopy@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<bool> >::_Ucopy<unsigned int *>
PUBLIC	??$?0V?$allocator@I@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@$$QAV?$allocator@I@1@@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<unsigned int> >
PUBLIC	??$distance@PB_W@std@@YAHPB_W0@Z		; std::distance<wchar_t const *>
PUBLIC	??$_Is_word@_W@std@@YA_N_W@Z			; std::_Is_word<wchar_t>
PUBLIC	??$_Advance1@PB_WH@std@@YAXAAPB_WHUrandom_access_iterator_tag@0@@Z ; std::_Advance1<wchar_t const *,int>
PUBLIC	??$_Find_unchecked1@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<wchar_t const *,enum std::_Meta_type>
PUBLIC	??$_Find_unchecked1@PB_WG@std@@YAPB_WPB_W0ABGU?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<wchar_t const *,unsigned short>
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABQA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABQA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
PUBLIC	?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::begin
PUBLIC	?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::size
PUBLIC	?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
PUBLIC	?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Destroy
PUBLIC	?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@AAE_NI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy
PUBLIC	?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
PUBLIC	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
PUBLIC	??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0ABV?$allocator@_W@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,void>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::operator*
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::operator*
PUBLIC	??$construct@U_Loop_vals_t@std@@$$V@?$allocator_traits@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@SAXAAV?$allocator@U_Loop_vals_t@std@@@1@PAU_Loop_vals_t@1@@Z ; std::allocator_traits<std::allocator<std::_Loop_vals_t> >::construct<std::_Loop_vals_t>
PUBLIC	??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ; std::allocator<unsigned int>::allocator<unsigned int><bool>
PUBLIC	??$forward@ABI@std@@YAABIABI@Z			; std::forward<unsigned int const &>
PUBLIC	??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z ; std::allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
PUBLIC	??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
PUBLIC	??$_Copy_memmove@PAU_Loop_vals_t@std@@PAU12@@std@@YAPAU_Loop_vals_t@0@PAU10@00@Z ; std::_Copy_memmove<std::_Loop_vals_t *,std::_Loop_vals_t *>
PUBLIC	??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z ; std::_Fill_memset_is_safe<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
PUBLIC	??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
PUBLIC	??$_Unchecked_n@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@U_Distance_unknown@2@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@U_Distance_unknown@0@@Z ; std::_Unchecked_n<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Distance_unknown>
PUBLIC	??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ; std::_Copy_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$construct@V?$sub_match@PB_W@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@1@@Z ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *> >
PUBLIC	??$_Unchecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@@Z ; std::_Unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$sub_match@PB_W@std@@@std@@PAV?$sub_match@PB_W@2@@std@@YAXPAV?$sub_match@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<std::sub_match<wchar_t const *> >,std::sub_match<wchar_t const *> *>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
PUBLIC	??$_Ptr_move_cat@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z ; std::_Ptr_move_cat<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t>
PUBLIC	??$_Uninitialized_move_al_unchecked@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??$_Rechecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@AAPAU120@PAU120@@Z ; std::_Rechecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$_Unchecked@PAV?$sub_match@PB_W@std@@@std@@YAPAV?$sub_match@PB_W@0@PAV10@@Z ; std::_Unchecked<std::sub_match<wchar_t const *> *>
PUBLIC	??$_Ptr_move_cat@V?$sub_match@PB_W@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$sub_match@PB_W@0@0@Z ; std::_Ptr_move_cat<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >
PUBLIC	??$move@AAV?$sub_match@PB_W@std@@@std@@YA$$QAV?$sub_match@PB_W@0@AAV10@@Z ; std::move<std::sub_match<wchar_t const *> &>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >
PUBLIC	??$_Rechecked@PAV?$sub_match@PB_W@std@@PAV12@@std@@YAAAPAV?$sub_match@PB_W@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *>
PUBLIC	??$_Unchecked@PAI@std@@YAPAIPAI@Z		; std::_Unchecked<unsigned int *>
PUBLIC	??$_Uninitialized_move_al_unchecked@IIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned int,unsigned int,std::allocator<unsigned int> >
PUBLIC	??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z	; std::_Rechecked<unsigned int *,unsigned int *>
PUBLIC	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??$_Uninitialized_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ; std::_Uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z ; std::forward<std::allocator<unsigned int> >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > ><std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,void>
PUBLIC	??$_Ucopy@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEPAU_Grp_t@?$_Tgt_state_t@PB_W@1@PAU231@00@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Ucopy<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$_Traits_equal@U?$char_traits@_W@std@@@std@@YA_NQB_WI0I@Z ; std::_Traits_equal<std::char_traits<wchar_t> >
PUBLIC	??$?0V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@$$QAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> ><std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??$_Destroy_range@V?$allocator@_W@std@@PA_W@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Destroy_range<std::allocator<wchar_t>,wchar_t *>
PUBLIC	??$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z ; std::_Regex_traits<wchar_t>::lookup_classname<wchar_t const *>
PUBLIC	??$_Swap_adl@PAV_Node_base@std@@@std@@YAXAAPAV_Node_base@0@0@Z ; std::_Swap_adl<std::_Node_base *>
PUBLIC	??$swap@PAV_Node_base@std@@X@std@@YAXAAPAV_Node_base@0@0@Z ; std::swap<std::_Node_base *,void>
PUBLIC	??$_Distance1@PB_W@std@@YAHPB_W0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<wchar_t const *>
PUBLIC	??$?0ABV?$allocator@_W@std@@X@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>
PUBLIC	??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$_Range_construct_or_tidy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t *>
PUBLIC	??$construct@U_Loop_vals_t@std@@$$V@?$allocator@U_Loop_vals_t@std@@@std@@QAEXPAU_Loop_vals_t@1@@Z ; std::allocator<std::_Loop_vals_t>::construct<std::_Loop_vals_t>
PUBLIC	??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z ; std::allocator<unsigned int>::construct<unsigned int,unsigned int const &>
PUBLIC	??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SAXAAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@1@PAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
PUBLIC	??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
PUBLIC	??$construct@V?$sub_match@PB_W@std@@$$V@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAXAAV?$allocator@V?$sub_match@PB_W@std@@@1@PAV?$sub_match@PB_W@1@@Z ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *> >
PUBLIC	??$distance@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAHPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z ; std::distance<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$next@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@H@Z ; std::next<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$_Copy_unchecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00@Z ; std::_Copy_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$_Copy_memmove@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00@Z ; std::_Copy_memmove<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$construct@V?$sub_match@PB_W@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >
PUBLIC	??$distance@PAI@std@@YAHPAI0@Z			; std::distance<unsigned int *>
PUBLIC	??$next@PAI@std@@YAPAIPAIH@Z			; std::next<unsigned int *>
PUBLIC	??$_Copy_unchecked@PAIPAI@std@@YAPAIPAI00@Z	; std::_Copy_unchecked<unsigned int *,unsigned int *>
PUBLIC	??$_Ptr_copy_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z ; std::_Ptr_copy_cat<unsigned int,unsigned int>
PUBLIC	??$_Uninitialized_copy_al_unchecked@IIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<unsigned int,unsigned int,std::allocator<unsigned int> >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1><std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
PUBLIC	??$_Uninitialized_copy@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??$forward@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@YA$$QAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@0@AAV10@@Z ; std::forward<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??$_Destroy_range1@V?$allocator@_W@std@@PA_W@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<wchar_t>,wchar_t *>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<unsigned int> > &>
PUBLIC	??$_Mark@I@_Bitmap@std@@QAEXI@Z			; std::_Bitmap::_Mark<unsigned int>
PUBLIC	??$_Mark@G@_Bitmap@std@@QAEXG@Z			; std::_Bitmap::_Mark<unsigned short>
PUBLIC	??0?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@QAE@ABV?$_Regex_traits@_W@1@@Z ; std::_Cmp_icase<std::_Regex_traits<wchar_t> >::_Cmp_icase<std::_Regex_traits<wchar_t> >
PUBLIC	??R?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@QAE_N_W0@Z ; std::_Cmp_icase<std::_Regex_traits<wchar_t> >::operator()
PUBLIC	??$equal@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W000U?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z ; std::equal<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
PUBLIC	??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
PUBLIC	??$distance@PA_W@std@@YAHPA_W0@Z		; std::distance<wchar_t *>
PUBLIC	??$_Ucopy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEPA_WPA_W00@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Ucopy<wchar_t *>
PUBLIC	??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
PUBLIC	??$construct@V?$sub_match@PB_W@std@@$$V@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@1@@Z ; std::allocator<std::sub_match<wchar_t const *> >::construct<std::sub_match<wchar_t const *> >
PUBLIC	??$_Distance1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAHPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$advance@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@H@std@@YAXAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@H@Z ; std::advance<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,int>
PUBLIC	??$_Ptr_copy_cat@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z ; std::_Ptr_copy_cat<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t>
PUBLIC	??$_Copy_unchecked1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
PUBLIC	??$forward@V?$sub_match@PB_W@std@@@std@@YA$$QAV?$sub_match@PB_W@0@AAV10@@Z ; std::forward<std::sub_match<wchar_t const *> >
PUBLIC	??$construct@V?$sub_match@PB_W@std@@V12@@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAXAAV?$allocator@V?$sub_match@PB_W@std@@@1@PAV?$sub_match@PB_W@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >
PUBLIC	??$_Distance1@PAI@std@@YAHPAI0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<unsigned int *>
PUBLIC	??$advance@PAIH@std@@YAXAAPAIH@Z		; std::advance<unsigned int *,int>
PUBLIC	??$_Copy_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<unsigned int *,unsigned int *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > &>
PUBLIC	??$_Const_cast@$$CB_W@std@@YAPA_WPB_W@Z		; std::_Const_cast<wchar_t const >
PUBLIC	??$move@AAPAV_Node_base@std@@@std@@YA$$QAPAV_Node_base@0@AAPAV10@@Z ; std::move<std::_Node_base * &>
PUBLIC	??$_Equal_unchecked@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W000AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@Urandom_access_iterator_tag@0@2@Z ; std::_Equal_unchecked<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
PUBLIC	??$_Distance1@PA_W@std@@YAHPA_W0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<wchar_t *>
PUBLIC	??$_Uninitialized_copy@PA_WPA_WV?$allocator@_W@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninitialized_copy<wchar_t *,wchar_t *,std::allocator<wchar_t> >
PUBLIC	??$_Advance1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@H@std@@YAXAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,int>
PUBLIC	??$construct@V?$sub_match@PB_W@std@@V12@@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@1@$$QAV21@@Z ; std::allocator<std::sub_match<wchar_t const *> >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >
PUBLIC	??$_Advance1@PAIH@std@@YAXAAPAIHUrandom_access_iterator_tag@0@@Z ; std::_Advance1<unsigned int *,int>
PUBLIC	??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z ; std::_Regex_traits<wchar_t>::transform_primary<wchar_t const *>
PUBLIC	??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z ; std::_Regex_traits<wchar_t>::transform_primary<wchar_t *>
PUBLIC	??$_Equal_unchecked@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z ; std::_Equal_unchecked<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
PUBLIC	??$_Ptr_copy_cat@_W_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_W0@Z ; std::_Ptr_copy_cat<wchar_t,wchar_t>
PUBLIC	??$_Uninitialized_copy_al_unchecked@_W_WV?$allocator@_W@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<wchar_t,wchar_t,std::allocator<wchar_t> >
PUBLIC	??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z ; std::_Rechecked<wchar_t *,wchar_t *>
PUBLIC	??$_Insert@PB_W@?$_Buf@_W@std@@QAEXPB_W0@Z	; std::_Buf<wchar_t>::_Insert<wchar_t const *>
PUBLIC	??$?0PB_WX@?$vector@_WV?$allocator@_W@std@@@std@@QAE@PB_W0ABV?$allocator@_W@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><wchar_t const *,void>
PUBLIC	??$?0PA_WX@?$vector@_WV?$allocator@_W@std@@@std@@QAE@PA_W0ABV?$allocator@_W@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><wchar_t *,void>
PUBLIC	??$_Equal_memcmp_is_safe@$$CB_W$$CB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQB_W0ABU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z ; std::_Equal_memcmp_is_safe<wchar_t const ,wchar_t const ,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
PUBLIC	??$_Equal_unchecked1@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Equal_unchecked1<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
PUBLIC	??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z	; std::_Copy_memmove<wchar_t *,wchar_t *>
PUBLIC	??$_Range_construct_or_tidy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPB_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t const *>
PUBLIC	??$_Ucopy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEPA_WPB_W0PA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Ucopy<wchar_t const *>
PUBLIC	??$_Uninitialized_copy@PB_WPA_WV?$allocator@_W@std@@@std@@YAPA_WPB_W0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ; std::_Uninitialized_copy<wchar_t const *,wchar_t *,std::allocator<wchar_t> >
PUBLIC	??$_Ptr_copy_cat@$$CB_W_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQB_WABQA_W@Z ; std::_Ptr_copy_cat<wchar_t const ,wchar_t>
PUBLIC	??$_Uninitialized_copy_al_unchecked@$$CB_W_WV?$allocator@_W@std@@@std@@YAPA_WPB_W0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<wchar_t const ,wchar_t,std::allocator<wchar_t> >
PUBLIC	??$_Copy_memmove@PB_WPA_W@std@@YAPA_WPB_W0PA_W@Z ; std::_Copy_memmove<wchar_t const *,wchar_t *>
PUBLIC	??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?__SK_InjectionHistory@@3PAUSK_InjectionRecord_s@@A ; __SK_InjectionHistory
PUBLIC	??_7?$collate@_W@std@@6B@			; std::collate<wchar_t>::`vftable'
PUBLIC	?_Is_word_table@?1??_Is_word@std@@YA_NE@Z@4QB_NB ; `std::_Is_word'::`2'::_Is_word_table
PUBLIC	??_7_Node_base@std@@6B@				; std::_Node_base::`vftable'
PUBLIC	??_7_Root_node@std@@6B@				; std::_Root_node::`vftable'
PUBLIC	??_7_Node_end_group@std@@6B@			; std::_Node_end_group::`vftable'
PUBLIC	??_7_Node_assert@std@@6B@			; std::_Node_assert::`vftable'
PUBLIC	??_7_Node_capture@std@@6B@			; std::_Node_capture::`vftable'
PUBLIC	??_7_Node_back@std@@6B@				; std::_Node_back::`vftable'
PUBLIC	??_7_Node_endif@std@@6B@			; std::_Node_endif::`vftable'
PUBLIC	??_7_Node_if@std@@6B@				; std::_Node_if::`vftable'
PUBLIC	??_7_Node_end_rep@std@@6B@			; std::_Node_end_rep::`vftable'
PUBLIC	??_7_Node_rep@std@@6B@				; std::_Node_rep::`vftable'
PUBLIC	??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init'::`2'::_Stinit
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<wchar_t,char,_Mbstatet> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$collate@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::collate<wchar_t> >::_Psave
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Meta_map@?1??_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ@4QBDB ; `std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans'::`2'::_Meta_map
PUBLIC	??_7?$_Node_str@_W@std@@6B@			; std::_Node_str<wchar_t>::`vftable'
PUBLIC	??_7?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@ ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`vftable'
PUBLIC	?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B ; `std::_Regex_traits<wchar_t>::lookup_classname<wchar_t const *>'::`2'::_Names
PUBLIC	??_C@_05IIMHCHIO@alnum?$AA@			; `string'
PUBLIC	??_C@_1M@KLMEPMCM@?$AAa?$AAl?$AAn?$AAu?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_05IAEKHIAN@alpha?$AA@			; `string'
PUBLIC	??_C@_1M@DHGLHBMI@?$AAa?$AAl?$AAp?$AAh?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_05BABJKOGB@blank?$AA@			; `string'
PUBLIC	??_C@_1M@EJAAJBPE@?$AAb?$AAl?$AAa?$AAn?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_05JMDPEFNK@cntrl?$AA@			; `string'
PUBLIC	??_C@_1M@LMIMILA@?$AAc?$AAn?$AAt?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	??_C@_13GKPPEALH@?$AAd?$AA?$AA@			; `string'
PUBLIC	??_C@_05ODNOIFML@digit?$AA@			; `string'
PUBLIC	??_C@_1M@JDAEIBKG@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_05KCJBMLII@graph?$AA@			; `string'
PUBLIC	??_C@_1M@MDKNJLLK@?$AAg?$AAr?$AAa?$AAp?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_05IPJEPLHL@lower?$AA@			; `string'
PUBLIC	??_C@_1M@LGAECJJD@?$AAl?$AAo?$AAw?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_05IJDJACGD@print?$AA@			; `string'
PUBLIC	??_C@_1M@ELNLAPLA@?$AAp?$AAr?$AAi?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_05KOBGHFJJ@punct?$AA@			; `string'
PUBLIC	??_C@_1M@BPFMAOAO@?$AAp?$AAu?$AAn?$AAc?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_05OLNILLAB@space?$AA@			; `string'
PUBLIC	??_C@_1M@LPGODFOM@?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_13KHDBCPJB@?$AAs?$AA?$AA@			; `string'
PUBLIC	??_C@_05NECKJAMC@upper?$AA@			; `string'
PUBLIC	??_C@_1M@PLNFCNIC@?$AAu?$AAp?$AAp?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_13CIFDLIMG@?$AAw?$AA?$AA@			; `string'
PUBLIC	??_C@_06BAPHGFFK@xdigit?$AA@			; `string'
PUBLIC	??_C@_1O@OAFMJDHN@?$AAx?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_R4?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R4?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$collate@_W@std@@6B@			; std::collate<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$collate@_W@std@@@8			; std::collate<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$collate@_W@std@@8			; std::collate<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$collate@_W@std@@8			; std::collate<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$collate@_W@std@@8		; std::collate<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_base@std@@6B@			; std::_Node_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_base@std@@@8			; std::_Node_base `RTTI Type Descriptor'
PUBLIC	??_R3_Node_base@std@@8				; std::_Node_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_base@std@@8				; std::_Node_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_base@std@@8			; std::_Node_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Root_node@std@@6B@			; std::_Root_node::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Root_node@std@@@8			; std::_Root_node `RTTI Type Descriptor'
PUBLIC	??_R3_Root_node@std@@8				; std::_Root_node::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Root_node@std@@8				; std::_Root_node::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Root_node@std@@8			; std::_Root_node::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_end_group@std@@6B@			; std::_Node_end_group::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_end_group@std@@@8			; std::_Node_end_group `RTTI Type Descriptor'
PUBLIC	??_R3_Node_end_group@std@@8			; std::_Node_end_group::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_end_group@std@@8			; std::_Node_end_group::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_end_group@std@@8		; std::_Node_end_group::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_assert@std@@6B@			; std::_Node_assert::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_assert@std@@@8			; std::_Node_assert `RTTI Type Descriptor'
PUBLIC	??_R3_Node_assert@std@@8			; std::_Node_assert::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_assert@std@@8			; std::_Node_assert::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_assert@std@@8		; std::_Node_assert::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_capture@std@@6B@			; std::_Node_capture::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_capture@std@@@8			; std::_Node_capture `RTTI Type Descriptor'
PUBLIC	??_R3_Node_capture@std@@8			; std::_Node_capture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_capture@std@@8			; std::_Node_capture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_capture@std@@8		; std::_Node_capture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_back@std@@6B@			; std::_Node_back::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_back@std@@@8			; std::_Node_back `RTTI Type Descriptor'
PUBLIC	??_R3_Node_back@std@@8				; std::_Node_back::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_back@std@@8				; std::_Node_back::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_back@std@@8			; std::_Node_back::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_endif@std@@6B@			; std::_Node_endif::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_endif@std@@@8			; std::_Node_endif `RTTI Type Descriptor'
PUBLIC	??_R3_Node_endif@std@@8				; std::_Node_endif::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_endif@std@@8				; std::_Node_endif::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_endif@std@@8		; std::_Node_endif::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_if@std@@6B@				; std::_Node_if::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_if@std@@@8			; std::_Node_if `RTTI Type Descriptor'
PUBLIC	??_R3_Node_if@std@@8				; std::_Node_if::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_if@std@@8				; std::_Node_if::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_if@std@@8			; std::_Node_if::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_rep@std@@6B@				; std::_Node_rep::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_rep@std@@@8			; std::_Node_rep `RTTI Type Descriptor'
PUBLIC	??_R3_Node_rep@std@@8				; std::_Node_rep::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_rep@std@@8				; std::_Node_rep::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_rep@std@@8			; std::_Node_rep::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Node_end_rep@std@@6B@			; std::_Node_end_rep::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Node_end_rep@std@@@8			; std::_Node_end_rep `RTTI Type Descriptor'
PUBLIC	??_R3_Node_end_rep@std@@8			; std::_Node_end_rep::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Node_end_rep@std@@8			; std::_Node_end_rep::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Node_end_rep@std@@8		; std::_Node_end_rep::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@ ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Node_class@_WV?$regex_traits@_W@std@@@std@@@8 ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8 ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8 ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8 ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$_Node_str@_W@std@@6B@			; std::_Node_str<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Node_str@_W@std@@@8			; std::_Node_str<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Node_str@_W@std@@8			; std::_Node_str<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Node_str@_W@std@@8			; std::_Node_str<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Node_str@_W@std@@8		; std::_Node_str<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__iswalpha:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__wcsncpy:PROC
EXTRN	__imp__SetCurrentDirectoryW@4:PROC
EXTRN	__imp__GetCurrentDirectoryW@8:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__DeleteFileW@4:PROC
EXTRN	__imp__GetFileAttributesA@4:PROC
EXTRN	__imp__GetFileAttributesW@4:PROC
EXTRN	__imp__GetTempFileNameW@16:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__SleepEx@8:PROC
EXTRN	__imp__CreateEventW@16:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	__imp__TerminateProcess@8:PROC
EXTRN	__imp__GetExitCodeProcess@8:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__OpenProcess@12:PROC
EXTRN	__imp__GetSystemDirectoryW@8:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__GetModuleHandleExW@12:PROC
EXTRN	__imp__lstrcatW@8:PROC
EXTRN	__imp__LoadLibraryW@4:PROC
EXTRN	__imp__GetSystemWow64DirectoryW@8:PROC
EXTRN	__imp__CopyFileW@12:PROC
EXTRN	__imp__MoveFileW@8:PROC
EXTRN	__imp__ReplaceFileW@24:PROC
EXTRN	__imp__SendMessageW@16:PROC
EXTRN	__imp__FindWindowW@8:PROC
EXTRN	__imp__SetWindowsHookExW@16:PROC
EXTRN	__imp__UnhookWindowsHookEx@4:PROC
EXTRN	__imp__CallNextHookEx@16:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__ShellExecuteA@24:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	?SK_FindRootWindow@@YA?AUwindow_t@@K@Z:PROC	; SK_FindRootWindow
EXTRN	__imp__fgetwc:PROC
EXTRN	__imp__fputwc:PROC
EXTRN	__imp__fputws:PROC
EXTRN	__imp__ungetwc:PROC
EXTRN	__imp___wfopen:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	__imp__fgetpos:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fsetpos:PROC
EXTRN	__imp___fseeki64:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__setvbuf:PROC
EXTRN	__imp__ungetc:PROC
EXTRN	__imp___lock_file:PROC
EXTRN	__imp___unlock_file:PROC
EXTRN	_fprintf:PROC
EXTRN	_fscanf:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	?SK_GetConfigPath@@YGPB_WXZ:PROC		; SK_GetConfigPath
EXTRN	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ:PROC		; SK_GetDLL
EXTRN	?SK_IsHostAppSKIM@@YA_NXZ:PROC			; SK_IsHostAppSKIM
EXTRN	?SK_IsInjected@@YG_N_N@Z:PROC			; SK_IsInjected
EXTRN	?SK_GetFramesDrawn@@YGKXZ:PROC			; SK_GetFramesDrawn
EXTRN	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ:PROC ; SK_GetCurrentRenderBackend
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	__imp___Getcoll:PROC
EXTRN	__imp___Wcscoll:PROC
EXTRN	__imp___Wcsxfrm:PROC
EXTRN	__imp_??0_Locinfo@std@@QAE@PBD@Z:PROC
EXTRN	__imp_??1_Locinfo@std@@QAE@XZ:PROC
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_??0facet@locale@std@@IAE@I@Z:PROC
EXTRN	__imp_??1facet@locale@std@@MAE@XZ:PROC
EXTRN	__imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?in@?$codecvt@_WDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPA_W3AAPA_W@Z:PROC
EXTRN	__imp_?out@?$codecvt@_WDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PB_W1AAPB_WPAD3AAPAD@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@_WDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z:PROC
EXTRN	__imp_?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?is@?$ctype@_W@std@@QBE_NF_W@Z:PROC
EXTRN	__imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z:PROC
EXTRN	__imp_?tolower@?$ctype@_W@std@@QBEPB_WPA_WPB_W@Z:PROC
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ:PROC
EXTRN	__imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:PROC
EXTRN	__imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z:PROC
EXTRN	__imp_??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:PROC
EXTRN	?SK_SaveConfig@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z:PROC ; SK_SaveConfig
EXTRN	__imp___time64:PROC
EXTRN	?SK_GetHostPath@@YAPB_WXZ:PROC			; SK_GetHostPath
EXTRN	?SK_GetDocumentsDir@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ:PROC ; SK_GetDocumentsDir
EXTRN	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z:PROC ; SK_WideCharToUTF8
EXTRN	?SK_UTF8ToWideChar@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:PROC ; SK_UTF8ToWideChar
EXTRN	?SK_FormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBDZZ:PROC ; SK_FormatString
EXTRN	?SK_SYS_GetInstallPath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ:PROC ; SK_SYS_GetInstallPath
EXTRN	?SK_GetModuleFullName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z:PROC ; SK_GetModuleFullName
EXTRN	__imp__StrStrA@8:PROC
EXTRN	__imp__StrStrIW@8:PROC
EXTRN	__imp__PathAppendW@8:PROC
EXTRN	__imp__PathRemoveFileSpecW@4:PROC
EXTRN	__imp__PathStripPathW@4:PROC
EXTRN	?SK_EstablishRootPath@@YGXXZ:PROC		; SK_EstablishRootPath
EXTRN	_CreateToolhelp32Snapshot@8:PROC
EXTRN	_Process32FirstW@8:PROC
EXTRN	_Process32NextW@8:PROC
EXTRN	__imp_?_Fiopen@std@@YAPAU_iobuf@@PB_WHH@Z:PROC
EXTRN	??_E?$collate@_W@std@@MAEPAXI@Z:PROC		; std::collate<wchar_t>::`vector deleting destructor'
EXTRN	__imp_?_Xregex_error@std@@YAXW4error_type@regex_constants@1@@Z:PROC
EXTRN	??_E_Node_base@std@@UAEPAXI@Z:PROC		; std::_Node_base::`vector deleting destructor'
EXTRN	??_E_Root_node@std@@UAEPAXI@Z:PROC		; std::_Root_node::`vector deleting destructor'
EXTRN	??_E_Node_end_group@std@@UAEPAXI@Z:PROC		; std::_Node_end_group::`vector deleting destructor'
EXTRN	??_E_Node_assert@std@@UAEPAXI@Z:PROC		; std::_Node_assert::`vector deleting destructor'
EXTRN	??_E_Node_capture@std@@UAEPAXI@Z:PROC		; std::_Node_capture::`vector deleting destructor'
EXTRN	??_E_Node_back@std@@UAEPAXI@Z:PROC		; std::_Node_back::`vector deleting destructor'
EXTRN	??_E_Node_endif@std@@UAEPAXI@Z:PROC		; std::_Node_endif::`vector deleting destructor'
EXTRN	??_E_Node_if@std@@UAEPAXI@Z:PROC		; std::_Node_if::`vector deleting destructor'
EXTRN	??_E_Node_end_rep@std@@UAEPAXI@Z:PROC		; std::_Node_end_rep::`vector deleting destructor'
EXTRN	??_E_Node_rep@std@@UAEPAXI@Z:PROC		; std::_Node_rep::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$_Node_str@_W@std@@UAEPAXI@Z:PROC		; std::_Node_str<wchar_t>::`vector deleting destructor'
EXTRN	??_E?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`vector deleting destructor'
EXTRN	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ:PROC ; std::locale::facet::_Decref
EXTRN	?_Incref@facet@locale@std@@UAEXXZ:PROC		; std::locale::facet::_Incref
EXTRN	?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
EXTRN	?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
EXTRN	?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?id@?$codecvt@_WDU_Mbstatet@@@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?__SK_DLL_Attached@@3JC:DWORD			; __SK_DLL_Attached
EXTRN	?__SK_HookContextOwner@@3JC:DWORD		; __SK_HookContextOwner
EXTRN	__imp_?id@?$collate@_W@std@@2V0locale@2@A:DWORD
SK_Hooks	SEGMENT
?__SK_InjectionHistory@@3PAUSK_InjectionRecord_s@@A DB 08e00H DUP (?) ; __SK_InjectionHistory
SK_Hooks	ENDS
;	COMDAT ?lHookIters@?6??CBTProc@@YGJHIJ@Z@4JC
_BSS	SEGMENT
?lHookIters@?6??CBTProc@@YGJHIJ@Z@4JC DD 01H DUP (?)	; `CBTProc'::`7'::lHookIters
_BSS	ENDS
;	COMDAT ?lHookIters@?6??ShellProc@@YGJHIJ@Z@4JC
_BSS	SEGMENT
?lHookIters@?6??ShellProc@@YGJHIJ@Z@4JC DD 01H DUP (?)	; `ShellProc'::`7'::lHookIters
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<wchar_t,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$collate@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$collate@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::collate<wchar_t> >::_Psave
_BSS	ENDS
CRT$XCU	SEGMENT
?__SK_InjectionHistory$initializer$@@3P6AXXZA DD FLAT:??__E__SK_InjectionHistory@@YAXXZ ; __SK_InjectionHistory$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Node_str@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Node_str@_W@std@@8 DD FLAT:??_R0?AV?$_Node_str@_W@std@@@8 ; std::_Node_str<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Node_str@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Node_str@_W@std@@8
rdata$r	SEGMENT
??_R2?$_Node_str@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Node_str@_W@std@@8 ; std::_Node_str<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Node_str@_W@std@@8
rdata$r	SEGMENT
??_R3?$_Node_str@_W@std@@8 DD 00H			; std::_Node_str<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Node_str@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Node_str@_W@std@@@8
data$r	SEGMENT
??_R0?AV?$_Node_str@_W@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_str<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Node_str@_W@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$_Node_str@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$_Node_str@_W@std@@6B@ DD 00H			; std::_Node_str<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Node_str@_W@std@@@8
	DD	FLAT:??_R3?$_Node_str@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$_Node_class@_WV?$regex_traits@_W@std@@@std@@@8 ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8 ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8 DD 00H ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Node_class@_WV?$regex_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$_Node_class@_WV?$regex_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Node_class@_WV?$regex_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@ DD 00H ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Node_class@_WV?$regex_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$_Node_class@_WV?$regex_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_end_rep@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_end_rep@std@@8 DD FLAT:??_R0?AV_Node_end_rep@std@@@8 ; std::_Node_end_rep::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_end_rep@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_end_rep@std@@8
rdata$r	SEGMENT
??_R2_Node_end_rep@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_end_rep@std@@8 ; std::_Node_end_rep::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Node_end_rep@std@@8
rdata$r	SEGMENT
??_R3_Node_end_rep@std@@8 DD 00H			; std::_Node_end_rep::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Node_end_rep@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_end_rep@std@@@8
data$r	SEGMENT
??_R0?AV_Node_end_rep@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_end_rep `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_end_rep@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_end_rep@std@@6B@
rdata$r	SEGMENT
??_R4_Node_end_rep@std@@6B@ DD 00H			; std::_Node_end_rep::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_end_rep@std@@@8
	DD	FLAT:??_R3_Node_end_rep@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_rep@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_rep@std@@8 DD FLAT:??_R0?AV_Node_rep@std@@@8 ; std::_Node_rep::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_rep@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_rep@std@@8
rdata$r	SEGMENT
??_R2_Node_rep@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_rep@std@@8 ; std::_Node_rep::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Node_rep@std@@8
rdata$r	SEGMENT
??_R3_Node_rep@std@@8 DD 00H				; std::_Node_rep::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Node_rep@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_rep@std@@@8
data$r	SEGMENT
??_R0?AV_Node_rep@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Node_rep `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_rep@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_rep@std@@6B@
rdata$r	SEGMENT
??_R4_Node_rep@std@@6B@ DD 00H				; std::_Node_rep::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_rep@std@@@8
	DD	FLAT:??_R3_Node_rep@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_if@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_if@std@@8 DD FLAT:??_R0?AV_Node_if@std@@@8 ; std::_Node_if::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_if@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_if@std@@8
rdata$r	SEGMENT
??_R2_Node_if@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_if@std@@8 ; std::_Node_if::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Node_if@std@@8
rdata$r	SEGMENT
??_R3_Node_if@std@@8 DD 00H				; std::_Node_if::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Node_if@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_if@std@@@8
data$r	SEGMENT
??_R0?AV_Node_if@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Node_if `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_if@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_if@std@@6B@
rdata$r	SEGMENT
??_R4_Node_if@std@@6B@ DD 00H				; std::_Node_if::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_if@std@@@8
	DD	FLAT:??_R3_Node_if@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_endif@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_endif@std@@8 DD FLAT:??_R0?AV_Node_endif@std@@@8 ; std::_Node_endif::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_endif@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_endif@std@@8
rdata$r	SEGMENT
??_R2_Node_endif@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_endif@std@@8 ; std::_Node_endif::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Node_endif@std@@8
rdata$r	SEGMENT
??_R3_Node_endif@std@@8 DD 00H				; std::_Node_endif::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Node_endif@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_endif@std@@@8
data$r	SEGMENT
??_R0?AV_Node_endif@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Node_endif `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_endif@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_endif@std@@6B@
rdata$r	SEGMENT
??_R4_Node_endif@std@@6B@ DD 00H			; std::_Node_endif::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_endif@std@@@8
	DD	FLAT:??_R3_Node_endif@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_back@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_back@std@@8 DD FLAT:??_R0?AV_Node_back@std@@@8 ; std::_Node_back::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_back@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_back@std@@8
rdata$r	SEGMENT
??_R2_Node_back@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_back@std@@8 ; std::_Node_back::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Node_back@std@@8
rdata$r	SEGMENT
??_R3_Node_back@std@@8 DD 00H				; std::_Node_back::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Node_back@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_back@std@@@8
data$r	SEGMENT
??_R0?AV_Node_back@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Node_back `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_back@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_back@std@@6B@
rdata$r	SEGMENT
??_R4_Node_back@std@@6B@ DD 00H				; std::_Node_back::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_back@std@@@8
	DD	FLAT:??_R3_Node_back@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_capture@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_capture@std@@8 DD FLAT:??_R0?AV_Node_capture@std@@@8 ; std::_Node_capture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_capture@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_capture@std@@8
rdata$r	SEGMENT
??_R2_Node_capture@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_capture@std@@8 ; std::_Node_capture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Node_capture@std@@8
rdata$r	SEGMENT
??_R3_Node_capture@std@@8 DD 00H			; std::_Node_capture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Node_capture@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_capture@std@@@8
data$r	SEGMENT
??_R0?AV_Node_capture@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_capture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_capture@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_capture@std@@6B@
rdata$r	SEGMENT
??_R4_Node_capture@std@@6B@ DD 00H			; std::_Node_capture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_capture@std@@@8
	DD	FLAT:??_R3_Node_capture@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_assert@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_assert@std@@8 DD FLAT:??_R0?AV_Node_assert@std@@@8 ; std::_Node_assert::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_assert@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_assert@std@@8
rdata$r	SEGMENT
??_R2_Node_assert@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_assert@std@@8 ; std::_Node_assert::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Node_assert@std@@8
rdata$r	SEGMENT
??_R3_Node_assert@std@@8 DD 00H				; std::_Node_assert::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Node_assert@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_assert@std@@@8
data$r	SEGMENT
??_R0?AV_Node_assert@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Node_assert `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_assert@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_assert@std@@6B@
rdata$r	SEGMENT
??_R4_Node_assert@std@@6B@ DD 00H			; std::_Node_assert::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_assert@std@@@8
	DD	FLAT:??_R3_Node_assert@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_end_group@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_end_group@std@@8 DD FLAT:??_R0?AV_Node_end_group@std@@@8 ; std::_Node_end_group::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_end_group@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_end_group@std@@8
rdata$r	SEGMENT
??_R2_Node_end_group@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_end_group@std@@8 ; std::_Node_end_group::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Node_end_group@std@@8
rdata$r	SEGMENT
??_R3_Node_end_group@std@@8 DD 00H			; std::_Node_end_group::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Node_end_group@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_end_group@std@@@8
data$r	SEGMENT
??_R0?AV_Node_end_group@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Node_end_group `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_end_group@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_end_group@std@@6B@
rdata$r	SEGMENT
??_R4_Node_end_group@std@@6B@ DD 00H			; std::_Node_end_group::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_end_group@std@@@8
	DD	FLAT:??_R3_Node_end_group@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Root_node@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Root_node@std@@8 DD FLAT:??_R0?AV_Root_node@std@@@8 ; std::_Root_node::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Root_node@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Root_node@std@@8
rdata$r	SEGMENT
??_R2_Root_node@std@@8 DD FLAT:??_R1A@?0A@EA@_Root_node@std@@8 ; std::_Root_node::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Root_node@std@@8
rdata$r	SEGMENT
??_R3_Root_node@std@@8 DD 00H				; std::_Root_node::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Root_node@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Root_node@std@@@8
data$r	SEGMENT
??_R0?AV_Root_node@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Root_node `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Root_node@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Root_node@std@@6B@
rdata$r	SEGMENT
??_R4_Root_node@std@@6B@ DD 00H				; std::_Root_node::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Root_node@std@@@8
	DD	FLAT:??_R3_Root_node@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Node_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Node_base@std@@8 DD FLAT:??_R0?AV_Node_base@std@@@8 ; std::_Node_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Node_base@std@@8
rdata$r	SEGMENT
??_R2_Node_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Node_base@std@@8 ; std::_Node_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Node_base@std@@8
rdata$r	SEGMENT
??_R3_Node_base@std@@8 DD 00H				; std::_Node_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Node_base@std@@@8
data$r	SEGMENT
??_R0?AV_Node_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Node_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Node_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Node_base@std@@6B@
rdata$r	SEGMENT
??_R4_Node_base@std@@6B@ DD 00H				; std::_Node_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Node_base@std@@@8
	DD	FLAT:??_R3_Node_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$collate@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$collate@_W@std@@8 DD FLAT:??_R0?AV?$collate@_W@std@@@8 ; std::collate<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$collate@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$collate@_W@std@@8
rdata$r	SEGMENT
??_R2?$collate@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$collate@_W@std@@8 ; std::collate<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$collate@_W@std@@8
rdata$r	SEGMENT
??_R3?$collate@_W@std@@8 DD 00H				; std::collate<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$collate@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$collate@_W@std@@@8
data$r	SEGMENT
??_R0?AV?$collate@_W@std@@@8 DD FLAT:??_7type_info@@6B@	; std::collate<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$collate@_W@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$collate@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$collate@_W@std@@6B@ DD 00H			; std::collate<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$collate@_W@std@@@8
	DD	FLAT:??_R3?$collate@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$r	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	070H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1O@OAFMJDHN@?$AAx?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1O@OAFMJDHN@?$AAx?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@ DB 'x', 00H, 'd'
	DB	00H, 'i', 00H, 'g', 00H, 'i', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAPHGFFK@xdigit?$AA@
CONST	SEGMENT
??_C@_06BAPHGFFK@xdigit?$AA@ DB 'xdigit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13CIFDLIMG@?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_13CIFDLIMG@?$AAw?$AA?$AA@ DB 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PLNFCNIC@?$AAu?$AAp?$AAp?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PLNFCNIC@?$AAu?$AAp?$AAp?$AAe?$AAr?$AA?$AA@ DB 'u', 00H, 'p', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NECKJAMC@upper?$AA@
CONST	SEGMENT
??_C@_05NECKJAMC@upper?$AA@ DB 'upper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13KHDBCPJB@?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_13KHDBCPJB@?$AAs?$AA?$AA@ DB 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LPGODFOM@?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LPGODFOM@?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?$AA@ DB 's', 00H, 'p', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLNILLAB@space?$AA@
CONST	SEGMENT
??_C@_05OLNILLAB@space?$AA@ DB 'space', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BPFMAOAO@?$AAp?$AAu?$AAn?$AAc?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BPFMAOAO@?$AAp?$AAu?$AAn?$AAc?$AAt?$AA?$AA@ DB 'p', 00H, 'u', 00H
	DB	'n', 00H, 'c', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KOBGHFJJ@punct?$AA@
CONST	SEGMENT
??_C@_05KOBGHFJJ@punct?$AA@ DB 'punct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@ELNLAPLA@?$AAp?$AAr?$AAi?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@ELNLAPLA@?$AAp?$AAr?$AAi?$AAn?$AAt?$AA?$AA@ DB 'p', 00H, 'r', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJDJACGD@print?$AA@
CONST	SEGMENT
??_C@_05IJDJACGD@print?$AA@ DB 'print', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LGAECJJD@?$AAl?$AAo?$AAw?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LGAECJJD@?$AAl?$AAo?$AAw?$AAe?$AAr?$AA?$AA@ DB 'l', 00H, 'o', 00H
	DB	'w', 00H, 'e', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPJEPLHL@lower?$AA@
CONST	SEGMENT
??_C@_05IPJEPLHL@lower?$AA@ DB 'lower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MDKNJLLK@?$AAg?$AAr?$AAa?$AAp?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MDKNJLLK@?$AAg?$AAr?$AAa?$AAp?$AAh?$AA?$AA@ DB 'g', 00H, 'r', 00H
	DB	'a', 00H, 'p', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KCJBMLII@graph?$AA@
CONST	SEGMENT
??_C@_05KCJBMLII@graph?$AA@ DB 'graph', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JDAEIBKG@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JDAEIBKG@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@ DB 'd', 00H, 'i', 00H
	DB	'g', 00H, 'i', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODNOIFML@digit?$AA@
CONST	SEGMENT
??_C@_05ODNOIFML@digit?$AA@ DB 'digit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13GKPPEALH@?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_13GKPPEALH@?$AAd?$AA?$AA@ DB 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LMIMILA@?$AAc?$AAn?$AAt?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LMIMILA@?$AAc?$AAn?$AAt?$AAr?$AAl?$AA?$AA@ DB 'c', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMDPEFNK@cntrl?$AA@
CONST	SEGMENT
??_C@_05JMDPEFNK@cntrl?$AA@ DB 'cntrl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EJAAJBPE@?$AAb?$AAl?$AAa?$AAn?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJAAJBPE@?$AAb?$AAl?$AAa?$AAn?$AAk?$AA?$AA@ DB 'b', 00H, 'l', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BABJKOGB@blank?$AA@
CONST	SEGMENT
??_C@_05BABJKOGB@blank?$AA@ DB 'blank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DHGLHBMI@?$AAa?$AAl?$AAp?$AAh?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DHGLHBMI@?$AAa?$AAl?$AAp?$AAh?$AAa?$AA?$AA@ DB 'a', 00H, 'l', 00H
	DB	'p', 00H, 'h', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IAEKHIAN@alpha?$AA@
CONST	SEGMENT
??_C@_05IAEKHIAN@alpha?$AA@ DB 'alpha', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KLMEPMCM@?$AAa?$AAl?$AAn?$AAu?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KLMEPMCM@?$AAa?$AAl?$AAn?$AAu?$AAm?$AA?$AA@ DB 'a', 00H, 'l', 00H
	DB	'n', 00H, 'u', 00H, 'm', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IIMHCHIO@alnum?$AA@
CONST	SEGMENT
??_C@_05IIMHCHIO@alnum?$AA@ DB 'alnum', 00H		; `string'
CONST	ENDS
;	COMDAT ?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B
CONST	SEGMENT
?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B DD FLAT:??_C@_05IIMHCHIO@alnum?$AA@ ; `std::_Regex_traits<wchar_t>::lookup_classname<wchar_t const *>'::`2'::_Names
	DD	FLAT:??_C@_1M@KLMEPMCM@?$AAa?$AAl?$AAn?$AAu?$AAm?$AA?$AA@
	DD	05H
	DW	0107H
	ORG $+2
	DD	FLAT:??_C@_05IAEKHIAN@alpha?$AA@
	DD	FLAT:??_C@_1M@DHGLHBMI@?$AAa?$AAl?$AAp?$AAh?$AAa?$AA?$AA@
	DD	05H
	DW	0103H
	ORG $+2
	DD	FLAT:??_C@_05BABJKOGB@blank?$AA@
	DD	FLAT:??_C@_1M@EJAAJBPE@?$AAb?$AAl?$AAa?$AAn?$AAk?$AA?$AA@
	DD	05H
	DW	048H
	ORG $+2
	DD	FLAT:??_C@_05JMDPEFNK@cntrl?$AA@
	DD	FLAT:??_C@_1M@LMIMILA@?$AAc?$AAn?$AAt?$AAr?$AAl?$AA?$AA@
	DD	05H
	DW	020H
	ORG $+2
	DD	FLAT:??_C@_01LPLHEDKD@d?$AA@
	DD	FLAT:??_C@_13GKPPEALH@?$AAd?$AA?$AA@
	DD	01H
	DW	04H
	ORG $+2
	DD	FLAT:??_C@_05ODNOIFML@digit?$AA@
	DD	FLAT:??_C@_1M@JDAEIBKG@?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@
	DD	05H
	DW	04H
	ORG $+2
	DD	FLAT:??_C@_05KCJBMLII@graph?$AA@
	DD	FLAT:??_C@_1M@MDKNJLLK@?$AAg?$AAr?$AAa?$AAp?$AAh?$AA?$AA@
	DD	05H
	DW	0117H
	ORG $+2
	DD	FLAT:??_C@_05IPJEPLHL@lower?$AA@
	DD	FLAT:??_C@_1M@LGAECJJD@?$AAl?$AAo?$AAw?$AAe?$AAr?$AA?$AA@
	DD	05H
	DW	02H
	ORG $+2
	DD	FLAT:??_C@_05IJDJACGD@print?$AA@
	DD	FLAT:??_C@_1M@ELNLAPLA@?$AAp?$AAr?$AAi?$AAn?$AAt?$AA?$AA@
	DD	05H
	DW	01d7H
	ORG $+2
	DD	FLAT:??_C@_05KOBGHFJJ@punct?$AA@
	DD	FLAT:??_C@_1M@BPFMAOAO@?$AAp?$AAu?$AAn?$AAc?$AAt?$AA?$AA@
	DD	05H
	DW	010H
	ORG $+2
	DD	FLAT:??_C@_05OLNILLAB@space?$AA@
	DD	FLAT:??_C@_1M@LPGODFOM@?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?$AA@
	DD	05H
	DW	048H
	ORG $+2
	DD	FLAT:??_C@_01LKDEMHDF@s?$AA@
	DD	FLAT:??_C@_13KHDBCPJB@?$AAs?$AA?$AA@
	DD	01H
	DW	048H
	ORG $+2
	DD	FLAT:??_C@_05NECKJAMC@upper?$AA@
	DD	FLAT:??_C@_1M@PLNFCNIC@?$AAu?$AAp?$AAp?$AAe?$AAr?$AA?$AA@
	DD	05H
	DW	01H
	ORG $+2
	DD	FLAT:??_C@_01NOFIACDB@w?$AA@
	DD	FLAT:??_C@_13CIFDLIMG@?$AAw?$AA?$AA@
	DD	01H
	DW	0ffffH
	ORG $+2
	DD	FLAT:??_C@_06BAPHGFFK@xdigit?$AA@
	DD	FLAT:??_C@_1O@OAFMJDHN@?$AAx?$AAd?$AAi?$AAg?$AAi?$AAt?$AA?$AA@
	DD	06H
	DW	080H
	ORG $+2
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	ORG $+2
CONST	ENDS
;	COMDAT ??_7?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@ ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$_Node_str@_W@std@@6B@
CONST	SEGMENT
??_7?$_Node_str@_W@std@@6B@ DD FLAT:??_R4?$_Node_str@_W@std@@6B@ ; std::_Node_str<wchar_t>::`vftable'
	DD	FLAT:??_E?$_Node_str@_W@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?_Meta_map@?1??_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ@4QBDB
CONST	SEGMENT
?_Meta_map@?1??_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ@4QBDB DB 028H ; `std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans'::`2'::_Meta_map
	DB	029H
	DB	024H
	DB	05eH
	DB	02eH
	DB	02aH
	DB	02bH
	DB	03fH
	DB	05bH
	DB	05dH
	DB	07cH
	DB	05cH
	DB	02dH
	DB	07bH
	DB	07dH
	DB	02cH
	DB	03aH
	DB	03dH
	DB	021H
	DB	0aH
	DB	0dH
	DB	08H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT ??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z
	DD	FLAT:?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7_Node_rep@std@@6B@
CONST	SEGMENT
??_7_Node_rep@std@@6B@ DD FLAT:??_R4_Node_rep@std@@6B@	; std::_Node_rep::`vftable'
	DD	FLAT:??_E_Node_rep@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Node_end_rep@std@@6B@
CONST	SEGMENT
??_7_Node_end_rep@std@@6B@ DD FLAT:??_R4_Node_end_rep@std@@6B@ ; std::_Node_end_rep::`vftable'
	DD	FLAT:??_E_Node_end_rep@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Node_if@std@@6B@
CONST	SEGMENT
??_7_Node_if@std@@6B@ DD FLAT:??_R4_Node_if@std@@6B@	; std::_Node_if::`vftable'
	DD	FLAT:??_E_Node_if@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Node_endif@std@@6B@
CONST	SEGMENT
??_7_Node_endif@std@@6B@ DD FLAT:??_R4_Node_endif@std@@6B@ ; std::_Node_endif::`vftable'
	DD	FLAT:??_E_Node_endif@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Node_back@std@@6B@
CONST	SEGMENT
??_7_Node_back@std@@6B@ DD FLAT:??_R4_Node_back@std@@6B@ ; std::_Node_back::`vftable'
	DD	FLAT:??_E_Node_back@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Node_capture@std@@6B@
CONST	SEGMENT
??_7_Node_capture@std@@6B@ DD FLAT:??_R4_Node_capture@std@@6B@ ; std::_Node_capture::`vftable'
	DD	FLAT:??_E_Node_capture@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Node_assert@std@@6B@
CONST	SEGMENT
??_7_Node_assert@std@@6B@ DD FLAT:??_R4_Node_assert@std@@6B@ ; std::_Node_assert::`vftable'
	DD	FLAT:??_E_Node_assert@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Node_end_group@std@@6B@
CONST	SEGMENT
??_7_Node_end_group@std@@6B@ DD FLAT:??_R4_Node_end_group@std@@6B@ ; std::_Node_end_group::`vftable'
	DD	FLAT:??_E_Node_end_group@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Root_node@std@@6B@
CONST	SEGMENT
??_7_Root_node@std@@6B@ DD FLAT:??_R4_Root_node@std@@6B@ ; std::_Root_node::`vftable'
	DD	FLAT:??_E_Root_node@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7_Node_base@std@@6B@
CONST	SEGMENT
??_7_Node_base@std@@6B@ DD FLAT:??_R4_Node_base@std@@6B@ ; std::_Node_base::`vftable'
	DD	FLAT:??_E_Node_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?_Is_word_table@?1??_Is_word@std@@YA_NE@Z@4QB_NB
CONST	SEGMENT
?_Is_word_table@?1??_Is_word@std@@YA_NE@Z@4QB_NB DB 00H	; `std::_Is_word'::`2'::_Is_word_table
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ??_7?$collate@_W@std@@6B@
CONST	SEGMENT
??_7?$collate@_W@std@@6B@ DD FLAT:??_R4?$collate@_W@std@@6B@ ; std::collate<wchar_t>::`vftable'
	DD	FLAT:??_E?$collate@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_compare@?$collate@_W@std@@MBEHPB_W000@Z
	DD	FLAT:?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z
	DD	FLAT:?do_hash@?$collate@_W@std@@MBEJPB_W0@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z$1
__ehfuncinfo$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z$1
__ehfuncinfo$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1
__ehfuncinfo$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z$96 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z$0
__unwindtable$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z$96
__ehfuncinfo$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z$68 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z$0
__unwindtable$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z$68
__ehfuncinfo$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z$96 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z$0
__unwindtable$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z$96
__ehfuncinfo$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z$1
__ehfuncinfo$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z$96 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z$0
__unwindtable$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z$96
__ehfuncinfo$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z$0
__ehfuncinfo$?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z$0
__ehfuncinfo$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z$84
	DD	01H
	DD	FLAT:__unwindfunclet$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z$1
__ehfuncinfo$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z$84
	DD	01H
	DD	FLAT:__unwindfunclet$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z$1
__ehfuncinfo$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tgt_state_t@PB_W@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??0?$_Tgt_state_t@PB_W@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tgt_state_t@PB_W@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Bt_state_t@PB_W@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??0?$_Bt_state_t@PB_W@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Bt_state_t@PB_W@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z$0
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z$1
	DD	03H
	DD	FLAT:__unwindfunclet$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z$0
__unwindtable$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z$4
__ehfuncinfo$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z$0
__ehfuncinfo$?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ$0
__unwindtable$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ$2
__ehfuncinfo$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z$0
__ehfuncinfo$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z$0
__ehfuncinfo$??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z$27 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z$0
__tryblocktable$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z$27
__ehfuncinfo$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z$0
__ehfuncinfo$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ$0
__ehfuncinfo$?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ$0
__ehfuncinfo$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z$0
__ehfuncinfo$?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z$0
__ehfuncinfo$??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z$2
__ehfuncinfo$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z$0
__ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z$44 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z$0
__unwindtable$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z$44
__ehfuncinfo$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$regex_traits@_W@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$regex_traits@_W@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$regex_traits@_W@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$regex_traits@_W@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$regex_traits@_W@std@@QAE@XZ$1
__ehfuncinfo$??0?$regex_traits@_W@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$regex_traits@_W@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Regex_traits@_W@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$_Regex_traits@_W@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Regex_traits@_W@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Regex_traits@_W@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Regex_traits@_W@std@@QAE@XZ$0
__ehfuncinfo$??0?$_Regex_traits@_W@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Regex_traits@_W@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z$0
__ehfuncinfo$?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	03H
	DD	FLAT:__unwindfunclet$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$0
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$18
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
__ehfuncinfo$?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$0
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$18
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z$1
__unwindtable$?SK_Inject_SwitchToRenderWrapper@@YA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_Inject_SwitchToRenderWrapper@@YA_NXZ$1
__ehfuncinfo$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_Inject_SwitchToRenderWrapper@@YA_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_Inject_SwitchToRenderWrapper@@YA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$2
	DD	04H
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$3
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$51
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$49
	DD	08H
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$54
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$4
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
	sub	ecx, DWORD PTR [ecx-4]
	jmp	??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_memmove@PB_WPA_W@std@@YAPA_WPB_W0PA_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PB_WPA_W@std@@YAPA_WPB_W0PA_W@Z PROC	; std::_Copy_memmove<wchar_t const *,wchar_t *>, COMDAT

; 2295 : 	{	// implement copy-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2302 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PB_WPA_W@std@@YAPA_WPB_W0PA_W@Z ENDP	; std::_Copy_memmove<wchar_t const *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@$$CB_W_WV?$allocator@_W@std@@@std@@YAPA_WPB_W0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked@$$CB_W_WV?$allocator@_W@std@@@std@@YAPA_WPB_W0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<wchar_t const ,wchar_t,std::allocator<wchar_t> >, COMDAT

; 108  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 110  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@$$CB_W_WV?$allocator@_W@std@@@std@@YAPA_WPB_W0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<wchar_t const ,wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CB_W_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQB_WABQA_W@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@$$CB_W_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQB_WABQA_W@Z PROC ; std::_Ptr_copy_cat<wchar_t const ,wchar_t>, COMDAT

; 875  : 	{	// return pointer copy optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 876  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 877  : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@$$CB_W_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQB_WABQA_W@Z ENDP ; std::_Ptr_copy_cat<wchar_t const ,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PB_WPA_WV?$allocator@_W@std@@@std@@YAPA_WPB_W0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PB_WPA_WV?$allocator@_W@std@@@std@@YAPA_WPB_W0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z PROC ; std::_Uninitialized_copy<wchar_t const *,wchar_t *,std::allocator<wchar_t> >, COMDAT

; 117  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 127  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PB_WPA_WV?$allocator@_W@std@@@std@@YAPA_WPB_W0PA_WAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ENDP ; std::_Uninitialized_copy<wchar_t const *,wchar_t *,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Ucopy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEPA_WPB_W0PA_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEPA_WPB_W0PA_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Ucopy<wchar_t const *>, COMDAT
; _this$ = ecx

; 1858 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1860 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEPA_WPB_W0PA_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Ucopy<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPB_W0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPB_W0Uforward_iterator_tag@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t const *>, COMDAT
; _this$ = ecx

; 775  : 		{	// initialize with [_First, _Last), avoid leaking, forward iterators

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	ebx, DWORD PTR __Last$[ebp]
	sub	ebx, DWORD PTR __First$[ebp]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 775  : 		{	// initialize with [_First, _Last), avoid leaking, forward iterators

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	esi, ebx
	sar	esi, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1909 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [edi], 0

; 1910 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [edi+4], 0

; 1911 : 		this->_Myend() = pointer();

	mov	DWORD PTR [edi+8], 0

; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	je	SHORT $LN5@Range_cons

; 1914 : 			{
; 1915 : 			return (false);
; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	esi, 2147483647				; 7fffffffH
	ja	SHORT $LN160@Range_cons
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	esi
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [edi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [edi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ebx
	push	DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	lea	eax, DWORD PTR [eax+esi*2]
	mov	DWORD PTR [edi+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	esi, DWORD PTR [edi]

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	call	DWORD PTR __imp__memmove

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [ebx+esi]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 779  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

	mov	DWORD PTR [edi+4], eax
$LN5@Range_cons:
	pop	edi
	pop	esi
	pop	ebx

; 780  : 			_CATCH_ALL
; 781  : 			_Tidy();
; 782  : 			_RERAISE;
; 783  : 			_CATCH_END
; 784  : 			}
; 785  : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN160@Range_cons:

; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN162@Range_cons:
$LN159@Range_cons:
	int	3
??$_Range_construct_or_tidy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPB_W0Uforward_iterator_tag@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z PROC	; std::_Copy_memmove<wchar_t *,wchar_t *>, COMDAT

; 2295 : 	{	// implement copy-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2302 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ENDP	; std::_Copy_memmove<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Equal_unchecked1@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Pred$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Equal_unchecked1@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Equal_unchecked1<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >, COMDAT

; 2841 : 	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 2842 : 	for (; _First1 != _Last1; ++_First1, (void)++_First2)

	mov	esi, DWORD PTR __First1$[ebp]
	push	edi
	cmp	esi, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Equal_unch
	mov	eax, DWORD PTR __First2$[ebp]
	sub	eax, esi
	mov	DWORD PTR __First2$[ebp], eax
	npad	8
$LL4@Equal_unch:

; 2843 : 		if (!_Pred(*_First1, *_First2))

	movzx	ebx, WORD PTR [eax+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR __Pred$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2843 : 		if (!_Pred(*_First1, *_First2))

	movzx	ecx, WORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	ecx

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [eax]

; 301  : 		return (_Getctype()->tolower(_Ch));

	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z
	movzx	edi, ax

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR __Pred$[ebp]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	ebx

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [eax]

; 301  : 		return (_Getctype()->tolower(_Ch));

	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 207  : 		return (_Traits.translate_nocase(_E1)

	cmp	di, ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2843 : 		if (!_Pred(*_First1, *_First2))

	jne	SHORT $LN18@Equal_unch

; 2842 : 	for (; _First1 != _Last1; ++_First1, (void)++_First2)

	mov	eax, DWORD PTR __First2$[ebp]
	add	esi, 2
	cmp	esi, DWORD PTR __Last1$[ebp]
	jne	SHORT $LL4@Equal_unch
$LN3@Equal_unch:
	pop	edi
	pop	esi

; 2845 : 	return (true);

	mov	al, 1
	pop	ebx

; 2846 : 	}

	pop	ebp
	ret	0
$LN18@Equal_unch:
	pop	edi
	pop	esi

; 2844 : 			return (false);

	xor	al, al
	pop	ebx

; 2846 : 	}

	pop	ebp
	ret	0
??$_Equal_unchecked1@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Equal_unchecked1<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Equal_memcmp_is_safe@$$CB_W$$CB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQB_W0ABU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Equal_memcmp_is_safe@$$CB_W$$CB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQB_W0ABU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z PROC ; std::_Equal_memcmp_is_safe<wchar_t const ,wchar_t const ,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >, COMDAT

; 2833 : 	return {};

	xor	al, al

; 2834 : 	}

	ret	0
??$_Equal_memcmp_is_safe@$$CB_W$$CB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQB_W0ABU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z ENDP ; std::_Equal_memcmp_is_safe<wchar_t const ,wchar_t const ,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0PA_WX@?$vector@_WV?$allocator@_W@std@@@std@@QAE@PA_W0ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$?0PA_WX@?$vector@_WV?$allocator@_W@std@@@std@@QAE@PA_W0ABV?$allocator@_W@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><wchar_t *,void>, COMDAT
; _this$ = ecx

; 792  : 		{	// construct from [_First, _Last) with optional allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	mov	esi, ecx
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [esi], 0

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	push	DWORD PTR __First$[ebp]

; 477  : 		_Mylast(),

	mov	DWORD PTR [esi+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [esi+8], 0

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	call	??$_Range_construct_or_tidy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t *>

; 795  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$?0PA_WX@?$vector@_WV?$allocator@_W@std@@@std@@QAE@PA_W0ABV?$allocator@_W@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><wchar_t *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0PB_WX@?$vector@_WV?$allocator@_W@std@@@std@@QAE@PB_W0ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$?0PB_WX@?$vector@_WV?$allocator@_W@std@@@std@@QAE@PB_W0ABV?$allocator@_W@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><wchar_t const *,void>, COMDAT
; _this$ = ecx

; 792  : 		{	// construct from [_First, _Last) with optional allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	mov	esi, ecx
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [esi], 0

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	push	DWORD PTR __First$[ebp]

; 477  : 		_Mylast(),

	mov	DWORD PTR [esi+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [esi+8], 0

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	call	??$_Range_construct_or_tidy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPB_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t const *>

; 795  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$?0PB_WX@?$vector@_WV?$allocator@_W@std@@@std@@QAE@PB_W0ABV?$allocator@_W@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><wchar_t const *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Insert@PB_W@?$_Buf@_W@std@@QAEXPB_W0@Z
_TEXT	SEGMENT
__Len$1$ = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insert@PB_W@?$_Buf@_W@std@@QAEXPB_W0@Z PROC		; std::_Buf<wchar_t>::_Insert<wchar_t const *>, COMDAT
; _this$ = ecx

; 1609 : 		{	// append multiple characters

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1610 : 		while (_First != _Last)

	mov	edi, DWORD PTR __First$[ebp]
	mov	esi, ecx
	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN18@Insert
	push	ebx
$LL2@Insert:

; 1597 : 		if (_Sz <= _Nchrs)

	mov	eax, DWORD PTR [esi+4]

; 1611 : 			_Insert(*_First++);

	movzx	ebx, WORD PTR [edi]

; 1597 : 		if (_Sz <= _Nchrs)

	cmp	DWORD PTR [esi], eax
	ja	SHORT $LN10@Insert

; 1598 : 			_Expand(_Nchrs + _Buf_incr);

	add	eax, 16					; 00000010H
	mov	DWORD PTR __Len$1$[ebp], eax

; 1617 : 		_Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));

	add	eax, eax
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 1618 : 		if (!_Tmp)

	test	eax, eax
	je	SHORT $LN14@Insert

; 1620 : 		_Chrs = _Tmp;

	mov	DWORD PTR [esi+8], eax

; 1621 : 		_Sz = _Len;

	mov	eax, DWORD PTR __Len$1$[ebp]
	mov	DWORD PTR [esi], eax
$LN10@Insert:

; 1599 : 		_Chrs[_Nchrs++] = _Ch;

	mov	ecx, DWORD PTR [esi+4]

; 1611 : 			_Insert(*_First++);

	add	edi, 2

; 1599 : 		_Chrs[_Nchrs++] = _Ch;

	mov	eax, DWORD PTR [esi+8]
	mov	WORD PTR [eax+ecx*2], bx
	inc	DWORD PTR [esi+4]

; 1610 : 		while (_First != _Last)

	cmp	edi, DWORD PTR __Last$[ebp]
	jne	SHORT $LL2@Insert
	pop	ebx
$LN18@Insert:
	pop	edi
	pop	esi

; 1612 : 		}

	pop	ebp
	ret	8
$LN14@Insert:

; 1619 : 			_Xbad_alloc();

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN22@Insert:
$LN21@Insert:
	int	3
??$_Insert@PB_W@?$_Buf@_W@std@@QAEXPB_W0@Z ENDP		; std::_Buf<wchar_t>::_Insert<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z PROC	; std::_Rechecked<wchar_t *,wchar_t *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PA_WPA_W@std@@YAAAPA_WAAPA_WPA_W@Z ENDP	; std::_Rechecked<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@_W_WV?$allocator@_W@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked@_W_WV?$allocator@_W@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<wchar_t,wchar_t,std::allocator<wchar_t> >, COMDAT

; 108  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 110  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@_W_WV?$allocator@_W@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<wchar_t,wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_copy_cat@_W_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_W0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@_W_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_W0@Z PROC ; std::_Ptr_copy_cat<wchar_t,wchar_t>, COMDAT

; 875  : 	{	// return pointer copy optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 876  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 877  : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@_W_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_W0@Z ENDP ; std::_Ptr_copy_cat<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Equal_unchecked@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Equal_unchecked@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z PROC ; std::_Equal_unchecked<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >, COMDAT

; 2865 : 	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred, choose optimization

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2833 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2866 : 	return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Pred$[ebp]
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __Last1$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	??$_Equal_unchecked1@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Equal_unchecked1<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
	add	esp, 20					; 00000014H

; 2867 : 		_Equal_memcmp_is_safe(_First1, _First2, _Pred)));
; 2868 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Equal_unchecked@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z ENDP ; std::_Equal_unchecked<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z
_TEXT	SEGMENT
$T2 = -56						; size = 24
__Temp$3 = -32						; size = 12
$T4 = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T5 = 12						; size = 1
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z PROC ; std::_Regex_traits<wchar_t>::transform_primary<wchar_t *>, COMDAT
; _this$ = ecx

; 312  : 		{	// apply locale-specific case-insensitive transformation

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 312  : 		{	// apply locale-specific case-insensitive transformation

	mov	DWORD PTR _this$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 324  : 		return (_Res);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T4[ebp], 1
	cmp	eax, ecx
	je	$LN347@transform_
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T5[ebp], 0
	push	DWORD PTR $T5[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR __Temp$3[ebp], 0

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	push	ecx
	push	eax
	lea	ecx, DWORD PTR __Temp$3[ebp]

; 477  : 		_Mylast(),

	mov	DWORD PTR __Temp$3[ebp+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR __Temp$3[ebp+8], 0

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	call	??$_Range_construct_or_tidy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t *>

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ebx, DWORD PTR __Temp$3[ebp]
	mov	eax, DWORD PTR __Temp$3[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 319  : 			_Getctype()->tolower(&*_Temp.begin(),

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, ebx
	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 317  : 			vector<_Elem> _Temp(_First, _Last);

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 319  : 			_Getctype()->tolower(&*_Temp.begin(),

	mov	ecx, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ebx+eax*2]
	push	esi
	push	ebx
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBEPB_WPA_WPB_W@Z

; 320  : 				&*_Temp.begin() + _Temp.size());
; 321  : 			_Res = _Getcoll()->transform(&*_Temp.begin(),

	push	esi
	push	ebx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform
	push	eax
	mov	ecx, edi
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN223@transform_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN223@transform_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	ebx, ebx
	je	SHORT $LN346@transform_

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR __Temp$3[ebp+8]
	sub	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	ebx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN346@transform_:
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 324  : 		return (_Res);

	mov	eax, edi
	pop	edi

; 325  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN347@transform_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 1
	je	$LN5@transform_
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN5@transform_:
	ret	0
__unwindfunclet$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z$1:
	lea	ecx, DWORD PTR __Temp$3[ebp]
	jmp	??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
__ehhandler$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z ENDP ; std::_Regex_traits<wchar_t>::transform_primary<wchar_t *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z
_TEXT	SEGMENT
$T2 = -56						; size = 24
__Temp$3 = -32						; size = 12
$T4 = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T5 = 12						; size = 1
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z PROC ; std::_Regex_traits<wchar_t>::transform_primary<wchar_t const *>, COMDAT
; _this$ = ecx

; 312  : 		{	// apply locale-specific case-insensitive transformation

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 312  : 		{	// apply locale-specific case-insensitive transformation

	mov	DWORD PTR _this$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 324  : 		return (_Res);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T4[ebp], 1
	cmp	eax, ecx
	je	$LN347@transform_
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T5[ebp], 0
	push	DWORD PTR $T5[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR __Temp$3[ebp], 0

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	push	ecx
	push	eax
	lea	ecx, DWORD PTR __Temp$3[ebp]

; 477  : 		_Mylast(),

	mov	DWORD PTR __Temp$3[ebp+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR __Temp$3[ebp+8], 0

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	call	??$_Range_construct_or_tidy@PB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPB_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t const *>

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ebx, DWORD PTR __Temp$3[ebp]
	mov	eax, DWORD PTR __Temp$3[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 319  : 			_Getctype()->tolower(&*_Temp.begin(),

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, ebx
	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 317  : 			vector<_Elem> _Temp(_First, _Last);

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 319  : 			_Getctype()->tolower(&*_Temp.begin(),

	mov	ecx, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ebx+eax*2]
	push	esi
	push	ebx
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBEPB_WPA_WPB_W@Z

; 320  : 				&*_Temp.begin() + _Temp.size());
; 321  : 			_Res = _Getcoll()->transform(&*_Temp.begin(),

	push	esi
	push	ebx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform
	push	eax
	mov	ecx, edi
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN223@transform_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN223@transform_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	ebx, ebx
	je	SHORT $LN346@transform_

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR __Temp$3[ebp+8]
	sub	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	ebx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN346@transform_:
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 324  : 		return (_Res);

	mov	eax, edi
	pop	edi

; 325  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN347@transform_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 1
	je	$LN5@transform_
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN5@transform_:
	ret	0
__unwindfunclet$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z$1:
	lea	ecx, DWORD PTR __Temp$3[ebp]
	jmp	??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
__ehhandler$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z ENDP ; std::_Regex_traits<wchar_t>::transform_primary<wchar_t const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Advance1@PAIH@std@@YAXAAPAIHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance1@PAIH@std@@YAXAAPAIHUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance1<unsigned int *,int>, COMDAT

; 1078 : 	{	// increment iterator by offset, random-access iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Where$[ebp]
	add	DWORD PTR [eax], ecx

; 1080 : 	}

	pop	ebp
	ret	0
??$_Advance1@PAIH@std@@YAXAAPAIHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance1<unsigned int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$sub_match@PB_W@std@@V12@@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@1@$$QAV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$sub_match@PB_W@std@@V12@@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@1@$$QAV21@@Z PROC ; std::allocator<std::sub_match<wchar_t const *> >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@V?$sub_match@PB_W@std@@V12@@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@1@$$QAV21@@Z ENDP ; std::allocator<std::sub_match<wchar_t const *> >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Advance1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@H@std@@YAXAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@H@std@@YAXAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,int>, COMDAT

; 1078 : 	{	// increment iterator by offset, random-access iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[ebp]
	add	DWORD PTR [eax], ecx

; 1080 : 	}

	pop	ebp
	ret	0
??$_Advance1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@H@std@@YAXAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PA_WPA_WV?$allocator@_W@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PA_WPA_WV?$allocator@_W@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z PROC ; std::_Uninitialized_copy<wchar_t *,wchar_t *,std::allocator<wchar_t> >, COMDAT

; 117  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 127  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PA_WPA_WV?$allocator@_W@std@@@std@@YAPA_WPA_W00AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ENDP ; std::_Uninitialized_copy<wchar_t *,wchar_t *,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@PA_W@std@@YAHPA_W0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@PA_W@std@@YAHPA_W0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<wchar_t *>, COMDAT

; 1105 : 	{	// return distance between iterators; random-access

	npad	2
	push	ebp
	mov	ebp, esp

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 1

; 1107 : 	}

	pop	ebp
	ret	0
??$_Distance1@PA_W@std@@YAHPA_W0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Equal_unchecked@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W000AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
$T1 = 12						; size = 1
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Pred$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Equal_unchecked@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W000AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Equal_unchecked<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >, COMDAT

; 2950 : 	{	// compare [_First1, _Last1) to [_First2, _Last2)

	npad	2
	push	ebp
	mov	ebp, esp

; 2951 : 		// using _Pred, random-access iterators
; 2952 : 	if (_Last1 - _First1 != _Last2 - _First2)

	mov	edx, DWORD PTR __Last1$[ebp]
	mov	ecx, edx
	mov	eax, DWORD PTR __Last2$[ebp]
	sub	ecx, DWORD PTR __First1$[ebp]
	sub	eax, DWORD PTR __First2$[ebp]
	xor	ecx, eax
	test	ecx, -2					; fffffffeH
	je	SHORT $LN2@Equal_unch

; 2953 : 		return (false);

	xor	al, al

; 2954 : 	return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
; 2955 : 	}

	pop	ebp
	ret	0
$LN2@Equal_unch:

; 2833 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2866 : 	return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Pred$[ebp]
	push	DWORD PTR __First2$[ebp]
	push	edx
	push	DWORD PTR __First1$[ebp]
	call	??$_Equal_unchecked1@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Equal_unchecked1<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
	add	esp, 20					; 00000014H

; 2954 : 	return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
; 2955 : 	}

	pop	ebp
	ret	0
??$_Equal_unchecked@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W000AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Equal_unchecked<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAPAV_Node_base@std@@@std@@YA$$QAPAV_Node_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAV_Node_base@std@@@std@@YA$$QAPAV_Node_base@0@AAPAV10@@Z PROC ; std::move<std::_Node_base * &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAPAV_Node_base@std@@@std@@YA$$QAPAV_Node_base@0@AAPAV10@@Z ENDP ; std::move<std::_Node_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Const_cast@$$CB_W@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CB_W@std@@YAPA_WPB_W@Z PROC		; std::_Const_cast<wchar_t const >, COMDAT

; 314  : 	{	// remove constness from a plain pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 315  : 	return (const_cast<remove_const_t<_Ty> *>(_Ptr));

	mov	eax, DWORD PTR __Ptr$[ebp]

; 316  : 	}

	pop	ebp
	ret	0
??$_Const_cast@$$CB_W@std@@YAPA_WPB_W@Z ENDP		; std::_Const_cast<wchar_t const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT

; 108  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 110  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<unsigned int *,unsigned int *>, COMDAT

; 2318 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable

	npad	2
	push	ebp
	mov	ebp, esp

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2319 : 	return (_Copy_memmove(_First, _Last, _Dest));
; 2320 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$advance@PAIH@std@@YAXAAPAIH@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAIH@std@@YAXAAPAIH@Z PROC			; std::advance<unsigned int *,int>, COMDAT

; 1085 : 	{	// increment iterator by offset, arbitrary iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Where$[ebp]
	add	DWORD PTR [eax], ecx

; 1086 : 		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
; 1087 : 	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
; 1088 : 	}

	pop	ebp
	ret	0
??$advance@PAIH@std@@YAXAAPAIH@Z ENDP			; std::advance<unsigned int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@PAI@std@@YAHPAI0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@PAI@std@@YAHPAI0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<unsigned int *>, COMDAT

; 1105 : 	{	// return distance between iterators; random-access

	npad	2
	push	ebp
	mov	ebp, esp

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2

; 1107 : 	}

	pop	ebp
	ret	0
??$_Distance1@PAI@std@@YAHPAI0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$sub_match@PB_W@std@@V12@@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAXAAV?$allocator@V?$sub_match@PB_W@std@@@1@PAV?$sub_match@PB_W@1@$$QAV31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$sub_match@PB_W@std@@V12@@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAXAAV?$allocator@V?$sub_match@PB_W@std@@@1@PAV?$sub_match@PB_W@1@$$QAV31@@Z PROC ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@V?$sub_match@PB_W@std@@V12@@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAXAAV?$allocator@V?$sub_match@PB_W@std@@@1@PAV?$sub_match@PB_W@1@$$QAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$sub_match@PB_W@std@@@std@@YA$$QAV?$sub_match@PB_W@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$sub_match@PB_W@std@@@std@@YA$$QAV?$sub_match@PB_W@0@AAV10@@Z PROC ; std::forward<std::sub_match<wchar_t const *> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$sub_match@PB_W@std@@@std@@YA$$QAV?$sub_match@PB_W@0@AAV10@@Z ENDP ; std::forward<std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_unchecked1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 2318 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable

	npad	2
	push	ebp
	mov	ebp, esp

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2319 : 	return (_Copy_memmove(_First, _Last, _Dest));
; 2320 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_copy_cat@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z PROC ; std::_Ptr_copy_cat<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t>, COMDAT

; 875  : 	{	// return pointer copy optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 876  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 877  : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z ENDP ; std::_Ptr_copy_cat<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$advance@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@H@std@@YAXAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@H@std@@YAXAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@H@Z PROC ; std::advance<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,int>, COMDAT

; 1085 : 	{	// increment iterator by offset, arbitrary iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[ebp]
	add	DWORD PTR [eax], ecx

; 1086 : 		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
; 1087 : 	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
; 1088 : 	}

	pop	ebp
	ret	0
??$advance@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@H@std@@YAXAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@H@Z ENDP ; std::advance<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAHPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAHPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 1105 : 	{	// return distance between iterators; random-access

	npad	2
	push	ebp
	mov	ebp, esp

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3

; 1107 : 	}

	pop	ebp
	ret	0
??$_Distance1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAHPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$sub_match@PB_W@std@@$$V@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$sub_match@PB_W@std@@$$V@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@1@@Z PROC ; std::allocator<std::sub_match<wchar_t const *> >::construct<std::sub_match<wchar_t const *> >, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 103  : 		: first(), second()

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 660  : 		: _Mybase(), matched(false)

	mov	BYTE PTR [eax+8], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 841  : 		}

	pop	ebp
	ret	4
??$construct@V?$sub_match@PB_W@std@@$$V@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@1@@Z ENDP ; std::allocator<std::sub_match<wchar_t const *> >::construct<std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z PROC ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	4
??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z ENDP ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Ucopy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEPA_WPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEPA_WPA_W00@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Ucopy<wchar_t *>, COMDAT
; _this$ = ecx

; 1858 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1860 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEPA_WPA_W00@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Ucopy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@PA_W@std@@YAHPA_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PA_W@std@@YAHPA_W0@Z PROC			; std::distance<wchar_t *>, COMDAT

; 1112 : 	{	// return distance between iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 1

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
; 1114 : 	}

	pop	ebp
	ret	0
??$distance@PA_W@std@@YAHPA_W0@Z ENDP			; std::distance<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$equal@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W000U?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
$T1 = 12						; size = 1
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$equal@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W000U?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z PROC ; std::equal<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >, COMDAT

; 2962 : 	{	// compare [_First1, _Last1) to [_First2, _Last2) using _Pred

	npad	2
	push	ebp
	mov	ebp, esp

; 2952 : 	if (_Last1 - _First1 != _Last2 - _First2)

	mov	edx, DWORD PTR __Last1$[ebp]
	mov	ecx, edx
	mov	eax, DWORD PTR __Last2$[ebp]
	sub	ecx, DWORD PTR __First1$[ebp]
	sub	eax, DWORD PTR __First2$[ebp]
	xor	ecx, eax
	test	ecx, -2					; fffffffeH
	je	SHORT $LN12@equal

; 2953 : 		return (false);

	xor	al, al

; 2963 : 	_DEBUG_RANGE(_First1, _Last1);
; 2964 : 	_DEBUG_RANGE(_First2, _Last2);
; 2965 : 	return (_Equal_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
; 2966 : 		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
; 2967 : 			_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
; 2968 : 	}

	pop	ebp
	ret	0
$LN12@equal:

; 2833 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2866 : 	return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,

	lea	eax, DWORD PTR __Pred$[ebp]
	push	DWORD PTR $T1[ebp]
	push	eax
	push	DWORD PTR __First2$[ebp]
	push	edx
	push	DWORD PTR __First1$[ebp]
	call	??$_Equal_unchecked1@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Equal_unchecked1<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
	add	esp, 20					; 00000014H

; 2963 : 	_DEBUG_RANGE(_First1, _Last1);
; 2964 : 	_DEBUG_RANGE(_First2, _Last2);
; 2965 : 	return (_Equal_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
; 2966 : 		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
; 2967 : 			_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
; 2968 : 	}

	pop	ebp
	ret	0
??$equal@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W000U?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@@Z ENDP ; std::equal<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??R?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@QAE_N_W0@Z
_TEXT	SEGMENT
__E1$ = 8						; size = 2
__E2$ = 12						; size = 2
??R?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@QAE_N_W0@Z PROC ; std::_Cmp_icase<std::_Regex_traits<wchar_t> >::operator(), COMDAT
; _this$ = ecx

; 206  : 		{	// return true if equal

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	DWORD PTR __E1$[ebp]

; 206  : 		{	// return true if equal

	mov	edi, ecx

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [edi]

; 301  : 		return (_Getctype()->tolower(_Ch));

	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z
	push	DWORD PTR __E2$[ebp]
	movzx	esi, ax

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [edi]

; 301  : 		return (_Getctype()->tolower(_Ch));

	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 207  : 		return (_Traits.translate_nocase(_E1)

	xor	ecx, ecx
	cmp	si, ax
	pop	edi
	sete	al
	pop	esi

; 208  : 			== _Traits.translate_nocase(_E2));
; 209  : 		}

	pop	ebp
	ret	8
??R?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@QAE_N_W0@Z ENDP ; std::_Cmp_icase<std::_Regex_traits<wchar_t> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@QAE@ABV?$_Regex_traits@_W@1@@Z
_TEXT	SEGMENT
__Tr$ = 8						; size = 4
??0?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@QAE@ABV?$_Regex_traits@_W@1@@Z PROC ; std::_Cmp_icase<std::_Regex_traits<wchar_t> >::_Cmp_icase<std::_Regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 202  : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp

; 201  : 		: _Traits(_Tr)

	mov	eax, DWORD PTR __Tr$[ebp]
	mov	DWORD PTR [ecx], eax

; 203  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@QAE@ABV?$_Regex_traits@_W@1@@Z ENDP ; std::_Cmp_icase<std::_Regex_traits<wchar_t> >::_Cmp_icase<std::_Regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Mark@G@_Bitmap@std@@QAEXG@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
??$_Mark@G@_Bitmap@std@@QAEXG@Z PROC			; std::_Bitmap::_Mark<unsigned short>, COMDAT
; _this$ = ecx

; 1639 : 		{	// mark character _Ch

	npad	2
	push	ebp
	mov	ebp, esp

; 1640 : 		static_assert(is_unsigned<_Elem>::value, "_Elem must be unsigned");
; 1641 : 		unsigned int _Wide = _Ch;

	movzx	edx, WORD PTR __Ch$[ebp]

; 1642 : 		_Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

	mov	eax, edx
	and	edx, 7
	shr	eax, 3
	add	ecx, eax
	movzx	eax, BYTE PTR [ecx]
	bts	eax, edx
	mov	BYTE PTR [ecx], al

; 1643 : 		}

	pop	ebp
	ret	4
??$_Mark@G@_Bitmap@std@@QAEXG@Z ENDP			; std::_Bitmap::_Mark<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Mark@I@_Bitmap@std@@QAEXI@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
??$_Mark@I@_Bitmap@std@@QAEXI@Z PROC			; std::_Bitmap::_Mark<unsigned int>, COMDAT
; _this$ = ecx

; 1639 : 		{	// mark character _Ch

	npad	2
	push	ebp
	mov	ebp, esp

; 1640 : 		static_assert(is_unsigned<_Elem>::value, "_Elem must be unsigned");
; 1641 : 		unsigned int _Wide = _Ch;
; 1642 : 		_Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

	mov	edx, DWORD PTR __Ch$[ebp]
	mov	eax, edx
	shr	eax, 3
	and	edx, 7
	add	ecx, eax
	movzx	eax, BYTE PTR [ecx]
	bts	eax, edx
	mov	BYTE PTR [ecx], al

; 1643 : 		}

	pop	ebp
	ret	4
??$_Mark@I@_Bitmap@std@@QAEXI@Z ENDP			; std::_Bitmap::_Mark<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<unsigned int> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<unsigned int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@_W@std@@PA_W@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@_W@std@@PA_W@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<wchar_t>,wchar_t *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@_W@std@@PA_W@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<wchar_t>,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@YA$$QAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@YA$$QAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@YA$$QAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT

; 117  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 127  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1><std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1><std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@IIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked@IIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 108  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 110  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@IIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_copy_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z PROC ; std::_Ptr_copy_cat<unsigned int,unsigned int>, COMDAT

; 875  : 	{	// return pointer copy optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 876  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 877  : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z ENDP ; std::_Ptr_copy_cat<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_unchecked@PAIPAI@std@@YAPAIPAI00@Z PROC	; std::_Copy_unchecked<unsigned int *,unsigned int *>, COMDAT

; 2326 : 	{	// copy [_First, _Last) to [_Dest, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2327 : 		// note: _Copy_unchecked is called directly from elsewhere in the STL
; 2328 : 	return (_Copy_unchecked1(_First, _Last,
; 2329 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2330 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked@PAIPAI@std@@YAPAIPAI00@Z ENDP	; std::_Copy_unchecked<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$next@PAI@std@@YAPAIPAIH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Off$ = 12						; size = 4
??$next@PAI@std@@YAPAIPAIH@Z PROC			; std::next<unsigned int *>, COMDAT

; 1119 : 	{	// increment iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 1120 : 	static_assert(is_base_of<input_iterator_tag, _Iter_cat_t<_InIt>>::value,
; 1121 : 		"next requires input iterator");
; 1122 : 
; 1123 : 	_STD advance(_First, _Off);
; 1124 : 	return (_First);
; 1125 : 	}

	pop	ebp
	ret	0
??$next@PAI@std@@YAPAIPAIH@Z ENDP			; std::next<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@PAI@std@@YAHPAI0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PAI@std@@YAHPAI0@Z PROC			; std::distance<unsigned int *>, COMDAT

; 1112 : 	{	// return distance between iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
; 1114 : 	}

	pop	ebp
	ret	0
??$distance@PAI@std@@YAHPAI0@Z ENDP			; std::distance<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$sub_match@PB_W@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@1@$$QAV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$sub_match@PB_W@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@1@$$QAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@V?$sub_match@PB_W@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@1@$$QAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_memmove@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00@Z PROC ; std::_Copy_memmove<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 2295 : 	{	// implement copy-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2302 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00@Z ENDP ; std::_Copy_memmove<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_unchecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00@Z PROC ; std::_Copy_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 2326 : 	{	// copy [_First, _Last) to [_Dest, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2327 : 		// note: _Copy_unchecked is called directly from elsewhere in the STL
; 2328 : 	return (_Copy_unchecked1(_First, _Last,
; 2329 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2330 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00@Z ENDP ; std::_Copy_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$next@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@H@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Off$ = 12						; size = 4
??$next@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@H@Z PROC ; std::next<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 1119 : 	{	// increment iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]

; 1120 : 	static_assert(is_base_of<input_iterator_tag, _Iter_cat_t<_InIt>>::value,
; 1121 : 		"next requires input iterator");
; 1122 : 
; 1123 : 	_STD advance(_First, _Off);
; 1124 : 	return (_First);
; 1125 : 	}

	pop	ebp
	ret	0
??$next@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@H@Z ENDP ; std::next<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAHPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAHPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z PROC ; std::distance<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 1112 : 	{	// return distance between iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
; 1114 : 	}

	pop	ebp
	ret	0
??$distance@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAHPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z ENDP ; std::distance<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$sub_match@PB_W@std@@$$V@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAXAAV?$allocator@V?$sub_match@PB_W@std@@@1@PAV?$sub_match@PB_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@V?$sub_match@PB_W@std@@$$V@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAXAAV?$allocator@V?$sub_match@PB_W@std@@@1@PAV?$sub_match@PB_W@1@@Z PROC ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *> >, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN5@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 103  : 		: first(), second()

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 660  : 		: _Mybase(), matched(false)

	mov	BYTE PTR [eax+8], 0
$LN5@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 960  : 		}

	pop	ebp
	ret	0
??$construct@V?$sub_match@PB_W@std@@$$V@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAXAAV?$allocator@V?$sub_match@PB_W@std@@@1@PAV?$sub_match@PB_W@1@@Z ENDP ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2308 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Dest$[ebp+4]
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
$LL20@Copy_unche:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2304 : 		return (this->_Myptr == _Right._Myptr

	cmp	edi, DWORD PTR __Last$[ebp]
	jne	SHORT $LN26@Copy_unche
	cmp	ecx, DWORD PTR __Last$[ebp+4]
	je	SHORT $LN77@Copy_unche
$LN26@Copy_unche:

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	eax, 1
	shl	eax, cl

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	eax, DWORD PTR [edi]

; 2144 : 			*(_Vbase *)_Getptr() |= _Mask();

	mov	eax, DWORD PTR [esi]
	je	SHORT $LN61@Copy_unche
	bts	eax, edx

; 2145 : 		else

	jmp	SHORT $LN80@Copy_unche
$LN61@Copy_unche:

; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	btr	eax, edx
$LN80@Copy_unche:
	mov	DWORD PTR [esi], eax

; 2381 : 		if (this->_Myoff < _VBITS - 1)

	mov	edx, DWORD PTR __Dest$[ebp+4]

; 2383 : 		else

	mov	esi, DWORD PTR __Dest$[ebp]
	cmp	edx, 31					; 0000001fH
	jae	SHORT $LN11@Copy_unche

; 2382 : 			++this->_Myoff;

	inc	edx

; 2383 : 		else

	jmp	SHORT $LN81@Copy_unche
$LN11@Copy_unche:

; 2384 : 			{	// move to next word
; 2385 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2386 : 			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
; 2387 : 				{	// report error
; 2388 : 				_DEBUG_ERROR("vector<bool> iterator not incrementable");
; 2389 : 				}
; 2390 : 
; 2391 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 2392 : 			_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 2393 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Valid(1) <= 0);
; 2394 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 2395 : 
; 2396 : 			this->_Myoff = 0;

	xor	edx, edx

; 2397 : 			++this->_Myptr;

	add	esi, 4
	mov	DWORD PTR __Dest$[ebp], esi
$LN81@Copy_unche:

; 2381 : 		if (this->_Myoff < _VBITS - 1)

	mov	ecx, DWORD PTR __First$[ebp+4]

; 2383 : 		else

	mov	edi, DWORD PTR __First$[ebp]

; 2396 : 			this->_Myoff = 0;

	mov	DWORD PTR __Dest$[ebp+4], edx

; 2381 : 		if (this->_Myoff < _VBITS - 1)

	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN19@Copy_unche

; 2382 : 			++this->_Myoff;

	inc	ecx
	mov	DWORD PTR __First$[ebp+4], ecx

; 2383 : 		else

	jmp	SHORT $LL20@Copy_unche
$LN19@Copy_unche:

; 2384 : 			{	// move to next word
; 2385 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2386 : 			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
; 2387 : 				{	// report error
; 2388 : 				_DEBUG_ERROR("vector<bool> iterator not incrementable");
; 2389 : 				}
; 2390 : 
; 2391 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 2392 : 			_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 2393 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Valid(1) <= 0);
; 2394 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 2395 : 
; 2396 : 			this->_Myoff = 0;

	xor	ecx, ecx

; 2397 : 			++this->_Myptr;

	add	edi, 4
	mov	DWORD PTR __First$[ebp+4], ecx
	mov	DWORD PTR __First$[ebp], edi
	jmp	SHORT $LL20@Copy_unche
$LN77@Copy_unche:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2311 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2312 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SAXAAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@1@PAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SAXAAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@1@PAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN5@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
$LN5@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SAXAAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@1@PAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z PROC	; std::allocator<unsigned int>::construct<unsigned int,unsigned int const &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@IABI@?$allocator@I@std@@QAEXPAIABI@Z ENDP	; std::allocator<unsigned int>::construct<unsigned int,unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Loop_vals_t@std@@$$V@?$allocator@U_Loop_vals_t@std@@@std@@QAEXPAU_Loop_vals_t@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@U_Loop_vals_t@std@@$$V@?$allocator@U_Loop_vals_t@std@@@std@@QAEXPAU_Loop_vals_t@1@@Z PROC ; std::allocator<std::_Loop_vals_t>::construct<std::_Loop_vals_t>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	4
??$construct@U_Loop_vals_t@std@@$$V@?$allocator@U_Loop_vals_t@std@@@std@@QAEXPAU_Loop_vals_t@1@@Z ENDP ; std::allocator<std::_Loop_vals_t>::construct<std::_Loop_vals_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t *>, COMDAT
; _this$ = ecx

; 775  : 		{	// initialize with [_First, _Last), avoid leaking, forward iterators

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	ebx, DWORD PTR __Last$[ebp]
	sub	ebx, DWORD PTR __First$[ebp]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 775  : 		{	// initialize with [_First, _Last), avoid leaking, forward iterators

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	esi, ebx
	sar	esi, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1909 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [edi], 0

; 1910 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [edi+4], 0

; 1911 : 		this->_Myend() = pointer();

	mov	DWORD PTR [edi+8], 0

; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	je	SHORT $LN5@Range_cons

; 1914 : 			{
; 1915 : 			return (false);
; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	esi, 2147483647				; 7fffffffH
	ja	SHORT $LN160@Range_cons
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	esi
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [edi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [edi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ebx
	push	DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	lea	eax, DWORD PTR [eax+esi*2]
	mov	DWORD PTR [edi+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	esi, DWORD PTR [edi]

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	call	DWORD PTR __imp__memmove

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [ebx+esi]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 779  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

	mov	DWORD PTR [edi+4], eax
$LN5@Range_cons:
	pop	edi
	pop	esi
	pop	ebx

; 780  : 			_CATCH_ALL
; 781  : 			_Tidy();
; 782  : 			_RERAISE;
; 783  : 			_CATCH_END
; 784  : 			}
; 785  : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN160@Range_cons:

; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN162@Range_cons:
$LN159@Range_cons:
	int	3
??$_Range_construct_or_tidy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1510 : 	{	// convert to unchecked

	npad	2
	push	ebp
	mov	ebp, esp

; 1511 : 	return (_Iter._Unchecked());

	mov	eax, DWORD PTR __Iter$[ebp]

; 1512 : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPA_WV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0ABV?$allocator@_W@std@@X@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@_W@std@@X@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 517  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 517  : 		}

	ret	4
??$?0ABV?$allocator@_W@std@@X@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@PB_W@std@@YAHPB_W0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@PB_W@std@@YAHPB_W0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<wchar_t const *>, COMDAT

; 1105 : 	{	// return distance between iterators; random-access

	npad	2
	push	ebp
	mov	ebp, esp

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 1

; 1107 : 	}

	pop	ebp
	ret	0
??$_Distance1@PB_W@std@@YAHPB_W0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$swap@PAV_Node_base@std@@X@std@@YAXAAPAV_Node_base@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAV_Node_base@std@@X@std@@YAXAAPAV_Node_base@0@0@Z PROC ; std::swap<std::_Node_base *,void>, COMDAT

; 65   : 	{	// exchange values stored at _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR __Left$[ebp]

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], esi
	pop	esi

; 69   : 	}

	pop	ebp
	ret	0
??$swap@PAV_Node_base@std@@X@std@@YAXAAPAV_Node_base@0@0@Z ENDP ; std::swap<std::_Node_base *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$_Swap_adl@PAV_Node_base@std@@@std@@YAXAAPAV_Node_base@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAV_Node_base@std@@@std@@YAXAAPAV_Node_base@0@0@Z PROC ; std::_Swap_adl<std::_Node_base *>, COMDAT

; 75   : 	{	// exchange values stored at _Left and _Right, using ADL

	npad	2
	push	ebp
	mov	ebp, esp

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR __Left$[ebp]

; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	esi, DWORD PTR [edx]

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ecx], esi
	pop	esi

; 76   : 	swap(_Left, _Right);
; 77   : 	}

	pop	ebp
	ret	0
??$_Swap_adl@PAV_Node_base@std@@@std@@YAXAAPAV_Node_base@0@0@Z ENDP ; std::_Swap_adl<std::_Node_base *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z
_TEXT	SEGMENT
__Pred$ = -4						; size = 4
__First$ = 8						; size = 4
$T1 = 12						; size = 1
__Last$ = 12						; size = 4
__Icase$ = 16						; size = 1
??$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z PROC ; std::_Regex_traits<wchar_t>::lookup_classname<wchar_t const *>, COMDAT
; _this$ = ecx

; 339  : 		{	// map [_First, _Last) to character class mask value

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 340  :   #define _REGEX_CHAR_CLASS_NAME(n, c) \
; 341  : 	{n, L ## n, sizeof (n) / sizeof (n[0]) - 1, c}
; 342  : 		static constexpr _Cl_names _Names[] =
; 343  : 			{	// map class names to numeric constants
; 344  : 			_REGEX_CHAR_CLASS_NAME("alnum", _Ch_alnum),
; 345  : 			_REGEX_CHAR_CLASS_NAME("alpha", _Ch_alpha),
; 346  : 			_REGEX_CHAR_CLASS_NAME("blank", _Ch_blank),
; 347  : 			_REGEX_CHAR_CLASS_NAME("cntrl", _Ch_cntrl),
; 348  : 			_REGEX_CHAR_CLASS_NAME("d", _Ch_digit),
; 349  : 			_REGEX_CHAR_CLASS_NAME("digit", _Ch_digit),
; 350  : 			_REGEX_CHAR_CLASS_NAME("graph", _Ch_graph),
; 351  : 			_REGEX_CHAR_CLASS_NAME("lower", _Ch_lower),
; 352  : 			_REGEX_CHAR_CLASS_NAME("print", _Ch_print),
; 353  : 			_REGEX_CHAR_CLASS_NAME("punct", _Ch_punct),
; 354  : 			_REGEX_CHAR_CLASS_NAME("space", _Ch_space),
; 355  : 			_REGEX_CHAR_CLASS_NAME("s", _Ch_space),
; 356  : 			_REGEX_CHAR_CLASS_NAME("upper", _Ch_upper),
; 357  : 			_REGEX_CHAR_CLASS_NAME("w", (ctype_base::mask)(-1)),
; 358  : 			_REGEX_CHAR_CLASS_NAME("xdigit", _Ch_xdigit),
; 359  : 			{0, 0, 0},
; 360  : 			};
; 361  :   #undef _REGEX_CHAR_CLASS_NAME
; 362  : 
; 363  : 		_DEBUG_RANGE(_First, _Last);
; 364  : 		unsigned int _Ix = 0;

	xor	esi, esi

; 365  : 		for (; _Names[_Ix]._Get<_Elem>(); ++_Ix)

	cmp	DWORD PTR ?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B+4, esi
	je	SHORT $LN44@lookup_cla

; 366  : 			if (_STD equal(_First, _Last,

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	push	ebx
	mov	ebx, DWORD PTR __Last$[ebp]
	push	edi
	mov	edi, ebx
	mov	DWORD PTR __Pred$[ebp], ecx
	sub	edi, edx
	mov	ecx, OFFSET ?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B+4
	sar	edi, 1
	npad	7
$LL4@lookup_cla:
	mov	eax, DWORD PTR ?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B[eax+8]

; 182  : 	return (_Wide);

	mov	ecx, DWORD PTR [ecx]

; 366  : 			if (_STD equal(_First, _Last,

	add	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2952 : 	if (_Last1 - _First1 != _Last2 - _First2)

	sar	eax, 1
	cmp	edi, eax
	jne	SHORT $LN41@lookup_cla

; 2833 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2866 : 	return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,

	lea	eax, DWORD PTR __Pred$[ebp]
	push	DWORD PTR $T1[ebp]
	push	eax
	push	ecx
	push	ebx
	push	edx
	call	??$_Equal_unchecked1@PB_WPB_WU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@std@@@std@@YA_NPB_W00AAU?$_Cmp_icase@V?$_Regex_traits@_W@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Equal_unchecked1<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::_Regex_traits<wchar_t> > >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 366  : 			if (_STD equal(_First, _Last,

	test	al, al
	jne	SHORT $LN45@lookup_cla
	mov	edx, DWORD PTR __First$[ebp]
$LN41@lookup_cla:

; 365  : 		for (; _Names[_Ix]._Get<_Elem>(); ++_Ix)

	inc	esi
	mov	eax, esi
	shl	eax, 4
	cmp	DWORD PTR ?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B[eax+4], 0

; 182  : 	return (_Wide);

	lea	ecx, DWORD PTR ?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B[eax+4]

; 365  : 		for (; _Names[_Ix]._Get<_Elem>(); ++_Ix)

	jne	SHORT $LL4@lookup_cla
$LN45@lookup_cla:
	pop	edi
	pop	ebx
$LN44@lookup_cla:

; 367  : 				_Names[_Ix]._Get<_Elem>(),
; 368  : 				_Names[_Ix]._Get<_Elem>() + _Names[_Ix]._Len,
; 369  : 				_Cmp_icase<_Regex_traits<_Elem> >(*this)))
; 370  : 				break;
; 371  : 
; 372  : 		char_class_type _Mask = (char_class_type)0;
; 373  : 		if (_Names[_Ix]._Get<_Elem>() != 0)

	shl	esi, 4
	xor	eax, eax
	cmp	DWORD PTR ?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B[esi+4], eax
	je	SHORT $LN6@lookup_cla

; 374  : 			_Mask = _Names[_Ix]._Ctype;

	movzx	eax, WORD PTR ?_Names@?1???$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z@4QBU_Cl_names@2@B[esi+12]
$LN6@lookup_cla:

; 375  : 		if (_Icase && _Mask & (_Ch_lower | _Ch_upper))

	cmp	BYTE PTR __Icase$[ebp], 0
	pop	esi
	je	SHORT $LN7@lookup_cla
	test	al, 3
	je	SHORT $LN7@lookup_cla

; 376  : 			_Mask |= _Ch_lower | _Ch_upper;

	or	eax, 3
$LN7@lookup_cla:

; 377  : 		return (_Mask);
; 378  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z ENDP ; std::_Regex_traits<wchar_t>::lookup_classname<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@_W@std@@PA_W@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@_W@std@@PA_W@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t>,wchar_t *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@_W@std@@PA_W@std@@YAXPA_W0AAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t>,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@$$QAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@$$QAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> ><std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@$$QAV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> ><std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@_W@std@@@std@@YA_NQB_WI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_equal@U?$char_traits@_W@std@@@std@@YA_NQB_WI0I@Z PROC ; std::_Traits_equal<std::char_traits<wchar_t> >, COMDAT

; 24   : 	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	esi, DWORD PTR __Left_size$[ebp]
	cmp	esi, DWORD PTR __Right_size$[ebp]
	jne	SHORT $LN3@Traits_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Left$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN19@Traits_equ
$LL11@Traits_equ:

; 217  :             if (*_S1 != *_S2)

	mov	ax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	jne	SHORT $LN15@Traits_equ

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	edx, 2
	add	ecx, 2
	sub	esi, 1
	jne	SHORT $LL11@Traits_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	al, 1
	pop	esi

; 26   : 	}

	pop	ebp
	ret	0
$LN15@Traits_equ:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	movzx	eax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	jne	SHORT $LN3@Traits_equ
$LN19@Traits_equ:
	mov	al, 1
	pop	esi

; 26   : 	}

	pop	ebp
	ret	0
$LN3@Traits_equ:

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	xor	al, al
	pop	esi

; 26   : 	}

	pop	ebp
	ret	0
??$_Traits_equal@U?$char_traits@_W@std@@@std@@YA_NQB_WI0I@Z ENDP ; std::_Traits_equal<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Ucopy@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEPAU_Grp_t@?$_Tgt_state_t@PB_W@1@PAU231@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEPAU_Grp_t@?$_Tgt_state_t@PB_W@1@PAU231@00@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Ucopy<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT
; _this$ = ecx

; 1858 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1860 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEPAU_Grp_t@?$_Tgt_state_t@PB_W@1@PAU231@00@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Ucopy<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > ><std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,void>, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 517  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 517  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > ><std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<wchar_t> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z PROC ; std::forward<std::allocator<unsigned int> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z ENDP ; std::forward<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z PROC ; std::_Uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 117  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 127  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ENDP ; std::_Uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT

; 1139 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv672 = 12						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>, COMDAT
; _this$ = ecx

; 1357 : 		{	// assign [_First, _Last), forward iterators

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ebx+8]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+4]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	sar	esi, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 2

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	eax, 2

; 1358 : 		const size_type _Newsize = _STD distance(_First, _Last);
; 1359 : 
; 1360 : 		this->_Orphan_all();
; 1361 : 
; 1362 : 		const size_type _Oldsize = size();
; 1363 : 		const size_type _Oldcapacity = capacity();
; 1364 : 
; 1365 : 		if (_Newsize > _Oldcapacity)

	cmp	esi, edx
	jbe	SHORT $LN2@Assign_ran

; 1366 : 			{	// reallocate
; 1367 : 			if (_Newsize > max_size())

	cmp	esi, 1073741823				; 3fffffffH
	ja	$LN315@Assign_ran

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, edx
	shr	eax, 1
	mov	DWORD PTR tv672[ebp], eax
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, DWORD PTR tv672[ebp]
	cmp	edx, eax
	ja	SHORT $LN75@Assign_ran

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow
; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	mov	eax, DWORD PTR tv672[ebp]
	add	eax, edx

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, esi
	cmovb	eax, esi
	mov	esi, eax
$LN75@Assign_ran:

; 1370 : 				}
; 1371 : 
; 1372 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1373 : 
; 1374 : 			if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN5@Assign_ran
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	edx
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN5@Assign_ran:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1380 : 			_Buy(_Newcapacity);

	push	esi
	mov	ecx, ebx
	call	?_Buy@?$vector@IV?$allocator@_N@std@@@std@@AAE_NI@Z ; std::vector<unsigned int,std::allocator<bool> >::_Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	esi, DWORD PTR [ebx]

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	DWORD PTR __First$[ebp]
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1382 : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

	mov	DWORD PTR [ebx+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1396 : 			}
; 1397 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Assign_ran:

; 1383 : 			}
; 1384 : 		else if (_Newsize > _Oldsize)

	cmp	esi, eax
	jbe	SHORT $LN6@Assign_ran
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	edi, DWORD PTR __imp__memmove

; 1079 : 	_Where += _Off;

	lea	esi, DWORD PTR [eax*4]

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	DWORD PTR __First$[ebp]
	push	ecx
	call	edi

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __First$[ebp]

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __Last$[ebp]

; 1079 : 	_Where += _Off;

	add	eax, esi

; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	esi, DWORD PTR [ebx+4]

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	ecx, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ecx
	push	eax
	push	esi
	mov	DWORD PTR __Last$[ebp], ecx
	call	edi

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Last$[ebp]
	add	esp, 24					; 00000018H
	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1388 : 			this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());

	mov	DWORD PTR [ebx+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1396 : 			}
; 1397 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN6@Assign_ran:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1392 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	esi, DWORD PTR [ecx+esi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1395 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [ebx+4], esi
	pop	edi
	pop	esi
	pop	ebx

; 1396 : 			}
; 1397 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN315@Assign_ran:

; 1368 : 				{
; 1369 : 				_Xlength();

	call	?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlength
$LN317@Assign_ran:
$LN313@Assign_ran:
	int	3
??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z PROC	; std::_Rechecked<unsigned int *,unsigned int *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z ENDP	; std::_Rechecked<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@IIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@IIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 157  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 159  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@IIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAI@std@@YAPAIPAI@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAI@std@@YAPAIPAI@Z PROC			; std::_Unchecked<unsigned int *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAI@std@@YAPAIPAI@Z ENDP			; std::_Unchecked<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAV?$sub_match@PB_W@std@@PAV12@@std@@YAAAPAV?$sub_match@PB_W@0@AAPAV10@PAV10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$sub_match@PB_W@std@@PAV12@@std@@YAAAPAV?$sub_match@PB_W@0@AAPAV10@PAV10@@Z PROC ; std::_Rechecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAV?$sub_match@PB_W@std@@PAV12@@std@@YAAAPAV?$sub_match@PB_W@0@AAPAV10@PAV10@@Z ENDP ; std::_Rechecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >, COMDAT

; 135  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 139  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	push	esi
	mov	esi, DWORD PTR __Last$[ebp]
	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN2@Uninitiali
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax], xmm0
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 139  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 140  : 		{
; 141  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 142  : 		}
; 143  : 
; 144  : 	_CATCH_ALL
; 145  : 	_Destroy_range(_Next, _Dest, _Al);
; 146  : 	_RERAISE;
; 147  : 	_CATCH_END
; 148  : 
; 149  : 	return (_Dest);
; 150  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$sub_match@PB_W@std@@@std@@YA$$QAV?$sub_match@PB_W@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$sub_match@PB_W@std@@@std@@YA$$QAV?$sub_match@PB_W@0@AAV10@@Z PROC ; std::move<std::sub_match<wchar_t const *> &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$sub_match@PB_W@std@@@std@@YA$$QAV?$sub_match@PB_W@0@AAV10@@Z ENDP ; std::move<std::sub_match<wchar_t const *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$sub_match@PB_W@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$sub_match@PB_W@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_move_cat@V?$sub_match@PB_W@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$sub_match@PB_W@0@0@Z PROC ; std::_Ptr_move_cat<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >, COMDAT

; 893  : 	return {};

	xor	al, al

; 894  : 	}

	ret	0
??$_Ptr_move_cat@V?$sub_match@PB_W@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$sub_match@PB_W@0@0@Z ENDP ; std::_Ptr_move_cat<std::sub_match<wchar_t const *>,std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAV?$sub_match@PB_W@std@@@std@@YAPAV?$sub_match@PB_W@0@PAV10@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$sub_match@PB_W@std@@@std@@YAPAV?$sub_match@PB_W@0@PAV10@@Z PROC ; std::_Unchecked<std::sub_match<wchar_t const *> *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAV?$sub_match@PB_W@std@@@std@@YAPAV?$sub_match@PB_W@0@PAV10@@Z ENDP ; std::_Unchecked<std::sub_match<wchar_t const *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@AAPAU120@PAU120@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@AAPAU120@PAU120@@Z PROC ; std::_Rechecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@@std@@YAAAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@AAPAU120@PAU120@@Z ENDP ; std::_Rechecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT

; 157  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 159  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z PROC ; std::_Ptr_move_cat<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t>, COMDAT

; 892  : 	{	// return pointer move optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 893  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 894  : 	}

	pop	ebp
	ret	0
??$_Ptr_move_cat@U_Grp_t@?$_Tgt_state_t@PB_W@std@@U123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Grp_t@?$_Tgt_state_t@PB_W@0@0@Z ENDP ; std::_Ptr_move_cat<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::_Tgt_state_t<wchar_t const *>::_Grp_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >, COMDAT

; 1139 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$sub_match@PB_W@std@@@std@@PAV?$sub_match@PB_W@2@@std@@YAXPAV?$sub_match@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@V?$sub_match@PB_W@std@@@std@@PAV?$sub_match@PB_W@2@@std@@YAXPAV?$sub_match@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<std::sub_match<wchar_t const *> >,std::sub_match<wchar_t const *> *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$sub_match@PB_W@std@@@std@@PAV?$sub_match@PB_W@2@@std@@YAXPAV?$sub_match@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<std::sub_match<wchar_t const *> >,std::sub_match<wchar_t const *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv672 = 12						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT
; _this$ = ecx

; 1357 : 		{	// assign [_First, _Last), forward iterators

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ebx+8]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+4]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	sar	esi, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 3

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	eax, 3

; 1358 : 		const size_type _Newsize = _STD distance(_First, _Last);
; 1359 : 
; 1360 : 		this->_Orphan_all();
; 1361 : 
; 1362 : 		const size_type _Oldsize = size();
; 1363 : 		const size_type _Oldcapacity = capacity();
; 1364 : 
; 1365 : 		if (_Newsize > _Oldcapacity)

	cmp	esi, edx
	jbe	SHORT $LN2@Assign_ran

; 1366 : 			{	// reallocate
; 1367 : 			if (_Newsize > max_size())

	cmp	esi, 536870911				; 1fffffffH
	ja	$LN315@Assign_ran

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, edx
	shr	eax, 1
	mov	DWORD PTR tv672[ebp], eax
	mov	eax, 536870911				; 1fffffffH
	sub	eax, DWORD PTR tv672[ebp]
	cmp	edx, eax
	ja	SHORT $LN75@Assign_ran

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow
; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	mov	eax, DWORD PTR tv672[ebp]
	add	eax, edx

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, esi
	cmovb	eax, esi
	mov	esi, eax
$LN75@Assign_ran:

; 1370 : 				}
; 1371 : 
; 1372 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1373 : 
; 1374 : 			if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN5@Assign_ran
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	edx
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN5@Assign_ran:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1380 : 			_Buy(_Newcapacity);

	push	esi
	mov	ecx, ebx
	call	?_Buy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAE_NI@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	esi, DWORD PTR [ebx]

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	DWORD PTR __First$[ebp]
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1382 : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

	mov	DWORD PTR [ebx+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1396 : 			}
; 1397 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Assign_ran:

; 1383 : 			}
; 1384 : 		else if (_Newsize > _Oldsize)

	cmp	esi, eax
	jbe	SHORT $LN6@Assign_ran
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	edi, DWORD PTR __imp__memmove

; 1079 : 	_Where += _Off;

	lea	esi, DWORD PTR [eax*8]

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	DWORD PTR __First$[ebp]
	push	ecx
	call	edi

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __First$[ebp]

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __Last$[ebp]

; 1079 : 	_Where += _Off;

	add	eax, esi

; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	esi, DWORD PTR [ebx+4]

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	ecx, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ecx
	push	eax
	push	esi
	mov	DWORD PTR __Last$[ebp], ecx
	call	edi

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Last$[ebp]
	add	esp, 24					; 00000018H
	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1388 : 			this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());

	mov	DWORD PTR [ebx+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1396 : 			}
; 1397 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN6@Assign_ran:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1392 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	esi, DWORD PTR [ecx+esi*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1395 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [ebx+4], esi
	pop	edi
	pop	esi
	pop	ebx

; 1396 : 			}
; 1397 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN315@Assign_ran:

; 1368 : 				{
; 1369 : 				_Xlength();

	call	?_Xlength@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@CAXXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Xlength
$LN317@Assign_ran:
$LN313@Assign_ran:
	int	3
??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@@Z PROC ; std::_Unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@@Z ENDP ; std::_Unchecked<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$sub_match@PB_W@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$sub_match@PB_W@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *> >, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 103  : 		: first(), second()

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 660  : 		: _Mybase(), matched(false)

	mov	BYTE PTR [eax+8], 0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1098 : 		}

	pop	ebp
	ret	4
??$construct@V?$sub_match@PB_W@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::construct<std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::_Copy_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2326 : 	{	// copy [_First, _Last) to [_Dest, ...)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 866  : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2327 : 		// note: _Copy_unchecked is called directly from elsewhere in the STL
; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	add	esp, 32					; 00000020H

; 2329 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2330 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::_Copy_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked_n@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@U_Distance_unknown@2@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@U_Distance_unknown@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Src$ = 12						; size = 8
___formal$ = 20						; size = 1
??$_Unchecked_n@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@U_Distance_unknown@2@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@U_Distance_unknown@0@@Z PROC ; std::_Unchecked_n<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Distance_unknown>, COMDAT

; 711  : 	{	// blindly unwrap _Src under IDL == 0

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Src$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 712  : 	return (_Unchecked(_Src));
; 713  : 	}

	pop	ebp
	ret	0
??$_Unchecked_n@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@U_Distance_unknown@2@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@U_Distance_unknown@0@@Z ENDP ; std::_Unchecked_n<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Distance_unknown>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>, COMDAT

; 2688 : 	{	// copy _Val through [_First, _Last), no special optimization

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	edx, DWORD PTR __First$[ebp]
	push	esi
	mov	esi, DWORD PTR __Val$[ebp]
	npad	1
$LL12@Fill_unche:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2304 : 		return (this->_Myptr == _Right._Myptr

	cmp	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN18@Fill_unche
	cmp	ecx, DWORD PTR __Last$[ebp+4]
	je	SHORT $LN49@Fill_unche
$LN18@Fill_unche:

; 2143 : 		if (_Val)

	cmp	BYTE PTR [esi], 0

; 2144 : 			*(_Vbase *)_Getptr() |= _Mask();

	mov	eax, DWORD PTR [edx]
	je	SHORT $LN33@Fill_unche
	bts	eax, ecx

; 2145 : 		else

	jmp	SHORT $LN52@Fill_unche
$LN33@Fill_unche:

; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	btr	eax, ecx
$LN52@Fill_unche:
	mov	DWORD PTR [edx], eax

; 2381 : 		if (this->_Myoff < _VBITS - 1)

	mov	ecx, DWORD PTR __First$[ebp+4]

; 2383 : 		else

	mov	edx, DWORD PTR __First$[ebp]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN11@Fill_unche

; 2382 : 			++this->_Myoff;

	inc	ecx
	mov	DWORD PTR __First$[ebp+4], ecx

; 2383 : 		else

	jmp	SHORT $LL12@Fill_unche
$LN11@Fill_unche:

; 2384 : 			{	// move to next word
; 2385 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2386 : 			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
; 2387 : 				{	// report error
; 2388 : 				_DEBUG_ERROR("vector<bool> iterator not incrementable");
; 2389 : 				}
; 2390 : 
; 2391 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 2392 : 			_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 2393 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Valid(1) <= 0);
; 2394 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 2395 : 
; 2396 : 			this->_Myoff = 0;

	xor	ecx, ecx

; 2397 : 			++this->_Myptr;

	add	edx, 4
	mov	DWORD PTR __First$[ebp+4], ecx
	mov	DWORD PTR __First$[ebp], edx
	jmp	SHORT $LL12@Fill_unche
$LN49@Fill_unche:
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2691 : 	}

	pop	ebp
	ret	0
??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z PROC ; std::_Fill_memset_is_safe<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>, COMDAT

; 2682 : 	return {};

	xor	al, al

; 2683 : 	}

	ret	0
??$_Fill_memset_is_safe@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YA?AU?$integral_constant@_N$0A@@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AB_N@Z ENDP ; std::_Fill_memset_is_safe<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_memmove@PAU_Loop_vals_t@std@@PAU12@@std@@YAPAU_Loop_vals_t@0@PAU10@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAU_Loop_vals_t@std@@PAU12@@std@@YAPAU_Loop_vals_t@0@PAU10@00@Z PROC ; std::_Copy_memmove<std::_Loop_vals_t *,std::_Loop_vals_t *>, COMDAT

; 2295 : 	{	// implement copy-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2302 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAU_Loop_vals_t@std@@PAU12@@std@@YAPAU_Loop_vals_t@0@PAU10@00@Z ENDP ; std::_Copy_memmove<std::_Loop_vals_t *,std::_Loop_vals_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN7@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
$LN7@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	4
??$construct@U_Grp_t@?$_Tgt_state_t@PB_W@std@@$$V@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::construct<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z PROC ; std::allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z ENDP ; std::allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABI@std@@YAABIABI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABI@std@@YAABIABI@Z PROC			; std::forward<unsigned int const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABI@std@@YAABIABI@Z ENDP			; std::forward<unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z PROC ; std::allocator<unsigned int>::allocator<unsigned int><bool>, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ENDP ; std::allocator<unsigned int>::allocator<unsigned int><bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Loop_vals_t@std@@$$V@?$allocator_traits@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@SAXAAV?$allocator@U_Loop_vals_t@std@@@1@PAU_Loop_vals_t@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@U_Loop_vals_t@std@@$$V@?$allocator_traits@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@SAXAAV?$allocator@U_Loop_vals_t@std@@@1@PAU_Loop_vals_t@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Loop_vals_t> >::construct<std::_Loop_vals_t>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN5@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
$LN5@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@U_Loop_vals_t@std@@$$V@?$allocator_traits@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@SAXAAV?$allocator@U_Loop_vals_t@std@@@1@PAU_Loop_vals_t@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Loop_vals_t> >::construct<std::_Loop_vals_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 323  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 305  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::operator*, COMDAT
; _this$ = ecx

; 62   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 63   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 64   : 		if (_Mycont == 0
; 65   : 			|| _Ptr == _Tptr()
; 66   : 			|| _Ptr < _Mycont->_Myfirst
; 67   : 			|| _Mycont->_Mylast <= _Ptr)
; 68   : 			{	// report error
; 69   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 70   : 			}
; 71   : 
; 72   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 73   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 74   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 75   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 77   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 78   : 
; 79   : 		_Analysis_assume_(_Ptr != _Tptr());
; 80   : 
; 81   : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 82   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 44   : 		this->_Adopt(_Pvector);
; 45   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0ABV?$allocator@_W@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,void>, COMDAT
; _this$ = ecx

; 792  : 		{	// construct from [_First, _Last) with optional allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	mov	esi, ecx
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [esi], 0

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	push	DWORD PTR __First$[ebp]

; 477  : 		_Mylast(),

	mov	DWORD PTR [esi+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [esi+8], 0

; 793  : 		_DEBUG_RANGE(_First, _Last);
; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	call	??$_Range_construct_or_tidy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t *>

; 795  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@X@?$vector@_WV?$allocator@_W@std@@@std@@QAE@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0ABV?$allocator@_W@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@AAE_NI@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy, COMDAT
; _this$ = ecx

; 1908 : 		{	// allocate array with _Newcapacity elements

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1909 : 		this->_Myfirst() = pointer();
; 1910 : 		this->_Mylast() = pointer();
; 1911 : 		this->_Myend() = pointer();
; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	mov	edi, DWORD PTR __Newcapacity$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1914 : 			{
; 1915 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN2@Buy:

; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	edi, 2147483647				; 7fffffffH
	ja	SHORT $LN104@Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi*2]
	mov	DWORD PTR [esi+8], eax

; 1926 : 
; 1927 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN104@Buy:

; 1919 : 			{
; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN106@Buy:
$LN103@Buy:
	int	3
?_Buy@?$vector@_WV?$allocator@_W@std@@@std@@AAE_NI@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 2147483647				; 7fffffffH

; 1716 : 		}

	ret	0
?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ PROC	; std::vector<wchar_t,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 1

; 1711 : 		}

	ret	0
?size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ENDP	; std::vector<wchar_t,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::begin, COMDAT
; _this$ = ecx

; 1644 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1645 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
; 1646 : 		}

	pop	ebp
	ret	4
?begin@?$vector@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABQA_WXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABQA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABQA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABQA_WXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABQA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABQA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Find_unchecked1@PB_WG@std@@YAPB_WPB_W0ABGU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find_unchecked1@PB_WG@std@@YAPB_WPB_W0ABGU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find_unchecked1<wchar_t const *,unsigned short>, COMDAT

; 3159 : 	{	// find first matching _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 3160 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	eax, edx
	je	SHORT $LN8@Find_unche

; 3161 : 		if (*_First == _Val)

	mov	ecx, DWORD PTR __Val$[ebp]
	movzx	ecx, WORD PTR [ecx]
$LL4@Find_unche:
	cmp	WORD PTR [eax], cx
	je	SHORT $LN8@Find_unche

; 3160 : 	for (; _First != _Last; ++_First)

	add	eax, 2
	cmp	eax, edx
	jne	SHORT $LL4@Find_unche
$LN8@Find_unche:

; 3162 : 			break;
; 3163 : 	return (_First);
; 3164 : 	}

	pop	ebp
	ret	0
??$_Find_unchecked1@PB_WG@std@@YAPB_WPB_W0ABGU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find_unchecked1<wchar_t const *,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Find_unchecked1@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find_unchecked1@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find_unchecked1<wchar_t const *,enum std::_Meta_type>, COMDAT

; 3159 : 	{	// find first matching _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 3160 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	eax, edx
	je	SHORT $LN8@Find_unche

; 3161 : 		if (*_First == _Val)

	mov	ecx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR [ecx]
$LL4@Find_unche:
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, esi
	je	SHORT $LN14@Find_unche

; 3160 : 	for (; _First != _Last; ++_First)

	add	eax, 2
	cmp	eax, edx
	jne	SHORT $LL4@Find_unche
$LN14@Find_unche:
	pop	esi
$LN8@Find_unche:

; 3162 : 			break;
; 3163 : 	return (_First);
; 3164 : 	}

	pop	ebp
	ret	0
??$_Find_unchecked1@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find_unchecked1<wchar_t const *,enum std::_Meta_type>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Advance1@PB_WH@std@@YAXAAPB_WHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance1@PB_WH@std@@YAXAAPB_WHUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance1<wchar_t const *,int>, COMDAT

; 1078 : 	{	// increment iterator by offset, random-access iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR __Where$[ebp]
	add	DWORD PTR [eax], ecx

; 1080 : 	}

	pop	ebp
	ret	0
??$_Advance1@PB_WH@std@@YAXAAPB_WHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance1<wchar_t const *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Is_word@_W@std@@YA_N_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
??$_Is_word@_W@std@@YA_N_W@Z PROC			; std::_Is_word<wchar_t>, COMDAT

; 636  : 	{	// test if _Ch is a word character

	npad	2
	push	ebp
	mov	ebp, esp

; 637  : 		// assumes 'x' == L'x' for the ASCII range
; 638  : 	typedef make_unsigned_t<_Elem> _UElem;
; 639  : 	const auto _UCh = static_cast<_UElem>(_Ch);
; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	mov	ax, WORD PTR __Ch$[ebp]
	cmp	ax, 122					; 0000007aH
	ja	SHORT $LN3@Is_word

; 626  : 	return (_Is_word_table[_UCh]);

	movzx	eax, al

; 637  : 		// assumes 'x' == L'x' for the ASCII range
; 638  : 	typedef make_unsigned_t<_Elem> _UElem;
; 639  : 	const auto _UCh = static_cast<_UElem>(_Ch);
; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	cmp	BYTE PTR ?_Is_word_table@?1??_Is_word@std@@YA_NE@Z@4QB_NB[eax], 0
	je	SHORT $LN3@Is_word
	mov	al, 1

; 641  : 	}

	pop	ebp
	ret	0
$LN3@Is_word:

; 637  : 		// assumes 'x' == L'x' for the ASCII range
; 638  : 	typedef make_unsigned_t<_Elem> _UElem;
; 639  : 	const auto _UCh = static_cast<_UElem>(_Ch);
; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	xor	al, al

; 641  : 	}

	pop	ebp
	ret	0
??$_Is_word@_W@std@@YA_N_W@Z ENDP			; std::_Is_word<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@PB_W@std@@YAHPB_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PB_W@std@@YAHPB_W0@Z PROC			; std::distance<wchar_t const *>, COMDAT

; 1112 : 	{	// return distance between iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 1

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
; 1114 : 	}

	pop	ebp
	ret	0
??$distance@PB_W@std@@YAHPB_W0@Z ENDP			; std::distance<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0V?$allocator@I@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@$$QAV?$allocator@I@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@I@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@$$QAV?$allocator@I@1@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@I@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@$$QAV?$allocator@I@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Ucopy@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Ucopy<unsigned int *>, COMDAT
; _this$ = ecx

; 1858 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1860 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Ucopy<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::_Wrap_alloc<std::allocator<unsigned int> >,void>, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 517  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 517  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::_Wrap_alloc<std::allocator<unsigned int> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT

; 1144 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1145 : 	_Pocca(_Left, _Right, _Tag);
; 1146 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$assign@PAI@?$vector@IV?$allocator@_N@std@@@std@@QAEXPAI0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@PAI@?$vector@IV?$allocator@_N@std@@@std@@QAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::assign<unsigned int *>, COMDAT
; _this$ = ecx

; 1403 : 		{	// assign [_First, _Last)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1404 : 		_DEBUG_RANGE(_First, _Last);
; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 1406 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$assign@PAI@?$vector@IV?$allocator@_N@std@@@std@@QAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::assign<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$vector@IV?$allocator@_N@std@@@std@@@std@@YAPBV?$vector@IV?$allocator@_N@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$vector@IV?$allocator@_N@std@@@std@@@std@@YAPBV?$vector@IV?$allocator@_N@std@@@0@ABV10@@Z PROC ; std::addressof<std::vector<unsigned int,std::allocator<bool> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$vector@IV?$allocator@_N@std@@@std@@@std@@YAPBV?$vector@IV?$allocator@_N@std@@@0@ABV10@@Z ENDP ; std::addressof<std::vector<unsigned int,std::allocator<bool> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z PROC ; std::_Uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 176  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 893  : 	return {};

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 24					; 00000018H

; 173  : 		_Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 174  : 			_Ptr_move_cat(_UFirst, _UDest),
; 175  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(_STD move(*_UFirst))>())));
; 176  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 176  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@00AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::_Tgt_state_t<wchar_t const *>::_Grp_t *,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >, COMDAT

; 1144 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1145 : 	_Pocca(_Left, _Right, _Tag);
; 1146 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@std@@YAPBV?$vector@_NV?$allocator@_N@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@std@@YAPBV?$vector@_NV?$allocator@_N@std@@@0@ABV10@@Z PROC ; std::addressof<std::vector<bool,std::allocator<bool> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@std@@YAPBV?$vector@_NV?$allocator@_N@std@@@0@ABV10@@Z ENDP ; std::addressof<std::vector<bool,std::allocator<bool> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$sub_match@PB_W@std@@@std@@PAV?$sub_match@PB_W@2@@std@@YAXPAV?$sub_match@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$sub_match@PB_W@std@@@std@@PAV?$sub_match@PB_W@2@@std@@YAXPAV?$sub_match@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::sub_match<wchar_t const *> >,std::sub_match<wchar_t const *> *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$sub_match@PB_W@std@@@std@@PAV?$sub_match@PB_W@2@@std@@YAXPAV?$sub_match@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::sub_match<wchar_t const *> >,std::sub_match<wchar_t const *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$assign@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::assign<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT
; _this$ = ecx

; 1403 : 		{	// assign [_First, _Last)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1404 : 		_DEBUG_RANGE(_First, _Last);
; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>

; 1406 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$assign@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::assign<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@YAPBV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@YAPBV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@0@ABV10@@Z PROC ; std::addressof<std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@YAPBV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@0@ABV10@@Z ENDP ; std::addressof<std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 8
??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z PROC ; std::_Rechecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Src$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YAAAV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@AAV10@V10@@Z ENDP ; std::_Rechecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2499 : 	{	// copy [_First, _Last) backwards to [..., _Dest), no special optimization

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
$LL2@Copy_backw:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2304 : 		return (this->_Myptr == _Right._Myptr

	mov	edi, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp+4]
	cmp	DWORD PTR __First$[ebp], edi
	jne	SHORT $LN9@Copy_backw
	cmp	DWORD PTR __First$[ebp+4], ecx
	je	SHORT $LN76@Copy_backw
$LN9@Copy_backw:

; 2359 : 		if (this->_Myoff != 0)

	test	ecx, ecx
	je	SHORT $LN18@Copy_backw

; 2360 : 			--this->_Myoff;

	dec	ecx

; 2361 : 		else

	jmp	SHORT $LN79@Copy_backw
$LN18@Copy_backw:

; 2375 : 			--this->_Myptr;

	sub	edi, 4
	mov	ecx, 31					; 0000001fH
	mov	DWORD PTR __Last$[ebp], edi
$LN79@Copy_backw:

; 2359 : 		if (this->_Myoff != 0)

	mov	edx, DWORD PTR __Dest$[ebp+4]

; 2361 : 		else

	mov	esi, DWORD PTR __Dest$[ebp]

; 2374 : 			this->_Myoff = _VBITS - 1;

	mov	DWORD PTR __Last$[ebp+4], ecx

; 2359 : 		if (this->_Myoff != 0)

	test	edx, edx
	je	SHORT $LN36@Copy_backw

; 2360 : 			--this->_Myoff;

	dec	edx

; 2361 : 		else

	jmp	SHORT $LN80@Copy_backw
$LN36@Copy_backw:

; 2375 : 			--this->_Myptr;

	sub	esi, 4
	mov	edx, 31					; 0000001fH
	mov	DWORD PTR __Dest$[ebp], esi
$LN80@Copy_backw:

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	eax, 1

; 2374 : 			this->_Myoff = _VBITS - 1;

	mov	DWORD PTR __Dest$[ebp+4], edx

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	shl	eax, cl

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	eax, DWORD PTR [edi]

; 2144 : 			*(_Vbase *)_Getptr() |= _Mask();

	mov	eax, DWORD PTR [esi]
	je	SHORT $LN60@Copy_backw
	bts	eax, edx
	mov	DWORD PTR [esi], eax

; 2145 : 		else

	jmp	SHORT $LL2@Copy_backw
$LN60@Copy_backw:

; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	btr	eax, edx
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2501 : 		*--_Dest = *--_Last;

	jmp	SHORT $LL2@Copy_backw
$LN76@Copy_backw:

; 2502 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 2503 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z PROC ; std::_Ptr_copy_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 866  : 	return {};

	xor	al, al

; 867  : 	}

	ret	0
??$_Ptr_copy_cat@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z ENDP ; std::_Ptr_copy_cat<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked_n_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@U_Distance_unknown@2@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@U_Distance_unknown@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Src$ = 12						; size = 8
___formal$ = 20						; size = 1
??$_Unchecked_n_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@U_Distance_unknown@2@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@U_Distance_unknown@0@@Z PROC ; std::_Unchecked_n_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Distance_unknown>, COMDAT

; 755  : 	{	// blindly unwrap _Src under IDL == 0

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Src$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 756  : 	return (_Unchecked(_Src));
; 757  : 	}

	pop	ebp
	ret	0
??$_Unchecked_n_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@U_Distance_unknown@2@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@U_Distance_unknown@0@@Z ENDP ; std::_Unchecked_n_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Distance_unknown>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Idl_distance@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU_Distance_unknown@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Idl_distance@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU_Distance_unknown@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z PROC ; std::_Idl_distance<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 683  : 	return {};

	xor	al, al

; 684  : 	}

	ret	0
??$_Idl_distance@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU_Distance_unknown@0@ABV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0@Z ENDP ; std::_Idl_distance<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Deprecate@_Unchecked_iterators@?1???$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Deprecate@_Unchecked_iterators@?1???$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2518 : 	_DEPRECATE_UNCHECKED(copy_backward, _Dest);

	ret	0
?_Deprecate@_Unchecked_iterators@?1???$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >, COMDAT

; 228  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Uninitiali
	npad	1
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN19@Uninitiali
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 103  : 		: first(), second()

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 660  : 		: _Mybase(), matched(false)

	mov	BYTE PTR [eax+8], 0
$LN19@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	eax, 12					; 0000000cH
	sub	ecx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 233  : 		{
; 234  : 		_Al.construct(_Unfancy(_First));
; 235  : 		}
; 236  : 
; 237  : 	_CATCH_ALL
; 238  : 	_Destroy_range(_Next, _First, _Al);
; 239  : 	_RERAISE;
; 240  : 	_CATCH_END
; 241  : 
; 242  : 	return (_First);
; 243  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@V?$sub_match@PB_W@std@@@std@@YAPAV?$sub_match@PB_W@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$sub_match@PB_W@std@@@std@@YAPAV?$sub_match@PB_W@0@PAV10@@Z PROC ; std::_Unfancy<std::sub_match<wchar_t const *> >, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@V?$sub_match@PB_W@std@@@std@@YAPAV?$sub_match@PB_W@0@PAV10@@Z ENDP ; std::_Unfancy<std::sub_match<wchar_t const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::_Copy_no_deprecate<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2336 : 	{	// copy [_First, _Last) to [_Dest, ...), no _SCL_INSECURE_DEPRECATE_FN warnings

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 866  : 	return {};

	mov	BYTE PTR $T2[ebp], 0

; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	lea	eax, DWORD PTR $T1[ebp]
	push	DWORD PTR $T2[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >

; 2337 : 	_DEBUG_RANGE(_First, _Last);
; 2338 : 	const auto _UFirst = _Unchecked(_First);
; 2339 : 	const auto _ULast = _Unchecked(_Last);
; 2340 : 	const auto _UDest = _Unchecked_n(_Dest, _Idl_distance(_UFirst, _ULast));
; 2341 : 	return (_Rechecked(_Dest,

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	add	esp, 32					; 00000020H

; 2337 : 	_DEBUG_RANGE(_First, _Last);
; 2338 : 	const auto _UFirst = _Unchecked(_First);
; 2339 : 	const auto _ULast = _Unchecked(_Last);
; 2340 : 	const auto _UDest = _Unchecked_n(_Dest, _Idl_distance(_UFirst, _ULast));
; 2341 : 	return (_Rechecked(_Dest,

	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 2342 : 		_Copy_unchecked(_UFirst, _ULast, _UDest)));
; 2343 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_no_deprecate@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::_Copy_no_deprecate<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 8
??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z PROC ; std::_Is_checked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 444  : 	return {};

	xor	al, al

; 445  : 	}

	ret	0
??$_Is_checked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@@Z ENDP ; std::_Is_checked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2350 : 	_DEPRECATE_UNCHECKED(copy, _Dest);

	ret	0
?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>, COMDAT

; 2703 : 	{	// copy _Val through [_First, _Last), choose optimization

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2682 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
	add	esp, 24					; 00000018H

; 2705 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Src$ = 12						; size = 8
??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z PROC ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Src$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@@Z ENDP ; std::_Unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAU_Loop_vals_t@std@@PAU12@@std@@YAAAPAU_Loop_vals_t@0@AAPAU10@PAU10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAU_Loop_vals_t@std@@PAU12@@std@@YAAAPAU_Loop_vals_t@0@AAPAU10@PAU10@@Z PROC ; std::_Rechecked<std::_Loop_vals_t *,std::_Loop_vals_t *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAU_Loop_vals_t@std@@PAU12@@std@@YAAAPAU_Loop_vals_t@0@AAPAU10@PAU10@@Z ENDP ; std::_Rechecked<std::_Loop_vals_t *,std::_Loop_vals_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 556  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	mov	eax, ecx
	ret	4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@U_Loop_vals_t@std@@U12@V?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@U_Loop_vals_t@std@@U12@V?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<std::_Loop_vals_t,std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >, COMDAT

; 157  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 159  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@U_Loop_vals_t@std@@U12@V?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<std::_Loop_vals_t,std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@U_Loop_vals_t@std@@U12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Loop_vals_t@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@U_Loop_vals_t@std@@U12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Loop_vals_t@0@0@Z PROC ; std::_Ptr_move_cat<std::_Loop_vals_t,std::_Loop_vals_t>, COMDAT

; 892  : 	{	// return pointer move optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 893  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 894  : 	}

	pop	ebp
	ret	0
??$_Ptr_move_cat@U_Loop_vals_t@std@@U12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAU_Loop_vals_t@0@0@Z ENDP ; std::_Ptr_move_cat<std::_Loop_vals_t,std::_Loop_vals_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAU_Loop_vals_t@std@@@std@@YAPAU_Loop_vals_t@0@PAU10@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAU_Loop_vals_t@std@@@std@@YAPAU_Loop_vals_t@0@PAU10@@Z PROC ; std::_Unchecked<std::_Loop_vals_t *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAU_Loop_vals_t@std@@@std@@YAPAU_Loop_vals_t@0@PAU10@@Z ENDP ; std::_Unchecked<std::_Loop_vals_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT

; 228  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Uninitiali
	npad	1
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN2@Uninitiali
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	eax, 8
	sub	ecx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 233  : 		{
; 234  : 		_Al.construct(_Unfancy(_First));
; 235  : 		}
; 236  : 
; 237  : 	_CATCH_ALL
; 238  : 	_Destroy_range(_Next, _First, _Al);
; 239  : 	_RERAISE;
; 240  : 	_CATCH_END
; 241  : 
; 242  : 	return (_First);
; 243  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@@Z PROC ; std::_Unfancy<std::_Tgt_state_t<wchar_t const *>::_Grp_t>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@@Z ENDP ; std::_Unfancy<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<bool> const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@_N@std@@@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> ><std::allocator<bool> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z PROC		; std::_Copy_memmove<unsigned int *,unsigned int *>, COMDAT

; 2295 : 	{	// implement copy-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2302 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ENDP		; std::_Copy_memmove<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Loop_vals_t@std@@$$V@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@U_Loop_vals_t@std@@$$V@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::construct<std::_Loop_vals_t>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN7@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
$LN7@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	4
??$construct@U_Loop_vals_t@std@@$$V@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::construct<std::_Loop_vals_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3823 : 	{	// test for string equality

	npad	2
	push	ebp
	mov	ebp, esp

; 3824 : 	return (_Left._Equal(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal

; 3825 : 	}

	pop	ebp
	ret	0
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
_TEXT	SEGMENT
$T2 = -60						; size = 24
__Temp$3 = -36						; size = 12
$T4 = -24						; size = 1
$T5 = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z PROC ; std::_Regex_traits<wchar_t>::transform_primary<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >, COMDAT
; _this$ = ecx

; 312  : 		{	// apply locale-specific case-insensitive transformation

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 312  : 		{	// apply locale-specific case-insensitive transformation

	mov	DWORD PTR _this$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1330 : 		return (_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 324  : 		return (_Res);

	mov	DWORD PTR __$EHRec$[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1330 : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T5[ebp], 1
	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 315  : 		if (_First != _Last)

	je	$LN361@transform_
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T4[ebp], 0
	push	DWORD PTR $T4[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR __Temp$3[ebp], 0

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	push	ecx
	push	eax
	lea	ecx, DWORD PTR __Temp$3[ebp]

; 477  : 		_Mylast(),

	mov	DWORD PTR __Temp$3[ebp+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR __Temp$3[ebp+8], 0

; 794  : 		_Range_construct_or_tidy(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	call	??$_Range_construct_or_tidy@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Range_construct_or_tidy<wchar_t *>

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ebx, DWORD PTR __Temp$3[ebp]
	mov	eax, DWORD PTR __Temp$3[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 319  : 			_Getctype()->tolower(&*_Temp.begin(),

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, ebx
	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 317  : 			vector<_Elem> _Temp(_First, _Last);

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 319  : 			_Getctype()->tolower(&*_Temp.begin(),

	mov	ecx, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ebx+eax*2]
	push	esi
	push	ebx
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBEPB_WPA_WPB_W@Z

; 320  : 				&*_Temp.begin() + _Temp.size());
; 321  : 			_Res = _Getcoll()->transform(&*_Temp.begin(),

	push	esi
	push	ebx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform
	push	eax
	mov	ecx, edi
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN237@transform_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN237@transform_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	ebx, ebx
	je	SHORT $LN360@transform_

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR __Temp$3[ebp+8]
	sub	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	ebx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN360@transform_:
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 324  : 		return (_Res);

	mov	eax, edi
	pop	edi

; 325  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN361@transform_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 1
	je	$LN5@transform_
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN5@transform_:
	ret	0
__unwindfunclet$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1:
	lea	ecx, DWORD PTR __Temp$3[ebp]
	jmp	??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
__ehhandler$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ENDP ; std::_Regex_traits<wchar_t>::transform_primary<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Find_unchecked@PB_WG@std@@YAPB_WPB_W0ABG@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PB_WG@std@@YAPB_WPB_W0ABG@Z PROC	; std::_Find_unchecked<wchar_t const *,unsigned short>, COMDAT

; 3169 : 	{	// find first matching _Val; choose optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 3170 : 	// activate optimization for pointers to (const) bytes and integral values
; 3171 : 	typedef integral_constant<bool,
; 3172 : 		(is_same<_InIt, char *>::value
; 3173 : 		|| is_same<_InIt, signed char *>::value
; 3174 : 		|| is_same<_InIt, unsigned char *>::value
; 3175 : 		|| is_same<_InIt, const char *>::value
; 3176 : 		|| is_same<_InIt, const signed char *>::value
; 3177 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3178 : 		&& is_integral<_Ty>::value
; 3179 : 	> _Memchr_opt;
; 3180 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

	mov	eax, DWORD PTR __First$[ebp]

; 3160 : 	for (; _First != _Last; ++_First)

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	eax, edx
	je	SHORT $LN10@Find_unche

; 3161 : 		if (*_First == _Val)

	mov	ecx, DWORD PTR __Val$[ebp]
	movzx	ecx, WORD PTR [ecx]
$LL6@Find_unche:
	cmp	WORD PTR [eax], cx
	je	SHORT $LN10@Find_unche

; 3160 : 	for (; _First != _Last; ++_First)

	add	eax, 2
	cmp	eax, edx
	jne	SHORT $LL6@Find_unche
$LN10@Find_unche:

; 3181 : 	}

	pop	ebp
	ret	0
??$_Find_unchecked@PB_WG@std@@YAPB_WPB_W0ABG@Z ENDP	; std::_Find_unchecked<wchar_t const *,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Cmp_chrange@PB_WPB_WU?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_cs@V?$regex_traits@_W@std@@@0@@Z
_TEXT	SEGMENT
__Res$1$ = 8						; size = 4
__Begin1$ = 8						; size = 4
__End1$ = 12						; size = 4
__Begin2$ = 16						; size = 4
__End2$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Cmp_chrange@PB_WPB_WU?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_cs@V?$regex_traits@_W@std@@@0@@Z PROC ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_cs<std::regex_traits<wchar_t> > >, COMDAT

; 4337 : 	{	// compare character ranges

	npad	2
	push	ebp
	mov	ebp, esp

; 4338 : 	_BidIt1 _Res = _Begin1;

	mov	edx, DWORD PTR __Begin1$[ebp]
	mov	eax, edx
	push	ebx

; 4339 : 	while (_Begin1 != _End1 && _Begin2 != _End2)

	mov	ebx, DWORD PTR __End2$[ebp]
	push	esi
	mov	esi, DWORD PTR __Begin2$[ebp]
	push	edi
	mov	edi, DWORD PTR __End1$[ebp]
	mov	DWORD PTR __Res$1$[ebp], eax
	cmp	edx, edi
	je	SHORT $LN3@Cmp_chrang
	npad	3
$LL2@Cmp_chrang:
	cmp	esi, ebx
	je	SHORT $LN13@Cmp_chrang

; 191  : 		return (_E1 == _E2);

	movzx	ecx, WORD PTR [edx]

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	add	edx, 2

; 191  : 		return (_E1 == _E2);

	movzx	eax, WORD PTR [esi]

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	add	esi, 2

; 191  : 		return (_E1 == _E2);

	cmp	cx, ax

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	jne	SHORT $LN9@Cmp_chrang

; 4339 : 	while (_Begin1 != _End1 && _Begin2 != _End2)

	cmp	edx, edi
	jne	SHORT $LL2@Cmp_chrang
$LN13@Cmp_chrang:
	mov	eax, DWORD PTR __Res$1$[ebp]
$LN3@Cmp_chrang:

; 4342 : 	return (_Begin2 == _End2 ? _Begin1 : _Res);

	cmp	esi, ebx
	pop	edi
	pop	esi
	cmove	eax, edx
	pop	ebx

; 4343 : 	}

	pop	ebp
	ret	0
$LN9@Cmp_chrang:

; 4341 : 			return (_Res);

	mov	eax, DWORD PTR __Res$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 4343 : 	}

	pop	ebp
	ret	0
??$_Cmp_chrange@PB_WPB_WU?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_cs@V?$regex_traits@_W@std@@@0@@Z ENDP ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_cs<std::regex_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??R?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z
_TEXT	SEGMENT
__E1$ = 8						; size = 2
__E2$ = 12						; size = 2
??R?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z PROC ; std::_Cmp_cs<std::regex_traits<wchar_t> >::operator(), COMDAT
; _this$ = ecx

; 190  : 		{	// return true if equal

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ax, WORD PTR __E1$[ebp]
	cmp	ax, WORD PTR __E2$[ebp]
	sete	al

; 191  : 		return (_E1 == _E2);
; 192  : 		}

	pop	ebp
	ret	8
??R?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z ENDP ; std::_Cmp_cs<std::regex_traits<wchar_t> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Cmp_chrange@PB_WPB_WU?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_collate@V?$regex_traits@_W@std@@@0@@Z
_TEXT	SEGMENT
__Res$1 = -60						; size = 24
__Res$2 = -36						; size = 24
$T3 = -12						; size = 4
__Res$1$ = -8						; size = 4
__Ch$ = -4						; size = 2
__Ch$ = 8						; size = 2
__Begin1$ = 8						; size = 4
__End1$ = 12						; size = 4
__Begin2$ = 16						; size = 4
__End2$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Cmp_chrange@PB_WPB_WU?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_collate@V?$regex_traits@_W@std@@@0@@Z PROC ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_collate<std::regex_traits<wchar_t> > >, COMDAT

; 4337 : 	{	// compare character ranges

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 4338 : 	_BidIt1 _Res = _Begin1;
; 4339 : 	while (_Begin1 != _End1 && _Begin2 != _End2)

	mov	eax, DWORD PTR __End2$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Begin1$[ebp]
	mov	ecx, esi
	push	edi
	mov	edi, DWORD PTR __Begin2$[ebp]
	mov	DWORD PTR __Res$1$[ebp], ecx
	cmp	esi, DWORD PTR __End1$[ebp]
	je	$LN3@Cmp_chrang
$LL2@Cmp_chrang:
	cmp	edi, eax
	je	$LN186@Cmp_chrang

; 229  : 		return (_Traits.translate(_E1) == _Traits.translate(_E2));

	movzx	eax, WORD PTR [esi]

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	mov	ecx, DWORD PTR __Pred$[ebp]

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	movzx	ebx, WORD PTR [edi]

; 229  : 		return (_Traits.translate(_E1) == _Traits.translate(_E2));

	mov	DWORD PTR __Ch$[ebp], eax

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	lea	eax, DWORD PTR __Ch$[ebp+2]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	lea	eax, DWORD PTR __Res$2[ebp]
	push	eax
	call	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	cmp	DWORD PTR __Res$2[ebp+16], 1
	mov	edx, DWORD PTR __Res$2[ebp+20]
	mov	ecx, DWORD PTR __Res$2[ebp]
	jne	SHORT $LN10@Cmp_chrang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Res$2[ebp]
	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	movzx	eax, WORD PTR [eax]
	jmp	SHORT $LN188@Cmp_chrang
$LN10@Cmp_chrang:
	movzx	eax, WORD PTR __Ch$[ebp]
$LN188@Cmp_chrang:
	mov	DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN79@Cmp_chrang

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	eax, DWORD PTR [edx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN175@Cmp_chrang

; 99   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN74@Cmp_chrang

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	BYTE PTR __Res$2[ebp], 31		; 0000001fH
	jne	$LN175@Cmp_chrang

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN175@Cmp_chrang

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN175@Cmp_chrang

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN175@Cmp_chrang

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN74@Cmp_chrang:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN79@Cmp_chrang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	mov	ecx, DWORD PTR __Pred$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR __Res$2[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 229  : 		return (_Traits.translate(_E1) == _Traits.translate(_E2));

	mov	eax, ebx
	mov	DWORD PTR __Ch$[ebp], eax

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	lea	eax, DWORD PTR __Ch$[ebp+2]
	push	eax
	lea	eax, DWORD PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Res$2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	push	eax
	lea	eax, DWORD PTR __Res$1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Res$2[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	cmp	DWORD PTR __Res$1[ebp+16], 1
	mov	edx, DWORD PTR __Res$1[ebp+20]
	mov	eax, DWORD PTR __Res$1[ebp]
	jne	SHORT $LN91@Cmp_chrang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 1614 : 		return (_Large_string_engaged()

	lea	ecx, DWORD PTR __Res$1[ebp]
	cmovae	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	movzx	ebx, WORD PTR [ecx]
	jmp	SHORT $LN92@Cmp_chrang
$LN91@Cmp_chrang:
	movzx	ebx, WORD PTR __Ch$[ebp]
$LN92@Cmp_chrang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN160@Cmp_chrang

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [edx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	ecx, 2147483647				; 7fffffffH
	ja	SHORT $LN175@Cmp_chrang

; 99   : 	const size_t _User_size = _Count * _Sz;

	add	ecx, ecx

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN155@Cmp_chrang

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	jne	SHORT $LN175@Cmp_chrang

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN175@Cmp_chrang

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN175@Cmp_chrang

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	ja	SHORT $LN175@Cmp_chrang

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN155@Cmp_chrang:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN160@Cmp_chrang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	add	esi, 2
	add	edi, 2

; 229  : 		return (_Traits.translate(_E1) == _Traits.translate(_E2));

	cmp	WORD PTR $T3[ebp], bx

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	jne	SHORT $LN181@Cmp_chrang

; 4338 : 	_BidIt1 _Res = _Begin1;
; 4339 : 	while (_Begin1 != _End1 && _Begin2 != _End2)

	mov	eax, DWORD PTR __End2$[ebp]
	cmp	esi, DWORD PTR __End1$[ebp]
	jne	$LL2@Cmp_chrang
$LN186@Cmp_chrang:
	mov	ecx, DWORD PTR __Res$1$[ebp]
$LN3@Cmp_chrang:

; 4342 : 	return (_Begin2 == _End2 ? _Begin1 : _Res);

	cmp	edi, eax
	pop	edi
	cmove	ecx, esi
	pop	esi
	mov	eax, ecx
	pop	ebx

; 4343 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN175@Cmp_chrang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN190@Cmp_chrang:
$LN181@Cmp_chrang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4341 : 			return (_Res);

	mov	eax, DWORD PTR __Res$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 4343 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN189@Cmp_chrang:
??$_Cmp_chrange@PB_WPB_WU?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_collate@V?$regex_traits@_W@std@@@0@@Z ENDP ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_collate<std::regex_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??R?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z
_TEXT	SEGMENT
__Res$1 = -48						; size = 24
__Res$2 = -24						; size = 24
__Ch$ = 8						; size = 2
__E1$ = 8						; size = 2
__Ch$ = 12						; size = 2
__E2$ = 12						; size = 2
??R?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z PROC ; std::_Cmp_collate<std::regex_traits<wchar_t> >::operator(), COMDAT
; _this$ = ecx

; 228  : 		{	// return true if equal

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 229  : 		return (_Traits.translate(_E1) == _Traits.translate(_E2));

	movzx	eax, WORD PTR __E1$[ebp]
	push	esi
	mov	DWORD PTR __Ch$[ebp], eax
	mov	esi, ecx
	push	edi

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	lea	eax, DWORD PTR __Ch$[ebp+2]
	push	eax

; 401  : 		return (_Pcoll);

	mov	ecx, DWORD PTR [esi]

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	lea	eax, DWORD PTR __Res$2[ebp]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	cmp	DWORD PTR __Res$2[ebp+16], 1
	mov	ecx, DWORD PTR __Res$2[ebp+20]
	mov	edx, DWORD PTR __Res$2[ebp]
	jne	SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Res$2[ebp]
	cmovae	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	movzx	edi, WORD PTR [eax]
	jmp	SHORT $LN6@operator
$LN5@operator:
	movzx	edi, WORD PTR __Ch$[ebp]
$LN6@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN44@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	eax, DWORD PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	edx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN44@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 401  : 		return (_Pcoll);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR __Res$2[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 229  : 		return (_Traits.translate(_E1) == _Traits.translate(_E2));

	movzx	eax, WORD PTR __E2$[ebp]
	mov	DWORD PTR __Ch$[ebp], eax

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	lea	eax, DWORD PTR __Ch$[ebp+2]
	push	eax
	lea	eax, DWORD PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Res$2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	push	eax
	lea	eax, DWORD PTR __Res$1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Res$2[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	cmp	DWORD PTR __Res$1[ebp+16], 1
	mov	ecx, DWORD PTR __Res$1[ebp+20]
	mov	edx, DWORD PTR __Res$1[ebp]
	jne	SHORT $LN72@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Res$1[ebp]
	cmovae	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	movzx	esi, WORD PTR [eax]
	jmp	SHORT $LN73@operator
$LN72@operator:
	movzx	esi, WORD PTR __Ch$[ebp]
$LN73@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN111@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	eax, DWORD PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	edx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN111@operator:
	cmp	di, si
	pop	edi
	sete	al
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 230  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??R?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z ENDP ; std::_Cmp_collate<std::regex_traits<wchar_t> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@@Z
_TEXT	SEGMENT
__Tr$ = 8						; size = 4
??0?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@@Z PROC ; std::_Cmp_collate<std::regex_traits<wchar_t> >::_Cmp_collate<std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 224  : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp

; 223  : 		: _Traits(_Tr)

	mov	eax, DWORD PTR __Tr$[ebp]
	mov	DWORD PTR [ecx], eax

; 225  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@@Z ENDP ; std::_Cmp_collate<std::regex_traits<wchar_t> >::_Cmp_collate<std::regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Cmp_chrange@PB_WPB_WU?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_icase@V?$regex_traits@_W@std@@@0@@Z
_TEXT	SEGMENT
__Begin2$1$ = -4					; size = 4
__Res$1$ = 8						; size = 4
__Begin1$ = 8						; size = 4
__End1$ = 12						; size = 4
__Begin2$ = 16						; size = 4
__End2$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Cmp_chrange@PB_WPB_WU?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_icase@V?$regex_traits@_W@std@@@0@@Z PROC ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::regex_traits<wchar_t> > >, COMDAT

; 4337 : 	{	// compare character ranges

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 4338 : 	_BidIt1 _Res = _Begin1;
; 4339 : 	while (_Begin1 != _End1 && _Begin2 != _End2)

	mov	eax, DWORD PTR __End2$[ebp]
	mov	ecx, DWORD PTR __Begin2$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Begin1$[ebp]
	mov	edx, esi
	push	edi
	mov	DWORD PTR __Res$1$[ebp], edx
	cmp	esi, DWORD PTR __End1$[ebp]
	je	SHORT $LN3@Cmp_chrang
	mov	DWORD PTR __Begin2$1$[ebp], ecx
	npad	1
$LL2@Cmp_chrang:
	cmp	ecx, eax
	je	SHORT $LN21@Cmp_chrang

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	movzx	ebx, WORD PTR [ecx]

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR __Pred$[ebp]

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	movzx	ecx, WORD PTR [esi]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z
	movzx	edi, ax

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR __Pred$[ebp]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	ebx
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	mov	ecx, DWORD PTR __Begin2$1$[ebp]
	add	esi, 2
	add	ecx, 2
	mov	DWORD PTR __Begin2$1$[ebp], ecx

; 207  : 		return (_Traits.translate_nocase(_E1)

	cmp	di, ax

; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))

	jne	SHORT $LN17@Cmp_chrang

; 4338 : 	_BidIt1 _Res = _Begin1;
; 4339 : 	while (_Begin1 != _End1 && _Begin2 != _End2)

	mov	eax, DWORD PTR __End2$[ebp]
	cmp	esi, DWORD PTR __End1$[ebp]
	jne	SHORT $LL2@Cmp_chrang
$LN21@Cmp_chrang:
	mov	edx, DWORD PTR __Res$1$[ebp]
$LN3@Cmp_chrang:

; 4342 : 	return (_Begin2 == _End2 ? _Begin1 : _Res);

	cmp	ecx, eax
	pop	edi
	cmove	edx, esi
	pop	esi
	mov	eax, edx
	pop	ebx

; 4343 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@Cmp_chrang:

; 4341 : 			return (_Res);

	mov	eax, DWORD PTR __Res$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 4343 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Cmp_chrange@PB_WPB_WU?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_icase@V?$regex_traits@_W@std@@@0@@Z ENDP ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::regex_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??R?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z
_TEXT	SEGMENT
__E1$ = 8						; size = 2
__E2$ = 12						; size = 2
??R?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z PROC ; std::_Cmp_icase<std::regex_traits<wchar_t> >::operator(), COMDAT
; _this$ = ecx

; 206  : 		{	// return true if equal

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	DWORD PTR __E1$[ebp]

; 206  : 		{	// return true if equal

	mov	edi, ecx

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [edi]

; 301  : 		return (_Getctype()->tolower(_Ch));

	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z
	push	DWORD PTR __E2$[ebp]
	movzx	esi, ax

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [edi]

; 301  : 		return (_Getctype()->tolower(_Ch));

	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 207  : 		return (_Traits.translate_nocase(_E1)

	xor	ecx, ecx
	cmp	si, ax
	pop	edi
	sete	al
	pop	esi

; 208  : 			== _Traits.translate_nocase(_E2));
; 209  : 		}

	pop	ebp
	ret	8
??R?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@QAE_N_W0@Z ENDP ; std::_Cmp_icase<std::regex_traits<wchar_t> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@@Z
_TEXT	SEGMENT
__Tr$ = 8						; size = 4
??0?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@@Z PROC ; std::_Cmp_icase<std::regex_traits<wchar_t> >::_Cmp_icase<std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 202  : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp

; 201  : 		: _Traits(_Tr)

	mov	eax, DWORD PTR __Tr$[ebp]
	mov	DWORD PTR [ecx], eax

; 203  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@@Z ENDP ; std::_Cmp_icase<std::regex_traits<wchar_t> >::_Cmp_icase<std::regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PB_WPB_W@std@@YAAAPB_WAAPB_WPB_W@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PB_WPB_W@std@@YAAAPB_WAAPB_WPB_W@Z PROC	; std::_Rechecked<wchar_t const *,wchar_t const *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PB_WPB_W@std@@YAAAPB_WAAPB_WPB_W@Z ENDP	; std::_Rechecked<wchar_t const *,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Find_unchecked@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z PROC ; std::_Find_unchecked<wchar_t const *,enum std::_Meta_type>, COMDAT

; 3169 : 	{	// find first matching _Val; choose optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 3170 : 	// activate optimization for pointers to (const) bytes and integral values
; 3171 : 	typedef integral_constant<bool,
; 3172 : 		(is_same<_InIt, char *>::value
; 3173 : 		|| is_same<_InIt, signed char *>::value
; 3174 : 		|| is_same<_InIt, unsigned char *>::value
; 3175 : 		|| is_same<_InIt, const char *>::value
; 3176 : 		|| is_same<_InIt, const signed char *>::value
; 3177 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3178 : 		&& is_integral<_Ty>::value
; 3179 : 	> _Memchr_opt;
; 3180 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

	mov	eax, DWORD PTR __First$[ebp]

; 3160 : 	for (; _First != _Last; ++_First)

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	eax, edx
	je	SHORT $LN10@Find_unche

; 3161 : 		if (*_First == _Val)

	mov	ecx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR [ecx]
$LL6@Find_unche:
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, esi
	je	SHORT $LN16@Find_unche

; 3160 : 	for (; _First != _Last; ++_First)

	add	eax, 2
	cmp	eax, edx
	jne	SHORT $LL6@Find_unche
$LN16@Find_unche:
	pop	esi
$LN10@Find_unche:

; 3181 : 	}

	pop	ebp
	ret	0
??$_Find_unchecked@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z ENDP ; std::_Find_unchecked<wchar_t const *,enum std::_Meta_type>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PB_W@std@@YAPB_WPB_W@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PB_W@std@@YAPB_WPB_W@Z PROC		; std::_Unchecked<wchar_t const *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PB_W@std@@YAPB_WPB_W@Z ENDP		; std::_Unchecked<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$advance@PB_WH@std@@YAXAAPB_WH@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PB_WH@std@@YAXAAPB_WH@Z PROC			; std::advance<wchar_t const *,int>, COMDAT

; 1085 : 	{	// increment iterator by offset, arbitrary iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR __Where$[ebp]
	add	DWORD PTR [eax], ecx

; 1086 : 		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
; 1087 : 	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
; 1088 : 	}

	pop	ebp
	ret	0
??$advance@PB_WH@std@@YAXAAPB_WH@Z ENDP			; std::advance<wchar_t const *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Oldsize$1$ = -24					; size = 4
__Newcapacity$2 = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 1
$T4 = 8							; size = 1
__Newvec$5 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Udefault_or_fill$ = 12				; size = 8
??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Resize<<lambda_b34abe9eb6f8b770c54a1bf984cd7e79> >, COMDAT
; _this$ = ecx

; 1442 : 		{	// trim or append elements, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 1443 : 		const size_type _Oldsize = size();
; 1444 : 		const size_type _Oldcapacity = capacity();
; 1445 : 
; 1446 : 		if (_Newsize > _Oldcapacity)

	mov	esi, DWORD PTR __Newsize$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ebx, DWORD PTR [edi+4]
	mov	eax, ebx
	mov	edx, DWORD PTR [edi]
	sub	eax, edx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	eax, 2

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	ecx, 2

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1443 : 		const size_type _Oldsize = size();
; 1444 : 		const size_type _Oldcapacity = capacity();
; 1445 : 
; 1446 : 		if (_Newsize > _Oldcapacity)

	cmp	esi, ecx
	jbe	$LN2@Resize

; 1447 : 			{	// reallocate
; 1448 : 			if (_Newsize > max_size())

	cmp	esi, 1073741823				; 3fffffffH
	jbe	SHORT $LN4@Resize

; 1449 : 				{
; 1450 : 				_Xlength();

	call	?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlength
$LN350@Resize:
$LN4@Resize:

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, ecx
	mov	eax, 1073741823				; 3fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN76@Resize

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	ebx, esi
	mov	DWORD PTR __Newcapacity$2[ebp], esi
	jmp	SHORT $LN77@Resize
$LN76@Resize:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	ebx, DWORD PTR [edx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	ebx, esi
	cmovb	ebx, esi
	mov	DWORD PTR __Newcapacity$2[ebp], ebx
$LN77@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	ebx
	mov	ecx, edi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1456 : 			const pointer _Appended_first = _Newvec + _Oldsize;

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	mov	DWORD PTR __Newvec$5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1459 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1456 : 			const pointer _Appended_first = _Newvec + _Oldsize;

	lea	edx, DWORD PTR [eax+ecx*4]

; 1460 : 			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1460 : 			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);

	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	eax
	push	edx
	call	??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR [edi+4]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Newvec$5[ebp]
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN183@Resize

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN183@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$5[ebp]
	mov	DWORD PTR [edi], ecx

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	lea	eax, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [edi+8], eax

; 1485 : 			}
; 1486 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z$0:

; 1461 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 1462 : 			_CATCH_ALL
; 1463 : 			_Destroy(_Appended_first, _Appended_last);
; 1464 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR __Newvec$5[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate

; 1465 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN351@Resize:
$LN2@Resize:

; 1466 : 			_CATCH_END
; 1467 : 
; 1468 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1469 : 			}
; 1470 : 		else if (_Newsize > _Oldsize)

	cmp	esi, eax
	jbe	SHORT $LN348@Resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1473 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);

	sub	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp]
	push	DWORD PTR __Udefault_or_fill$[ebp+4]
	push	esi
	push	ebx
	call	??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1996 : 		}

	jmp	SHORT $LN349@Resize
$LN348@Resize:

; 1474 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1475 : 			}
; 1476 : 		else if (_Newsize == _Oldsize)

	je	SHORT $LN9@Resize

; 1477 : 			{	// nothing to do, avoid invalidating iterators
; 1478 : 			}
; 1479 : 		else
; 1480 : 			{	// trim
; 1481 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]
$LN349@Resize:

; 1482 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1483 : 			_Destroy(_Newlast, this->_Mylast());
; 1484 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [edi+4], eax
$LN9@Resize:

; 1485 : 			}
; 1486 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN347@Resize:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Resize<<lambda_b34abe9eb6f8b770c54a1bf984cd7e79> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@QAE@QAV?$vector@IV?$allocator@_N@std@@@std@@ABI@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
_<_Val>$ = 12						; size = 4
??0<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@QAE@QAV?$vector@IV?$allocator@_N@std@@@std@@ABI@Z PROC ; <lambda_b34abe9eb6f8b770c54a1bf984cd7e79>::<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>, COMDAT
; _this$ = ecx

; 1504 : 			};

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __This$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Val>$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@QAE@QAV?$vector@IV?$allocator@_N@std@@@std@@ABI@Z ENDP ; <lambda_b34abe9eb6f8b770c54a1bf984cd7e79>::<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??R<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@QBEPAIPAII@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
$T1 = 12						; size = 1
__Count$ = 12						; size = 4
??R<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@QBEPAIPAII@Z PROC ; <lambda_b34abe9eb6f8b770c54a1bf984cd7e79>::operator(), COMDAT
; _this$ = ecx

; 1502 : 			{

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [ecx]
	push	DWORD PTR [ecx+4]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1504 : 			};

	pop	ebp
	ret	8
??R<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@QBEPAIPAII@Z ENDP ; <lambda_b34abe9eb6f8b770c54a1bf984cd7e79>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2517 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 866  : 	return {};

	mov	BYTE PTR $T2[ebp], 0

; 2518 : 	_DEPRECATE_UNCHECKED(copy_backward, _Dest);
; 2519 : 	_DEBUG_RANGE(_First, _Last);
; 2520 : 	const auto _UFirst = _Unchecked(_First);
; 2521 : 	const auto _ULast = _Unchecked(_Last);
; 2522 : 	const auto _UDest = _Unchecked_n_backward(_Dest, _Idl_distance(_UFirst, _ULast));
; 2523 : 	return (_Rechecked(_Dest,

	lea	eax, DWORD PTR $T1[ebp]
	push	DWORD PTR $T2[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, edx
	mov	DWORD PTR [edx+4], ecx

; 2524 : 		_Copy_backward_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest))));
; 2525 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z PROC		; std::_Unfancy_maybe_null<unsigned int>, COMDAT

; 692  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 693  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 694  : 	}

	pop	ebp
	ret	0
??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ENDP		; std::_Unfancy_maybe_null<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >, COMDAT

; 260  : 	{	// value-initialize _Count objects to raw _First, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 261  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 16					; 00000010H

; 263  : 		_Conjunction_t<
; 264  : 			is_pointer<_FwdIt>,
; 265  : 			is_scalar<_Ty>,
; 266  : 			negation<is_volatile<_Ty>>,
; 267  : 			negation<is_member_pointer<_Ty>>,
; 268  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>()));
; 269  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >, COMDAT

; 2349 : 	{	// copy [_First, _Last) to [_Dest, ...)

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 866  : 	return {};

	mov	BYTE PTR $T2[ebp], 0

; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	lea	eax, DWORD PTR $T1[ebp]
	push	DWORD PTR $T2[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >

; 2341 : 	return (_Rechecked(_Dest,

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	add	esp, 32					; 00000020H

; 2341 : 	return (_Rechecked(_Dest,

	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 2350 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2351 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));
; 2352 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z PROC ; std::fill<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>, COMDAT

; 2710 : 	{	// copy _Val through [_First, _Last)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2682 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
	add	esp, 24					; 00000018H

; 2711 : 	_DEBUG_RANGE(_First, _Last);
; 2712 : 	_Fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2713 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$fill@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_N@Z ENDP ; std::fill<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_Loop_vals_t@std@@PAU12@V?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAU_Loop_vals_t@std@@PAU12@V?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::_Loop_vals_t *,std::_Loop_vals_t *,std::allocator<std::_Loop_vals_t> >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 176  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAU_Loop_vals_t@std@@PAU12@V?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::_Loop_vals_t *,std::_Loop_vals_t *,std::allocator<std::_Loop_vals_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Oldsize$1$ = -24					; size = 4
$T2 = -24						; size = 1
__Oldcapacity$1$ = -20					; size = 4
__Newcapacity$3 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newvec$4 = 8						; size = 4
__Newsize$ = 8						; size = 4
$T5 = 12						; size = 1
$T6 = 12						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Resize<<lambda_cfdb45d3a034db37f9e74d96913a06ba> >, COMDAT
; _this$ = ecx

; 1442 : 		{	// trim or append elements, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH

; 1442 : 		{	// trim or append elements, provide strong guarantee

	push	esi

; 1443 : 		const size_type _Oldsize = size();
; 1444 : 		const size_type _Oldcapacity = capacity();
; 1445 : 
; 1446 : 		if (_Newsize > _Oldcapacity)

	mov	esi, DWORD PTR __Newsize$[ebp]
	push	edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [ebx]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	imul	edx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH

; 1442 : 		{	// trim or append elements, provide strong guarantee

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	edi, edx

; 1442 : 		{	// trim or append elements, provide strong guarantee

	mov	DWORD PTR _this$[ebp], ebx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	shr	edi, 31					; 0000001fH
	add	edi, edx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	imul	ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	DWORD PTR __Oldsize$1$[ebp], edi

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Oldcapacity$1$[ebp], eax

; 1443 : 		const size_type _Oldsize = size();
; 1444 : 		const size_type _Oldcapacity = capacity();
; 1445 : 
; 1446 : 		if (_Newsize > _Oldcapacity)

	cmp	esi, eax
	jbe	$LN2@Resize

; 1447 : 			{	// reallocate
; 1448 : 			if (_Newsize > max_size())

	cmp	esi, 357913941				; 15555555H
	jbe	SHORT $LN4@Resize

; 1449 : 				{
; 1450 : 				_Xlength();

	call	?_Xlength@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@CAXXZ ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Xlength
$LN255@Resize:
$LN4@Resize:

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, DWORD PTR __Oldcapacity$1$[ebp]
	mov	ecx, eax
	shr	ecx, 1
	mov	eax, 357913941				; 15555555H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN76@Resize

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	edi, esi
	mov	DWORD PTR __Newcapacity$3[ebp], esi
	jmp	SHORT $LN77@Resize
$LN76@Resize:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	edi, DWORD PTR [ecx+edx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	edi, esi
	cmovb	edi, esi
	mov	DWORD PTR __Newcapacity$3[ebp], edi
$LN77@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	mov	ecx, ebx
	call	?allocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z ; std::allocator<std::sub_match<wchar_t const *> >::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1456 : 			const pointer _Appended_first = _Newvec + _Oldsize;

	mov	edx, DWORD PTR __Oldsize$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1455 : 			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1456 : 			const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [edx+edx*2]

; 1457 : 			pointer _Appended_last = _Appended_first;
; 1458 : 
; 1459 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR [eax+ecx*4]

; 1460 : 			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);

	mov	eax, esi
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	eax
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 893  : 	return {};

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T2[ebp]
	push	ebx
	push	DWORD PTR __Newvec$4[ebp]
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx]
	call	??$_Uninitialized_move_al_unchecked@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1468 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	ecx, ebx
	push	edi
	push	esi
	push	DWORD PTR __Newvec$4[ebp]
	call	?_Change_array@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXQAV?$sub_match@PB_W@2@II@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Change_array

; 1485 : 			}
; 1486 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z$0:

; 1461 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 1462 : 			_CATCH_ALL
; 1463 : 			_Destroy(_Appended_first, _Appended_last);
; 1464 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR __Newvec$4[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::deallocate

; 1465 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN256@Resize:
$LN2@Resize:

; 1469 : 			}
; 1470 : 		else if (_Newsize > _Oldsize)

	cmp	esi, edi
	jbe	SHORT $LN253@Resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1473 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);

	sub	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp]
	push	esi
	push	DWORD PTR [ebx+4]
	call	??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1996 : 		}

	jmp	SHORT $LN254@Resize
$LN253@Resize:

; 1474 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1475 : 			}
; 1476 : 		else if (_Newsize == _Oldsize)

	je	SHORT $LN9@Resize

; 1477 : 			{	// nothing to do, avoid invalidating iterators
; 1478 : 			}
; 1479 : 		else
; 1480 : 			{	// trim
; 1481 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [ecx+eax*4]
$LN254@Resize:

; 1482 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1483 : 			_Destroy(_Newlast, this->_Mylast());
; 1484 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [ebx+4], eax
$LN9@Resize:

; 1485 : 			}
; 1486 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN252@Resize:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Resize<<lambda_cfdb45d3a034db37f9e74d96913a06ba> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@QAE@QAV?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@QAE@QAV?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@Z PROC ; <lambda_cfdb45d3a034db37f9e74d96913a06ba>::<lambda_cfdb45d3a034db37f9e74d96913a06ba>, COMDAT
; _this$ = ecx

; 1494 : 			};

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __This$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@QAE@QAV?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@Z ENDP ; <lambda_cfdb45d3a034db37f9e74d96913a06ba>::<lambda_cfdb45d3a034db37f9e74d96913a06ba>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??R<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@QBEPAV?$sub_match@PB_W@std@@PAV12@I@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
$T1 = 12						; size = 1
__Count$ = 12						; size = 4
??R<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@QBEPAV?$sub_match@PB_W@std@@PAV12@I@Z PROC ; <lambda_cfdb45d3a034db37f9e74d96913a06ba>::operator(), COMDAT
; _this$ = ecx

; 1492 : 			{

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [ecx]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1494 : 			};

	pop	ebp
	ret	8
??R<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@QBEPAV?$sub_match@PB_W@std@@PAV12@I@Z ENDP ; <lambda_cfdb45d3a034db37f9e74d96913a06ba>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT

; 260  : 	{	// value-initialize _Count objects to raw _First, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 261  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
	add	esp, 16					; 00000010H

; 263  : 		_Conjunction_t<
; 264  : 			is_pointer<_FwdIt>,
; 265  : 			is_scalar<_Ty>,
; 266  : 			negation<is_volatile<_Ty>>,
; 267  : 			negation<is_member_pointer<_Ty>>,
; 268  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>()));
; 269  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-, COMDAT
; _this$ = ecx

; 2499 : 		{	// return difference of iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5

; 2500 : 		return (*(_Mybase *)this - _Right);

	sub	eax, DWORD PTR [edx+4]

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	add	eax, DWORD PTR [ecx+4]

; 2501 : 		}

	pop	ebp
	ret	4
??G?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+, COMDAT
; _this$ = ecx

; 2482 : 		{	// return this + integer

	npad	2
	push	ebp
	mov	ebp, esp

; 2483 : 		_Mytype _Tmp = *this;

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx]

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	test	ecx, ecx
	jns	SHORT $LN6@operator
	mov	eax, ecx
	neg	eax
	cmp	edx, eax
	jae	SHORT $LN6@operator

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;

	add	edx, ecx

; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	eax, -4					; fffffffcH
	or	ecx, -1
	sub	ecx, edx
	shr	ecx, 5
	shl	ecx, 2
	sub	eax, ecx
	add	esi, eax

; 2484 : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH

; 2484 : 		return (_Tmp += _Off);

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2485 : 		}

	pop	ebp
	ret	8
$LN6@operator:

; 2263 : 			this->_Myoff += _Off;

	add	edx, ecx

; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, edx
	shr	eax, 5

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	lea	esi, DWORD PTR [esi+eax*4]

; 2484 : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2485 : 		}

	pop	ebp
	ret	8
??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 2476 : 		{	// increment by integer

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	test	ecx, ecx
	jns	SHORT $LN4@operator
	mov	edx, DWORD PTR [esi+4]
	mov	eax, ecx
	neg	eax
	cmp	edx, eax
	jae	SHORT $LN4@operator

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;

	add	edx, ecx

; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	eax, -4					; fffffffcH
	mov	ecx, edx
	not	ecx
	shr	ecx, 5
	shl	ecx, 2
	sub	eax, ecx
	add	DWORD PTR [esi], eax

; 2259 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	mov	DWORD PTR [esi+4], edx

; 2477 : 		*(_Mybase *)this += _Off;
; 2478 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2479 : 		}

	pop	ebp
	ret	4
$LN4@operator:

; 2263 : 			this->_Myoff += _Off;

	add	ecx, DWORD PTR [esi+4]

; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, ecx
	shr	eax, 5
	shl	eax, 2
	add	DWORD PTR [esi], eax

; 2265 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [esi+4], ecx

; 2477 : 		*(_Mybase *)this += _Off;
; 2478 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2479 : 		}

	pop	ebp
	ret	4
??Y?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--, COMDAT
; _this$ = ecx

; 2359 : 		if (this->_Myoff != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN6@operator

; 2360 : 			--this->_Myoff;

	dec	eax
	mov	DWORD PTR [ecx+4], eax

; 2464 : 		--*(_Mybase *)this;
; 2465 : 		return (*this);

	mov	eax, ecx

; 2466 : 		}

	ret	0
$LN6@operator:

; 2375 : 			--this->_Myptr;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 2464 : 		--*(_Mybase *)this;
; 2465 : 		return (*this);

	mov	eax, ecx

; 2374 : 			this->_Myoff = _VBITS - 1;

	mov	DWORD PTR [ecx+4], 31			; 0000001fH

; 2466 : 		}

	ret	0
??F?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++, COMDAT
; _this$ = ecx

; 2381 : 		if (this->_Myoff < _VBITS - 1)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 31					; 0000001fH
	jae	SHORT $LN6@operator

; 2382 : 			++this->_Myoff;

	inc	eax
	mov	DWORD PTR [ecx+4], eax

; 2451 : 		++*(_Mybase *)this;
; 2452 : 		return (*this);

	mov	eax, ecx

; 2453 : 		}

	ret	0
$LN6@operator:

; 2397 : 			++this->_Myptr;

	add	DWORD PTR [ecx], 4

; 2451 : 		++*(_Mybase *)this;
; 2452 : 		return (*this);

	mov	eax, ecx

; 2396 : 			this->_Myoff = 0;

	mov	DWORD PTR [ecx+4], 0

; 2453 : 		}

	ret	0
??E?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*, COMDAT
; _this$ = ecx

; 2445 : 		{	// return (reference to) designated object

	npad	2
	push	ebp
	mov	ebp, esp

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 2446 : 		return (_Reft(*this));
; 2447 : 		}

	pop	ebp
	ret	4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Mypvbool$ = 12					; size = 4
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2441 : 		{	// construct with offset and pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], eax

; 2442 : 		}

	mov	eax, ecx

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	DWORD PTR [ecx+4], 0

; 2442 : 		}

	pop	ebp
	ret	8
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PAIPAU_Container_base0@1@@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Inc, COMDAT
; _this$ = ecx

; 2381 : 		if (this->_Myoff < _VBITS - 1)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 31					; 0000001fH
	jae	SHORT $LN2@Inc

; 2382 : 			++this->_Myoff;

	inc	eax
	mov	DWORD PTR [ecx+4], eax

; 2398 : 			}
; 2399 : 		}

	ret	0
$LN2@Inc:

; 2383 : 		else
; 2384 : 			{	// move to next word
; 2385 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2386 : 			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
; 2387 : 				{	// report error
; 2388 : 				_DEBUG_ERROR("vector<bool> iterator not incrementable");
; 2389 : 				}
; 2390 : 
; 2391 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 2392 : 			_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 2393 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Valid(1) <= 0);
; 2394 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 2395 : 
; 2396 : 			this->_Myoff = 0;
; 2397 : 			++this->_Myptr;

	add	DWORD PTR [ecx], 4
	mov	DWORD PTR [ecx+4], 0

; 2398 : 			}
; 2399 : 		}

	ret	0
?_Inc@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Inc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Dec, COMDAT
; _this$ = ecx

; 2359 : 		if (this->_Myoff != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@Dec

; 2360 : 			--this->_Myoff;

	dec	eax
	mov	DWORD PTR [ecx+4], eax

; 2376 : 			}
; 2377 : 		}

	ret	0
$LN2@Dec:

; 2361 : 		else
; 2362 : 			{	// move to previous word
; 2363 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2364 : 			if (this->_Getcont() == 0 || 0 < this->_Valid((size_type)-1))
; 2365 : 				{	// report error
; 2366 : 				_DEBUG_ERROR("vector<bool> iterator not decrementable");
; 2367 : 				}
; 2368 : 
; 2369 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 2370 : 			_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 2371 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Valid((size_type)-1) <= 0);
; 2372 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 2373 : 
; 2374 : 			this->_Myoff = _VBITS - 1;
; 2375 : 			--this->_Myptr;

	add	DWORD PTR [ecx], -4			; fffffffcH
	mov	DWORD PTR [ecx+4], 31			; 0000001fH

; 2376 : 			}
; 2377 : 		}

	ret	0
?_Dec@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Dec
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Compat, COMDAT
; _this$ = ecx

; 2354 : 		}

	ret	4
?_Compat@?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=, COMDAT
; _this$ = ecx

; 2309 : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp

; 2304 : 		return (this->_Myptr == _Right._Myptr

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN5@operator
	mov	ecx, 1

; 2310 : 		return (!(*this == _Right));

	xor	eax, eax
	test	cl, cl
	sete	al

; 2311 : 		}

	pop	ebp
	ret	4
$LN5@operator:

; 2304 : 		return (this->_Myptr == _Right._Myptr

	xor	ecx, ecx

; 2310 : 		return (!(*this == _Right));

	xor	eax, eax
	test	cl, cl
	sete	al

; 2311 : 		}

	pop	ebp
	ret	4
??9?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator==, COMDAT
; _this$ = ecx

; 2302 : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp

; 2303 : 		_Compat(_Right);
; 2304 : 		return (this->_Myptr == _Right._Myptr

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN3@operator
	mov	al, 1

; 2305 : 			&& this->_Myoff == _Right._Myoff);
; 2306 : 		}

	pop	ebp
	ret	4
$LN3@operator:

; 2303 : 		_Compat(_Right);
; 2304 : 		return (this->_Myptr == _Right._Myptr

	xor	al, al

; 2305 : 			&& this->_Myoff == _Right._Myoff);
; 2306 : 		}

	pop	ebp
	ret	4
??8?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-, COMDAT
; _this$ = ecx

; 2289 : 		{	// return difference of iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 2290 : 		_Compat(_Right);
; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 2292 : 			+ (difference_type)this->_Myoff
; 2293 : 			- (difference_type)_Right._Myoff);
; 2294 : 		}

	pop	ebp
	ret	4
??G?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 2254 : 		{	// increment by integer

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	test	ecx, ecx
	jns	SHORT $LN2@operator
	mov	edx, DWORD PTR [esi+4]
	mov	eax, ecx
	neg	eax
	cmp	edx, eax
	jae	SHORT $LN2@operator

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;

	add	edx, ecx

; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	eax, -4					; fffffffcH
	mov	ecx, edx
	not	ecx
	shr	ecx, 5
	shl	ecx, 2
	sub	eax, ecx
	add	DWORD PTR [esi], eax

; 2259 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	mov	DWORD PTR [esi+4], edx

; 2266 : 			}
; 2267 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2268 : 		}

	pop	ebp
	ret	4
$LN2@operator:

; 2260 : 			}
; 2261 : 		else
; 2262 : 			{	/* add non-negative increment */
; 2263 : 			this->_Myoff += _Off;

	add	ecx, DWORD PTR [esi+4]

; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, ecx
	shr	eax, 5
	shl	eax, 2
	add	DWORD PTR [esi], eax

; 2265 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [esi+4], ecx

; 2266 : 			}
; 2267 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2268 : 		}

	pop	ebp
	ret	4
??Y?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--, COMDAT
; _this$ = ecx

; 2359 : 		if (this->_Myoff != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN4@operator

; 2360 : 			--this->_Myoff;

	dec	eax
	mov	DWORD PTR [ecx+4], eax

; 2242 : 		_Dec();
; 2243 : 		return (*this);

	mov	eax, ecx

; 2244 : 		}

	ret	0
$LN4@operator:

; 2375 : 			--this->_Myptr;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 2242 : 		_Dec();
; 2243 : 		return (*this);

	mov	eax, ecx

; 2374 : 			this->_Myoff = _VBITS - 1;

	mov	DWORD PTR [ecx+4], 31			; 0000001fH

; 2244 : 		}

	ret	0
??F?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++, COMDAT
; _this$ = ecx

; 2381 : 		if (this->_Myoff < _VBITS - 1)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 31					; 0000001fH
	jae	SHORT $LN4@operator

; 2382 : 			++this->_Myoff;

	inc	eax
	mov	DWORD PTR [ecx+4], eax

; 2229 : 		_Inc();
; 2230 : 		return (*this);

	mov	eax, ecx

; 2231 : 		}

	ret	0
$LN4@operator:

; 2397 : 			++this->_Myptr;

	add	DWORD PTR [ecx], 4

; 2229 : 		_Inc();
; 2230 : 		return (*this);

	mov	eax, ecx

; 2396 : 			this->_Myoff = 0;

	mov	DWORD PTR [ecx+4], 0

; 2231 : 		}

	ret	0
??E?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Mypvbool$ = 12					; size = 4
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2219 : 		{	// construct with offset and pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], eax

; 2220 : 		}

	mov	eax, ecx

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	DWORD PTR [ecx+4], 0

; 2220 : 		}

	pop	ebp
	ret	8
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base0@1@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newvec$2 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$3 = 8					; size = 4
__Newsize$ = 8						; size = 4
$T4 = 12						; size = 1
$T5 = 12						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Resize<<lambda_3726096f4ce354b1c936d6bab7ace3a2> >, COMDAT
; _this$ = ecx

; 1442 : 		{	// trim or append elements, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 1443 : 		const size_type _Oldsize = size();
; 1444 : 		const size_type _Oldcapacity = capacity();
; 1445 : 
; 1446 : 		if (_Newsize > _Oldcapacity)

	mov	esi, DWORD PTR __Newsize$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [edi+4]
	mov	ebx, edx
	mov	eax, DWORD PTR [edi]
	sub	ebx, eax

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	ebx, 3

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	ecx, 3

; 1443 : 		const size_type _Oldsize = size();
; 1444 : 		const size_type _Oldcapacity = capacity();
; 1445 : 
; 1446 : 		if (_Newsize > _Oldcapacity)

	cmp	esi, ecx
	jbe	$LN2@Resize

; 1447 : 			{	// reallocate
; 1448 : 			if (_Newsize > max_size())

	cmp	esi, 536870911				; 1fffffffH
	jbe	SHORT $LN4@Resize

; 1449 : 				{
; 1450 : 				_Xlength();

	call	?_Xlength@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@CAXXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Xlength
$LN350@Resize:
$LN4@Resize:

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, ecx
	mov	eax, 536870911				; 1fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN76@Resize

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, esi
	mov	DWORD PTR __Newcapacity$3[ebp], esi
	jmp	SHORT $LN77@Resize
$LN76@Resize:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, esi
	cmovb	eax, esi
	mov	DWORD PTR __Newcapacity$3[ebp], eax
$LN77@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	mov	ecx, edi
	call	?allocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1455 : 			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1456 : 			const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [eax+ebx*8]

; 1457 : 			pointer _Appended_last = _Appended_first;
; 1458 : 
; 1459 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1460 : 			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);

	mov	eax, esi
	sub	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	eax
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR [edi+4]

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	ebx, DWORD PTR __Newvec$2[ebp]
	sub	eax, ecx
	push	eax
	push	ecx
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN183@Resize

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN183@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	lea	eax, DWORD PTR [ebx+esi*8]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$3[ebp]
	lea	eax, DWORD PTR [ebx+eax*8]
	mov	DWORD PTR [edi+8], eax

; 1485 : 			}
; 1486 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z$0:

; 1461 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 1462 : 			_CATCH_ALL
; 1463 : 			_Destroy(_Appended_first, _Appended_last);
; 1464 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR __Newvec$2[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::deallocate

; 1465 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN351@Resize:
$LN2@Resize:

; 1466 : 			_CATCH_END
; 1467 : 
; 1468 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1469 : 			}
; 1470 : 		else if (_Newsize > _Oldsize)

	cmp	esi, ebx
	jbe	SHORT $LN348@Resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1473 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);

	sub	esi, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp]
	push	esi
	push	edx
	call	??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1996 : 		}

	jmp	SHORT $LN349@Resize
$LN348@Resize:

; 1474 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1475 : 			}
; 1476 : 		else if (_Newsize == _Oldsize)

	je	SHORT $LN9@Resize

; 1477 : 			{	// nothing to do, avoid invalidating iterators
; 1478 : 			}
; 1479 : 		else
; 1480 : 			{	// trim
; 1481 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	eax, DWORD PTR [eax+esi*8]
$LN349@Resize:

; 1482 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1483 : 			_Destroy(_Newlast, this->_Mylast());
; 1484 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [edi+4], eax
$LN9@Resize:

; 1485 : 			}
; 1486 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN347@Resize:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Resize<<lambda_3726096f4ce354b1c936d6bab7ace3a2> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@QAE@QAV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@QAE@QAV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@Z PROC ; <lambda_3726096f4ce354b1c936d6bab7ace3a2>::<lambda_3726096f4ce354b1c936d6bab7ace3a2>, COMDAT
; _this$ = ecx

; 1494 : 			};

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __This$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@QAE@QAV?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@Z ENDP ; <lambda_3726096f4ce354b1c936d6bab7ace3a2>::<lambda_3726096f4ce354b1c936d6bab7ace3a2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??R<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@QBEPAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@I@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
$T1 = 12						; size = 1
__Count$ = 12						; size = 4
??R<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@QBEPAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@I@Z PROC ; <lambda_3726096f4ce354b1c936d6bab7ace3a2>::operator(), COMDAT
; _this$ = ecx

; 1492 : 			{

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [ecx]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1494 : 			};

	pop	ebp
	ret	8
??R<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@QBEPAU_Grp_t@?$_Tgt_state_t@PB_W@std@@PAU123@I@Z ENDP ; <lambda_3726096f4ce354b1c936d6bab7ace3a2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >, COMDAT

; 184  : 	{	// copy _Count copies of _Val to raw _First, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 188  : 	for (; 0 < _Count; --_Count, (void)++_First)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	test	edx, edx
	je	SHORT $LN3@Uninit_all
	push	esi
	mov	esi, DWORD PTR __Val$[ebp]
$LL4@Uninit_all:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN2@Uninit_all
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$LN2@Uninit_all:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 188  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	eax, 4
	sub	edx, 1
	jne	SHORT $LL4@Uninit_all
	pop	esi
$LN3@Uninit_all:

; 189  : 		{
; 190  : 		_Al.construct(_Unfancy(_First), _Val);
; 191  : 		}
; 192  : 
; 193  : 	_CATCH_ALL
; 194  : 	_Destroy_range(_Next, _First, _Al);
; 195  : 	_RERAISE;
; 196  : 	_CATCH_END
; 197  : 
; 198  : 	return (_First);
; 199  : 	}

	pop	ebp
	ret	0
??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@I@std@@YAPAIPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@I@std@@YAPAIPAI@Z PROC			; std::_Unfancy<unsigned int>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@I@std@@YAPAIPAI@Z ENDP			; std::_Unfancy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<bool> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0ABV?$allocator@_N@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_N@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<bool> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z PROC ; std::forward<std::allocator<bool> const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABV?$allocator@_N@std@@@std@@YAABV?$allocator@_N@0@ABV10@@Z ENDP ; std::forward<std::allocator<bool> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Move_unchecked1<unsigned int *,unsigned int *>, COMDAT

; 2542 : 	{	// move [_First, _Last) to [_Dest, ...), memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2543 : 	return (_Copy_memmove(_First, _Last, _Dest));
; 2544 : 	}

	pop	ebp
	ret	0
??$_Move_unchecked1@PAIPAI@std@@YAPAIPAI00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Move_unchecked1<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z PROC ; std::_Ptr_move_cat<unsigned int,unsigned int>, COMDAT

; 892  : 	{	// return pointer move optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 893  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 894  : 	}

	pop	ebp
	ret	0
??$_Ptr_move_cat@II@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAI0@Z ENDP ; std::_Ptr_move_cat<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >, COMDAT

; 228  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Uninitiali
	npad	1
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN2@Uninitiali
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	eax, 8
	sub	ecx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 233  : 		{
; 234  : 		_Al.construct(_Unfancy(_First));
; 235  : 		}
; 236  : 
; 237  : 	_CATCH_ALL
; 238  : 	_Destroy_range(_Next, _First, _Al);
; 239  : 	_RERAISE;
; 240  : 	_CATCH_END
; 241  : 
; 242  : 	return (_First);
; 243  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@U_Loop_vals_t@std@@@std@@YAPAU_Loop_vals_t@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Loop_vals_t@std@@@std@@YAPAU_Loop_vals_t@0@PAU10@@Z PROC ; std::_Unfancy<std::_Loop_vals_t>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@U_Loop_vals_t@std@@@std@@YAPAU_Loop_vals_t@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Loop_vals_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@U_Loop_vals_t@std@@@std@@PAU_Loop_vals_t@2@@std@@YAXPAU_Loop_vals_t@0@0AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@U_Loop_vals_t@std@@@std@@PAU_Loop_vals_t@2@@std@@YAXPAU_Loop_vals_t@0@0AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<std::_Loop_vals_t>,std::_Loop_vals_t *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@U_Loop_vals_t@std@@@std@@PAU_Loop_vals_t@2@@std@@YAXPAU_Loop_vals_t@0@0AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<std::_Loop_vals_t>,std::_Loop_vals_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@PAU_Grp_t@?$_Tgt_state_t@PB_W@2@@std@@YAXPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@PAU_Grp_t@?$_Tgt_state_t@PB_W@2@@std@@YAXPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@PAU_Grp_t@?$_Tgt_state_t@PB_W@2@@std@@YAXPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask, COMDAT
; _this$ = ecx

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, 1
	shl	eax, cl

; 2182 : 		}

	ret	0
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr, COMDAT
; _this$ = ecx

; 2162 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2163 : 		if (this->_Getcont() == 0
; 2164 : 			|| this->_Myptr == 0
; 2165 : 			|| 0 <= this->_Valid(0))
; 2166 : 			{	// report error
; 2167 : 			_DEBUG_ERROR("vector<bool> iterator not dereferencable");
; 2168 : 			}
; 2169 : 
; 2170 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 2171 : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Myptr != 0);
; 2172 : 		_SCL_SECURE_VALIDATE_RANGE(this->_Valid(0) < 0);
; 2173 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 2174 : 
; 2175 : 		return (this->_Myptr);

	mov	eax, DWORD PTR [ecx]

; 2176 : 		}

	ret	0
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool, COMDAT
; _this$ = ecx

; 2156 : 		{	// test if bit is set

	mov	eax, ecx

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	edx, 1
	mov	ecx, DWORD PTR [eax+4]

; 2175 : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax]

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	shl	edx, cl

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	edx, DWORD PTR [eax]
	setne	al

; 2158 : 		}

	ret	0
??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=, COMDAT
; _this$ = ecx

; 2142 : 		{	// assign _Val to bit

	npad	2
	push	ebp
	mov	ebp, esp

; 2143 : 		if (_Val)

	cmp	BYTE PTR __Val$[ebp], 0
	push	edi
	mov	edi, ecx

; 2144 : 			*(_Vbase *)_Getptr() |= _Mask();

	mov	eax, DWORD PTR [edi+4]
	je	SHORT $LN2@operator
	push	esi

; 2175 : 		return (this->_Myptr);

	mov	esi, DWORD PTR [edi]

; 2144 : 			*(_Vbase *)_Getptr() |= _Mask();

	mov	edx, DWORD PTR [esi]
	bts	edx, eax

; 2147 : 		return (*this);

	mov	eax, edi
	mov	DWORD PTR [esi], edx
	pop	esi
	pop	edi

; 2148 : 		}

	pop	ebp
	ret	4
$LN2@operator:

; 2175 : 		return (this->_Myptr);

	mov	edx, DWORD PTR [edi]

; 2145 : 		else
; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	mov	ecx, DWORD PTR [edx]
	btr	ecx, eax

; 2147 : 		return (*this);

	mov	eax, edi
	mov	DWORD PTR [edx], ecx
	pop	edi

; 2148 : 		}

	pop	ebp
	ret	4
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=, COMDAT
; _this$ = ecx

; 2137 : 		{	// assign _Vb_reference _Right to bit

	npad	2
	push	ebp
	mov	ebp, esp

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, 1
	push	esi

; 2137 : 		{	// assign _Vb_reference _Right to bit

	mov	esi, ecx

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	ecx, DWORD PTR [eax+4]

; 2175 : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax]

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	shl	edx, cl

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	edx, DWORD PTR [eax]

; 2175 : 		return (this->_Myptr);

	mov	edx, DWORD PTR [esi]

; 2144 : 			*(_Vbase *)_Getptr() |= _Mask();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edx]
	je	SHORT $LN11@operator
	bts	ecx, eax

; 2138 : 		return (*this = bool(_Right));

	mov	eax, esi

; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	mov	DWORD PTR [edx], ecx
	pop	esi

; 2139 : 		}

	pop	ebp
	ret	4
$LN11@operator:

; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	btr	ecx, eax

; 2138 : 		return (*this = bool(_Right));

	mov	eax, esi

; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	mov	DWORD PTR [edx], ecx
	pop	esi

; 2139 : 		}

	pop	ebp
	ret	4
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2133 : 		{	// construct with base

	npad	2
	push	ebp
	mov	ebp, esp

; 2087 : 		{	// construct with offset and pointer
; 2088 : 		this->_Adopt(_Mypvbool);
; 2089 : 		}
; 2090 : 
; 2091 : 	void _Advance(_Sizet _Off)
; 2092 : 		{	// advance iterator by _Off
; 2093 : 		_Myoff += _Off;
; 2094 : 		_Myptr += _Myoff / _VBITS;
; 2095 : 		_Myoff %= _VBITS;
; 2096 : 		}
; 2097 : 
; 2098 : 	int _Valid(_Sizet _Inc) const
; 2099 : 		{	// test for valid incremented offset
; 2100 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2101 : 		const auto _Cont = static_cast<const _Mycont *>(this->_Getcont());
; 2102 : 		_Sizet _Mysize = _Cont->_Mysize;
; 2103 : 
; 2104 : 		_Inc += _Myoff;
; 2105 : 		_Inc += _VBITS * (_Myptr - _Cont->_Myvec.data());
; 2106 : 		return (_Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1);
; 2107 : 
; 2108 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2109 : 		(void)_Inc;
; 2110 : 		return (-1);
; 2111 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2112 : 		}
; 2113 : 
; 2114 : 	const _Vbase *_Myptr;
; 2115 : 	_Sizet _Myoff;
; 2116 : 	};
; 2117 : 
; 2118 : 		// CLASS _Vb_reference
; 2119 : template<class _Alloc>
; 2120 : 	class _Vb_reference
; 2121 : 		: public _Vb_iter_base<_Alloc>
; 2122 : 	{	// reference to a bit within a base word
; 2123 : 	typedef _Vb_iter_base<_Alloc> _Mybase;
; 2124 : 	typedef _Vb_reference<_Alloc> _Mytype;
; 2125 : 
; 2126 : 	_Vb_reference() _NOEXCEPT
; 2127 : 		{	// construct with null pointer (private)
; 2128 : 		}
; 2129 : 
; 2130 : public:
; 2131 : 	_Vb_reference(const _Mybase& _Right)
; 2132 : 		: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 2134 : 		}

	mov	eax, ecx

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	DWORD PTR [ecx+4], edx

; 2134 : 		}

	pop	ebp
	ret	4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance, COMDAT
; _this$ = ecx

; 2092 : 		{	// advance iterator by _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 2093 : 		_Myoff += _Off;

	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR __Off$[ebp]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	eax, edx
	shr	eax, 5
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 2095 : 		_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	mov	DWORD PTR [ecx+4], edx

; 2096 : 		}

	pop	ebp
	ret	4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Mypvbool$ = 16					; size = 4
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2087 : 		{	// construct with offset and pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2088 : 		this->_Adopt(_Mypvbool);
; 2089 : 		}

	mov	eax, ecx
	pop	ebp
	ret	12					; 0000000cH
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base0@1@@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 24
$T3 = -88						; size = 24
__Str1$ = -64						; size = 24
__Str0$ = -40						; size = 24
__$EHRec$ = -12						; size = 12
__Ch$ = 8						; size = 2
__Ix$1$ = 12						; size = 4
__Eq$ = 12						; size = 4
$T4 = 15						; size = 1
__Traits$ = 16						; size = 4
??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z PROC ; std::_Lookup_equiv<wchar_t,std::regex_traits<wchar_t> >, COMDAT

; 4383 : 	{	// check whether _Ch is in _Eq

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Str0$[ebp+16], 0
	push	edi

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str0$[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR __Str0$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4384 : 	typename _RxTraits::string_type _Str0;

	mov	DWORD PTR __$EHRec$[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	ax, WORD PTR __Ch$[ebp]
	mov	WORD PTR __Str1$[ebp], ax
	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str1$[ebp+20], 7

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str1$[ebp+16], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR __Str1$[ebp+2], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4386 : 	_Str1 = _Traits.transform_primary(_Str1.begin(), _Str1.end());

	mov	ecx, DWORD PTR __Traits$[ebp]
	lea	eax, DWORD PTR __Str1$[ebp+2]
	push	eax
	lea	eax, DWORD PTR __Str1$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::_Regex_traits<wchar_t>::transform_primary<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2076 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __Str1$[ebp]
	cmp	eax, esi
	je	SHORT $LN312@Lookup_equ

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR __Str1$[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN243@Lookup_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR __Str1$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN243@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Str1$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str1$[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR __Str1$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [esi]
	movups	XMMWORD PTR __Str1$[ebp], xmm0
	movq	xmm0, QWORD PTR [esi+16]
	movq	QWORD PTR __Str1$[ebp+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], eax

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
$LN312@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN318@Lookup_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN318@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4387 : 	while (_Eq)

	mov	edi, DWORD PTR __Eq$[ebp]
	test	edi, edi
	je	$LN742@Lookup_equ
	npad	2
$LL2@Lookup_equ:

; 4389 : 		for (unsigned int _Ix = 0; _Ix < _Eq->_Data._Size(); _Ix += _Eq->_Sz)

	xor	ecx, ecx
	mov	DWORD PTR __Ix$1$[ebp], ecx
	cmp	DWORD PTR [edi+8], ecx
	jbe	$LN5@Lookup_equ
	npad	2
$LL6@Lookup_equ:

; 4390 : 			{	// look for _Ch
; 4391 : 			_Str0.assign(_Eq->_Data._Str() + _Ix, _Eq->_Sz);

	mov	eax, DWORD PTR [edi+12]
	push	DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ecx*2]
	push	eax
	lea	ecx, DWORD PTR __Str0$[ebp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str0$[ebp+20], 8

; 1614 : 		return (_Large_string_engaged()

	lea	ecx, DWORD PTR __Str0$[ebp]

; 2872 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));

	mov	eax, DWORD PTR __Str0$[ebp+16]

; 1614 : 		return (_Large_string_engaged()

	cmovae	ecx, DWORD PTR __Str0$[ebp]

; 2872 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));

	lea	eax, DWORD PTR [ecx+eax*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4392 : 			_Str0 = _Traits.transform_primary(_Str0.begin(), _Str0.end());

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	lea	ecx, DWORD PTR __Str0$[ebp]
	cmovae	ecx, DWORD PTR __Str0$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4392 : 			_Str0 = _Traits.transform_primary(_Str0.begin(), _Str0.end());

	lea	eax, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Traits$[ebp]
	push	eax
	call	??$transform_primary@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::_Regex_traits<wchar_t>::transform_primary<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2076 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __Str0$[ebp]
	cmp	eax, esi
	je	$LN515@Lookup_equ

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR __Str0$[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN464@Lookup_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Str0$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN721@Lookup_equ

; 99   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN459@Lookup_equ

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN721@Lookup_equ

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN721@Lookup_equ

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN721@Lookup_equ

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN721@Lookup_equ

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN459@Lookup_equ:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN464@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Str0$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str0$[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR __Str0$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [esi]
	movups	XMMWORD PTR __Str0$[ebp], xmm0
	movq	xmm0, QWORD PTR [esi+16]
	movq	QWORD PTR __Str0$[ebp+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], eax

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
$LN515@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN551@Lookup_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN721@Lookup_equ

; 99   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN546@Lookup_equ

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN721@Lookup_equ

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN721@Lookup_equ

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN721@Lookup_equ

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN721@Lookup_equ

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN546@Lookup_equ:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN551@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str1$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	edx, DWORD PTR __Str1$[ebp]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	esi, DWORD PTR __Str0$[ebp+16]

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str0$[ebp]
	cmovae	edx, DWORD PTR __Str1$[ebp]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str0$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR __Str0$[ebp]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	cmp	esi, DWORD PTR __Str1$[ebp+16]
	jne	SHORT $LN617@Lookup_equ
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN727@Lookup_equ
	npad	2
$LL626@Lookup_equ:

; 217  :             if (*_S1 != *_S2)

	mov	cx, WORD PTR [eax]
	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN745@Lookup_equ

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	eax, 2
	add	edx, 2
	sub	esi, 1
	jne	SHORT $LL626@Lookup_equ
$LN727@Lookup_equ:
	mov	BYTE PTR $T4[ebp], 1
	jmp	SHORT $LN746@Lookup_equ
$LN745@Lookup_equ:

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	je	SHORT $LN727@Lookup_equ
$LN617@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4389 : 		for (unsigned int _Ix = 0; _Ix < _Eq->_Data._Size(); _Ix += _Eq->_Sz)

	mov	ecx, DWORD PTR __Ix$1$[ebp]
	add	ecx, DWORD PTR [edi]
	mov	DWORD PTR __Ix$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+8]
	jb	$LL6@Lookup_equ
$LN5@Lookup_equ:

; 4393 : 			if (_Str0 == _Str1)
; 4394 : 				return (true);
; 4395 : 			}
; 4396 : 		_Eq = _Eq->_Next;

	mov	edi, DWORD PTR [edi+16]
	test	edi, edi
	jne	$LL2@Lookup_equ
$LN742@Lookup_equ:

; 4397 : 		}
; 4398 : 	return (false);

	mov	BYTE PTR $T4[ebp], 0
$LN746@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR __Str1$[ebp+20]
	mov	ecx, DWORD PTR __Str0$[ebp]
	mov	edx, DWORD PTR __Str1$[ebp]
	pop	edi
	pop	esi
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN663@Lookup_equ

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN657@Lookup_equ
$LN721@Lookup_equ:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN747@Lookup_equ:
$LN657@Lookup_equ:

; 99   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN658@Lookup_equ

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	BYTE PTR __Str1$[ebp], 31		; 0000001fH
	je	SHORT $LN659@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN748@Lookup_equ:
$LN659@Lookup_equ:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [edx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, edx
	jb	SHORT $LN660@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN749@Lookup_equ:
$LN660@Lookup_equ:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	edx, eax
	cmp	edx, 4
	jae	SHORT $LN661@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN750@Lookup_equ:
$LN661@Lookup_equ:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	edx, 35					; 00000023H
	jbe	SHORT $LN662@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN751@Lookup_equ:
$LN662@Lookup_equ:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	edx, eax
$LN658@Lookup_equ:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __Str0$[ebp]
	add	esp, 4
$LN663@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Str1$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR __Str1$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR __Str0$[ebp+20]

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str1$[ebp+20], 7

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN705@Lookup_equ

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN699@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN752@Lookup_equ:
$LN699@Lookup_equ:

; 99   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN700@Lookup_equ

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	BYTE PTR __Str0$[ebp], 31		; 0000001fH
	je	SHORT $LN701@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN753@Lookup_equ:
$LN701@Lookup_equ:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN702@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN754@Lookup_equ:
$LN702@Lookup_equ:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN703@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN755@Lookup_equ:
$LN703@Lookup_equ:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN704@Lookup_equ
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN756@Lookup_equ:
$LN704@Lookup_equ:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN700@Lookup_equ:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN705@Lookup_equ:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4399 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, BYTE PTR $T4[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN744@Lookup_equ:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z$0:
	lea	ecx, DWORD PTR __Str0$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z$1:
	lea	ecx, DWORD PTR __Str1$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z ENDP ; std::_Lookup_equiv<wchar_t,std::regex_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$find@PB_WG@std@@YAPB_WPB_W0ABG@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$find@PB_WG@std@@YAPB_WPB_W0ABG@Z PROC		; std::find<wchar_t const *,unsigned short>, COMDAT

; 3186 : 	{	// find first matching _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 3180 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

	mov	eax, DWORD PTR __First$[ebp]

; 3160 : 	for (; _First != _Last; ++_First)

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	eax, edx
	je	SHORT $LN18@find

; 3161 : 		if (*_First == _Val)

	mov	ecx, DWORD PTR __Val$[ebp]
	movzx	ecx, WORD PTR [ecx]
$LL12@find:
	cmp	WORD PTR [eax], cx
	je	SHORT $LN18@find

; 3160 : 	for (; _First != _Last; ++_First)

	add	eax, 2
	cmp	eax, edx
	jne	SHORT $LL12@find
$LN18@find:

; 3187 : 	_DEBUG_RANGE(_First, _Last);
; 3188 : 	return (_Rechecked(_First,
; 3189 : 		_Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
; 3190 : 	}

	pop	ebp
	ret	0
??$find@PB_WG@std@@YAPB_WPB_W0ABG@Z ENDP		; std::find<wchar_t const *,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Find@G@_Bitmap@std@@QBE_NG@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
??$_Find@G@_Bitmap@std@@QBE_NG@Z PROC			; std::_Bitmap::_Find<unsigned short>, COMDAT
; _this$ = ecx

; 1647 : 		{	// return true if _Ch is marked

	npad	2
	push	ebp
	mov	ebp, esp

; 1648 : 		static_assert(is_unsigned<_Elem>::value, "_Elem must be unsigned");
; 1649 : 		unsigned int _Wide = _Ch;

	movzx	edx, WORD PTR __Ch$[ebp]

; 1650 : 		return ((_Chrs[_Wide >> _Bmp_shift] & (1 << (_Wide & _Bmp_mask))) != 0);

	mov	eax, 1
	push	esi
	mov	esi, ecx
	mov	ecx, edx
	and	ecx, 7
	shr	edx, 3
	shl	eax, cl
	test	al, BYTE PTR [edx+esi]
	pop	esi
	setne	al

; 1651 : 		}

	pop	ebp
	ret	4
??$_Find@G@_Bitmap@std@@QBE_NG@Z ENDP			; std::_Bitmap::_Find<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Lookup_range@_W@std@@YA_NIPBU?$_Buf@_W@0@@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
__Bufptr$ = 12						; size = 4
??$_Lookup_range@_W@std@@YA_NIPBU?$_Buf@_W@0@@Z PROC	; std::_Lookup_range<wchar_t>, COMDAT

; 4367 : 	{	// check whether _Ch is in _Buf

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Bufptr$[ebp]

; 4368 : 	typedef typename make_unsigned<_Elem>::type _Uelem;
; 4369 : 	for (unsigned int _Ix = 0; _Ix < _Bufptr->_Size(); _Ix += 2)

	xor	eax, eax
	push	esi
	push	edi
	mov	edi, DWORD PTR [edx+4]
	test	edi, edi
	je	SHORT $LN18@Lookup_ran

; 1587 : 		return (_Chrs[_Idx]);

	mov	edx, DWORD PTR [edx+8]
	mov	esi, DWORD PTR __Ch$[ebp]
	npad	7
$LL4@Lookup_ran:

; 4370 : 		{	// check current position
; 4371 : 		if ((_Uelem)_Bufptr->_At(_Ix) <= _Ch
; 4372 : 			&& _Ch <= (_Uelem)_Bufptr->_At(_Ix + 1))

	movzx	ecx, WORD PTR [edx+eax*2]
	cmp	ecx, esi
	ja	SHORT $LN2@Lookup_ran
	movzx	ecx, WORD PTR [edx+eax*2+2]
	cmp	esi, ecx
	jbe	SHORT $LN14@Lookup_ran
$LN2@Lookup_ran:

; 4368 : 	typedef typename make_unsigned<_Elem>::type _Uelem;
; 4369 : 	for (unsigned int _Ix = 0; _Ix < _Bufptr->_Size(); _Ix += 2)

	add	eax, 2
	cmp	eax, edi
	jb	SHORT $LL4@Lookup_ran
$LN18@Lookup_ran:
	pop	edi

; 4374 : 		}
; 4375 : 	return (false);

	xor	al, al
	pop	esi

; 4376 : 	}

	pop	ebp
	ret	0
$LN14@Lookup_ran:
	pop	edi

; 4373 : 				return (true);

	mov	al, 1
	pop	esi

; 4376 : 	}

	pop	ebp
	ret	0
??$_Lookup_range@_W@std@@YA_NIPBU?$_Buf@_W@0@@Z ENDP	; std::_Lookup_range<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Lookup_coll@PB_W_W@std@@YAPB_WPB_W0PBU?$_Sequence@_W@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Eq$ = 16						; size = 4
??$_Lookup_coll@PB_W_W@std@@YAPB_WPB_W0PBU?$_Sequence@_W@0@@Z PROC ; std::_Lookup_coll<wchar_t const *,wchar_t>, COMDAT

; 4405 : 	{	// look for collation element [_First, _Last) in _Eq

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 4406 : 	while (_Eq)

	mov	eax, DWORD PTR __Eq$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	ebx
	push	esi
	push	edi
	test	eax, eax
	je	SHORT $LN31@Lookup_col
$LL2@Lookup_col:
	mov	ecx, DWORD PTR [eax+8]

; 4407 : 		{	// look for sequence of elements that are the right size
; 4408 : 		for (unsigned int _Ix = 0; _Ix < _Eq->_Data._Size(); _Ix += _Eq->_Sz)

	xor	ebx, ebx
	mov	DWORD PTR $T1[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN5@Lookup_col
	mov	edi, DWORD PTR [eax]
$LL6@Lookup_col:

; 4409 : 			{	// look for character range
; 4410 : 			_BidIt _Res = _First;

	mov	esi, edx

; 4411 : 			for (size_t _Jx = 0; _Jx < _Eq->_Sz; ++_Jx)

	xor	edx, edx
	test	edi, edi
	je	SHORT $LN20@Lookup_col

; 1592 : 		return (_Chrs);

	mov	eax, DWORD PTR [eax+12]

; 4407 : 		{	// look for sequence of elements that are the right size
; 4408 : 		for (unsigned int _Ix = 0; _Ix < _Eq->_Data._Size(); _Ix += _Eq->_Sz)

	lea	eax, DWORD PTR [eax+ebx*2]
	npad	1
$LL9@Lookup_col:

; 4412 : 				{	// check current character
; 4413 : 				if (*_Res++ != *(_Eq->_Data._Str() + _Ix + _Jx))

	movzx	ecx, WORD PTR [esi]
	add	esi, 2
	cmp	cx, WORD PTR [eax]
	jne	SHORT $LN32@Lookup_col

; 4411 : 			for (size_t _Jx = 0; _Jx < _Eq->_Sz; ++_Jx)

	inc	edx
	add	eax, 2
	cmp	edx, edi
	jb	SHORT $LL9@Lookup_col
$LN32@Lookup_col:
	mov	eax, DWORD PTR __Eq$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
$LN20@Lookup_col:

; 4414 : 					break;
; 4415 : 				}
; 4416 : 			if (_Res == _Last)

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	esi, edx
	je	SHORT $LN31@Lookup_col

; 4407 : 		{	// look for sequence of elements that are the right size
; 4408 : 		for (unsigned int _Ix = 0; _Ix < _Eq->_Data._Size(); _Ix += _Eq->_Sz)

	mov	edx, DWORD PTR __First$[ebp]
	add	ebx, edi
	cmp	ebx, ecx
	jb	SHORT $LL6@Lookup_col
$LN5@Lookup_col:

; 4417 : 				return (_Last);
; 4418 : 			}
; 4419 : 		_Eq = _Eq->_Next;

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Eq$[ebp], eax
	test	eax, eax
	jne	SHORT $LL2@Lookup_col
$LN31@Lookup_col:
	pop	edi
	pop	esi

; 4420 : 		}
; 4421 : 	return (_First);

	mov	eax, edx
	pop	ebx

; 4422 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lookup_coll@PB_W_W@std@@YAPB_WPB_W0PBU?$_Sequence@_W@0@@Z ENDP ; std::_Lookup_coll<wchar_t const *,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G?$_Sequence@_W@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_Sequence@_W@std@@QAEPAXI@Z PROC			; std::_Sequence<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1568 : 		free(_Chrs);

	push	DWORD PTR [esi+12]
	call	DWORD PTR __imp__free
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN10@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$_Sequence@_W@std@@QAEPAXI@Z ENDP			; std::_Sequence<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1?$_Sequence@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Sequence@_W@std@@QAE@XZ PROC			; std::_Sequence<wchar_t>::~_Sequence<wchar_t>, COMDAT
; _this$ = ecx

; 1568 : 		free(_Chrs);

	push	DWORD PTR [ecx+12]
	call	DWORD PTR __imp__free
	pop	ecx
	ret	0
??1?$_Sequence@_W@std@@QAE@XZ ENDP			; std::_Sequence<wchar_t>::~_Sequence<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Sequence@_W@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Len$ = 8						; size = 4
??0?$_Sequence@_W@std@@QAE@I@Z PROC			; std::_Sequence<wchar_t>::_Sequence<wchar_t>, COMDAT
; _this$ = ecx

; 1663 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1563 : 		{	// construct
; 1564 : 		}
; 1565 : 
; 1566 : 	~_Buf() _NOEXCEPT
; 1567 : 		{	// destroy
; 1568 : 		free(_Chrs);
; 1569 : 		}
; 1570 : 
; 1571 : 	unsigned int _Size() const
; 1572 : 		{	// return number of characters held in buffer
; 1573 : 		return (_Nchrs);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Elem _At(unsigned int _Idx) const
; 1577 : 		{	// return character at _Idx
; 1578 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1579 : 		if (_Nchrs <= _Idx)
; 1580 : 			{
; 1581 : 			_DEBUG_ERROR("regex buffer subscript out of range");
; 1582 : 			}
; 1583 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1584 : 		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Nchrs);
; 1585 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1586 : 
; 1587 : 		return (_Chrs[_Idx]);
; 1588 : 		}
; 1589 : 
; 1590 : 	const _Elem *_Str() const
; 1591 : 		{	// return pointer to first character
; 1592 : 		return (_Chrs);
; 1593 : 		}
; 1594 : 
; 1595 : 	void _Insert(_Elem _Ch)
; 1596 : 		{	// append _Ch
; 1597 : 		if (_Sz <= _Nchrs)
; 1598 : 			_Expand(_Nchrs + _Buf_incr);
; 1599 : 		_Chrs[_Nchrs++] = _Ch;
; 1600 : 		}
; 1601 : 
; 1602 : 	_Elem _Del()
; 1603 : 		{	// remove and return last character
; 1604 : 		return (_Chrs[--_Nchrs]);
; 1605 : 		}
; 1606 : 
; 1607 : 	template<class _FwdIt>
; 1608 : 		void _Insert(_FwdIt _First, _FwdIt _Last)
; 1609 : 		{	// append multiple characters
; 1610 : 		while (_First != _Last)
; 1611 : 			_Insert(*_First++);
; 1612 : 		}
; 1613 : 
; 1614 : private:
; 1615 : 	void _Expand(unsigned int _Len)
; 1616 : 		{	// expand buffer to hold _Len characters
; 1617 : 		_Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));
; 1618 : 		if (!_Tmp)
; 1619 : 			_Xbad_alloc();
; 1620 : 		_Chrs = _Tmp;
; 1621 : 		_Sz = _Len;
; 1622 : 		}
; 1623 : 
; 1624 : 	unsigned int _Sz;
; 1625 : 	unsigned int _Nchrs;
; 1626 : 	_Elem *_Chrs;
; 1627 : 	};
; 1628 : 
; 1629 : 	// STRUCT _Bitmap
; 1630 : struct _Bitmap
; 1631 : 	{	// accelerator table for small character values
; 1632 : 	_Bitmap()
; 1633 : 		{	// construct
; 1634 : 		_CSTD memset(_Chrs, '\0', _Bmp_size);
; 1635 : 		}
; 1636 : 
; 1637 : 	template<class _Elem>
; 1638 : 		void _Mark(_Elem _Ch)
; 1639 : 		{	// mark character _Ch
; 1640 : 		static_assert(is_unsigned<_Elem>::value, "_Elem must be unsigned");
; 1641 : 		unsigned int _Wide = _Ch;
; 1642 : 		_Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));
; 1643 : 		}
; 1644 : 
; 1645 : 	template<class _Elem>
; 1646 : 		bool _Find(_Elem _Ch) const
; 1647 : 		{	// return true if _Ch is marked
; 1648 : 		static_assert(is_unsigned<_Elem>::value, "_Elem must be unsigned");
; 1649 : 		unsigned int _Wide = _Ch;
; 1650 : 		return ((_Chrs[_Wide >> _Bmp_shift] & (1 << (_Wide & _Bmp_mask))) != 0);
; 1651 : 		}
; 1652 : 
; 1653 : private:
; 1654 : 	unsigned char _Chrs[_Bmp_size];
; 1655 : 	};
; 1656 : 
; 1657 : 	// TEMPLATE CLASS _Sequence
; 1658 : template<class _Elem>
; 1659 : 	struct _Sequence
; 1660 : 	{	// holds sequences of _Sz elements
; 1661 : 	_Sequence(unsigned int _Len)
; 1662 : 		: _Sz(_Len)

	mov	eax, DWORD PTR __Len$[ebp]
	mov	DWORD PTR [ecx], eax

; 1664 : 		}

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1562 : 		: _Sz(0), _Nchrs(0), _Chrs(0)

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 1664 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Sequence@_W@std@@QAE@I@Z ENDP			; std::_Sequence<wchar_t>::_Sequence<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAE@XZ ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::~_Node_class<wchar_t,std::regex_traits<wchar_t> >
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	44					; 0000002cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Tidy@?$_Node_class@_WV?$regex_traits@_W@std@@@std@@QAEXPAU?$_Sequence@_W@2@@Z
_TEXT	SEGMENT
__Head$ = 8						; size = 4
?_Tidy@?$_Node_class@_WV?$regex_traits@_W@std@@@std@@QAEXPAU?$_Sequence@_W@2@@Z PROC ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 1815 : 		{	// clean up a list of sequences

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1816 : 		while (_Head)

	mov	esi, DWORD PTR __Head$[ebp]
	test	esi, esi
	je	SHORT $LN3@Tidy
	push	ebx
	mov	ebx, DWORD PTR __imp__free
	push	edi
$LL2@Tidy:

; 1817 : 			{	// delete the head of the list
; 1818 : 			_Sequence<_Elem> *_Temp = _Head;

	mov	edi, esi

; 1819 : 			_Head = _Head->_Next;

	mov	esi, DWORD PTR [esi+16]

; 1568 : 		free(_Chrs);

	push	DWORD PTR [edi+12]
	call	ebx
	push	20					; 00000014H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 12					; 0000000cH

; 1816 : 		while (_Head)

	test	esi, esi
	jne	SHORT $LL2@Tidy
	pop	edi
	pop	ebx
$LN3@Tidy:
	pop	esi

; 1820 : 			delete _Temp;
; 1821 : 			}
; 1822 : 		}

	pop	ebp
	ret	4
?_Tidy@?$_Node_class@_WV?$regex_traits@_W@std@@@std@@QAEXPAU?$_Sequence@_W@2@@Z ENDP ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAE@XZ PROC ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::~_Node_class<wchar_t,std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 1806 : 		{	// destroy

	npad	2
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 1807 : 		_Tidy(_Coll);

	mov	edi, DWORD PTR [ebx+20]
	mov	DWORD PTR [ebx], OFFSET ??_7?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@

; 1816 : 		while (_Head)

	test	edi, edi
	je	SHORT $LN9@Node_class
$LL8@Node_class:

; 1817 : 			{	// delete the head of the list
; 1818 : 			_Sequence<_Elem> *_Temp = _Head;

	mov	esi, edi

; 1819 : 			_Head = _Head->_Next;

	mov	edi, DWORD PTR [edi+16]

; 1568 : 		free(_Chrs);

	push	DWORD PTR [esi+12]
	call	DWORD PTR __imp__free
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 12					; 0000000cH

; 1816 : 		while (_Head)

	test	edi, edi
	jne	SHORT $LL8@Node_class
$LN9@Node_class:

; 1808 : 		delete _Small;

	push	32					; 00000020H
	push	DWORD PTR [ebx+24]
	call	??3@YAXPAXI@Z				; operator delete

; 1809 : 		delete _Large;

	mov	edi, DWORD PTR [ebx+28]
	add	esp, 8

; 1568 : 		free(_Chrs);

	mov	esi, DWORD PTR __imp__free

; 1809 : 		delete _Large;

	test	edi, edi
	je	SHORT $LN24@Node_class

; 1568 : 		free(_Chrs);

	push	DWORD PTR [edi+8]
	call	esi
	push	12					; 0000000cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 12					; 0000000cH
$LN24@Node_class:

; 1810 : 		delete _Ranges;

	mov	edi, DWORD PTR [ebx+32]
	test	edi, edi
	je	SHORT $LN31@Node_class

; 1568 : 		free(_Chrs);

	push	DWORD PTR [edi+8]
	call	esi
	push	12					; 0000000cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 12					; 0000000cH
$LN31@Node_class:

; 1811 : 		_Tidy(_Equiv);

	mov	edi, DWORD PTR [ebx+40]

; 1816 : 		while (_Head)

	test	edi, edi
	je	SHORT $LN62@Node_class
	npad	7
$LL38@Node_class:

; 1817 : 			{	// delete the head of the list
; 1818 : 			_Sequence<_Elem> *_Temp = _Head;

	mov	esi, edi

; 1819 : 			_Head = _Head->_Next;

	mov	edi, DWORD PTR [edi+16]

; 1568 : 		free(_Chrs);

	push	DWORD PTR [esi+12]
	call	DWORD PTR __imp__free
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 12					; 0000000cH

; 1816 : 		while (_Head)

	test	edi, edi
	jne	SHORT $LL38@Node_class
$LN62@Node_class:
	pop	edi
	pop	esi

; 1686 : 		{	// destroy

	mov	DWORD PTR [ebx], OFFSET ??_7_Node_base@std@@6B@
	pop	ebx

; 1812 : 		}

	ret	0
??1?$_Node_class@_WV?$regex_traits@_W@std@@@std@@UAE@XZ ENDP ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::~_Node_class<wchar_t,std::regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Node_class@_WV?$regex_traits@_W@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ty$ = 8						; size = 4
__Fl$ = 12						; size = 4
??0?$_Node_class@_WV?$regex_traits@_W@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z PROC ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::_Node_class<wchar_t,std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 1802 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	eax, DWORD PTR __Ty$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Fl$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1677 : 		{	// construct
; 1678 : 		}
; 1679 : 
; 1680 : 	_Node_type _Kind;
; 1681 : 	_Node_flags _Flags;
; 1682 : 	_Node_base *_Next;
; 1683 : 	_Node_base *_Prev;
; 1684 : 
; 1685 : 	virtual ~_Node_base() _NOEXCEPT
; 1686 : 		{	// destroy
; 1687 : 		}
; 1688 : 	};
; 1689 : 
; 1690 : 	// FUNCTION _Destroy_node
; 1691 : inline void _Destroy_node(_Node_base *_Nx,
; 1692 : 	_Node_base *_Ne = 0)
; 1693 : 	{	// destroy sublist of nodes
; 1694 : 	while (_Nx != _Ne && _Nx != 0)
; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;
; 1697 : 		_Nx = _Nx->_Next;
; 1698 : 		_Tmp->_Next = 0;
; 1699 : 		delete _Tmp;
; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	// CLASS _Root_node
; 1704 : class _Root_node
; 1705 : 	: public _Node_base
; 1706 : 	{	// root of parse tree
; 1707 : public:
; 1708 : 	_Root_node()
; 1709 : 		: _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)
; 1710 : 		{	// construct
; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)
; 1728 : 		{	// construct
; 1729 : 		}
; 1730 : 
; 1731 : 	_Node_base *_Back;
; 1732 : 	};
; 1733 : 
; 1734 : 	// CLASS _Node_assert
; 1735 : class _Node_assert
; 1736 : 	: public _Node_base
; 1737 : 	{	// node that holds an ECMAScript assertion
; 1738 : public:
; 1739 : 	_Node_assert(_Node_type _Ty, _Node_flags _Fl = _Fl_none)
; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)
; 1741 : 		{	// construct
; 1742 : 		}
; 1743 : 
; 1744 : 	~_Node_assert() _NOEXCEPT
; 1745 : 		{	// destroy branch
; 1746 : 		_Destroy_node(_Child);
; 1747 : 		}
; 1748 : 
; 1749 : 	_Node_base *_Child;
; 1750 : 	};
; 1751 : 
; 1752 : 	// TEMPLATE CLASS _Node_capture
; 1753 : class _Node_capture
; 1754 : 	: public _Node_base
; 1755 : 	{	// node that marks beginning of a capture group
; 1756 : public:
; 1757 : 	_Node_capture(unsigned int _Ix)
; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)
; 1759 : 		{	// construct
; 1760 : 		}
; 1761 : 
; 1762 : 	unsigned int _Idx;
; 1763 : 	};
; 1764 : 
; 1765 : 	// CLASS _Node_back
; 1766 : class _Node_back
; 1767 : 	: public _Node_base
; 1768 : 	{	// node that holds a back reference
; 1769 : public:
; 1770 : 	_Node_back(unsigned int _Ix)
; 1771 : 		: _Node_base(_N_back, _Fl_none), _Idx(_Ix)
; 1772 : 		{	// construct
; 1773 : 		}
; 1774 : 
; 1775 : 	unsigned int _Idx;
; 1776 : 	};
; 1777 : 
; 1778 : 	// TEMPLATE CLASS _Node_str
; 1779 : template<class _Elem>
; 1780 : 	class _Node_str
; 1781 : 		: public _Node_base
; 1782 : 	{	// node that holds text
; 1783 : public:
; 1784 : 	_Node_str(_Node_flags _Fl = _Fl_none)
; 1785 : 		: _Node_base(_N_str, _Fl)
; 1786 : 		{	// construct
; 1787 : 		}
; 1788 : 
; 1789 : 	_Buf<_Elem> _Data;
; 1790 : 	};
; 1791 : 
; 1792 : 	// TEMPLATE CLASS _Node_class
; 1793 : template<class _Elem,
; 1794 : 	class _RxTraits>
; 1795 : 	class _Node_class
; 1796 : 		: public _Node_base
; 1797 : 	{	// node that holds a character class (POSIX bracket expression)
; 1798 : public:
; 1799 : 	_Node_class(_Node_type _Ty = _N_class, _Node_flags _Fl = _Fl_none)
; 1800 : 		: _Node_base(_Ty, _Fl), _Coll(0), _Small(0), _Large(0), _Ranges(0),
; 1801 : 		_Classes((typename _RxTraits::char_class_type)0), _Equiv(0)

	xor	eax, eax
	mov	WORD PTR [ecx+36], ax
	mov	DWORD PTR [ecx+40], eax

; 1803 : 		}

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1802 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0

; 1803 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Node_class@_WV?$regex_traits@_W@std@@@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ENDP ; std::_Node_class<wchar_t,std::regex_traits<wchar_t> >::_Node_class<wchar_t,std::regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Compare@PB_WPB_WV?$regex_traits@_W@std@@@std@@YAPB_WPB_W000ABV?$regex_traits@_W@0@W4syntax_option_type@regex_constants@0@@Z
_TEXT	SEGMENT
__Begin1$ = 8						; size = 4
$T1 = 12						; size = 1
__End1$ = 12						; size = 4
__Begin2$ = 16						; size = 4
__End2$ = 20						; size = 4
__Traits$ = 24						; size = 4
__Sflags$ = 28						; size = 4
??$_Compare@PB_WPB_WV?$regex_traits@_W@std@@@std@@YAPB_WPB_W000ABV?$regex_traits@_W@0@W4syntax_option_type@regex_constants@0@@Z PROC ; std::_Compare<wchar_t const *,wchar_t const *,std::regex_traits<wchar_t> >, COMDAT

; 4351 : 	{	// compare character ranges

	npad	2
	push	ebp
	mov	ebp, esp

; 113  : _BITMASK_OPS(syntax_option_type)

	mov	eax, DWORD PTR __Sflags$[ebp]
	test	eax, 256				; 00000100H

; 4352 : 	_BidIt1 _Res = _End1;
; 4353 : 	if (_Sflags & regex_constants::icase)

	je	SHORT $LN2@Compare

; 4354 : 		_Res = _Cmp_chrange(_Begin1, _End1, _Begin2, _End2,

	push	DWORD PTR __Traits$[ebp]
	push	DWORD PTR __End2$[ebp]
	push	DWORD PTR __Begin2$[ebp]
	push	DWORD PTR __End1$[ebp]
	push	DWORD PTR __Begin1$[ebp]
	call	??$_Cmp_chrange@PB_WPB_WU?$_Cmp_icase@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_icase@V?$regex_traits@_W@std@@@0@@Z ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_icase<std::regex_traits<wchar_t> > >

; 4358 : 			_Cmp_collate<_RxTraits>(_Traits));
; 4359 : 	else
; 4360 : 		_Res = _Cmp_chrange(_Begin1, _End1, _Begin2, _End2,

	add	esp, 20					; 00000014H

; 4361 : 			_Cmp_cs<_RxTraits>());
; 4362 : 	return (_Res);
; 4363 : 	}

	pop	ebp
	ret	0
$LN2@Compare:

; 113  : _BITMASK_OPS(syntax_option_type)

	test	eax, 2048				; 00000800H

; 4355 : 			_Cmp_icase<_RxTraits>(_Traits));
; 4356 : 	else if (_Sflags & regex_constants::collate)

	je	SHORT $LN4@Compare

; 4357 : 		_Res = _Cmp_chrange(_Begin1, _End1, _Begin2, _End2,

	push	DWORD PTR __Traits$[ebp]
	push	DWORD PTR __End2$[ebp]
	push	DWORD PTR __Begin2$[ebp]
	push	DWORD PTR __End1$[ebp]
	push	DWORD PTR __Begin1$[ebp]
	call	??$_Cmp_chrange@PB_WPB_WU?$_Cmp_collate@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_collate@V?$regex_traits@_W@std@@@0@@Z ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_collate<std::regex_traits<wchar_t> > >

; 4358 : 			_Cmp_collate<_RxTraits>(_Traits));
; 4359 : 	else
; 4360 : 		_Res = _Cmp_chrange(_Begin1, _End1, _Begin2, _End2,

	add	esp, 20					; 00000014H

; 4361 : 			_Cmp_cs<_RxTraits>());
; 4362 : 	return (_Res);
; 4363 : 	}

	pop	ebp
	ret	0
$LN4@Compare:

; 4358 : 			_Cmp_collate<_RxTraits>(_Traits));
; 4359 : 	else
; 4360 : 		_Res = _Cmp_chrange(_Begin1, _End1, _Begin2, _End2,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __End2$[ebp]
	push	DWORD PTR __Begin2$[ebp]
	push	DWORD PTR __End1$[ebp]
	push	DWORD PTR __Begin1$[ebp]
	call	??$_Cmp_chrange@PB_WPB_WU?$_Cmp_cs@V?$regex_traits@_W@std@@@std@@@std@@YAPB_WPB_W000U?$_Cmp_cs@V?$regex_traits@_W@std@@@0@@Z ; std::_Cmp_chrange<wchar_t const *,wchar_t const *,std::_Cmp_cs<std::regex_traits<wchar_t> > >
	add	esp, 20					; 00000014H

; 4361 : 			_Cmp_cs<_RxTraits>());
; 4362 : 	return (_Res);
; 4363 : 	}

	pop	ebp
	ret	0
??$_Compare@PB_WPB_WV?$regex_traits@_W@std@@@std@@YAPB_WPB_W000ABV?$regex_traits@_W@0@W4syntax_option_type@regex_constants@0@@Z ENDP ; std::_Compare<wchar_t const *,wchar_t const *,std::regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G?$_Node_str@_W@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_Node_str@_W@std@@UAEPAXI@Z PROC			; std::_Node_str<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1568 : 		free(_Chrs);

	push	DWORD PTR [esi+28]
	call	DWORD PTR __imp__free
	add	esp, 4

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar
	push	32					; 00000020H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$_Node_str@_W@std@@UAEPAXI@Z ENDP			; std::_Node_str<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1?$_Node_str@_W@std@@UAE@XZ
_TEXT	SEGMENT
??1?$_Node_str@_W@std@@UAE@XZ PROC			; std::_Node_str<wchar_t>::~_Node_str<wchar_t>, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 1568 : 		free(_Chrs);

	push	DWORD PTR [esi+28]
	call	DWORD PTR __imp__free
	add	esp, 4

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	pop	esi
	ret	0
??1?$_Node_str@_W@std@@UAE@XZ ENDP			; std::_Node_str<wchar_t>::~_Node_str<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G?$_Buf@_W@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_Buf@_W@std@@QAEPAXI@Z PROC			; std::_Buf<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1568 : 		free(_Chrs);

	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__free
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$_Buf@_W@std@@QAEPAXI@Z ENDP			; std::_Buf<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Expand@?$_Buf@_W@std@@AAEXI@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
?_Expand@?$_Buf@_W@std@@AAEXI@Z PROC			; std::_Buf<wchar_t>::_Expand, COMDAT
; _this$ = ecx

; 1616 : 		{	// expand buffer to hold _Len characters

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1617 : 		_Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));

	mov	edi, DWORD PTR __Len$[ebp]
	mov	esi, ecx
	lea	eax, DWORD PTR [edi+edi]
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 1618 : 		if (!_Tmp)

	test	eax, eax
	jne	SHORT $LN2@Expand

; 1619 : 			_Xbad_alloc();

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Expand:
$LN2@Expand:

; 1620 : 		_Chrs = _Tmp;
; 1621 : 		_Sz = _Len;

	mov	DWORD PTR [esi], edi
	pop	edi
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1622 : 		}

	pop	ebp
	ret	4
$LN5@Expand:
?_Expand@?$_Buf@_W@std@@AAEXI@Z ENDP			; std::_Buf<wchar_t>::_Expand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Del@?$_Buf@_W@std@@QAE_WXZ
_TEXT	SEGMENT
?_Del@?$_Buf@_W@std@@QAE_WXZ PROC			; std::_Buf<wchar_t>::_Del, COMDAT
; _this$ = ecx

; 1604 : 		return (_Chrs[--_Nchrs]);

	dec	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+8]
	mov	ax, WORD PTR [eax+edx*2]

; 1605 : 		}

	ret	0
?_Del@?$_Buf@_W@std@@QAE_WXZ ENDP			; std::_Buf<wchar_t>::_Del
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Insert@?$_Buf@_W@std@@QAEX_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?_Insert@?$_Buf@_W@std@@QAEX_W@Z PROC			; std::_Buf<wchar_t>::_Insert, COMDAT
; _this$ = ecx

; 1596 : 		{	// append _Ch

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1597 : 		if (_Sz <= _Nchrs)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi], eax
	ja	SHORT $LN6@Insert

; 1598 : 			_Expand(_Nchrs + _Buf_incr);

	push	edi
	lea	edi, DWORD PTR [eax+16]

; 1617 : 		_Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));

	lea	eax, DWORD PTR [edi+edi]
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 1618 : 		if (!_Tmp)

	test	eax, eax
	jne	SHORT $LN5@Insert

; 1619 : 			_Xbad_alloc();

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN10@Insert:
$LN5@Insert:

; 1620 : 		_Chrs = _Tmp;
; 1621 : 		_Sz = _Len;

	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+8], eax
	pop	edi
$LN6@Insert:

; 1599 : 		_Chrs[_Nchrs++] = _Ch;

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	mov	ax, WORD PTR __Ch$[ebp]
	mov	WORD PTR [ecx+edx*2], ax
	inc	DWORD PTR [esi+4]
	pop	esi

; 1600 : 		}

	pop	ebp
	ret	4
$LN9@Insert:
?_Insert@?$_Buf@_W@std@@QAEX_W@Z ENDP			; std::_Buf<wchar_t>::_Insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Str@?$_Buf@_W@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Str@?$_Buf@_W@std@@QBEPB_WXZ PROC			; std::_Buf<wchar_t>::_Str, COMDAT
; _this$ = ecx

; 1592 : 		return (_Chrs);

	mov	eax, DWORD PTR [ecx+8]

; 1593 : 		}

	ret	0
?_Str@?$_Buf@_W@std@@QBEPB_WXZ ENDP			; std::_Buf<wchar_t>::_Str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_At@?$_Buf@_W@std@@QBE_WI@Z
_TEXT	SEGMENT
__Idx$ = 8						; size = 4
?_At@?$_Buf@_W@std@@QBE_WI@Z PROC			; std::_Buf<wchar_t>::_At, COMDAT
; _this$ = ecx

; 1577 : 		{	// return character at _Idx

	npad	2
	push	ebp
	mov	ebp, esp

; 1578 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1579 : 		if (_Nchrs <= _Idx)
; 1580 : 			{
; 1581 : 			_DEBUG_ERROR("regex buffer subscript out of range");
; 1582 : 			}
; 1583 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1584 : 		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Nchrs);
; 1585 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1586 : 
; 1587 : 		return (_Chrs[_Idx]);

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ax, WORD PTR [ecx+eax*2]

; 1588 : 		}

	pop	ebp
	ret	4
?_At@?$_Buf@_W@std@@QBE_WI@Z ENDP			; std::_Buf<wchar_t>::_At
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Size@?$_Buf@_W@std@@QBEIXZ
_TEXT	SEGMENT
?_Size@?$_Buf@_W@std@@QBEIXZ PROC			; std::_Buf<wchar_t>::_Size, COMDAT
; _this$ = ecx

; 1573 : 		return (_Nchrs);

	mov	eax, DWORD PTR [ecx+4]

; 1574 : 		}

	ret	0
?_Size@?$_Buf@_W@std@@QBEIXZ ENDP			; std::_Buf<wchar_t>::_Size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1?$_Buf@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Buf@_W@std@@QAE@XZ PROC				; std::_Buf<wchar_t>::~_Buf<wchar_t>, COMDAT
; _this$ = ecx

; 1568 : 		free(_Chrs);

	push	DWORD PTR [ecx+8]
	call	DWORD PTR __imp__free
	pop	ecx

; 1569 : 		}

	ret	0
??1?$_Buf@_W@std@@QAE@XZ ENDP				; std::_Buf<wchar_t>::~_Buf<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Buf@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Buf@_W@std@@QAE@XZ PROC				; std::_Buf<wchar_t>::_Buf<wchar_t>, COMDAT
; _this$ = ecx

; 1562 : 		: _Sz(0), _Nchrs(0), _Chrs(0)

	mov	DWORD PTR [ecx], 0

; 1564 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Buf@_W@std@@QAE@XZ ENDP				; std::_Buf<wchar_t>::_Buf<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Node_str@_W@std@@QAE@W4_Node_flags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Fl$ = 8						; size = 4
??0?$_Node_str@_W@std@@QAE@W4_Node_flags@1@@Z PROC	; std::_Node_str<wchar_t>::_Node_str<wchar_t>, COMDAT
; _this$ = ecx

; 1786 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	eax, DWORD PTR __Fl$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1787 : 		}

	mov	eax, ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 6
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1786 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7?$_Node_str@_W@std@@6B@
	mov	DWORD PTR _this$[ebp], ecx

; 1562 : 		: _Sz(0), _Nchrs(0), _Chrs(0)

	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0

; 1787 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Node_str@_W@std@@QAE@W4_Node_flags@1@@Z ENDP	; std::_Node_str<wchar_t>::_Node_str<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$find@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$find@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z PROC ; std::find<wchar_t const *,enum std::_Meta_type>, COMDAT

; 3186 : 	{	// find first matching _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 3180 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

	mov	eax, DWORD PTR __First$[ebp]

; 3160 : 	for (; _First != _Last; ++_First)

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	eax, edx
	je	SHORT $LN18@find

; 3161 : 		if (*_First == _Val)

	mov	ecx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR [ecx]
$LL12@find:
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, esi
	je	SHORT $LN24@find

; 3160 : 	for (; _First != _Last; ++_First)

	add	eax, 2
	cmp	eax, edx
	jne	SHORT $LL12@find
$LN24@find:
	pop	esi
$LN18@find:

; 3187 : 	_DEBUG_RANGE(_First, _Last);
; 3188 : 	return (_Rechecked(_First,
; 3189 : 		_Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
; 3190 : 	}

	pop	ebp
	ret	0
??$find@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z ENDP ; std::find<wchar_t const *,enum std::_Meta_type>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$prev@PB_W@std@@YAPB_WPB_WH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Off$ = 12						; size = 4
??$prev@PB_W@std@@YAPB_WPB_WH@Z PROC			; std::prev<wchar_t const *>, COMDAT

; 1130 : 	{	// decrement iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 1079 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	add	eax, eax
	sub	ecx, eax

; 1131 : 	static_assert(is_base_of<bidirectional_iterator_tag, _Iter_cat_t<_BidIt>>::value,
; 1132 : 		"prev requires bidirectional iterator");
; 1133 : 
; 1134 : 	_STD advance(_First, -_Off);
; 1135 : 	return (_First);

	mov	eax, ecx

; 1136 : 	}

	pop	ebp
	ret	0
??$prev@PB_W@std@@YAPB_WPB_WH@Z ENDP			; std::prev<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z PROC ; std::_Uninitialized_fill_n<unsigned int *,unsigned int,std::allocator<unsigned int> >, COMDAT

; 216  : 	{	// copy _Count copies of _Val to raw _First, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >
	add	esp, 20					; 00000014H

; 218  : 		_Conjunction_t<decltype(_Fill_memset_is_safe(_First, _Val)),
; 219  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)>>()));
; 220  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_fill_n@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<unsigned int *,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0ABV?$allocator@_N@std@@X@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@_N@std@@X@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::allocator<bool> const &,void>, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 517  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 517  : 		}

	ret	4
??$?0ABV?$allocator@_N@std@@X@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$allocator@_N@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > ><std::allocator<bool> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z PROC	; std::_Move_unchecked<unsigned int *,unsigned int *>, COMDAT

; 2550 : 	{	// move [_First, _Last) to [_Dest, ...), choose optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2551 : 		// note: _Move_unchecked is called directly from elsewhere in the STL
; 2552 : 	return (_Move_unchecked1(_First, _Last,
; 2553 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2554 : 	}

	pop	ebp
	ret	0
??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z ENDP	; std::_Move_unchecked<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >, COMDAT

; 260  : 	{	// value-initialize _Count objects to raw _First, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 261  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
	add	esp, 16					; 00000010H

; 263  : 		_Conjunction_t<
; 264  : 			is_pointer<_FwdIt>,
; 265  : 			is_scalar<_Ty>,
; 266  : 			negation<is_volatile<_Ty>>,
; 267  : 			negation<is_member_pointer<_Ty>>,
; 268  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>()));
; 269  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@U_Loop_vals_t@std@@@std@@PAU_Loop_vals_t@2@@std@@YAXPAU_Loop_vals_t@0@0AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U_Loop_vals_t@std@@@std@@PAU_Loop_vals_t@2@@std@@YAXPAU_Loop_vals_t@0@0AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_Loop_vals_t>,std::_Loop_vals_t *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@U_Loop_vals_t@std@@@std@@PAU_Loop_vals_t@2@@std@@YAXPAU_Loop_vals_t@0@0AAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_Loop_vals_t>,std::_Loop_vals_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@PAU_Grp_t@?$_Tgt_state_t@PB_W@2@@std@@YAXPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@PAU_Grp_t@?$_Tgt_state_t@PB_W@2@@std@@YAXPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@PAU_Grp_t@?$_Tgt_state_t@PB_W@2@@std@@YAXPAU_Grp_t@?$_Tgt_state_t@PB_W@0@0AAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>,std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+, COMDAT
; _this$ = ecx

; 363  : 		{	// return this + integer

	npad	2
	push	ebp
	mov	ebp, esp

; 171  : 		_Ptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 364  : 		_Myiter _Tmp = *this;
; 365  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 366  : 		}

	pop	ebp
	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 357  : 		{	// increment by integer

	npad	2
	push	ebp
	mov	ebp, esp

; 171  : 		_Ptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 358  : 		*(_Mybase *)this += _Off;
; 359  : 		return (*this);

	mov	eax, ecx

; 360  : 		}

	pop	ebp
	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 305  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 148  : 		{	// increment by integer

	npad	2
	push	ebp
	mov	ebp, esp

; 149  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 150  : 		if (_Off != 0)
; 151  : 			{
; 152  : 			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 153  : 			if (_Mycont == 0
; 154  : 				|| _Ptr + _Off < _Mycont->_Myfirst
; 155  : 				|| _Mycont->_Mylast < _Ptr + _Off)
; 156  : 				{
; 157  : 				_DEBUG_ERROR("vector iterator + offset out of range");
; 158  : 				}
; 159  : 			}
; 160  : 
; 161  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 162  : 		if (_Off != 0)
; 163  : 			{
; 164  : 			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 165  : 			_SCL_SECURE_VALIDATE(_Mycont != 0);
; 166  : 			_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr + _Off
; 167  : 				&& _Ptr + _Off <= _Mycont->_Mylast);
; 168  : 			}
; 169  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 170  : 
; 171  : 		_Ptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 172  : 		return (*this);

	mov	eax, ecx

; 173  : 		}

	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 44   : 		this->_Adopt(_Pvector);
; 45   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newvec$2 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$3 = 8					; size = 4
__Newsize$ = 8						; size = 4
$T4 = 12						; size = 1
$T5 = 12						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Resize<<lambda_73aa1e031ed5205b52738960793434b5> >, COMDAT
; _this$ = ecx

; 1442 : 		{	// trim or append elements, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 1443 : 		const size_type _Oldsize = size();
; 1444 : 		const size_type _Oldcapacity = capacity();
; 1445 : 
; 1446 : 		if (_Newsize > _Oldcapacity)

	mov	esi, DWORD PTR __Newsize$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [edi+4]
	mov	ebx, edx
	mov	eax, DWORD PTR [edi]
	sub	ebx, eax

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	ebx, 3

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	ecx, 3

; 1443 : 		const size_type _Oldsize = size();
; 1444 : 		const size_type _Oldcapacity = capacity();
; 1445 : 
; 1446 : 		if (_Newsize > _Oldcapacity)

	cmp	esi, ecx
	jbe	$LN2@Resize

; 1447 : 			{	// reallocate
; 1448 : 			if (_Newsize > max_size())

	cmp	esi, 536870911				; 1fffffffH
	jbe	SHORT $LN4@Resize

; 1449 : 				{
; 1450 : 				_Xlength();

	call	?_Xlength@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@CAXXZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Xlength
$LN350@Resize:
$LN4@Resize:

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, ecx
	mov	eax, 536870911				; 1fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN76@Resize

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, esi
	mov	DWORD PTR __Newcapacity$3[ebp], esi
	jmp	SHORT $LN77@Resize
$LN76@Resize:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, esi
	cmovb	eax, esi
	mov	DWORD PTR __Newcapacity$3[ebp], eax
$LN77@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	mov	ecx, edi
	call	?allocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z ; std::allocator<std::_Loop_vals_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1455 : 			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1456 : 			const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [eax+ebx*8]

; 1457 : 			pointer _Appended_last = _Appended_first;
; 1458 : 
; 1459 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1460 : 			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);

	mov	eax, esi
	sub	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	eax
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR [edi+4]

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	ebx, DWORD PTR __Newvec$2[ebp]
	sub	eax, ecx
	push	eax
	push	ecx
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN183@Resize

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN183@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	lea	eax, DWORD PTR [ebx+esi*8]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$3[ebp]
	lea	eax, DWORD PTR [ebx+eax*8]
	mov	DWORD PTR [edi+8], eax

; 1485 : 			}
; 1486 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z$0:

; 1461 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 1462 : 			_CATCH_ALL
; 1463 : 			_Destroy(_Appended_first, _Appended_last);
; 1464 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR __Newvec$2[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::deallocate

; 1465 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN351@Resize:
$LN2@Resize:

; 1466 : 			_CATCH_END
; 1467 : 
; 1468 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1469 : 			}
; 1470 : 		else if (_Newsize > _Oldsize)

	cmp	esi, ebx
	jbe	SHORT $LN348@Resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1473 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);

	sub	esi, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR __Udefault_or_fill$[ebp]
	push	esi
	push	edx
	call	??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1996 : 		}

	jmp	SHORT $LN349@Resize
$LN348@Resize:

; 1474 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1475 : 			}
; 1476 : 		else if (_Newsize == _Oldsize)

	je	SHORT $LN9@Resize

; 1477 : 			{	// nothing to do, avoid invalidating iterators
; 1478 : 			}
; 1479 : 		else
; 1480 : 			{	// trim
; 1481 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	eax, DWORD PTR [eax+esi*8]
$LN349@Resize:

; 1482 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1483 : 			_Destroy(_Newlast, this->_Mylast());
; 1484 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [edi+4], eax
$LN9@Resize:

; 1485 : 			}
; 1486 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN347@Resize:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Resize<<lambda_73aa1e031ed5205b52738960793434b5> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0<lambda_73aa1e031ed5205b52738960793434b5>@@QAE@QAV?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_73aa1e031ed5205b52738960793434b5>@@QAE@QAV?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@Z PROC ; <lambda_73aa1e031ed5205b52738960793434b5>::<lambda_73aa1e031ed5205b52738960793434b5>, COMDAT
; _this$ = ecx

; 1494 : 			};

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __This$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_73aa1e031ed5205b52738960793434b5>@@QAE@QAV?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@Z ENDP ; <lambda_73aa1e031ed5205b52738960793434b5>::<lambda_73aa1e031ed5205b52738960793434b5>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??R<lambda_73aa1e031ed5205b52738960793434b5>@@QBEPAU_Loop_vals_t@std@@PAU12@I@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
$T1 = 12						; size = 1
__Count$ = 12						; size = 4
??R<lambda_73aa1e031ed5205b52738960793434b5>@@QBEPAU_Loop_vals_t@std@@PAU12@I@Z PROC ; <lambda_73aa1e031ed5205b52738960793434b5>::operator(), COMDAT
; _this$ = ecx

; 1492 : 			{

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [ecx]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1494 : 			};

	pop	ebp
	ret	8
??R<lambda_73aa1e031ed5205b52738960793434b5>@@QBEPAU_Loop_vals_t@std@@PAU12@I@Z ENDP ; <lambda_73aa1e031ed5205b52738960793434b5>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@I@std@@PAI@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@I@std@@PAI@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned int>,unsigned int *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@I@std@@PAI@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned int>,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPB_WPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z
_TEXT	SEGMENT
__Pfirst$ = 8						; size = 4
__Matches$ = 12						; size = 4
__Full_match$ = 16					; size = 1
??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPB_WPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >, COMDAT
; _this$ = ecx

; 2052 : 		{	// try to match

	npad	2
	push	ebp
	mov	ebp, esp

; 2053 : 		_First = _Pfirst;
; 2054 : 		return (_Match(_Matches, _Full_match));

	push	DWORD PTR __Full_match$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	push	DWORD PTR __Matches$[ebp]
	mov	DWORD PTR [ecx+84], eax
	call	??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >

; 2055 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPB_WPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z
_TEXT	SEGMENT
__Matches$ = 8						; size = 4
_this$1$ = 12						; size = 4
__Full_match$ = 12					; size = 1
??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >, COMDAT
; _this$ = ecx

; 2060 : 		{	// try to match

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2061 : 		if (_Matches)

	mov	edi, DWORD PTR __Matches$[ebp]
	mov	esi, ecx
	test	edi, edi
	je	SHORT $LN5@Match

; 1428 : 		_Matches.resize(_Nx);

	lea	ecx, DWORD PTR [edi+8]

; 2062 : 			{	// clear _Matches before doing work
; 2063 : 			_Matches->_Ready = true;

	mov	BYTE PTR [edi+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	ecx
	push	0
	call	??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Resize<<lambda_cfdb45d3a034db37f9e74d96913a06ba> >
$LN5@Match:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2067 : 		_Begin = _First;

	mov	eax, DWORD PTR [esi+84]

; 2068 : 		_Tgt_state._Cur = _First;
; 2069 : 		_Tgt_state._Grp_valid.resize(_Get_ncap());

	lea	ecx, DWORD PTR [esi+4]
	push	0
	push	DWORD PTR [esi+104]
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi], eax
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 2070 : 		_Tgt_state._Grps.resize(_Get_ncap());

	lea	ecx, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	ecx
	push	DWORD PTR [esi+104]
	call	??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Resize<<lambda_3726096f4ce354b1c936d6bab7ace3a2> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2078 : 		if (!_Match_pat(_Rep))

	push	DWORD PTR [esi+88]
	test	edi, edi
	mov	DWORD PTR [esi+120], 10000000		; 00989680H
	mov	ecx, esi
	mov	DWORD PTR [esi+124], 1000		; 000003e8H
	setne	al
	mov	BYTE PTR [esi+100], 0
	mov	BYTE PTR [esi+101], al
	mov	al, BYTE PTR __Full_match$[ebp]
	mov	BYTE PTR [esi+116], al
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	test	al, al
	jne	SHORT $LN6@Match
	pop	edi
	pop	esi

; 2114 : 		}

	pop	ebp
	ret	8
$LN6@Match:

; 2079 : 			return (false);
; 2080 : 
; 2081 : 		if (_Matches)

	test	edi, edi
	je	$LN7@Match
	push	ebx

; 1428 : 		_Matches.resize(_Nx);

	add	edi, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	edi
	push	DWORD PTR [esi+104]
	mov	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 1428 : 		_Matches.resize(_Nx);

	mov	DWORD PTR _this$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1496 : 		_Resize(_Newsize, _Lambda_default);

	call	??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Resize<<lambda_cfdb45d3a034db37f9e74d96913a06ba> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2084 : 			for (unsigned int _Idx = 0; _Idx < _Get_ncap(); ++_Idx)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+104], ebx
	jbe	SHORT $LN3@Match

; 1428 : 		_Matches.resize(_Nx);

	xor	edi, edi
$LL4@Match:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [esi+36]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	eax, ebx
	shr	eax, 5
	lea	edx, DWORD PTR [ecx+eax*4]

; 2095 : 		_Myoff %= _VBITS;

	mov	ecx, ebx
	and	ecx, 31					; 0000001fH

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	eax, 1
	shl	eax, cl

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	eax, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2088 : 					_Matches->_At(_Idx).matched = true;

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [edx]
	je	SHORT $LN8@Match
	mov	BYTE PTR [edi+eax+8], 1

; 2089 : 					_Matches->_At(_Idx).first = _Res._Grps[_Idx]._Begin;

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ebx*8]
	mov	DWORD PTR [edi+ecx], eax

; 2090 : 					_Matches->_At(_Idx).second = _Res._Grps[_Idx]._End;

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+ebx*8+4]

; 2091 : 					}
; 2092 : 				else

	jmp	SHORT $LN235@Match
$LN8@Match:

; 2093 : 					{	// copy failed match
; 2094 : 					_Matches->_At(_Idx).matched = false;

	mov	BYTE PTR [edi+eax+8], 0

; 2095 : 					_Matches->_At(_Idx).first = _End;

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [edi+ecx], eax

; 2096 : 					_Matches->_At(_Idx).second = _End;

	mov	eax, DWORD PTR [esi+80]
$LN235@Match:
	mov	ecx, DWORD PTR [edx]
	inc	ebx
	mov	DWORD PTR [edi+ecx+4], eax
	add	edi, 12					; 0000000cH
	cmp	ebx, DWORD PTR [esi+104]
	jb	SHORT $LL4@Match
	mov	edi, DWORD PTR _this$1$[ebp]
$LN3@Match:

; 2097 : 					}
; 2098 : 				}
; 2099 : 			_Matches->_Org = _Begin;

	mov	edx, DWORD PTR __Matches$[ebp]
	mov	eax, DWORD PTR [esi+76]
	pop	ebx
	mov	DWORD PTR [edx], eax

; 2100 : 			_Matches->_Pfx().first = _Begin;

	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR [edx+20], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2101 : 			_Matches->_Pfx().second = _Matches->_At(0).first;

	mov	eax, DWORD PTR [eax]

; 2102 : 			_Matches->_Pfx().matched =

	cmp	ecx, eax
	mov	DWORD PTR [edx+24], eax
	setne	al
	mov	BYTE PTR [edx+28], al

; 2103 : 				_Matches->_Pfx().first != _Matches->_Pfx().second;
; 2104 : 
; 2105 : 			_Matches->_Sfx().first = _Matches->_At(0).second;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+32], ecx

; 2106 : 			_Matches->_Sfx().second = _End;

	mov	eax, DWORD PTR [esi+80]

; 2107 : 			_Matches->_Sfx().matched =

	cmp	ecx, eax
	mov	DWORD PTR [edx+36], eax
	setne	al
	mov	BYTE PTR [edx+40], al

; 2108 : 				_Matches->_Sfx().first != _Matches->_Sfx().second;
; 2109 : 
; 2110 : 			_Matches->_Null().first = _End;

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [edx+44], eax

; 2111 : 			_Matches->_Null().second = _End;

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [edx+48], eax
$LN7@Match:

; 2112 : 			}
; 2113 : 		return (true);

	pop	edi
	mov	al, 1
	pop	esi

; 2114 : 		}

	pop	ebp
	ret	8
??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@XZ PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::~_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+64]
	test	ecx, ecx
	je	SHORT $LN7@Matcher

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+72]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+64], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+68], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+72], 0
$LN7@Matcher:
	lea	ecx, DWORD PTR [esi+32]
	call	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
??1?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@XZ ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::~_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Get_ncap@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABEIXZ
_TEXT	SEGMENT
?_Get_ncap@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABEIXZ PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Get_ncap, COMDAT
; _this$ = ecx

; 4526 : 	return (static_cast<unsigned int>(_Ncap));

	mov	eax, DWORD PTR [ecx+104]

; 4527 : 	}

	ret	0
?_Get_ncap@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABEIXZ ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Get_ncap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Is_wbound@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABE_NXZ
_TEXT	SEGMENT
?_Is_wbound@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABE_NXZ PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Is_wbound, COMDAT
; _this$ = ecx

; 133  : _BITMASK_OPS(match_flag_type)

	mov	eax, DWORD PTR [ecx+96]
	test	eax, 256				; 00000100H

; 4503 : 	if ((_Mflags & regex_constants::match_prev_avail)
; 4504 : 		|| _Tgt_state._Cur != _Begin)

	jne	SHORT $LN4@Is_wbound
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [ecx+76]
	jne	SHORT $LN4@Is_wbound

; 4510 : 		}
; 4511 : 	else
; 4512 : 		{	// --_Cur is not valid
; 4513 : 		if (_Tgt_state._Cur == _End)

	cmp	edx, DWORD PTR [ecx+80]
	jne	SHORT $LN7@Is_wbound

; 133  : _BITMASK_OPS(match_flag_type)

	test	al, 12					; 0000000cH
	sete	al

; 4517 : 		}
; 4518 : 	}

	ret	0
$LN7@Is_wbound:

; 133  : _BITMASK_OPS(match_flag_type)

	test	al, 4

; 4514 : 			return ((_Mflags & (regex_constants::match_not_bow | regex_constants::match_not_eow)) == 0);
; 4515 : 		else
; 4516 : 			return ((_Mflags & regex_constants::match_not_bow) == 0 && _Is_word(*_Tgt_state._Cur));

	jne	SHORT $LN10@Is_wbound

; 639  : 	const auto _UCh = static_cast<_UElem>(_Ch);

	movzx	eax, WORD PTR [edx]
$LN62@Is_wbound:

; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	cmp	eax, 122				; 0000007aH
	ja	SHORT $LN10@Is_wbound

; 626  : 	return (_Is_word_table[_UCh]);

	movzx	eax, al

; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	cmp	BYTE PTR ?_Is_word_table@?1??_Is_word@std@@YA_NE@Z@4QB_NB[eax], 0
	je	SHORT $LN10@Is_wbound

; 4514 : 			return ((_Mflags & (regex_constants::match_not_bow | regex_constants::match_not_eow)) == 0);
; 4515 : 		else
; 4516 : 			return ((_Mflags & regex_constants::match_not_bow) == 0 && _Is_word(*_Tgt_state._Cur));

	mov	eax, 1

; 4517 : 		}
; 4518 : 	}

	ret	0
$LN4@Is_wbound:

; 4505 : 		{	// if --_Cur is valid, check for preceding word character
; 4506 : 		if (_Tgt_state._Cur == _End)

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [ecx+80]
	jne	SHORT $LN5@Is_wbound

; 133  : _BITMASK_OPS(match_flag_type)

	test	al, 8

; 4507 : 			return ((_Mflags & regex_constants::match_not_eow) == 0 && _Is_word(*_STD prev(_Tgt_state._Cur)));

	jne	SHORT $LN10@Is_wbound

; 639  : 	const auto _UCh = static_cast<_UElem>(_Ch);

	movzx	eax, WORD PTR [edx-2]

; 4507 : 			return ((_Mflags & regex_constants::match_not_eow) == 0 && _Is_word(*_STD prev(_Tgt_state._Cur)));

	jmp	SHORT $LN62@Is_wbound
$LN10@Is_wbound:
	xor	eax, eax

; 4517 : 		}
; 4518 : 	}

	ret	0
$LN5@Is_wbound:

; 639  : 	const auto _UCh = static_cast<_UElem>(_Ch);

	movzx	eax, WORD PTR [edx-2]
	push	ebx

; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	cmp	eax, 122				; 0000007aH
	ja	SHORT $LN38@Is_wbound

; 626  : 	return (_Is_word_table[_UCh]);

	movzx	eax, al

; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	cmp	BYTE PTR ?_Is_word_table@?1??_Is_word@std@@YA_NE@Z@4QB_NB[eax], 0
	je	SHORT $LN38@Is_wbound
	mov	ebx, 1
	jmp	SHORT $LN39@Is_wbound
$LN38@Is_wbound:
	xor	ebx, ebx
$LN39@Is_wbound:

; 639  : 	const auto _UCh = static_cast<_UElem>(_Ch);

	movzx	eax, WORD PTR [edx]

; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	cmp	eax, 122				; 0000007aH
	ja	SHORT $LN44@Is_wbound

; 626  : 	return (_Is_word_table[_UCh]);

	movzx	eax, al

; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	cmp	BYTE PTR ?_Is_word_table@?1??_Is_word@std@@YA_NE@Z@4QB_NB[eax], 0
	je	SHORT $LN44@Is_wbound
	mov	ecx, 1

; 4508 : 		else
; 4509 : 			return (_Is_word(*_STD prev(_Tgt_state._Cur)) != _Is_word(*_Tgt_state._Cur));

	xor	eax, eax
	cmp	bl, cl
	pop	ebx
	setne	al

; 4517 : 		}
; 4518 : 	}

	ret	0
$LN44@Is_wbound:

; 640  : 	return (_UCh <= static_cast<_UElem>('z') && _Is_word(static_cast<unsigned char>(_UCh)));

	xor	ecx, ecx

; 4508 : 		else
; 4509 : 			return (_Is_word(*_STD prev(_Tgt_state._Cur)) != _Is_word(*_Tgt_state._Cur));

	xor	eax, eax
	cmp	bl, cl
	pop	ebx
	setne	al

; 4517 : 		}
; 4518 : 	}

	ret	0
?_Is_wbound@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABE_NXZ ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Is_wbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Better_match@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NXZ
_TEXT	SEGMENT
?_Better_match@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NXZ PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Better_match, COMDAT
; _this$ = ecx

; 4480 : 	{	// check for better match under UNIX rules

	npad	2
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 4481 : 	for (unsigned int _Ix = 0; _Ix < _Get_ncap(); ++_Ix)

	xor	esi, esi
	cmp	DWORD PTR [edi+104], esi
	jbe	SHORT $LN216@Better_mat
	npad	2
$LL4@Better_mat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR [edi+36]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	edx, esi
	shr	edx, 5

; 2095 : 		_Myoff %= _VBITS;

	mov	ecx, esi
	shl	edx, 2
	and	ecx, 31					; 0000001fH
	add	eax, edx

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	ebx, 1
	shl	ebx, cl

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	ebx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4483 : 		if (!_Res._Grp_valid[_Ix] || !_Tgt_state._Grp_valid[_Ix])

	je	SHORT $LN2@Better_mat
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR [edi+4]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	add	eax, edx

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	ebx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4483 : 		if (!_Res._Grp_valid[_Ix] || !_Tgt_state._Grp_valid[_Ix])

	je	SHORT $LN2@Better_mat

; 4481 : 	for (unsigned int _Ix = 0; _Ix < _Get_ncap(); ++_Ix)

	mov	eax, DWORD PTR [edi+20]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [edi+52]
	lea	edx, DWORD PTR [eax+esi*8]

; 4484 : 			;
; 4485 : 		else if (_Res._Grps[_Ix]._Begin
; 4486 : 			!= _Tgt_state._Grps[_Ix]._Begin)

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN211@Better_mat

; 4488 : 				< _STD distance(_Begin, _Tgt_state._Grps[_Ix]._Begin));
; 4489 : 		else if (_Res._Grps[_Ix]._End
; 4490 : 			!= _Tgt_state._Grps[_Ix]._End)

	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN212@Better_mat
$LN2@Better_mat:

; 4481 : 	for (unsigned int _Ix = 0; _Ix < _Get_ncap(); ++_Ix)

	inc	esi
	cmp	esi, DWORD PTR [edi+104]
	jb	SHORT $LL4@Better_mat
$LN216@Better_mat:
	pop	edi
	pop	esi

; 4492 : 				< _STD distance(_Begin, _Tgt_state._Grps[_Ix]._End));
; 4493 : 		}
; 4494 : 	return (false);

	xor	al, al
	pop	ebx

; 4495 : 	}

	ret	0
$LN212@Better_mat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax+esi*8+4]
	mov	eax, DWORD PTR [edi+20]
	sub	edx, DWORD PTR [edi+76]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4491 : 			return (_STD distance(_Begin, _Res._Grps[_Ix]._End)

	and	edx, -2					; fffffffeH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR [eax+esi*8+4]
	sub	eax, DWORD PTR [edi+76]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4491 : 			return (_STD distance(_Begin, _Res._Grps[_Ix]._End)

	and	eax, -2					; fffffffeH
	pop	edi
	cmp	edx, eax
	pop	esi
	setl	al
	pop	ebx

; 4495 : 	}

	ret	0
$LN211@Better_mat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [edi+20]
	sub	edx, DWORD PTR [edi+76]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4487 : 			return (_STD distance(_Begin, _Res._Grps[_Ix]._Begin)

	and	edx, -2					; fffffffeH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR [eax+esi*8]
	sub	eax, DWORD PTR [edi+76]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4487 : 			return (_STD distance(_Begin, _Res._Grps[_Ix]._Begin)

	and	eax, -2					; fffffffeH
	pop	edi
	cmp	edx, eax
	pop	esi
	setl	al
	pop	ebx

; 4495 : 	}

	ret	0
?_Better_match@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NXZ ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Better_match
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z
_TEXT	SEGMENT
__St$5 = -44						; size = 20
__Ch$1$ = -20						; size = 4
tv1389 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Nx$ = 8						; size = 4
?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat, COMDAT
; _this$ = ecx

; 4535 : 	{	// check for match

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	esi, ecx

; 4536 : 	if (0 < _Max_stack_count && --_Max_stack_count <= 0)

	mov	eax, DWORD PTR [esi+124]
	test	eax, eax
	jle	SHORT $LN9@Match_pat
	dec	eax
	mov	DWORD PTR [esi+124], eax
	test	eax, eax
	jg	SHORT $LN9@Match_pat

; 4537 : 		_Xregex_error(regex_constants::error_stack);

	push	12					; 0000000cH
	call	DWORD PTR __imp_?_Xregex_error@std@@YAXW4error_type@regex_constants@1@@Z
$LN330@Match_pat:
$LN9@Match_pat:

; 4538 : 	if (0 < _Max_complexity_count && --_Max_complexity_count <= 0)

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	jle	SHORT $LN10@Match_pat
	dec	eax
	mov	DWORD PTR [esi+120], eax
	test	eax, eax
	jg	SHORT $LN10@Match_pat

; 4539 : 		_Xregex_error(regex_constants::error_complexity);

	push	11					; 0000000bH
	call	DWORD PTR __imp_?_Xregex_error@std@@YAXW4error_type@regex_constants@1@@Z
$LN331@Match_pat:
$LN10@Match_pat:
	push	ebx

; 4540 : 
; 4541 : 	bool _Failed = false;
; 4542 : 	while (_Nx != 0)

	mov	ebx, DWORD PTR __Nx$[ebp]
	xor	cl, cl
	mov	DWORD PTR tv1389[ebp], ecx
	push	edi
	test	ebx, ebx
	je	$LN323@Match_pat
	mov	edi, 1
$LL2@Match_pat:

; 4543 : 		{	// match current node
; 4544 : 		switch (_Nx->_Kind)

	mov	edx, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 20					; 00000014H
	ja	$LN57@Match_pat
	jmp	DWORD PTR $LN329@Match_pat[eax*4]
$LN12@Match_pat:

; 133  : _BITMASK_OPS(match_flag_type)

	test	DWORD PTR [esi+96], 256			; 00000100H

; 4545 : 			{	// handle current node's type
; 4546 : 			case _N_nop:
; 4547 : 				break;
; 4548 : 
; 4549 : 			case _N_bol:
; 4550 : 				if ((_Mflags & regex_constants::match_prev_avail)
; 4551 : 					|| _Tgt_state._Cur != _Begin)

	jne	SHORT $LN15@Match_pat
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [esi+76]
	jne	SHORT $LN15@Match_pat

; 133  : _BITMASK_OPS(match_flag_type)

	mov	cl, BYTE PTR [esi+96]
	and	ecx, -255				; ffffff01H
	mov	DWORD PTR tv1389[ebp], ecx

; 4554 : 					}
; 4555 : 				else
; 4556 : 					_Failed = (_Mflags & regex_constants::match_not_bol) != 0;

	jmp	$LN4@Match_pat
$LN15@Match_pat:

; 4552 : 					{	// if --_Cur is valid, check for preceding newline
; 4553 : 					_Failed = *_STD prev(_Tgt_state._Cur) != _Meta_nl;

	mov	eax, DWORD PTR [esi]
	cmp	WORD PTR [eax-2], 10			; 0000000aH
	setne	cl
	mov	DWORD PTR tv1389[ebp], ecx

; 4557 : 				break;

	jmp	$LN4@Match_pat
$LN16@Match_pat:

; 4558 : 
; 4559 : 			case _N_eol:
; 4560 : 				if (_Tgt_state._Cur == _End)

	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [esi+80]
	jne	SHORT $LN17@Match_pat

; 4561 : 					_Failed = (_Mflags & regex_constants::match_not_eol) != 0;

	mov	ecx, DWORD PTR [esi+96]
	shr	ecx, 1
	and	ecx, -255				; ffffff01H
	mov	DWORD PTR tv1389[ebp], ecx

; 4562 : 				else

	jmp	$LN4@Match_pat
$LN17@Match_pat:

; 4563 : 					_Failed = *_Tgt_state._Cur != _Meta_nl;

	cmp	WORD PTR [eax], 10			; 0000000aH
	setne	cl
	mov	DWORD PTR tv1389[ebp], ecx

; 4564 : 				break;

	jmp	$LN4@Match_pat
$LN19@Match_pat:

; 4565 : 
; 4566 : 			case _N_wbound:
; 4567 : 				_Failed = _Is_wbound() == ((_Nx->_Flags & _Fl_negate) != 0);

	mov	ecx, esi
	call	?_Is_wbound@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@ABE_NXZ ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Is_wbound
	mov	ecx, DWORD PTR [ebx+8]
	and	ecx, 1
	cmp	al, cl
	sete	cl
	mov	DWORD PTR tv1389[ebp], ecx

; 4568 : 				break;

	jmp	$LN4@Match_pat
$LN20@Match_pat:

; 4569 : 
; 4570 : 			case _N_dot:
; 4571 : 				if (_Tgt_state._Cur == _End
; 4572 : 					|| *_Tgt_state._Cur == _Meta_nl
; 4573 : 					|| *_Tgt_state._Cur == _Meta_cr)

	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [esi+80]
	je	$LN315@Match_pat
	movzx	edx, WORD PTR [eax]
	cmp	edx, 10					; 0000000aH
	je	$LN315@Match_pat
	cmp	edx, 13					; 0000000dH
	je	$LN315@Match_pat

; 4574 : 					_Failed = true;
; 4575 : 				else
; 4576 : 					++_Tgt_state._Cur;

	add	eax, 2
	mov	DWORD PTR [esi], eax

; 4577 : 				break;

	jmp	$LN4@Match_pat
$LN24@Match_pat:

; 4578 : 
; 4579 : 			case _N_str:
; 4580 : 				{	// check for string match
; 4581 : 				_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Nx;
; 4582 : 				_It _Res0;
; 4583 : 				if ((_Res0 = _Compare(_Tgt_state._Cur, _End,
; 4584 : 					_Node->_Data._Str(),
; 4585 : 					_Node->_Data._Str() + _Node->_Data._Size(),
; 4586 : 					_Traits, _Sflags))
; 4587 : 						!= _Tgt_state._Cur)

	push	DWORD PTR [esi+92]

; 1592 : 		return (_Chrs);

	mov	ecx, DWORD PTR [ebx+28]

; 1573 : 		return (_Nchrs);

	mov	eax, DWORD PTR [ebx+24]

; 4578 : 
; 4579 : 			case _N_str:
; 4580 : 				{	// check for string match
; 4581 : 				_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Nx;
; 4582 : 				_It _Res0;
; 4583 : 				if ((_Res0 = _Compare(_Tgt_state._Cur, _End,
; 4584 : 					_Node->_Data._Str(),
; 4585 : 					_Node->_Data._Str() + _Node->_Data._Size(),
; 4586 : 					_Traits, _Sflags))
; 4587 : 						!= _Tgt_state._Cur)

	push	DWORD PTR [esi+112]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	push	ecx
	push	DWORD PTR [esi+80]
	push	DWORD PTR [esi]
	call	??$_Compare@PB_WPB_WV?$regex_traits@_W@std@@@std@@YAPB_WPB_W000ABV?$regex_traits@_W@0@W4syntax_option_type@regex_constants@0@@Z ; std::_Compare<wchar_t const *,wchar_t const *,std::regex_traits<wchar_t> >
	add	esp, 24					; 00000018H
	cmp	eax, DWORD PTR [esi]
	je	$LN315@Match_pat

; 4588 : 					_Tgt_state._Cur = _Res0;
; 4589 : 				else
; 4590 : 					_Failed = true;
; 4591 : 				break;

	mov	ecx, DWORD PTR tv1389[ebp]
	mov	DWORD PTR [esi], eax
	jmp	$LN4@Match_pat
$LN27@Match_pat:

; 4592 : 				}
; 4593 : 
; 4594 : 			case _N_class:
; 4595 : 				{	// check for bracket expression match
; 4596 : 				_Failed = _Tgt_state._Cur == _End

	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [esi+80]
	je	$LN315@Match_pat
	push	ebx
	mov	ecx, esi
	call	?_Do_class@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_class
	test	al, al
	je	$LN315@Match_pat
	xor	cl, cl
	mov	DWORD PTR tv1389[ebp], ecx
	jmp	SHORT $LN58@Match_pat
$LN30@Match_pat:

; 4597 : 					|| !_Do_class(_Nx);
; 4598 : 				break;
; 4599 : 				}
; 4600 : 
; 4601 : 			case _N_group:
; 4602 : 				break;
; 4603 : 
; 4604 : 			case _N_end_group:
; 4605 : 				break;
; 4606 : 
; 4607 : 			case _N_neg_assert:
; 4608 : 			case _N_assert:
; 4609 : 				{	// check assert
; 4610 : 				_It _Ch = _Tgt_state._Cur;

	mov	eax, DWORD PTR [esi]
	lea	edi, DWORD PTR [esi+4]

; 4611 : 				bool _Neg = _Nx->_Kind == _N_neg_assert;

	cmp	edx, 11					; 0000000bH
	mov	DWORD PTR __Ch$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	push	edi
	lea	ecx, DWORD PTR __St$5[ebp+4]
	mov	DWORD PTR __St$5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4611 : 				bool _Neg = _Nx->_Kind == _N_neg_assert;

	sete	bl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR __St$5[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4613 : 				if (_Match_pat(((_Node_assert *)_Nx)->_Child) == _Neg)

	mov	eax, DWORD PTR __Nx$[ebp]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR [eax+20]
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	cmp	al, bl
	jne	SHORT $LN31@Match_pat

; 4614 : 					{	// restore initial state and indicate failure
; 4615 : 					_Tgt_state = _St;

	lea	eax, DWORD PTR __St$5[ebp]
	mov	ecx, esi
	push	eax
	call	??4?$_Tgt_state_t@PB_W@std@@QAEXABV?$_Bt_state_t@PB_W@1@@Z ; std::_Tgt_state_t<wchar_t const *>::operator=

; 4616 : 					_Failed = true;

	mov	edx, 1
	mov	DWORD PTR tv1389[ebp], edx

; 4617 : 					}
; 4618 : 				else

	jmp	SHORT $LN32@Match_pat
$LN31@Match_pat:

; 4619 : 					_Tgt_state._Cur = _Ch;

	mov	eax, DWORD PTR __Ch$1$[ebp]
	mov	DWORD PTR [esi], eax
$LN32@Match_pat:

; 4620 : 				break;

	lea	ecx, DWORD PTR __St$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1?$_Bt_state_t@PB_W@std@@QAE@XZ
	mov	ebx, DWORD PTR __Nx$[ebp]
$LN317@Match_pat:
	mov	ecx, DWORD PTR tv1389[ebp]
$LN324@Match_pat:
	mov	edi, 1
$LN4@Match_pat:

; 4715 : 			}
; 4716 : 
; 4717 : 		if (_Failed)

	test	cl, cl
	jne	SHORT $LN323@Match_pat
$LN58@Match_pat:

; 4718 : 			_Nx = 0;
; 4719 : 		else if (_Nx)

	test	ebx, ebx
	je	SHORT $LN323@Match_pat

; 4720 : 			_Nx = _Nx->_Next;

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR __Nx$[ebp], ebx
	test	ebx, ebx
	jne	$LL2@Match_pat
$LN323@Match_pat:
	mov	ecx, DWORD PTR tv1389[ebp]
$LN3@Match_pat:

; 4721 : 		}
; 4722 : 
; 4723 : 	if (0 < _Max_stack_count)

	mov	eax, DWORD PTR [esi+124]
	pop	edi
	pop	ebx
	test	eax, eax
	jle	SHORT $LN61@Match_pat

; 4724 : 		++_Max_stack_count;

	inc	eax
	mov	DWORD PTR [esi+124], eax
$LN61@Match_pat:

; 4725 : 	return (!_Failed);
; 4726 : 	}

	test	cl, cl
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	sete	al
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN34@Match_pat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	edx, DWORD PTR [ebx+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4630 : 				_Tgt_state._Grps[_Node->_Idx]._Begin = _Tgt_state._Cur;

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edx*8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2918 : 		return (this->_Mysize);

	mov	edi, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4632 : 					_Node->_Idx < _Idx; )

	cmp	DWORD PTR [ebx+20], edi
	jae	SHORT $LN317@Match_pat
$LL6@Match_pat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4633 : 					_Tgt_state._Grp_valid[--_Idx] = false;

	dec	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	eax, edi
	shr	eax, 5
	lea	edx, DWORD PTR [ecx+eax*4]

; 2095 : 		_Myoff %= _VBITS;

	mov	ecx, edi

; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	mov	eax, DWORD PTR [edx]

; 2095 : 		_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH

; 2146 : 			*(_Vbase *)_Getptr() &= (~_Mask());	// STET

	btr	eax, ecx
	mov	DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4632 : 					_Node->_Idx < _Idx; )

	cmp	DWORD PTR [ebx+20], edi
	jb	SHORT $LL6@Match_pat

; 4634 : 				break;

	jmp	SHORT $LN317@Match_pat
$LN35@Match_pat:

; 4635 : 				}
; 4636 : 
; 4637 : 			case _N_end_capture:
; 4638 : 				{	// record successful capture
; 4639 : 				_Node_end_group *_Node = (_Node_end_group *)_Nx;
; 4640 : 				_Node_capture *_Node0 = (_Node_capture *)_Node->_Back;
; 4641 : 				if (_Cap || _Node0->_Idx != 0)

	cmp	BYTE PTR [esi+101], 0
	mov	edi, DWORD PTR [ebx+20]
	jne	SHORT $LN37@Match_pat
	cmp	DWORD PTR [edi+20], 0
	je	$LN324@Match_pat
$LN37@Match_pat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2093 : 		_Myoff += _Off;

	mov	edx, DWORD PTR [edi+20]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	eax, edx

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [esi+4]

; 2095 : 		_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	shr	eax, 5
	lea	ecx, DWORD PTR [ecx+eax*4]

; 2144 : 			*(_Vbase *)_Getptr() |= _Mask();

	mov	eax, DWORD PTR [ecx]
	bts	eax, edx
	mov	DWORD PTR [ecx], eax

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	edx, DWORD PTR [edi+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4644 : 					_Tgt_state._Grps[_Node0->_Idx]._End = _Tgt_state._Cur;

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 4645 : 					}
; 4646 : 				break;

	jmp	$LN317@Match_pat
$LN38@Match_pat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2093 : 		_Myoff += _Off;

	mov	edi, DWORD PTR [ebx+20]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	eax, edi

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [esi+4]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	shr	eax, 5
	lea	edx, DWORD PTR [ecx+eax*4]

; 2095 : 		_Myoff %= _VBITS;

	mov	ecx, edi
	and	ecx, 31					; 0000001fH

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	eax, 1
	shl	eax, cl

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	eax, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4652 : 				if (_Tgt_state._Grp_valid[_Node->_Idx])

	je	$LN317@Match_pat

; 4653 : 					{	// check for match
; 4654 : 					_It _Res0 = _Tgt_state._Cur;
; 4655 : 					_It _Bx = _Tgt_state._Grps[_Node->_Idx]._Begin;

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+edi*8]

; 4656 : 					_It _Ex = _Tgt_state._Grps[_Node->_Idx]._End;

	mov	eax, DWORD PTR [eax+edi*8+4]

; 4657 : 					if (_Bx != _Ex	// _Bx == _Ex for zero-length match
; 4658 : 						&& (_Res0 = _Compare(_Tgt_state._Cur, _End,

	cmp	edx, eax
	je	SHORT $LN40@Match_pat
	push	DWORD PTR [esi+92]
	push	DWORD PTR [esi+112]
	push	eax
	push	edx
	push	DWORD PTR [esi+80]
	push	ecx
	call	??$_Compare@PB_WPB_WV?$regex_traits@_W@std@@@std@@YAPB_WPB_W000ABV?$regex_traits@_W@0@W4syntax_option_type@regex_constants@0@@Z ; std::_Compare<wchar_t const *,wchar_t const *,std::regex_traits<wchar_t> >
	mov	ecx, eax
	add	esp, 24					; 00000018H
	cmp	ecx, DWORD PTR [esi]
	je	$LN315@Match_pat
$LN40@Match_pat:

; 4662 : 					else
; 4663 : 						_Tgt_state._Cur = _Res0;

	mov	DWORD PTR [esi], ecx

; 4664 : 					}
; 4665 : 				break;

	jmp	$LN317@Match_pat
$LN42@Match_pat:

; 4666 : 				}
; 4667 : 
; 4668 : 			case _N_if:
; 4669 : 				if (!_Do_if((_Node_if *)_Nx))

	push	ebx
	mov	ecx, esi
	call	?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_if
$LN327@Match_pat:
	mov	edx, DWORD PTR tv1389[ebp]
	test	al, al
	movzx	ecx, dl
	cmove	ecx, edi
	mov	DWORD PTR tv1389[ebp], ecx
$LN33@Match_pat:

; 4670 : 					_Failed = true;
; 4671 : 				_Nx = 0;

	xor	ebx, ebx

; 4672 : 				break;

	jmp	$LN4@Match_pat
$LN45@Match_pat:

; 4673 : 
; 4674 : 			case _N_endif:
; 4675 : 				break;
; 4676 : 
; 4677 : 			case _N_rep:
; 4678 : 				if (!_Do_rep((_Node_rep *)_Nx,

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, esi
	shr	eax, 1
	and	al, 1
	push	0
	movzx	eax, al
	push	eax
	push	ebx
	call	?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep

; 4679 : 					(_Nx->_Flags & _Fl_greedy) != 0, 0))
; 4680 : 					_Failed = true;
; 4681 : 				_Nx = 0;
; 4682 : 				break;

	jmp	SHORT $LN327@Match_pat
$LN47@Match_pat:

; 4683 : 
; 4684 : 			case _N_end_rep:
; 4685 : 				{	// return at end of loop
; 4686 : 				_Node_rep *_Nr = ((_Node_end_rep *)_Nx)->_Begin_rep;

	mov	edx, DWORD PTR [ebx+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR [esi+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4689 : 				if (_Nr->_Simple_loop == 0 && !_Do_rep(_Nr,

	cmp	DWORD PTR [edx+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [edx+32]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4689 : 				if (_Nr->_Simple_loop == 0 && !_Do_rep(_Nr,

	jne	SHORT $LN318@Match_pat
	push	DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	shr	eax, 1
	and	al, 1
	movzx	eax, al
	push	eax
	push	edx
	call	?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep
	jmp	SHORT $LN327@Match_pat
$LN50@Match_pat:

; 133  : _BITMASK_OPS(match_flag_type)

	test	DWORD PTR [esi+96], 8224		; 00002020H

; 4690 : 					(_Nr->_Flags & _Fl_greedy) != 0, _Psav->_Loop_idx))
; 4691 : 					_Failed = true;	// recurse only if loop contains if/do
; 4692 : 				_Nx = 0;
; 4693 : 				break;
; 4694 : 				}
; 4695 : 
; 4696 : 			case _N_begin:
; 4697 : 				break;
; 4698 : 
; 4699 : 			case _N_end:
; 4700 : 				if (((_Mflags & (regex_constants::match_not_null
; 4701 : 						| regex_constants::_Match_not_null))
; 4702 : 					&& _Begin == _Tgt_state._Cur)
; 4703 : 						|| (_Full && _Tgt_state._Cur != _End))

	je	SHORT $LN54@Match_pat
	mov	eax, DWORD PTR [esi+76]
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN53@Match_pat
$LN54@Match_pat:
	cmp	BYTE PTR [esi+116], 0
	je	SHORT $LN51@Match_pat
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [esi+80]
	je	SHORT $LN51@Match_pat
$LN53@Match_pat:

; 4704 : 					_Failed = true;

	mov	cl, 1
	xor	ebx, ebx
	mov	DWORD PTR tv1389[ebp], ecx
	jmp	$LN4@Match_pat
$LN51@Match_pat:

; 4705 : 				else if (!_Matched || _Better_match())

	cmp	BYTE PTR [esi+100], 0
	je	SHORT $LN56@Match_pat
	mov	ecx, esi
	call	?_Better_match@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NXZ ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Better_match
	test	al, al
	je	SHORT $LN318@Match_pat
$LN56@Match_pat:

; 4706 : 					{	// record successful match
; 4707 : 					_Res = _Tgt_state;

	push	esi
	lea	ecx, DWORD PTR [esi+32]
	call	??4?$_Tgt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z

; 4708 : 					_Matched = true;

	mov	BYTE PTR [esi+100], 1
$LN318@Match_pat:

; 4670 : 					_Failed = true;
; 4671 : 				_Nx = 0;

	mov	ecx, DWORD PTR tv1389[ebp]
	xor	ebx, ebx

; 4672 : 				break;

	jmp	$LN4@Match_pat
$LN315@Match_pat:

; 4659 : 							_Bx, _Ex, _Traits, _Sflags))
; 4660 : 								== _Tgt_state._Cur)
; 4661 : 						_Failed = true;

	mov	cl, 1

; 4545 : 			{	// handle current node's type
; 4546 : 			case _N_nop:
; 4547 : 				break;
; 4548 : 
; 4549 : 			case _N_bol:
; 4550 : 				if ((_Mflags & regex_constants::match_prev_avail)
; 4551 : 					|| _Tgt_state._Cur != _Begin)

	jmp	$LN3@Match_pat
$LN57@Match_pat:

; 4709 : 					}
; 4710 : 				_Nx = 0;
; 4711 : 				break;
; 4712 : 
; 4713 : 			default:
; 4714 : 				_Xregex_error(regex_constants::error_parse);

	push	13					; 0000000dH
	call	DWORD PTR __imp_?_Xregex_error@std@@YAXW4error_type@regex_constants@1@@Z
$LN332@Match_pat:
$LN326@Match_pat:
	npad	3
$LN329@Match_pat:

; 4725 : 	return (!_Failed);
; 4726 : 	}

	DD	$LN4@Match_pat
	DD	$LN12@Match_pat
	DD	$LN16@Match_pat
	DD	$LN19@Match_pat
	DD	$LN20@Match_pat
	DD	$LN24@Match_pat
	DD	$LN27@Match_pat
	DD	$LN4@Match_pat
	DD	$LN4@Match_pat
	DD	$LN30@Match_pat
	DD	$LN30@Match_pat
	DD	$LN33@Match_pat
	DD	$LN34@Match_pat
	DD	$LN35@Match_pat
	DD	$LN38@Match_pat
	DD	$LN42@Match_pat
	DD	$LN4@Match_pat
	DD	$LN45@Match_pat
	DD	$LN47@Match_pat
	DD	$LN4@Match_pat
	DD	$LN50@Match_pat
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z$0:
	lea	ecx, DWORD PTR __St$5[ebp]
	jmp	??1?$_Bt_state_t@PB_W@std@@QAE@XZ
__ehhandler$?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_class@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z
_TEXT	SEGMENT
__Res0$1$ = -4						; size = 4
__Nx$ = 8						; size = 4
?_Do_class@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_class, COMDAT
; _this$ = ecx

; 4430 : 	{	// apply bracket expression

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 113  : _BITMASK_OPS(syntax_option_type)

	test	DWORD PTR [edi+92], 256			; 00000100H

; 4431 : 	bool _Found;
; 4432 : 	typename _RxTraits::_Uelem _Ch = *_Tgt_state._Cur;

	mov	eax, DWORD PTR [edi]
	movzx	esi, WORD PTR [eax]

; 4433 : 	if (_Sflags & regex_constants::icase)

	je	SHORT $LN2@Do_class

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [edi+112]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	esi
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 4434 : 		_Ch = _Traits.translate_nocase(_Ch);

	movzx	esi, ax
$LN2@Do_class:

; 4435 : 	_It _Res0 = _Tgt_state._Cur;
; 4436 : 	++_Res0;

	mov	eax, DWORD PTR [edi]

; 4437 : 	_It _Resx;
; 4438 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 4439 : 		(_Node_class<_Elem, _RxTraits> *)_Nx;
; 4440 : 	if (_Node->_Coll
; 4441 : 		&& (_Resx = _Lookup_coll(_Tgt_state._Cur, _End, _Node->_Coll))

	mov	ebx, DWORD PTR __Nx$[ebp]
	lea	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR __Res0$1$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+20]
	test	ecx, ecx
	je	SHORT $LN3@Do_class
	push	ecx
	push	DWORD PTR [edi+80]
	push	eax
	call	??$_Lookup_coll@PB_W_W@std@@YAPB_WPB_W0PBU?$_Sequence@_W@0@@Z ; std::_Lookup_coll<wchar_t const *,wchar_t>
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN3@Do_class

; 4442 : 			!= _Tgt_state._Cur)
; 4443 : 		{	// check for collation element
; 4444 : 		_Res0 = _Resx;

	mov	edx, eax

; 4445 : 		_Found = true;

	mov	ecx, 1

; 4446 : 		}
; 4447 : 	else if (_Node->_Ranges

	jmp	$LN14@Do_class
$LN3@Do_class:

; 4448 : 		&& (_Lookup_range((typename _RxTraits::_Uelem)

	cmp	DWORD PTR [ebx+32], 0
	je	SHORT $LN5@Do_class

; 113  : _BITMASK_OPS(syntax_option_type)

	test	DWORD PTR [edi+92], 2048		; 00000800H

; 4448 : 		&& (_Lookup_range((typename _RxTraits::_Uelem)

	je	SHORT $LN18@Do_class
	mov	ecx, DWORD PTR [edi+112]
	push	esi
	call	?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z ; std::_Regex_traits<wchar_t>::translate
	movzx	eax, ax
	jmp	SHORT $LN19@Do_class
$LN18@Do_class:
	movzx	eax, si
$LN19@Do_class:
	push	DWORD PTR [ebx+32]
	movzx	eax, ax
	push	eax
	call	??$_Lookup_range@_W@std@@YA_NIPBU?$_Buf@_W@0@@Z ; std::_Lookup_range<wchar_t>
	add	esp, 8
	test	al, al
	je	SHORT $LN5@Do_class

; 4449 : 			(_Sflags & regex_constants::collate
; 4450 : 				? _Traits.translate(_Ch)
; 4451 : 				: _Ch), _Node->_Ranges)))
; 4452 : 		_Found = true;

	mov	ecx, 1
	jmp	$LN64@Do_class
$LN5@Do_class:

; 4453 : 	else if (_Ch < _Bmp_max)

	mov	eax, 256				; 00000100H
	cmp	si, ax
	jae	SHORT $LN7@Do_class

; 4454 : 		_Found = _Node->_Small && _Node->_Small->_Find(_Ch);

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	$LN13@Do_class

; 1649 : 		unsigned int _Wide = _Ch;

	movzx	edx, si

; 1650 : 		return ((_Chrs[_Wide >> _Bmp_shift] & (1 << (_Wide & _Bmp_mask))) != 0);

	mov	eax, 1
	mov	ecx, edx
	shr	edx, 3
	and	ecx, 7
	shl	eax, cl
	mov	ecx, DWORD PTR [ebx+24]
	test	al, BYTE PTR [edx+ecx]

; 4454 : 		_Found = _Node->_Small && _Node->_Small->_Find(_Ch);

	je	SHORT $LN13@Do_class
	mov	ecx, 1
	jmp	SHORT $LN64@Do_class
$LN7@Do_class:

; 4456 : 		&& _STD find(_Node->_Large->_Str(),

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN9@Do_class
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 3180 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

	mov	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4456 : 		&& _STD find(_Node->_Large->_Str(),

	mov	eax, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+eax*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 3160 : 	for (; _First != _Last; ++_First)

	cmp	ecx, eax
	je	SHORT $LN9@Do_class
	npad	1
$LL49@Do_class:

; 3161 : 		if (*_First == _Val)

	cmp	WORD PTR [ecx], si
	je	SHORT $LN63@Do_class

; 3160 : 	for (; _First != _Last; ++_First)

	add	ecx, 2
	cmp	ecx, eax
	jne	SHORT $LL49@Do_class
$LN63@Do_class:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4456 : 		&& _STD find(_Node->_Large->_Str(),

	cmp	ecx, eax
	je	SHORT $LN9@Do_class

; 4457 : 			_Node->_Large->_Str() + _Node->_Large->_Size(), _Ch)
; 4458 : 				!= _Node->_Large->_Str() + _Node->_Large->_Size())
; 4459 : 		_Found = true;

	mov	ecx, 1
	jmp	SHORT $LN64@Do_class
$LN9@Do_class:

; 4460 : 	else if (_Node->_Classes != 0 && _Traits.isctype(_Ch, _Node->_Classes))

	movzx	eax, WORD PTR [ebx+36]
	test	ax, ax
	je	SHORT $LN11@Do_class
	mov	ecx, DWORD PTR [edi+112]
	push	eax
	push	esi
	call	?isctype@?$_Regex_traits@_W@std@@QBE_N_WF@Z ; std::_Regex_traits<wchar_t>::isctype
	test	al, al
	je	SHORT $LN11@Do_class

; 4461 : 		_Found = true;

	mov	ecx, 1
	jmp	SHORT $LN64@Do_class
$LN11@Do_class:

; 4462 : 	else if (_Node->_Equiv && _Lookup_equiv(_Ch, _Node->_Equiv, _Traits))

	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	SHORT $LN13@Do_class
	push	DWORD PTR [edi+112]
	push	eax
	push	esi
	call	??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z ; std::_Lookup_equiv<wchar_t,std::regex_traits<wchar_t> >
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN13@Do_class

; 4463 : 		_Found = true;

	mov	ecx, 1

; 4464 : 	else

	jmp	SHORT $LN64@Do_class
$LN13@Do_class:

; 4465 : 		_Found = false;

	xor	ecx, ecx
$LN64@Do_class:
	mov	edx, DWORD PTR __Res0$1$[ebp]
$LN14@Do_class:

; 4466 : 	if (_Found == (_Node->_Flags & _Fl_negate))

	mov	eax, DWORD PTR [ebx+8]
	and	eax, 1
	cmp	ecx, eax
	jne	SHORT $LN15@Do_class

; 4467 : 		return (false);

	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 4472 : 		}
; 4473 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN15@Do_class:

; 4468 : 	else
; 4469 : 		{	// record result
; 4470 : 		_Tgt_state._Cur = _Res0;

	mov	DWORD PTR [edi], edx

; 4471 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx

; 4472 : 		}
; 4473 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Do_class@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_class
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z
_TEXT	SEGMENT
__St$ = -60						; size = 32
__Loop_iter_sav$1$ = -28				; size = 4
__Loop_idx_sav$1$ = -24					; size = 4
__Cur_iter$ = -20					; size = 4
__Progress$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
__Node$ = 8						; size = 4
__Matched0$1$ = 11					; size = 1
__Greedy$ = 12						; size = 1
__Init_idx$ = 16					; size = 4
?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep, COMDAT
; _this$ = ecx

; 4269 : 	{	// apply repetition

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	edi

; 4270 : 	if (_Node->_Simple_loop == 1)

	mov	edi, DWORD PTR __Node$[ebp]
	mov	ebx, ecx
	cmp	DWORD PTR [edi+36], 1
	jne	SHORT $LN2@Do_rep

; 4271 : 		return (_Do_rep0(_Node, _Greedy));

	push	DWORD PTR __Greedy$[ebp]
	push	edi
	call	?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep0
	pop	edi
	pop	ebx

; 4330 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@Do_rep:
	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	lea	ecx, DWORD PTR __St$[ebp+4]
	push	esi
	lea	esi, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4273 : 	bool _Matched0 = false;

	mov	BYTE PTR __Matched0$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	push	esi
	mov	DWORD PTR __St$[ebp], eax
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR __St$[ebp+16], eax
	lea	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	ecx, DWORD PTR __St$[ebp+20]
	call	??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4278 : 	_It _Cur_iter = _Tgt_state._Cur;

	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	lea	esi, DWORD PTR [eax+ecx*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4276 : 	int _Loop_idx_sav = _Psav->_Loop_idx;

	mov	eax, DWORD PTR [esi]

; 4277 : 	_It *_Loop_iter_sav = (_It *)_Psav->_Loop_iter;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __Loop_idx_sav$1$[ebp], eax

; 4279 : 
; 4280 : 	bool _Progress = _Init_idx == 0 || *_Loop_iter_sav != _Cur_iter;

	mov	eax, DWORD PTR __Init_idx$[ebp]
	mov	DWORD PTR __Loop_iter_sav$1$[ebp], ecx
	mov	DWORD PTR __Cur_iter$[ebp], edx
	test	eax, eax
	je	SHORT $LN18@Do_rep
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LN18@Do_rep
	xor	cl, cl
	jmp	SHORT $LN51@Do_rep
$LN18@Do_rep:
	mov	cl, 1
$LN51@Do_rep:

; 4281 : 
; 4282 : 	if (0 <= _Node->_Max && _Node->_Max <= _Init_idx)

	mov	edx, DWORD PTR [edi+24]
	mov	BYTE PTR __Progress$1$[ebp], cl
	test	edx, edx
	js	SHORT $LN3@Do_rep
	cmp	edx, eax
	jle	$LN52@Do_rep
$LN3@Do_rep:

; 4283 : 		_Matched0 = _Match_pat(_Node->_End_rep->_Next);	// reps done, try tail
; 4284 : 	else if (_Init_idx < _Node->_Min)

	cmp	eax, DWORD PTR [edi+20]
	jge	SHORT $LN5@Do_rep

; 4285 : 		{	// try a required rep
; 4286 : 		if (!_Progress)

	test	cl, cl

; 4287 : 			_Matched0 = _Match_pat(_Node->_End_rep->_Next);	// empty, try tail

	mov	ecx, ebx
	je	$LN53@Do_rep

; 4288 : 		else
; 4289 : 			{	// try another required match
; 4290 : 			_Psav->_Loop_idx = _Init_idx + 1;

	inc	eax
	mov	DWORD PTR [esi], eax

; 4291 : 			_Psav->_Loop_iter = &_Cur_iter;

	lea	eax, DWORD PTR __Cur_iter$[ebp]
	mov	DWORD PTR [esi+4], eax

; 4292 : 			_Matched0 = _Match_pat(_Node->_Next);

	push	DWORD PTR [edi+12]

; 4293 : 			}

	jmp	$LN54@Do_rep
$LN5@Do_rep:

; 4294 : 		}
; 4295 : 	else if (!_Greedy)

	cmp	BYTE PTR __Greedy$[ebp], 0
	jne	SHORT $LN9@Do_rep

; 4296 : 		{	// not greedy, favor minimum number of reps
; 4297 : 		_Matched0 = _Match_pat(_Node->_End_rep->_Next);

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, ebx
	push	DWORD PTR [eax+12]
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	mov	BYTE PTR __Matched0$1$[ebp], al

; 4298 : 		if (!_Matched0 && _Progress)

	test	al, al
	jne	SHORT $LN16@Do_rep
	cmp	BYTE PTR __Progress$1$[ebp], al
	je	SHORT $LN48@Do_rep

; 4299 : 			{	// tail failed, try another rep
; 4300 : 			_Tgt_state = _St;

	lea	eax, DWORD PTR __St$[ebp]
	mov	ecx, ebx
	push	eax
	call	??4?$_Tgt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z

; 4301 : 			_Psav->_Loop_idx = _Init_idx + 1;

	mov	eax, DWORD PTR __Init_idx$[ebp]

; 4302 : 			_Psav->_Loop_iter = &_Cur_iter;
; 4303 : 			_Matched0 = _Match_pat(_Node->_Next);

	mov	ecx, ebx
	inc	eax
	mov	DWORD PTR [esi], eax
	lea	eax, DWORD PTR __Cur_iter$[ebp]
	mov	DWORD PTR [esi+4], eax
	push	DWORD PTR [edi+12]

; 4304 : 			}
; 4305 : 		}
; 4306 : 	else

	jmp	SHORT $LN54@Do_rep
$LN9@Do_rep:

; 4307 : 		{	// greedy, favor maximum number of reps
; 4308 : 		if (_Progress)

	test	cl, cl
	je	SHORT $LN47@Do_rep

; 4309 : 			{	// try another rep
; 4310 : 			_Psav->_Loop_idx = _Init_idx + 1;

	inc	eax

; 4311 : 			_Psav->_Loop_iter = &_Cur_iter;
; 4312 : 			_Matched0 = _Match_pat(_Node->_Next);

	mov	ecx, ebx
	mov	DWORD PTR [esi], eax
	lea	eax, DWORD PTR __Cur_iter$[ebp]
	mov	DWORD PTR [esi+4], eax
	push	DWORD PTR [edi+12]
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	mov	BYTE PTR __Matched0$1$[ebp], al

; 4315 : 			;
; 4316 : 		else if (!_Matched0)

	test	al, al
	jne	SHORT $LN16@Do_rep
	jmp	SHORT $LN49@Do_rep
$LN47@Do_rep:

; 4313 : 			}
; 4314 : 		if (!_Progress && 1 < _Init_idx)

	cmp	eax, 1
	jg	SHORT $LN48@Do_rep
$LN49@Do_rep:

; 4317 : 			{	// rep failed, try tail
; 4318 : 			_Psav->_Loop_idx = _Loop_idx_sav;

	mov	eax, DWORD PTR __Loop_idx_sav$1$[ebp]

; 4319 : 			_Psav->_Loop_iter = _Loop_iter_sav;
; 4320 : 			_Tgt_state = _St;

	mov	ecx, ebx
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Loop_iter_sav$1$[ebp]
	mov	DWORD PTR [esi+4], eax
	lea	eax, DWORD PTR __St$[ebp]
	push	eax
	call	??4?$_Tgt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z
$LN52@Do_rep:

; 4321 : 			_Matched0 = _Match_pat(_Node->_End_rep->_Next);

	mov	ecx, ebx
$LN53@Do_rep:
	mov	eax, DWORD PTR [edi+28]
	push	DWORD PTR [eax+12]
$LN54@Do_rep:
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	mov	BYTE PTR __Matched0$1$[ebp], al

; 4322 : 			}
; 4323 : 		}
; 4324 : 
; 4325 : 	if (!_Matched0)

	test	al, al
	jne	SHORT $LN16@Do_rep
$LN48@Do_rep:

; 4326 : 		_Tgt_state = _St;

	lea	eax, DWORD PTR __St$[ebp]
	mov	ecx, ebx
	push	eax
	call	??4?$_Tgt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z
$LN16@Do_rep:

; 4327 : 	_Psav->_Loop_idx = _Loop_idx_sav;

	mov	eax, DWORD PTR __Loop_idx_sav$1$[ebp]

; 4328 : 	_Psav->_Loop_iter = _Loop_iter_sav;
; 4329 : 	return (_Matched0);

	lea	ecx, DWORD PTR __St$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Loop_iter_sav$1$[ebp]
	mov	DWORD PTR [esi+4], eax
	call	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ

; 4330 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, BYTE PTR __Matched0$1$[ebp]
	pop	esi
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z$1:
	lea	ecx, DWORD PTR __St$[ebp]
	jmp	??1?$_Bt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z$0:
	lea	ecx, DWORD PTR __St$[ebp]
	jmp	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
__ehhandler$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Do_rep@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_NH@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z
_TEXT	SEGMENT
__St$ = -100						; size = 32
__Final$ = -68						; size = 32
__Mid$1$ = -36						; size = 4
$T2 = -32						; size = 1
$T3 = -28						; size = 1
$T4 = -24						; size = 1
$T5 = -24						; size = 1
$T6 = -24						; size = 1
__Saved_pos$1$ = -20					; size = 4
__Cur$1$ = -20						; size = 4
$T7 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Node$ = 8						; size = 4
$T8 = 12						; size = 1
$T9 = 12						; size = 1
$T10 = 12						; size = 1
$T11 = 12						; size = 1
__Greedy$ = 12						; size = 1
?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep0, COMDAT
; _this$ = ecx

; 4206 : 	{	// apply repetition to loop with no nested if/do

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 4207 : 	int _Ix = 0;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	lea	ecx, DWORD PTR __St$[ebp+4]
	mov	eax, DWORD PTR [edi]
	lea	ebx, DWORD PTR [edi+4]
	push	ebx
	mov	DWORD PTR __St$[ebp], eax
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR __St$[ebp+16], eax
	lea	eax, DWORD PTR [edi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], esi
	push	eax
	lea	ecx, DWORD PTR __St$[ebp+20]
	call	??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4210 : 	for (; _Ix < _Node->_Min; ++_Ix)

	mov	eax, DWORD PTR __Node$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR [eax+20], esi
	jle	SHORT $LN3@Do_rep0
	npad	7
$LL4@Do_rep0:

; 4211 : 		{	// do minimum number of reps
; 4212 : 		_It _Cur = _Tgt_state._Cur;

	mov	ecx, DWORD PTR [edi]

; 4213 : 		if (!_Match_pat(_Node->_Next))

	push	DWORD PTR [eax+12]
	mov	DWORD PTR __Cur$1$[ebp], ecx
	mov	ecx, edi
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	test	al, al
	je	$LN1352@Do_rep0

; 4214 : 			{	// didn't match minimum number of reps, fail
; 4215 : 			_Tgt_state = _St;
; 4216 : 			return (false);
; 4217 : 			}
; 4218 : 		else if (_Cur == _Tgt_state._Cur)

	mov	eax, DWORD PTR __Cur$1$[ebp]
	cmp	eax, DWORD PTR [edi]

; 4219 : 			_Ix = _Node->_Min - 1;	// skip matches that don't change state

	mov	eax, DWORD PTR __Node$[ebp]
	jne	SHORT $LN2@Do_rep0
	mov	esi, DWORD PTR [eax+20]
	dec	esi
$LN2@Do_rep0:

; 4210 : 	for (; _Ix < _Node->_Min; ++_Ix)

	inc	esi
	cmp	esi, DWORD PTR [eax+20]
	jl	SHORT $LL4@Do_rep0
$LN3@Do_rep0:
	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	lea	ecx, DWORD PTR __Final$[ebp+4]
	push	ebx
	mov	DWORD PTR __Final$[ebp], eax
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR __Final$[ebp+16], eax
	lea	ecx, DWORD PTR [edi+20]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	ecx
	lea	ecx, DWORD PTR __Final$[ebp+20]
	call	??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4223 : 	bool _Matched0 = false;

	xor	al, al
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR $T7[ebp], al

; 4224 : 	_It _Saved_pos = _Tgt_state._Cur;
; 4225 : 
; 4226 : 	if (!_Match_pat(_Node->_End_rep->_Next))

	mov	ecx, edi
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __Saved_pos$1$[ebp], eax
	mov	eax, DWORD PTR __Node$[ebp]
	mov	eax, DWORD PTR [eax+28]
	push	DWORD PTR [eax+12]
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	test	al, al
	je	SHORT $LL5@Do_rep0

; 4227 : 		;	// no full match yet
; 4228 : 	else if (!_Greedy)

	cmp	BYTE PTR __Greedy$[ebp], 0
	je	$LN1354@Do_rep0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __Final$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __Final$[ebp+4]
	cmp	eax, ebx
	je	SHORT $LN342@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T6[ebp], 0
	mov	ecx, eax
	push	DWORD PTR $T6[ebp]
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR __Final$[ebp+16], eax
$LN342@Do_rep0:

; 1415 : 		if (this != _STD addressof(_Right))

	lea	ecx, DWORD PTR __Final$[ebp+20]
	lea	eax, DWORD PTR [edi+20]
	cmp	ecx, eax
	je	SHORT $LN487@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T5[ebp], 0
	push	DWORD PTR $T5[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN487@Do_rep0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4233 : 		_Matched0 = true;

	mov	BYTE PTR $T7[ebp], 1
	npad	1
$LL5@Do_rep0:

; 4234 : 		}
; 4235 : 
; 4236 : 	while (_Node->_Max == -1 || _Ix++ < _Node->_Max)

	mov	eax, DWORD PTR __Node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, -1
	je	SHORT $LN14@Do_rep0
	mov	eax, esi
	inc	esi
	cmp	eax, ecx
	jge	$LN1355@Do_rep0
$LN14@Do_rep0:

; 4237 : 		{	// try another rep/tail match
; 4238 : 		_Tgt_state._Cur = _Saved_pos;

	mov	eax, DWORD PTR __Saved_pos$1$[ebp]
	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __St$[ebp+4]
	cmp	ebx, eax
	je	SHORT $LN618@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T4[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T4[ebp]
	push	DWORD PTR __St$[ebp+8]
	push	DWORD PTR __St$[ebp+4]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR __St$[ebp+16]
	mov	DWORD PTR [ebx+12], eax
$LN618@Do_rep0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4240 : 		if (!_Match_pat(_Node->_Next))

	mov	eax, DWORD PTR __Node$[ebp]
	mov	ecx, edi
	push	DWORD PTR [eax+12]
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	test	al, al
	je	$LN1355@Do_rep0

; 4241 : 			break;	// rep match failed, quit loop
; 4242 : 
; 4243 : 		_It _Mid = _Tgt_state._Cur;

	mov	eax, DWORD PTR [edi]

; 4244 : 		if (!_Match_pat(_Node->_End_rep->_Next))

	mov	ecx, edi
	mov	DWORD PTR __Mid$1$[ebp], eax
	mov	eax, DWORD PTR __Node$[ebp]
	mov	eax, DWORD PTR [eax+28]
	push	DWORD PTR [eax+12]
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	test	al, al
	je	SHORT $LN19@Do_rep0

; 4245 : 			;	// tail match failed, continue
; 4246 : 		else if (!_Greedy)

	cmp	BYTE PTR __Greedy$[ebp], 0
	je	$LN1354@Do_rep0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __Final$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __Final$[ebp+4]
	cmp	eax, ebx
	je	SHORT $LN781@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T3[ebp], 0
	mov	ecx, eax
	push	DWORD PTR $T3[ebp]
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR __Final$[ebp+16], eax
$LN781@Do_rep0:

; 1415 : 		if (this != _STD addressof(_Right))

	lea	ecx, DWORD PTR __Final$[ebp+20]
	lea	eax, DWORD PTR [edi+20]
	cmp	ecx, eax
	je	SHORT $LN926@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T2[ebp], 0
	push	DWORD PTR $T2[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN926@Do_rep0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4251 : 			_Matched0 = true;

	mov	BYTE PTR $T7[ebp], 1
$LN19@Do_rep0:

; 4252 : 			}
; 4253 : 
; 4254 : 		if (_Saved_pos == _Mid)

	mov	eax, DWORD PTR __Mid$1$[ebp]
	cmp	DWORD PTR __Saved_pos$1$[ebp], eax
	je	SHORT $LN1355@Do_rep0

; 4255 : 			break;	// rep match ate no additional elements, quit loop
; 4256 : 		_Saved_pos = _Mid;

	mov	DWORD PTR __Saved_pos$1$[ebp], eax

; 4257 : 		}

	jmp	$LL5@Do_rep0
$LN1352@Do_rep0:
	mov	eax, DWORD PTR __St$[ebp]
	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __St$[ebp+4]
	cmp	ebx, eax
	je	SHORT $LN47@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T11[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T11[ebp]
	push	DWORD PTR __St$[ebp+8]
	push	DWORD PTR __St$[ebp+4]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR __St$[ebp+16]
	mov	DWORD PTR [ebx+12], eax
$LN47@Do_rep0:

; 1415 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __St$[ebp+20]
	lea	ecx, DWORD PTR [edi+20]
	cmp	ecx, eax
	je	SHORT $LN192@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T10[ebp], 0
	push	DWORD PTR $T10[ebp]
	push	DWORD PTR __St$[ebp+24]
	push	DWORD PTR __St$[ebp+20]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN192@Do_rep0:
	xor	bl, bl
	jmp	SHORT $LN24@Do_rep0
$LN1354@Do_rep0:
	mov	bl, 1
	jmp	SHORT $LN26@Do_rep0
$LN1355@Do_rep0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4259 : 	_Tgt_state = _Matched0 ? _Final : _St;

	mov	al, BYTE PTR $T7[ebp]
	lea	esi, DWORD PTR __Final$[ebp]
	test	al, al
	lea	ecx, DWORD PTR __St$[ebp]
	cmove	esi, ecx
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	cmp	ebx, eax
	je	SHORT $LN1074@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T9[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T9[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ebx+12], eax
$LN1074@Do_rep0:
	add	esi, 20					; 00000014H

; 1415 : 		if (this != _STD addressof(_Right))

	lea	ecx, DWORD PTR [edi+20]
	cmp	ecx, esi
	je	SHORT $LN1219@Do_rep0

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T8[ebp], 0
	push	DWORD PTR $T8[ebp]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN1219@Do_rep0:
	mov	bl, BYTE PTR $T7[ebp]
$LN26@Do_rep0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4260 : 	return (_Matched0);

	lea	ecx, DWORD PTR __Final$[ebp]
	call	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
$LN24@Do_rep0:
	lea	ecx, DWORD PTR __St$[ebp]
	call	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ

; 4261 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, bl
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z$2:
	lea	ecx, DWORD PTR __St$[ebp]
	jmp	??1?$_Bt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z$0:
	lea	ecx, DWORD PTR __St$[ebp]
	jmp	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z$84:
	lea	ecx, DWORD PTR __Final$[ebp]
	jmp	??1?$_Bt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z$1:
	lea	ecx, DWORD PTR __Final$[ebp]
	jmp	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
__ehhandler$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Do_rep0@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_rep@2@_N@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_rep0
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z
_TEXT	SEGMENT
__Final$ = -100						; size = 32
__St$ = -68						; size = 32
$T2 = -36						; size = 1
$T3 = -32						; size = 1
$T4 = -28						; size = 1
$T5 = -24						; size = 1
$T6 = -24						; size = 1
_this$1$ = -20						; size = 4
__Final_len$1$ = -16					; size = 4
$T7 = -16						; size = 1
__$EHRec$ = -12						; size = 12
__Node$2$ = 8						; size = 4
$T8 = 8							; size = 1
$T9 = 8							; size = 1
__Node$ = 8						; size = 4
?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_if, COMDAT
; _this$ = ecx

; 4155 : 	{	// apply if node

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	lea	ecx, DWORD PTR __St$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4155 : 	{	// apply if node

	mov	DWORD PTR _this$1$[ebp], edi
	mov	eax, DWORD PTR [edi]
	lea	esi, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	push	esi
	mov	DWORD PTR __St$[ebp], eax
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR __St$[ebp+16], eax
	lea	ebx, DWORD PTR [edi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ebx
	lea	ecx, DWORD PTR __St$[ebp+20]
	call	??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4159 : 	for (; _Node; _Node = _Node->_Child)

	cmp	DWORD PTR __Node$[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	je	SHORT $LN1217@Do_if
	npad	4
$LL4@Do_if:
	mov	eax, DWORD PTR __St$[ebp]
	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __St$[ebp+4]
	cmp	esi, eax
	je	SHORT $LN39@Do_if

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T7[ebp], 0
	mov	ecx, esi
	push	DWORD PTR $T7[ebp]
	push	DWORD PTR __St$[ebp+8]
	push	DWORD PTR __St$[ebp+4]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR __St$[ebp+16]
	mov	DWORD PTR [esi+12], eax
$LN39@Do_if:

; 1415 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __St$[ebp+20]
	cmp	ebx, eax
	je	SHORT $LN184@Do_if

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T6[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T6[ebp]
	push	DWORD PTR __St$[ebp+24]
	push	DWORD PTR __St$[ebp+20]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN184@Do_if:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4162 : 		if (_Match_pat(_Node->_Next)) // try to match this branch

	mov	eax, DWORD PTR __Node$[ebp]
	mov	ecx, edi
	push	DWORD PTR [eax+12]
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
	test	al, al
	jne	SHORT $LN9@Do_if

; 4159 : 	for (; _Node; _Node = _Node->_Child)

	mov	eax, DWORD PTR __Node$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR __Node$[ebp], eax
	test	eax, eax
	jne	SHORT $LL4@Do_if
$LN1217@Do_if:
	xor	bl, bl
$LN17@Do_if:

; 4197 : 	return (true);

	lea	ecx, DWORD PTR __St$[ebp]
	call	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ

; 4198 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, bl
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN9@Do_if:

; 4163 : 			break;
; 4164 : 		}
; 4165 : 
; 4166 : 	// if none of the if branches matched, fail to match
; 4167 : 	if (!_Node)
; 4168 : 		return (false);
; 4169 : 
; 4170 : 	// if we aren't looking for the longest match, that's it
; 4171 : 	if (!_Longest)

	cmp	BYTE PTR [edi+108], 0
	jne	SHORT $LN10@Do_if

; 4172 : 		return (true);

	mov	bl, 1
	jmp	SHORT $LN17@Do_if
$LN10@Do_if:
	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2547 : 		: _Myvec(_Right._Myvec),

	lea	ecx, DWORD PTR __Final$[ebp+4]
	push	esi
	mov	DWORD PTR __Final$[ebp], eax
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR __Final$[ebp+16], eax
	push	ebx
	lea	ecx, DWORD PTR __Final$[ebp+20]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4179 : 		_Node = _Node->_Child;

	mov	eax, DWORD PTR __Node$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __St$[ebp]
	sub	ecx, edx
	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4179 : 		_Node = _Node->_Child;

	mov	eax, DWORD PTR [eax+24]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	DWORD PTR __Final_len$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4179 : 		_Node = _Node->_Child;

	mov	DWORD PTR __Node$2$[ebp], eax

; 4180 : 		if (!_Node)

	test	eax, eax
	je	$LN1219@Do_if
	npad	6
$LL5@Do_if:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __St$[ebp+4]
	mov	DWORD PTR [edi], edx
	cmp	esi, eax
	je	SHORT $LN338@Do_if

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, esi
	push	DWORD PTR $T5[ebp]
	push	DWORD PTR __St$[ebp+8]
	push	DWORD PTR __St$[ebp+4]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR __St$[ebp+16]
	mov	DWORD PTR [esi+12], eax
$LN338@Do_if:

; 1415 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __St$[ebp+20]
	cmp	ebx, eax
	je	SHORT $LN483@Do_if

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T4[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T4[ebp]
	push	DWORD PTR __St$[ebp+24]
	push	DWORD PTR __St$[ebp+20]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN483@Do_if:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4184 : 		if (_Match_pat(_Node->_Next))

	mov	eax, DWORD PTR __Node$2$[ebp]
	mov	ecx, edi
	push	DWORD PTR [eax+12]
	call	?_Match_pat@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match_pat
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	edx, DWORD PTR __St$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4184 : 		if (_Match_pat(_Node->_Next))

	test	al, al
	je	SHORT $LN13@Do_if
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	eax, DWORD PTR [edi]
	mov	edi, eax
	sub	edi, edx
	sar	edi, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4187 : 			if (_Final_len < _Len)

	cmp	DWORD PTR __Final_len$1$[ebp], edi
	jae	SHORT $LN1220@Do_if
	mov	DWORD PTR __Final$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __Final$[ebp+4]
	cmp	eax, esi
	je	SHORT $LN636@Do_if

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T3[ebp], 0
	mov	ecx, eax
	push	DWORD PTR $T3[ebp]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR __Final$[ebp+16], eax
$LN636@Do_if:

; 1415 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __Final$[ebp+20]
	cmp	eax, ebx
	je	SHORT $LN781@Do_if

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T2[ebp], 0
	mov	ecx, eax
	push	DWORD PTR $T2[ebp]
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN781@Do_if:
	mov	edx, DWORD PTR __St$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4190 : 				_Final_len = _Len;

	mov	DWORD PTR __Final_len$1$[ebp], edi
$LN1220@Do_if:
	mov	edi, DWORD PTR _this$1$[ebp]
$LN13@Do_if:

; 4179 : 		_Node = _Node->_Child;

	mov	eax, DWORD PTR __Node$2$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR __Node$2$[ebp], eax

; 4180 : 		if (!_Node)

	test	eax, eax
	jne	$LL5@Do_if
$LN1219@Do_if:
	mov	eax, DWORD PTR __Final$[ebp]
	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __Final$[ebp+4]
	cmp	esi, eax
	je	SHORT $LN916@Do_if

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T9[ebp], 0
	mov	ecx, esi
	push	DWORD PTR $T9[ebp]
	push	DWORD PTR __Final$[ebp+8]
	push	DWORD PTR __Final$[ebp+4]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR __Final$[ebp+16]
	mov	DWORD PTR [esi+12], eax
$LN916@Do_if:

; 1415 : 		if (this != _STD addressof(_Right))

	lea	eax, DWORD PTR __Final$[ebp+20]
	cmp	ebx, eax
	je	SHORT $LN1061@Do_if

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T8[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T8[ebp]
	push	DWORD PTR __Final$[ebp+24]
	push	DWORD PTR __Final$[ebp+20]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN1061@Do_if:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4197 : 	return (true);

	lea	ecx, DWORD PTR __Final$[ebp]
	mov	bl, 1
	call	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
	jmp	$LN17@Do_if
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z$2:
	lea	ecx, DWORD PTR __St$[ebp]
	jmp	??1?$_Bt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z$0:
	lea	ecx, DWORD PTR __St$[ebp]
	jmp	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z$84:
	lea	ecx, DWORD PTR __Final$[ebp]
	jmp	??1?$_Bt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z$1:
	lea	ecx, DWORD PTR __Final$[ebp]
	jmp	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
__ehhandler$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Do_if@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@AAE_NPAV_Node_if@2@@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Do_if
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$_Tgt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
$T2 = 8							; size = 1
___that$ = 8						; size = 4
??4?$_Tgt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z PROC	; std::_Tgt_state_t<wchar_t const *>::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR ___that$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebx]
	lea	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi], eax
	lea	eax, DWORD PTR [esi+4]

; 2790 : 		if (this != _STD addressof(_Right))

	cmp	eax, edi
	je	SHORT $LN6@operator

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T2[ebp], 0
	mov	ecx, eax
	push	DWORD PTR $T2[ebp]
	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+16], eax
$LN6@operator:
	lea	eax, DWORD PTR [ebx+20]
	lea	ecx, DWORD PTR [esi+20]

; 1415 : 		if (this != _STD addressof(_Right))

	cmp	ecx, eax
	je	SHORT $LN282@operator

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN282@operator:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
??4?$_Tgt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z ENDP	; std::_Tgt_state_t<wchar_t const *>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___that$ = 8						; size = 4
??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z PROC		; std::_Tgt_state_t<wchar_t const *>::_Tgt_state_t<wchar_t const *>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[ebp]
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	lea	esi, DWORD PTR [ecx+4]
	push	edi
	mov	eax, DWORD PTR [ebx]
	lea	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx], eax

; 2547 : 		: _Myvec(_Right._Myvec),

	mov	ecx, esi
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	esi, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ebx+20]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR [esi+20]
	call	??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Bt_state_t@PB_W@std@@QAE@XZ
__ehhandler$??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tgt_state_t@PB_W@std@@QAE@ABV01@@Z ENDP		; std::_Tgt_state_t<wchar_t const *>::_Tgt_state_t<wchar_t const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tgt_state_t@PB_W@std@@QAE@XZ PROC			; std::_Tgt_state_t<wchar_t const *>::~_Tgt_state_t<wchar_t const *>, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN7@Tgt_state_

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+28]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+24], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+28], 0
$LN7@Tgt_state_:

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN115@Tgt_state_

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+8], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+12], 0
$LN115@Tgt_state_:
	pop	esi
	ret	0
??1?$_Tgt_state_t@PB_W@std@@QAE@XZ ENDP			; std::_Tgt_state_t<wchar_t const *>::~_Tgt_state_t<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Tgt_state_t@PB_W@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$_Tgt_state_t@PB_W@std@@QAE@XZ PROC			; std::_Tgt_state_t<wchar_t const *>::_Tgt_state_t<wchar_t const *>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tgt_state_t@PB_W@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	lea	eax, DWORD PTR $T3[ebp]

; 2655 : 		{	// construct empty vector

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T2[ebp], 0
	push	eax
	push	0
	lea	ecx, DWORD PTR [edi+4]
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi

; 2534 : 		{	// construct _Count * _Val elements
; 2535 : 		_Alloc_proxy();
; 2536 : 		_Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [edi+20], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [edi+24], 0

; 478  : 		_Myend()

	mov	DWORD PTR [edi+28], 0
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tgt_state_t@PB_W@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tgt_state_t@PB_W@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tgt_state_t@PB_W@std@@QAE@XZ ENDP			; std::_Tgt_state_t<wchar_t const *>::_Tgt_state_t<wchar_t const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??4?$_Tgt_state_t@PB_W@std@@QAEXABV?$_Bt_state_t@PB_W@1@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Other$ = 8						; size = 4
??4?$_Tgt_state_t@PB_W@std@@QAEXABV?$_Bt_state_t@PB_W@1@@Z PROC ; std::_Tgt_state_t<wchar_t const *>::operator=, COMDAT
; _this$ = ecx

; 2011 : 		{	// assign from object of type _Bt_state_t<_BidIt>

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Other$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	lea	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2790 : 		if (this != _STD addressof(_Right))

	cmp	edi, esi
	je	SHORT $LN6@operator

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	mov	ecx, edi
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
$LN6@operator:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2013 : 		}

	pop	ebp
	ret	4
??4?$_Tgt_state_t@PB_W@std@@QAEXABV?$_Bt_state_t@PB_W@1@@Z ENDP ; std::_Tgt_state_t<wchar_t const *>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@ABEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@ABEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@0@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1996 : 		}

	ret	8
?_Orphan_range@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@ABEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@0@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@CAXXZ PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@CAXXZ ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXXZ PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXXZ ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXQAU_Grp_t@?$_Tgt_state_t@PB_W@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXQAU_Grp_t@?$_Tgt_state_t@PB_W@2@II@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXQAU_Grp_t@?$_Tgt_state_t@PB_W@2@II@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Buy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAE_NI@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Buy, COMDAT
; _this$ = ecx

; 1908 : 		{	// allocate array with _Newcapacity elements

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1909 : 		this->_Myfirst() = pointer();
; 1910 : 		this->_Mylast() = pointer();
; 1911 : 		this->_Myend() = pointer();
; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	mov	edi, DWORD PTR __Newcapacity$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1914 : 			{
; 1915 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN2@Buy:

; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	edi, 536870911				; 1fffffffH
	ja	SHORT $LN104@Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+8], eax

; 1926 : 
; 1927 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN104@Buy:

; 1919 : 			{
; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@CAXXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Xlength
$LN106@Buy:
$LN103@Buy:
	int	3
?_Buy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAE_NI@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@ABEII@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 536870911				; 1fffffffH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 3

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@ABEII@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@0@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@0@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@00@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@00@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Udefault@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@PAU342@I@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
$T1 = 12						; size = 1
__Count$ = 12						; size = 4
?_Udefault@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@PAU342@I@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Udefault, COMDAT
; _this$ = ecx

; 1847 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@IV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@YAPAU_Grp_t@?$_Tgt_state_t@PB_W@0@PAU120@IAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Tgt_state_t<wchar_t const *>::_Grp_t *,unsigned int,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1849 : 		}

	pop	ebp
	ret	8
?_Udefault@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@PAU342@I@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEAAU_Grp_t@?$_Tgt_state_t@PB_W@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEAAU_Grp_t@?$_Tgt_state_t@PB_W@1@I@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::operator[], COMDAT
; _this$ = ecx

; 1736 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1737 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1738 : 		if (size() <= _Pos)
; 1739 : 			{	// report error
; 1740 : 			_DEBUG_ERROR("vector subscript out of range");
; 1741 : 			}
; 1742 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1743 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1744 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1745 : 
; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]

; 1747 : 		}

	pop	ebp
	ret	4
??A?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEAAU_Grp_t@?$_Tgt_state_t@PB_W@1@I@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1721 : 		}

	ret	0
?capacity@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 536870911				; 1fffffffH

; 1716 : 		}

	ret	0
?max_size@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1711 : 		}

	ret	0
?size@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QBEIXZ ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?resize@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEXI@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::resize, COMDAT
; _this$ = ecx

; 1490 : 		{	// trim or append value-initialized elements, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 1491 : 		auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1492 : 			{
; 1493 : 			return (_Udefault(_Dest, _Count));
; 1494 : 			};
; 1495 : 
; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	ecx
	push	DWORD PTR __Newsize$[ebp]
	call	??$_Resize@V<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXIV<lambda_3726096f4ce354b1c936d6bab7ace3a2>@@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Resize<<lambda_3726096f4ce354b1c936d6bab7ace3a2> >

; 1497 : 		}

	pop	ebp
	ret	4
?resize@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEXI@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Right$ = 8						; size = 4
??4?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::operator=, COMDAT
; _this$ = ecx

; 1414 : 		{	// assign _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 1415 : 		if (this != _STD addressof(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN132@operator

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$_Assign_range@PAU_Grp_t@?$_Tgt_state_t@PB_W@std@@@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@AAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Assign_range<std::_Tgt_state_t<wchar_t const *>::_Grp_t *>
$LN132@operator:

; 1416 : 			{	// different, assign it
; 1417 : #pragma warning(push)
; 1418 : #pragma warning(disable: 4127)	// conditional expression is constant
; 1419 : 			if (_Alty::propagate_on_container_copy_assignment::value && this->_Getal() != _Right._Getal())
; 1420 : 				{	// reload array
; 1421 : 				_Tidy();
; 1422 : 				}
; 1423 : #pragma warning(pop)
; 1424 : 
; 1425 : 			this->_Copy_alloc(_Right._Getal());
; 1426 : 
; 1427 : 			assign(_Right._Myfirst(), _Right._Mylast());
; 1428 : 			}
; 1429 : 
; 1430 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1431 : 		}

	pop	ebp
	ret	4
??4?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@XZ PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::~vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@XZ ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::~vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT
; _this$ = ecx

; 805  : 		{	// construct by copying _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR __Right$[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ebx], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [ebx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ebx+8], 0

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [edi+4]
	sub	esi, DWORD PTR [edi]
	sar	esi, 3

; 1909 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [ebx], 0

; 1910 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [ebx+4], 0

; 1911 : 		this->_Myend() = pointer();

	mov	DWORD PTR [ebx+8], 0

; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	test	esi, esi
	je	SHORT $LN5@vector

; 1914 : 			{
; 1915 : 			return (false);
; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	esi, 536870911				; 1fffffffH
	ja	SHORT $LN220@vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	esi
	call	?allocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [ebx], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [ebx+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [ebx]
	lea	eax, DWORD PTR [eax+esi*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	DWORD PTR [ebx+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	eax, DWORD PTR [edi]

; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	edi, DWORD PTR [ebx]

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR [esi+4]
	sub	esi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [esi+edi]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 809  : 			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());

	mov	DWORD PTR [ebx+4], eax
$LN5@vector:

; 810  : 			_CATCH_ALL
; 811  : 			_Tidy();
; 812  : 			_RERAISE;
; 813  : 			_CATCH_END
; 814  : 			}
; 815  : 		}

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
$LN220@vector:

; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@CAXXZ ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Xlength
$LN222@vector:
$LN219@vector:
	int	3
??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@XZ PROC ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 723  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 723  : 		}

	ret	0
??0?$vector@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@QAE@XZ ENDP ; std::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::vector<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Vector_val<std::_Simple_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABQAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAPAU_Grp_t@?$_Tgt_state_t@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 521  : 		_Pocca(_Getal(), _Al);
; 522  : 		}

	ret	4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@2@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 509  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 509  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@U_Grp_t@?$_Tgt_state_t@PB_W@std@@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@3@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Tgt_state_t<wchar_t const *>::_Grp_t,std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 536870911				; 1fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 1013 : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 1014 : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1015 : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SA?AV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SA?AV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::select_on_container_copy_construction, COMDAT

; 975  : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 976  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 977  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SA?AV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SAIABV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SAIABV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 536870911				; 1fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@@std@@SAIABV?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 536870911				; 1fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z PROC ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 536870911				; 1fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 3

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ENDP ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z PROC ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAEXPAU_Grp_t@?$_Tgt_state_t@PB_W@2@I@Z ENDP ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U_Grp_t@?$_Tgt_state_t@PB_W@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>::allocator<std::_Tgt_state_t<wchar_t const *>::_Grp_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$_Bt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
___that$ = 8						; size = 4
??4?$_Bt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z PROC	; std::_Bt_state_t<wchar_t const *>::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [edx]
	push	edi
	lea	edi, DWORD PTR [edx+4]
	lea	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax

; 2790 : 		if (this != _STD addressof(_Right))

	cmp	ebx, edi
	je	SHORT $LN149@operator

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [ebx+12], eax
$LN149@operator:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
??4?$_Bt_state_t@PB_W@std@@QAEAAV01@ABV01@@Z ENDP	; std::_Bt_state_t<wchar_t const *>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Bt_state_t@PB_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_this$ = 8						; size = 4
___that$ = 8						; size = 4
??0?$_Bt_state_t@PB_W@std@@QAE@ABV01@@Z PROC		; std::_Bt_state_t<wchar_t const *>::_Bt_state_t<wchar_t const *>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	edx, DWORD PTR ___that$[ebp]
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	eax, DWORD PTR [edx]
	push	edi
	lea	edi, DWORD PTR [edx+4]
	mov	DWORD PTR _this$[ebp], ebx
	lea	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], eax

; 2547 : 		: _Myvec(_Right._Myvec),

	push	edi
	mov	ecx, esi
	mov	DWORD PTR _this$[ebp], esi
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [edi+12]
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	eax, ebx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Bt_state_t@PB_W@std@@QAE@ABV01@@Z ENDP		; std::_Bt_state_t<wchar_t const *>::_Bt_state_t<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$_Bt_state_t@PB_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Bt_state_t@PB_W@std@@QAE@XZ PROC			; std::_Bt_state_t<wchar_t const *>::~_Bt_state_t<wchar_t const *>, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN15@Bt_state_t

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+8], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+12], 0
$LN15@Bt_state_t:
	pop	esi
	ret	0
??1?$_Bt_state_t@PB_W@std@@QAE@XZ ENDP			; std::_Bt_state_t<wchar_t const *>::~_Bt_state_t<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Bt_state_t@PB_W@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$_Bt_state_t@PB_W@std@@QAE@XZ PROC			; std::_Bt_state_t<wchar_t const *>::_Bt_state_t<wchar_t const *>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Bt_state_t@PB_W@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	lea	eax, DWORD PTR $T3[ebp]

; 2655 : 		{	// construct empty vector

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T2[ebp], 0
	push	eax
	push	0
	lea	ecx, DWORD PTR [edi+4]
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi

; 2534 : 		{	// construct _Count * _Val elements
; 2535 : 		_Alloc_proxy();
; 2536 : 		_Mysize = 0;

	mov	DWORD PTR [edi+16], 0
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Bt_state_t@PB_W@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Bt_state_t@PB_W@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Bt_state_t@PB_W@std@@QAE@XZ ENDP			; std::_Bt_state_t<wchar_t const *>::_Bt_state_t<wchar_t const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Skip@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEPB_WPB_W0PAV_Node_base@2@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__First_arg$ = 8					; size = 4
tv664 = 12						; size = 4
$T1 = 12						; size = 4
__Last$ = 12						; size = 4
__Node_arg$ = 16					; size = 4
?_Skip@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEPB_WPB_W0PAV_Node_base@2@@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Skip, COMDAT
; _this$ = ecx

; 4734 : 	{	// skip until possible match

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 4735 : 		// assumes --_First_arg is valid
; 4736 : 	_Node_base *_Nx = _Node_arg != 0 ? _Node_arg : _Rep;

	mov	edi, DWORD PTR __Node_arg$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx
	test	edi, edi
	jne	SHORT $LN48@Skip
	mov	edi, DWORD PTR [ecx+88]
$LN48@Skip:

; 4737 : 
; 4738 : 	while (_First_arg != _Last && _Nx != 0)

	mov	esi, DWORD PTR __First_arg$[ebp]
	mov	ebx, DWORD PTR __Last$[ebp]
	cmp	esi, ebx
	je	SHORT $LN3@Skip
$LL2@Skip:
	test	edi, edi
	je	SHORT $LN3@Skip

; 4739 : 		{	// check current node
; 4740 : 		switch (_Nx->_Kind)

	mov	eax, DWORD PTR [edi+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	SHORT $LN3@Skip
	movzx	eax, BYTE PTR $LN136@Skip[eax]
	jmp	DWORD PTR $LN148@Skip[eax*4]
$LN38@Skip:

; 4821 : 						return (_First_arg);
; 4822 : 					}
; 4823 : 				}
; 4824 : 				return (_First_arg);
; 4825 : 
; 4826 : 			case _N_group:
; 4827 : 				break;
; 4828 : 
; 4829 : 			case _N_end_group:
; 4830 : 				break;
; 4831 : 
; 4832 : //			case _N_neg_assert:
; 4833 : //			case _N_assert:
; 4834 : 
; 4835 : 			case _N_end_assert:
; 4836 : 				_Nx = 0;

	xor	edi, edi

; 4837 : 				break;

	jmp	SHORT $LL2@Skip
$LN4@Skip:

; 4855 : 				}
; 4856 : 
; 4857 : //			case _N_endif:
; 4858 : //			case _N_rep:
; 4859 : //			case _N_end_rep:
; 4860 : 
; 4861 : 			case _N_begin:
; 4862 : 				break;
; 4863 : 
; 4864 : 			case _N_end:
; 4865 : 				_Nx = 0;
; 4866 : 				break;
; 4867 : 
; 4868 : 			default:
; 4869 : 				return (_First_arg);
; 4870 : 			}
; 4871 : 		if (_Nx)
; 4872 : 			_Nx = _Nx->_Next;

	mov	edi, DWORD PTR [edi+12]

; 4737 : 
; 4738 : 	while (_First_arg != _Last && _Nx != 0)

	jmp	SHORT $LL2@Skip
$LN16@Skip:

; 4741 : 			{	// handle current node's type
; 4742 : 			case _N_nop:
; 4743 : 				break;
; 4744 : 
; 4745 : 			case _N_bol:
; 4746 : 				{	// check for embedded newline
; 4747 : 					// return iterator to character just after the newline; for input like "\nabc"
; 4748 : 					// matching "^abc", _First_arg could be pointing at 'a', so we need to check
; 4749 : 					// --_First_arg for '\n'
; 4750 : 				if (*_STD prev(_First_arg) != _Meta_nl)

	cmp	WORD PTR [esi-2], 10			; 0000000aH
	je	SHORT $LN3@Skip

; 4751 : 					{
; 4752 : 					_First_arg = _STD find(_First_arg, _Last, _Meta_nl);

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp], 10			; 0000000aH
	push	eax
	push	ebx
	push	esi
	call	??$find@PB_WW4_Meta_type@std@@@std@@YAPB_WPB_W0ABW4_Meta_type@0@@Z ; std::find<wchar_t const *,enum std::_Meta_type>
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4753 : 					if (_First_arg != _Last)

	cmp	esi, ebx
	je	SHORT $LN3@Skip

; 4754 : 						++_First_arg;

	add	esi, 2
$LN3@Skip:
	pop	edi

; 4874 : 	return (_First_arg);

	mov	eax, esi
	pop	esi
	pop	ebx

; 4875 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LL19@Skip:
	cmp	WORD PTR [esi], 10			; 0000000aH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 3161 : 		if (*_First == _Val)

	je	SHORT $LN3@Skip

; 3160 : 	for (; _First != _Last; ++_First)

	add	esi, 2
	cmp	esi, ebx
	jne	SHORT $LL19@Skip
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4874 : 	return (_First_arg);

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 4875 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	4
$LL20@Skip:

; 4770 : 					{	// look for starting match
; 4771 : 					_BidIt _Next = _First_arg;
; 4772 : 					if (_Compare(_First_arg, ++_Next,
; 4773 : 						_Node->_Data._Str(),
; 4774 : 						_Node->_Data._Str() + 1,
; 4775 : 						_Traits, _Sflags)
; 4776 : 							!= _First_arg)

	mov	eax, DWORD PTR _this$1$[ebp]
	lea	edx, DWORD PTR [esi+2]

; 1592 : 		return (_Chrs);

	mov	ecx, DWORD PTR [edi+28]

; 4770 : 					{	// look for starting match
; 4771 : 					_BidIt _Next = _First_arg;
; 4772 : 					if (_Compare(_First_arg, ++_Next,
; 4773 : 						_Node->_Data._Str(),
; 4774 : 						_Node->_Data._Str() + 1,
; 4775 : 						_Traits, _Sflags)
; 4776 : 							!= _First_arg)

	mov	DWORD PTR tv664[ebp], edx
	push	DWORD PTR [eax+92]
	push	DWORD PTR [eax+112]
	lea	eax, DWORD PTR [ecx+2]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Compare@PB_WPB_WV?$regex_traits@_W@std@@@std@@YAPB_WPB_W000ABV?$regex_traits@_W@0@W4syntax_option_type@regex_constants@0@@Z ; std::_Compare<wchar_t const *,wchar_t const *,std::regex_traits<wchar_t> >
	add	esp, 24					; 00000018H
	cmp	eax, esi
	jne	SHORT $LN3@Skip

; 4755 : 					}
; 4756 : 
; 4757 : 				return (_First_arg);
; 4758 : 				}
; 4759 : 
; 4760 : 			case _N_eol:
; 4761 : 				return (_STD find(_First_arg, _Last, _Meta_nl));
; 4762 : 
; 4763 : //			case _N_wbound:
; 4764 : //			case _N_dot:
; 4765 : 
; 4766 : 			case _N_str:
; 4767 : 				{	// check for string match
; 4768 : 				_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Nx;
; 4769 : 				for (; _First_arg != _Last; ++_First_arg)

	mov	esi, DWORD PTR tv664[ebp]
	cmp	esi, ebx
	jne	SHORT $LL20@Skip

; 4874 : 	return (_First_arg);

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 4875 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LL22@Skip:

; 4785 : 					{	// look for starting match
; 4786 : 					bool _Found;
; 4787 : 					typename _RxTraits::_Uelem _Ch = *_First_arg;
; 4788 : 					_Node_class<_Elem, _RxTraits> *_Node =
; 4789 : 						(_Node_class<_Elem, _RxTraits> *)_Nx;
; 4790 : 					_It _Next = _First_arg;
; 4791 : 					++_Next;
; 4792 : 
; 4793 : 					if (_Node->_Coll
; 4794 : 						&& _Lookup_coll(_First_arg, _Next, _Node->_Coll)

	mov	eax, DWORD PTR [edi+20]
	movzx	ebx, WORD PTR [esi]
	test	eax, eax
	je	SHORT $LN23@Skip
	push	eax
	lea	eax, DWORD PTR [esi+2]
	push	eax
	push	esi
	call	??$_Lookup_coll@PB_W_W@std@@YAPB_WPB_W0PBU?$_Sequence@_W@0@@Z ; std::_Lookup_coll<wchar_t const *,wchar_t>
	add	esp, 12					; 0000000cH
	cmp	eax, esi
	je	SHORT $LN138@Skip

; 4795 : 							!= _First_arg)
; 4796 : 						_Found = true;

	mov	ecx, 1

; 4797 : 					else if (_Node->_Ranges

	jmp	$LN34@Skip
$LN138@Skip:
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN23@Skip:

; 4798 : 						&& (_Lookup_range((typename _RxTraits::_Uelem)

	cmp	DWORD PTR [edi+32], 0
	je	SHORT $LN25@Skip

; 113  : _BITMASK_OPS(syntax_option_type)

	test	DWORD PTR [ecx+92], 2048		; 00000800H

; 4798 : 						&& (_Lookup_range((typename _RxTraits::_Uelem)

	je	SHORT $LN49@Skip
	mov	ecx, DWORD PTR [ecx+112]
	push	ebx
	call	?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z ; std::_Regex_traits<wchar_t>::translate
	movzx	eax, ax
	jmp	SHORT $LN50@Skip
$LN49@Skip:
	mov	eax, ebx
$LN50@Skip:
	push	DWORD PTR [edi+32]
	movzx	eax, ax
	push	eax
	call	??$_Lookup_range@_W@std@@YA_NIPBU?$_Buf@_W@0@@Z ; std::_Lookup_range<wchar_t>
	add	esp, 8
	test	al, al
	je	SHORT $LN25@Skip

; 4799 : 							(_Sflags & regex_constants::collate
; 4800 : 								? _Traits.translate(_Ch)
; 4801 : 								: _Ch), _Node->_Ranges)))
; 4802 : 						_Found = true;

	mov	ecx, 1
	jmp	$LN34@Skip
$LN25@Skip:

; 4803 : 					else if (_Ch < _Bmp_max)

	mov	eax, 256				; 00000100H
	cmp	bx, ax
	jae	SHORT $LN27@Skip

; 4804 : 						_Found = _Node->_Small && _Node->_Small->_Find(_Ch);

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	$LN33@Skip

; 1649 : 		unsigned int _Wide = _Ch;

	mov	edx, ebx

; 1650 : 		return ((_Chrs[_Wide >> _Bmp_shift] & (1 << (_Wide & _Bmp_mask))) != 0);

	mov	eax, 1
	mov	ecx, edx
	shr	edx, 3
	and	ecx, 7
	shl	eax, cl
	mov	ecx, DWORD PTR [edi+24]
	test	al, BYTE PTR [edx+ecx]

; 4805 : 					else if (_Node->_Large

	jmp	SHORT $LN145@Skip
$LN27@Skip:

; 4806 : 						&& _STD find(_Node->_Large->_Str(),

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN29@Skip
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 3180 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

	mov	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4806 : 						&& _STD find(_Node->_Large->_Str(),

	mov	eax, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+eax*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 3160 : 	for (; _First != _Last; ++_First)

	cmp	ecx, eax
	je	SHORT $LN29@Skip
	npad	2
$LL100@Skip:

; 3161 : 		if (*_First == _Val)

	cmp	WORD PTR [ecx], bx
	je	SHORT $LN137@Skip

; 3160 : 	for (; _First != _Last; ++_First)

	add	ecx, 2
	cmp	ecx, eax
	jne	SHORT $LL100@Skip
$LN137@Skip:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4806 : 						&& _STD find(_Node->_Large->_Str(),

	cmp	ecx, eax
	je	SHORT $LN29@Skip

; 4807 : 							_Node->_Large->_Str() + _Node->_Large->_Size(),
; 4808 : 								_Ch)
; 4809 : 							!= _Node->_Large->_Str() + _Node->_Large->_Size())
; 4810 : 						_Found = true;

	mov	ecx, 1

; 4811 : 					else if (_Node->_Classes

	jmp	SHORT $LN34@Skip
$LN29@Skip:

; 4812 : 						&& _Traits.isctype(_Ch, _Node->_Classes))

	movzx	eax, WORD PTR [edi+36]
	test	ax, ax
	je	SHORT $LN31@Skip
	push	eax
	mov	eax, DWORD PTR _this$1$[ebp]
	push	ebx
	mov	ecx, DWORD PTR [eax+112]
	call	?isctype@?$_Regex_traits@_W@std@@QBE_N_WF@Z ; std::_Regex_traits<wchar_t>::isctype
	test	al, al
	je	SHORT $LN31@Skip

; 4813 : 						_Found = true;

	mov	ecx, 1

; 4814 : 					else if (_Node->_Equiv

	jmp	SHORT $LN34@Skip
$LN31@Skip:

; 4815 : 						&& _Lookup_equiv(_Ch, _Node->_Equiv, _Traits))

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN33@Skip
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	DWORD PTR [ecx+112]
	push	eax
	push	ebx
	call	??$_Lookup_equiv@_WV?$regex_traits@_W@std@@@std@@YA_NGPBU?$_Sequence@_W@0@ABV?$regex_traits@_W@0@@Z ; std::_Lookup_equiv<wchar_t,std::regex_traits<wchar_t> >
	add	esp, 12					; 0000000cH
	test	al, al
$LN145@Skip:
	je	SHORT $LN33@Skip

; 4816 : 						_Found = true;

	mov	ecx, 1

; 4817 : 					else

	jmp	SHORT $LN34@Skip
$LN33@Skip:

; 4818 : 						_Found = false;

	xor	ecx, ecx
$LN34@Skip:

; 4819 : 
; 4820 : 					if (_Found != (_Node->_Flags & _Fl_negate))

	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	cmp	ecx, eax
	jne	$LN3@Skip

; 4777 : 						break;
; 4778 : 					}
; 4779 : 				return (_First_arg);
; 4780 : 				}
; 4781 : 
; 4782 : 			case _N_class:
; 4783 : 				{	// check for string match
; 4784 : 				for (; _First_arg != _Last; ++_First_arg)

	mov	ecx, DWORD PTR _this$1$[ebp]
	add	esi, 2
	cmp	esi, DWORD PTR __Last$[ebp]
	jne	$LL22@Skip

; 4874 : 	return (_First_arg);

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 4875 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LL41@Skip:

; 4838 : 
; 4839 : 			case _N_capture:
; 4840 : 				break;
; 4841 : 
; 4842 : 			case _N_end_capture:
; 4843 : 				break;
; 4844 : 
; 4845 : //			case _N_back:
; 4846 : 
; 4847 : 			case _N_if:
; 4848 : 				{	// check for soonest string match
; 4849 : 				_Node_if *_Node = (_Node_if *)_Nx;
; 4850 : 
; 4851 : 				for (; _First_arg != _Last && _Node != 0;

	test	edi, edi
	je	SHORT $LN13@Skip

; 4852 : 					_Node = _Node->_Child)
; 4853 : 					_Last = _Skip(_First_arg, _Last, _Node->_Next);

	push	DWORD PTR [edi+12]
	push	ebx
	push	esi
	call	?_Skip@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEPB_WPB_W0PAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Skip
	mov	edi, DWORD PTR [edi+24]
	mov	ebx, eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	cmp	esi, ebx
	jne	SHORT $LL41@Skip
$LN13@Skip:
	pop	edi
	pop	esi

; 4854 : 				return (_Last);

	mov	eax, ebx
	pop	ebx

; 4875 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN148@Skip:
	DD	$LN4@Skip
	DD	$LN16@Skip
	DD	$LL19@Skip
	DD	$LL20@Skip
	DD	$LL22@Skip
	DD	$LN38@Skip
	DD	$LL41@Skip
	DD	$LN3@Skip
$LN136@Skip:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	7
	DB	3
	DB	4
	DB	0
	DB	0
	DB	7
	DB	7
	DB	5
	DB	0
	DB	0
	DB	7
	DB	6
	DB	7
	DB	7
	DB	7
	DB	0
	DB	5
?_Skip@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEPB_WPB_W0PAV_Node_base@2@@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Skip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Clearf@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEXW4match_flag_type@regex_constants@2@@Z
_TEXT	SEGMENT
__Mf$ = 8						; size = 4
?_Clearf@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEXW4match_flag_type@regex_constants@2@@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Clearf, COMDAT
; _this$ = ecx

; 2044 : 		{	// clear specified flags

	npad	2
	push	ebp
	mov	ebp, esp

; 133  : _BITMASK_OPS(match_flag_type)

	mov	eax, DWORD PTR __Mf$[ebp]
	not	eax
	and	DWORD PTR [ecx+96], eax

; 2045 : 		_Mflags &= ~_Mf;
; 2046 : 		}

	pop	ebp
	ret	4
?_Clearf@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEXW4match_flag_type@regex_constants@2@@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Clearf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Setf@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEXW4match_flag_type@regex_constants@2@@Z
_TEXT	SEGMENT
__Mf$ = 8						; size = 4
?_Setf@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEXW4match_flag_type@regex_constants@2@@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Setf, COMDAT
; _this$ = ecx

; 2039 : 		{	// set specified flags

	npad	2
	push	ebp
	mov	ebp, esp

; 133  : _BITMASK_OPS(match_flag_type)

	mov	eax, DWORD PTR __Mf$[ebp]
	or	DWORD PTR [ecx+96], eax

; 2040 : 		_Mflags |= _Mf;
; 2041 : 		}

	pop	ebp
	ret	4
?_Setf@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEXW4match_flag_type@regex_constants@2@@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Setf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -20						; size = 4
$T4 = -13						; size = 1
$T5 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Pfirst$ = 8						; size = 4
__Plast$ = 12						; size = 4
__Tr$ = 16						; size = 4
__Re$ = 20						; size = 4
__Nx$ = 24						; size = 4
__Sf$ = 28						; size = 4
__Mf$ = 32						; size = 4
??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z PROC ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>, COMDAT
; _this$ = ecx

; 2033 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	lea	eax, DWORD PTR $T5[ebp]

; 2655 : 		{	// construct empty vector

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], 0
	push	eax
	push	0
	lea	ecx, DWORD PTR [edi+4]
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2534 : 		{	// construct _Count * _Val elements
; 2535 : 		_Alloc_proxy();
; 2536 : 		_Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [edi+20], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [edi+24], 0

; 478  : 		_Myend()

	mov	DWORD PTR [edi+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2033 : 		{	// construct

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	lea	eax, DWORD PTR $T4[ebp]

; 2655 : 		{	// construct empty vector

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T2[ebp], 0
	push	eax
	push	0
	lea	ecx, DWORD PTR [edi+36]
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2534 : 		{	// construct _Count * _Val elements
; 2535 : 		_Alloc_proxy();
; 2536 : 		_Mysize = 0;

	mov	DWORD PTR [edi+48], 0

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [edi+52], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [edi+56], 0

; 478  : 		_Myend()

	mov	DWORD PTR [edi+60], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2033 : 		{	// construct

	lea	ecx, DWORD PTR [edi+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2033 : 		{	// construct

	mov	eax, DWORD PTR __Plast$[ebp]
	mov	esi, DWORD PTR __Re$[ebp]
	mov	edx, DWORD PTR __Mf$[ebp]
	mov	DWORD PTR [edi+80], eax
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edi+84], eax
	mov	eax, DWORD PTR __Sf$[ebp]
	mov	DWORD PTR [edi+92], eax
	mov	eax, DWORD PTR __Nx$[ebp]
	mov	DWORD PTR [edi+88], esi
	mov	DWORD PTR [edi+96], edx
	mov	BYTE PTR [edi+100], 0
	mov	DWORD PTR [edi+104], eax
	test	BYTE PTR [esi+8], 8
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	je	SHORT $LN3@Matcher

; 133  : _BITMASK_OPS(match_flag_type)

	test	dl, 16					; 00000010H

; 2029 : 				_Sflags(_Sf), _Mflags(_Mf), _Matched(false),
; 2030 : 				_Ncap(static_cast<int>(_Nx)),
; 2031 : 				_Longest((_Re->_Flags & _Fl_longest)

	jne	SHORT $LN3@Matcher
	mov	eax, 1
	jmp	SHORT $LN4@Matcher
$LN3@Matcher:
	xor	eax, eax
$LN4@Matcher:
	mov	BYTE PTR [edi+108], al
	mov	eax, DWORD PTR __Tr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2028 : 			: _First(_Pfirst), _End(_Plast), _Traits(_Tr), _Rep(_Re),

	mov	DWORD PTR [edi+112], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	DWORD PTR [esi+24]
	call	??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Resize<<lambda_73aa1e031ed5205b52738960793434b5> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2036 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
__unwindfunclet$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::~vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >
__ehhandler$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z ENDP ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 100  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN4@sentry

; 101  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN4@sentry:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 122  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 123  : 			}

	ret	0
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 116  : 			{	// construct locking and calling _Ipfx

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 92   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	push	esi

; 116  : 			{	// construct locking and calling _Ipfx

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 92   : 			: _Myistr(_Istr)

	mov	DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 95   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN5@sentry:

; 117  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	DWORD PTR __Noskip$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z

; 118  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	BYTE PTR [esi+4], al
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// destroy after unlocking

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 100  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 101  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 102  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 93   : 			{	// lock the stream buffer, if there

	npad	2
	push	ebp
	mov	ebp, esp

; 92   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	push	esi

; 93   : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 94   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 95   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 96   : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z PROC		; std::_Unchecked<wchar_t *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PA_W@std@@YAPA_WPA_W@Z ENDP		; std::_Unchecked<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@PAI@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@PAI@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int>,unsigned int *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@PAI@std@@YAXPAI0AAU?$_Wrap_alloc@V?$allocator@I@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int>,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1152 : 	_Left = _STD move(_Right);
; 1153 : 	}

	ret	0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@XZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::~_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN15@Parser

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+28]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+24], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+28], 0
$LN15@Parser:
	pop	esi
	ret	0
??1?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@XZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::~_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Get_tmax@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABEIXZ
_TEXT	SEGMENT
?_Get_tmax@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABEIXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Get_tmax, COMDAT
; _this$ = ecx

; 3921 : 	return (static_cast<unsigned int>(_Tmax));

	mov	eax, DWORD PTR [ecx+20]

; 3922 : 	}

	ret	0
?_Get_tmax@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABEIXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Get_tmax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Get_bmax@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABEIXZ
_TEXT	SEGMENT
?_Get_bmax@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABEIXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Get_bmax, COMDAT
; _this$ = ecx

; 3913 : 	return (static_cast<unsigned int>(_Bmax));

	mov	eax, DWORD PTR [ecx+16]

; 3914 : 	}

	ret	0
?_Get_bmax@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABEIXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Get_bmax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Char_to_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0HPAPAU?$_Sequence@_W@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Diff$ = 16						; size = 4
$T1 = 20						; size = 4
__Cur$ = 20						; size = 4
?_Char_to_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0HPAPAU?$_Sequence@_W@2@@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Char_to_elts, COMDAT
; _this$ = ecx

; 3896 : 	{	// add collation element to element sequence

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 3897 : 	while (*_Cur && (unsigned int)_Diff < (*_Cur)->_Sz)

	mov	esi, DWORD PTR __Cur$[ebp]
	push	edi
	mov	edi, DWORD PTR __Diff$[ebp]
	mov	ebx, DWORD PTR [esi]
	test	ebx, ebx
	je	SHORT $LN5@Char_to_el
$LL2@Char_to_el:
	mov	eax, DWORD PTR [esi]
	cmp	edi, DWORD PTR [eax]
	jae	SHORT $LN3@Char_to_el
	cmp	DWORD PTR [eax+16], 0

; 3898 : 		_Cur = &(*_Cur)->_Next;

	lea	esi, DWORD PTR [eax+16]
	jne	SHORT $LL2@Char_to_el
$LN3@Char_to_el:

; 3899 : 	if (!(*_Cur) || (unsigned int)_Diff != (*_Cur)->_Sz)

	mov	ebx, DWORD PTR [esi]
	test	ebx, ebx
	je	SHORT $LN5@Char_to_el
	cmp	edi, DWORD PTR [ebx]
	je	SHORT $LN4@Char_to_el
$LN5@Char_to_el:

; 3900 : 		{	// add new sequence holding elements of the same length
; 3901 : 		_Sequence<_Elem> *_Node = *_Cur;
; 3902 : 		*_Cur = new _Sequence<_Elem>((unsigned int)_Diff);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN7@Char_to_el

; 1662 : 		: _Sz(_Len)

	mov	DWORD PTR [eax], edi

; 1562 : 		: _Sz(0), _Nchrs(0), _Chrs(0)

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0

; 3900 : 		{	// add new sequence holding elements of the same length
; 3901 : 		_Sequence<_Elem> *_Node = *_Cur;
; 3902 : 		*_Cur = new _Sequence<_Elem>((unsigned int)_Diff);

	jmp	SHORT $LN8@Char_to_el
$LN7@Char_to_el:
	xor	eax, eax
$LN8@Char_to_el:
	mov	DWORD PTR [esi], eax

; 3903 : 		(*_Cur)->_Next = _Node;

	mov	DWORD PTR [eax+16], ebx
$LN4@Char_to_el:

; 3904 : 		}
; 3905 : 	(*_Cur)->_Data._Insert(_First, _Last);

	push	DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR __First$[ebp]
	add	ecx, 4
	call	??$_Insert@PB_W@?$_Buf@_W@std@@QAEXPB_W0@Z ; std::_Buf<wchar_t>::_Insert<wchar_t const *>
	pop	edi
	pop	esi
	pop	ebx

; 3906 : 	}

	pop	ebp
	ret	16					; 00000010H
?_Char_to_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0HPAPAU?$_Sequence@_W@2@@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Char_to_elts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPAV?$_Node_class@_WV?$regex_traits@_W@std@@@2@F_N@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
$T1 = 8							; size = 4
__Node$ = 8						; size = 4
__Cl$ = 12						; size = 2
__Negate$ = 16						; size = 1
?_Add_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPAV?$_Node_class@_WV?$regex_traits@_W@std@@@2@F_N@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_elts, COMDAT
; _this$ = ecx

; 3862 : 	{	// add characters in named class to set

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 3863 : 	for (unsigned int _Ch = 0; _Ch < _Bmp_max; ++_Ch)

	mov	ebx, DWORD PTR __Cl$[ebp]
	mov	eax, ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Node$[ebp]
	xor	esi, esi
	mov	DWORD PTR _this$1$[ebp], eax
$LL4@Add_elts:

; 3864 : 		{	// add elements or their inverse
; 3865 : 		bool _Matches = _Traits.isctype(static_cast<_Elem>(_Ch), _Cl);

	mov	ecx, DWORD PTR [eax+12]

; 329  : 		if (_Fx != (char_class_type)(-1))

	cmp	bx, -1
	je	SHORT $LN12@Add_elts

; 330  : 			return (_Getctype()->is(_Fx, _Ch));

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	push	ebx
	call	DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
	jmp	SHORT $LN16@Add_elts
$LN12@Add_elts:

; 331  : 		else
; 332  : 			return (_Ch == '_'	// assumes L'_' == '_'

	movzx	eax, si
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN15@Add_elts
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	push	263					; 00000107H
	call	DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
	test	al, al
	je	SHORT $LN16@Add_elts
$LN15@Add_elts:
	mov	al, 1
$LN16@Add_elts:

; 3866 : 		if (_Matches != _Negate)

	cmp	al, BYTE PTR __Negate$[ebp]
	je	SHORT $LN2@Add_elts

; 3867 : 			{	// add contents of named class to accelerator table
; 3868 : 			if (!_Node->_Small)

	cmp	DWORD PTR [edi+24], 0
	jne	SHORT $LN6@Add_elts

; 3869 : 				_Node->_Small = new _Bitmap;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN8@Add_elts
	xorps	xmm0, xmm0

; 1634 : 		_CSTD memset(_Chrs, '\0', _Bmp_size);

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 3869 : 				_Node->_Small = new _Bitmap;

	jmp	SHORT $LN9@Add_elts
$LN8@Add_elts:
	xor	eax, eax
$LN9@Add_elts:
	mov	DWORD PTR [edi+24], eax
$LN6@Add_elts:

; 1642 : 		_Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

	mov	edx, esi
	mov	eax, esi
	shr	edx, 3
	and	eax, 7
	add	edx, DWORD PTR [edi+24]
	movzx	ecx, BYTE PTR [edx]
	bts	ecx, eax
	mov	BYTE PTR [edx], cl
$LN2@Add_elts:

; 3863 : 	for (unsigned int _Ch = 0; _Ch < _Bmp_max; ++_Ch)

	mov	eax, DWORD PTR _this$1$[ebp]
	inc	esi
	cmp	esi, 256				; 00000100H
	jb	$LL4@Add_elts
	pop	edi
	pop	esi
	pop	ebx

; 3870 : 			_Node->_Small->_Mark(_Ch);
; 3871 : 			}
; 3872 : 		}
; 3873 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Add_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPAV?$_Node_class@_WV?$regex_traits@_W@std@@@2@F_N@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_elts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_char_to_array@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
$T1 = 8							; size = 4
?_Add_char_to_array@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_array, COMDAT
; _this$ = ecx

; 3799 : 	{	// append character to character array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 113  : _BITMASK_OPS(syntax_option_type)

	test	DWORD PTR [esi+8], 256			; 00000100H

; 3800 : 	if (_Flags & regex_constants::icase)

	je	SHORT $LN24@Add_char_t

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [esi+12]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 3801 : 		_Ch = _Traits.translate_nocase(_Ch);

	movzx	edi, ax
	jmp	SHORT $LN2@Add_char_t
$LN24@Add_char_t:
	mov	edi, DWORD PTR __Ch$[ebp]
$LN2@Add_char_t:

; 3802 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3803 : 		(_Node_class<_Elem, _RxTraits> *)_Current;

	mov	esi, DWORD PTR [esi+4]

; 3804 : 	if (!_Node->_Large)

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN3@Add_char_t

; 3805 : 		_Node->_Large = new _Buf<_Elem>;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN5@Add_char_t

; 1562 : 		: _Sz(0), _Nchrs(0), _Chrs(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0

; 3805 : 		_Node->_Large = new _Buf<_Elem>;

	jmp	SHORT $LN6@Add_char_t
$LN5@Add_char_t:
	xor	eax, eax
$LN6@Add_char_t:
	mov	DWORD PTR [esi+28], eax
$LN3@Add_char_t:

; 3806 : 	_Node->_Large->_Insert(_Ch);

	mov	esi, DWORD PTR [esi+28]

; 1597 : 		if (_Sz <= _Nchrs)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi], eax
	ja	SHORT $LN21@Add_char_t
	push	ebx

; 1598 : 			_Expand(_Nchrs + _Buf_incr);

	lea	ebx, DWORD PTR [eax+16]

; 1617 : 		_Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));

	lea	eax, DWORD PTR [ebx+ebx]
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 1618 : 		if (!_Tmp)

	test	eax, eax
	jne	SHORT $LN20@Add_char_t

; 1619 : 			_Xbad_alloc();

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN27@Add_char_t:
$LN20@Add_char_t:

; 1620 : 		_Chrs = _Tmp;
; 1621 : 		_Sz = _Len;

	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+8], eax
	pop	ebx
$LN21@Add_char_t:

; 1599 : 		_Chrs[_Nchrs++] = _Ch;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	mov	WORD PTR [eax+ecx*2], di
	inc	DWORD PTR [esi+4]
	pop	edi
	pop	esi

; 3807 : 	}

	pop	ebp
	ret	4
$LN26@Add_char_t:
?_Add_char_to_array@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
$T1 = 8							; size = 4
?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap, COMDAT
; _this$ = ecx

; 3784 : 	{	// add character to accelerator table

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 113  : _BITMASK_OPS(syntax_option_type)

	test	DWORD PTR [esi+8], 256			; 00000100H

; 3785 : 	if (_Flags & regex_constants::icase)

	je	SHORT $LN18@Add_char_t

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [esi+12]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 3786 : 		_Ch = _Traits.translate_nocase(_Ch);

	movzx	edi, ax
	jmp	SHORT $LN2@Add_char_t
$LN18@Add_char_t:
	mov	edi, DWORD PTR __Ch$[ebp]
$LN2@Add_char_t:

; 3787 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3788 : 		(_Node_class<_Elem, _RxTraits> *)_Current;

	mov	esi, DWORD PTR [esi+4]

; 3789 : 
; 3790 : 	if (!_Node->_Small)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN3@Add_char_t

; 3791 : 		_Node->_Small = new _Bitmap;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN5@Add_char_t
	xorps	xmm0, xmm0

; 1634 : 		_CSTD memset(_Chrs, '\0', _Bmp_size);

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 3791 : 		_Node->_Small = new _Bitmap;

	jmp	SHORT $LN6@Add_char_t
$LN5@Add_char_t:
	xor	eax, eax
$LN6@Add_char_t:
	mov	DWORD PTR [esi+24], eax
$LN3@Add_char_t:

; 3792 : 	_Node->_Small->_Mark(static_cast<typename _RxTraits::_Uelem>(_Ch));

	mov	ecx, DWORD PTR [esi+24]

; 1641 : 		unsigned int _Wide = _Ch;

	movzx	edx, di

; 1642 : 		_Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

	mov	eax, edx
	and	edx, 7
	shr	eax, 3
	add	ecx, eax
	pop	edi
	pop	esi
	movzx	eax, BYTE PTR [ecx]
	bts	eax, edx
	mov	BYTE PTR [ecx], al

; 3793 : 	}

	pop	ebp
	ret	4
?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NPAV_Node_base@2@@Z
_TEXT	SEGMENT
__Nx$ = 8						; size = 4
?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NPAV_Node_base@2@@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Beg_expr, COMDAT
; _this$ = ecx

; 3655 : 	{	// test for beginning of expression or subexpression

	npad	2
	push	ebp
	mov	ebp, esp

; 3656 : 	return (_Nx->_Kind == _N_begin

	mov	eax, DWORD PTR __Nx$[ebp]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, 20					; 00000014H
	je	SHORT $LN3@Beg_expr
	cmp	eax, 8
	je	SHORT $LN3@Beg_expr
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN3@Beg_expr
	xor	al, al

; 3657 : 		|| _Nx->_Kind == _N_group
; 3658 : 		|| _Nx->_Kind == _N_capture);
; 3659 : 	}

	pop	ebp
	ret	4
$LN3@Beg_expr:

; 3656 : 	return (_Nx->_Kind == _N_begin

	mov	al, 1

; 3657 : 		|| _Nx->_Kind == _N_group
; 3658 : 		|| _Nx->_Kind == _N_capture);
; 3659 : 	}

	pop	ebp
	ret	4
?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NPAV_Node_base@2@@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Beg_expr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_str_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Add_str_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_str_node, COMDAT
; _this$ = ecx

; 3753 : 	{	// add string node

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 3754 : 	_Link_node(new _Node_str<_Elem>);

	push	32					; 00000020H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx
	test	edx, edx
	je	SHORT $LN3@Add_str_no

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [edx+4], 6
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0

; 1786 : 		{	// construct

	mov	DWORD PTR [edx], OFFSET ??_7?$_Node_str@_W@std@@6B@

; 1562 : 		: _Sz(0), _Nchrs(0), _Chrs(0)

	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
	mov	DWORD PTR [edx+28], 0

; 3754 : 	_Link_node(new _Node_str<_Elem>);

	jmp	SHORT $LN4@Add_str_no
$LN3@Add_str_no:
	xor	edx, edx
$LN4@Add_str_no:

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN13@Add_str_no

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [edx+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], edx
$LN13@Add_str_no:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+12], edx

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [esi+4], edx
	pop	esi

; 3755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Add_str_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_str_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Kind$ = 8						; size = 4
?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node, COMDAT
; _this$ = ecx

; 3705 : 	{	// allocate and link simple node

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 3706 : 	return (_Link_node(new _Node_base(_Kind)));

	push	20					; 00000014H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx
	test	edx, edx
	je	SHORT $LN3@New_node

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	eax, DWORD PTR __Kind$[ebp]

; 1677 : 		{	// construct

	mov	DWORD PTR [edx], OFFSET ??_7_Node_base@std@@6B@
	mov	DWORD PTR [edx+4], eax
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0

; 3706 : 	return (_Link_node(new _Node_base(_Kind)));

	jmp	SHORT $LN4@New_node
$LN3@New_node:
	xor	edx, edx
$LN4@New_node:

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN9@New_node

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [edx+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+16], edx
$LN9@New_node:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	ecx, DWORD PTR [esi+4]

; 3706 : 	return (_Link_node(new _Node_base(_Kind)));

	mov	eax, edx

; 3682 : 	_Current->_Next = _Nx;

	mov	DWORD PTR [ecx+12], edx

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [esi+4], edx
	pop	esi

; 3707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Insert_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@CAXPAV_Node_base@2@0@Z
_TEXT	SEGMENT
__Insert_before$ = 8					; size = 4
__To_insert$ = 12					; size = 4
?_Insert_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@CAXPAV_Node_base@2@0@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Insert_node, COMDAT

; 3693 : 	{	// insert _To_insert into the graph before the node _Insert_before

	npad	2
	push	ebp
	mov	ebp, esp

; 3694 : 	_Insert_before->_Prev->_Next = _To_insert;

	mov	edx, DWORD PTR __Insert_before$[ebp]
	mov	ecx, DWORD PTR __To_insert$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+12], ecx

; 3695 : 	_To_insert->_Prev = _Insert_before->_Prev;

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax

; 3696 : 	_Insert_before->_Prev = _To_insert;

	mov	DWORD PTR [edx+16], ecx

; 3697 : 	_To_insert->_Next = _Insert_before;

	mov	DWORD PTR [ecx+12], edx

; 3698 : 	}

	pop	ebp
	ret	0
?_Insert_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@CAXPAV_Node_base@2@0@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Link_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z
_TEXT	SEGMENT
__Nx$ = 8						; size = 4
?_Link_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Link_node, COMDAT
; _this$ = ecx

; 3675 : 	{	// insert _Nx at current location

	npad	2
	push	ebp
	mov	ebp, esp

; 3676 : 	_Nx->_Prev = _Current;

	mov	edx, DWORD PTR __Nx$[ebp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN2@Link_node

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [edx+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+16], edx
$LN2@Link_node:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	ecx, DWORD PTR [esi+4]

; 3683 : 	_Current = _Nx;
; 3684 : 	return (_Nx);

	mov	eax, edx
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 3685 : 	}

	pop	ebp
	ret	4
?_Link_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@PAV32@@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Link_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_End_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ
_TEXT	SEGMENT
?_End_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_pattern, COMDAT
; _this$ = ecx

; 4134 : 	{	// wrap up

	npad	2
	push	esi

; 4135 : 	_New_node(_N_end);

	push	21					; 00000015H
	mov	esi, ecx
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 4136 : 	return (_Root);

	mov	eax, DWORD PTR [esi]
	pop	esi

; 4137 : 	}

	ret	0
?_End_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_pattern
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Mark_final@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Mark_final@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Mark_final, COMDAT
; _this$ = ecx

; 3639 : 	_Current->_Flags |= _Fl_final;

	mov	eax, DWORD PTR [ecx+4]

; 1523 : 	return (_Left = _Node_flags((int)_Left | _Right));

	or	DWORD PTR [eax+8], 4

; 3640 : 	}

	ret	0
?_Mark_final@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Mark_final
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Negate@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Negate@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Negate, COMDAT
; _this$ = ecx

; 3631 : 	_Current->_Flags ^= _Fl_negate;

	mov	eax, DWORD PTR [ecx+4]

; 1528 : 	return (_Left = _Node_flags((int)_Left ^ _Right));

	xor	DWORD PTR [eax+8], 1

; 3632 : 	}

	ret	0
?_Negate@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Negate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_rep@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXHH_N@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
$T1 = -8						; size = 4
$T2 = -8						; size = 4
__Pos$1$ = -4						; size = 4
$T3 = 8							; size = 4
$T4 = 8							; size = 4
$T5 = 8							; size = 4
$T6 = 8							; size = 4
__Min$ = 8						; size = 4
$T7 = 12						; size = 4
__Max$ = 12						; size = 4
__Greedy$ = 16						; size = 1
?_Add_rep@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXHH_N@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_rep, COMDAT
; _this$ = ecx

; 4078 : 	{	// add repeat node

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ebx

; 4079 : 	if (_Current->_Kind == _N_str
; 4080 : 		&& ((_Node_str<_Elem> *)_Current)->_Data._Size() != 1)

	mov	eax, DWORD PTR [ebx+4]
	cmp	DWORD PTR [eax+4], 6
	jne	SHORT $LN2@Add_rep
	cmp	DWORD PTR [eax+24], 1
	je	SHORT $LN2@Add_rep

; 1604 : 		return (_Chrs[--_Nchrs]);

	dec	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+24]

; 4081 : 		{	// move final character to new string node
; 4082 : 		_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Current;
; 4083 : 		_Add_char(_Node->_Data._Del());

	mov	eax, DWORD PTR [eax+28]
	movzx	eax, WORD PTR [eax+ecx*2]
	mov	ecx, ebx
	push	eax
	call	?_Add_char@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char
$LN2@Add_rep:

; 4084 : 		}
; 4085 : 
; 4086 : 	_Node_base *_Pos = _Current;

	mov	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR __Pos$1$[ebp], esi

; 4087 : 	if (_Pos->_Kind == _N_end_group
; 4088 : 		|| _Pos->_Kind == _N_end_capture)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 9
	je	SHORT $LN4@Add_rep
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN3@Add_rep
$LN4@Add_rep:

; 4089 : 		_Pos = ((_Node_end_group *)_Pos)->_Back;

	mov	esi, DWORD PTR [esi+20]
	mov	DWORD PTR __Pos$1$[ebp], esi
$LN3@Add_rep:

; 4090 : 
; 4091 : 	if (_Min == 0 && _Max == 1)

	cmp	DWORD PTR __Min$[ebp], 0
	jne	$LN5@Add_rep
	cmp	DWORD PTR __Max$[ebp], 1
	jne	$LN5@Add_rep

; 4092 : 		{	// rewrite zero-or-one quantifiers as alternations to make the
; 4093 : 			// "simple loop" optimization more likely to engage
; 4094 : 		_Node_endif *_End = new _Node_endif;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], esi
	test	esi, esi
	je	SHORT $LN9@Add_rep

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [esi+4], 17			; 00000011H
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0

; 1839 : 		{	// construct

	mov	DWORD PTR [esi], OFFSET ??_7_Node_endif@std@@6B@

; 4092 : 		{	// rewrite zero-or-one quantifiers as alternations to make the
; 4093 : 			// "simple loop" optimization more likely to engage
; 4094 : 		_Node_endif *_End = new _Node_endif;

	jmp	SHORT $LN10@Add_rep
$LN9@Add_rep:
	xor	esi, esi
$LN10@Add_rep:

; 4095 : 		_Node_if *_If_expr = new _Node_if(_End);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T5[ebp], edi
	test	edi, edi
	je	SHORT $LN11@Add_rep

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [edi+4], 16			; 00000010H
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0

; 1850 : 		{	// construct

	mov	DWORD PTR [edi], OFFSET ??_7_Node_if@std@@6B@
	mov	DWORD PTR [edi+20], esi
	mov	DWORD PTR [edi+24], 0

; 4095 : 		_Node_if *_If_expr = new _Node_if(_End);

	jmp	SHORT $LN12@Add_rep
$LN11@Add_rep:
	xor	edi, edi
$LN12@Add_rep:

; 4096 : 		_Node_if *_If_empty_str = new _Node_if(_End);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], ebx
	test	ebx, ebx
	je	SHORT $LN13@Add_rep

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ebx+4], 16			; 00000010H
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0

; 1850 : 		{	// construct

	mov	DWORD PTR [ebx], OFFSET ??_7_Node_if@std@@6B@
	mov	DWORD PTR [ebx+20], esi
	mov	DWORD PTR [ebx+24], 0

; 4096 : 		_Node_if *_If_empty_str = new _Node_if(_End);

	jmp	SHORT $LN14@Add_rep
$LN13@Add_rep:
	xor	ebx, ebx
$LN14@Add_rep:

; 4097 : 		_Node_base *_Gbegin = new _Node_base(_N_group);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	test	eax, eax
	je	SHORT $LN15@Add_rep

; 1677 : 		{	// construct

	mov	DWORD PTR [eax], OFFSET ??_7_Node_base@std@@6B@
	mov	DWORD PTR [eax+4], 8
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0

; 4097 : 		_Node_base *_Gbegin = new _Node_base(_N_group);

	jmp	SHORT $LN16@Add_rep
$LN15@Add_rep:
	mov	DWORD PTR $T3[ebp], 0
$LN16@Add_rep:

; 4098 : 		_Node_end_group *_Gend = new _Node_end_group(_N_end_group, _Fl_none, _Gbegin);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)

	mov	eax, DWORD PTR $T3[ebp]

; 4098 : 		_Node_end_group *_Gend = new _Node_end_group(_N_end_group, _Fl_none, _Gbegin);

	mov	DWORD PTR $T7[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN17@Add_rep

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 9
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1728 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_end_group@std@@6B@
	mov	DWORD PTR [ecx+20], eax

; 4098 : 		_Node_end_group *_Gend = new _Node_end_group(_N_end_group, _Fl_none, _Gbegin);

	jmp	SHORT $LN18@Add_rep
$LN17@Add_rep:
	xor	ecx, ecx
$LN18@Add_rep:

; 4099 : 
; 4100 : 		_If_empty_str->_Next = _Gbegin;

	mov	DWORD PTR [ebx+12], eax

; 4101 : 		_Gbegin->_Prev = _If_empty_str;
; 4102 : 
; 4103 : 		_Gbegin->_Next = _Gend;

	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ebx

; 4104 : 		_Gend->_Prev = _Gbegin;

	mov	DWORD PTR [ecx+16], eax

; 4105 : 
; 4106 : 		_Gend->_Next = _End;

	mov	DWORD PTR [ecx+12], esi

; 3676 : 	_Nx->_Prev = _Current;

	mov	ecx, DWORD PTR _this$1$[ebp]

; 4107 : 
; 4108 : 		_If_expr->_Child = _If_empty_str;

	mov	DWORD PTR [edi+24], ebx

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN53@Add_rep

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [esi+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], esi
$LN53@Add_rep:

; 4109 : 
; 4110 : 		_Link_node(_End);
; 4111 : 		_Insert_node(_Pos, _If_expr);
; 4112 : 
; 4113 : 		if (!_Greedy)

	cmp	BYTE PTR __Greedy$[ebp], 0

; 3682 : 	_Current->_Next = _Nx;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], esi

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [ecx+4], esi

; 3694 : 	_Insert_before->_Prev->_Next = _To_insert;

	mov	esi, DWORD PTR __Pos$1$[ebp]
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+12], edi

; 3695 : 	_To_insert->_Prev = _Insert_before->_Prev;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 3696 : 	_Insert_before->_Prev = _To_insert;

	mov	DWORD PTR [esi+16], edi

; 3697 : 	_To_insert->_Next = _Insert_before;

	mov	DWORD PTR [edi+12], esi

; 4109 : 
; 4110 : 		_Link_node(_End);
; 4111 : 		_Insert_node(_Pos, _If_expr);
; 4112 : 
; 4113 : 		if (!_Greedy)

	jne	$LN6@Add_rep

; 4114 : 			{
; 4115 : 			_Swap_adl(_If_expr->_Next->_Prev, _If_empty_str->_Next->_Prev);

	mov	edx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi+16]

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edx+16], ecx

; 66   : 	_Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi+12]

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+12], eax
	pop	edi
	pop	esi

; 68   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [ebx+12], ecx
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 4128 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN5@Add_rep:

; 4116 : 			_Swap_adl(_If_expr->_Next, _If_empty_str->_Next);
; 4117 : 			}
; 4118 : 		}
; 4119 : 	else
; 4120 : 		{
; 4121 : 		_Node_end_rep *_Node0 = new _Node_end_rep();

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi
	test	edi, edi
	je	SHORT $LN19@Add_rep

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [edi+4], 19			; 00000013H
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0

; 1879 : 		{	// construct

	mov	DWORD PTR [edi], OFFSET ??_7_Node_end_rep@std@@6B@
	mov	DWORD PTR [edi+20], 0

; 4116 : 			_Swap_adl(_If_expr->_Next, _If_empty_str->_Next);
; 4117 : 			}
; 4118 : 		}
; 4119 : 	else
; 4120 : 		{
; 4121 : 		_Node_end_rep *_Node0 = new _Node_end_rep();

	jmp	SHORT $LN20@Add_rep
$LN19@Add_rep:
	xor	edi, edi
$LN20@Add_rep:

; 4122 : 		_Node_rep *_Nx =
; 4123 : 			new _Node_rep(_Greedy, _Min, _Max, _Node0, _Root->_Loops++);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN21@Add_rep
	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [edx+24]
	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR [edx+24], ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	ecx, eax

; 1902 : 		: _Node_base(_N_rep, _Greedy ? _Fl_greedy : _Fl_none),

	xor	eax, eax
	mov	edx, 2
	cmp	BYTE PTR __Greedy$[ebp], al
	cmovne	eax, edx

; 1905 : 			_End_rep(_End),
; 1906 : 			_Loop_number(_Number),

	mov	DWORD PTR [ecx+32], esi

; 4122 : 		_Node_rep *_Nx =
; 4123 : 			new _Node_rep(_Greedy, _Min, _Max, _Node0, _Root->_Loops++);

	mov	esi, DWORD PTR __Pos$1$[ebp]

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+8], eax

; 1903 : 			_Min(_Mn),

	mov	eax, DWORD PTR __Min$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1904 : 			_Max(_Mx),

	mov	eax, DWORD PTR __Max$[ebp]

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 18			; 00000012H
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1908 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_rep@std@@6B@
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], edi
	mov	DWORD PTR [ecx+36], -1

; 4122 : 		_Node_rep *_Nx =
; 4123 : 			new _Node_rep(_Greedy, _Min, _Max, _Node0, _Root->_Loops++);

	jmp	SHORT $LN22@Add_rep
$LN21@Add_rep:
	xor	ecx, ecx
$LN22@Add_rep:

; 4124 : 		_Node0->_Begin_rep = _Nx;

	mov	DWORD PTR [edi+20], ecx

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN96@Add_rep

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [edi+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], edi
$LN96@Add_rep:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+12], edi

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [ebx+4], edi

; 3694 : 	_Insert_before->_Prev->_Next = _To_insert;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+12], ecx

; 3695 : 	_To_insert->_Prev = _Insert_before->_Prev;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax

; 3696 : 	_Insert_before->_Prev = _To_insert;

	mov	DWORD PTR [esi+16], ecx

; 3697 : 	_To_insert->_Next = _Insert_before;

	mov	DWORD PTR [ecx+12], esi
$LN6@Add_rep:
	pop	edi
	pop	esi
	pop	ebx

; 4128 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Add_rep@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXHH_N@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Else_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@0@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Start$ = 8						; size = 4
__End$ = 12						; size = 4
?_Else_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@0@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Else_if, COMDAT
; _this$ = ecx

; 4058 : 	{	// add else node

	npad	2
	push	ebp
	mov	ebp, esp

; 4059 : 	_Node_if *_Parent = (_Node_if *)_Start->_Next;

	mov	eax, DWORD PTR __Start$[ebp]
	push	ebx
	push	esi
	push	edi

; 4060 : 	_Node_base *_First = _End->_Next;

	mov	edi, DWORD PTR __End$[ebp]
	mov	esi, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR [edi+12]

; 4061 : 	_End->_Next = 0;

	mov	DWORD PTR [edi+12], 0

; 4062 : 	_Node_base *_Last = _Current;

	mov	eax, DWORD PTR [ecx+4]

; 4063 : 	_Current = _End;

	mov	DWORD PTR [ecx+4], edi

; 4064 : 	_End->_Next = 0;

	mov	DWORD PTR [edi+12], 0

; 4065 : 	_Last->_Next = _End;

	mov	DWORD PTR [eax+12], edi

; 4066 : 	while (_Parent->_Child)

	lea	eax, DWORD PTR [esi+24]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Else_if
$LL2@Else_if:

; 4067 : 		_Parent = _Parent->_Child;

	mov	esi, DWORD PTR [eax]
	cmp	DWORD PTR [esi+24], 0
	lea	eax, DWORD PTR [esi+24]
	jne	SHORT $LL2@Else_if
$LN3@Else_if:

; 4068 : 	_Parent->_Child = new _Node_if(_End);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN5@Else_if

; 1849 : 		: _Node_base(_N_if, _Fl_none), _Endif((_Node_endif *)_End), _Child(0)

	mov	DWORD PTR [eax+20], edi

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [eax+4], 16			; 00000010H
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0

; 1850 : 		{	// construct

	mov	DWORD PTR [eax], OFFSET ??_7_Node_if@std@@6B@
	mov	DWORD PTR [eax+24], 0

; 4068 : 	_Parent->_Child = new _Node_if(_End);

	mov	DWORD PTR [esi+24], eax

; 4069 : 	_Parent->_Child->_Next = _First;

	mov	DWORD PTR [eax+12], ebx

; 4070 : 	_First->_Prev = _Parent->_Child;

	mov	eax, DWORD PTR [esi+24]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+16], eax
	pop	ebx

; 4071 : 	}

	pop	ebp
	ret	8
$LN5@Else_if:

; 4068 : 	_Parent->_Child = new _Node_if(_End);

	xor	eax, eax
	mov	DWORD PTR [esi+24], eax
	pop	edi

; 4069 : 	_Parent->_Child->_Next = _First;

	mov	DWORD PTR [eax+12], ebx

; 4070 : 	_First->_Prev = _Parent->_Child;

	mov	eax, DWORD PTR [esi+24]
	pop	esi
	mov	DWORD PTR [ebx+16], eax
	pop	ebx

; 4071 : 	}

	pop	ebp
	ret	8
?_Else_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@0@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Else_if
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Begin_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
$T2 = -4						; size = 4
__Start$ = 8						; size = 4
?_Begin_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_if, COMDAT
; _this$ = ecx

; 4041 : 	{	// add if node

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 4042 : 	/* append endif node */
; 4043 : 	_Node_base *_Res = new _Node_endif;

	push	20					; 00000014H
	mov	edi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	test	esi, esi
	je	SHORT $LN3@Begin_if

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [esi+4], 17			; 00000011H
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0

; 1839 : 		{	// construct

	mov	DWORD PTR [esi], OFFSET ??_7_Node_endif@std@@6B@

; 4042 : 	/* append endif node */
; 4043 : 	_Node_base *_Res = new _Node_endif;

	jmp	SHORT $LN4@Begin_if
$LN3@Begin_if:
	xor	esi, esi
$LN4@Begin_if:

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN14@Begin_if

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [esi+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], esi
$LN14@Begin_if:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	eax, DWORD PTR [edi+4]

; 4044 : 	_Link_node(_Res);
; 4045 : 
; 4046 : 	/* insert if_node */
; 4047 : 	_Node_if *_Node1 = new _Node_if(_Res);

	push	28					; 0000001cH

; 3682 : 	_Current->_Next = _Nx;

	mov	DWORD PTR [eax+12], esi

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [edi+4], esi

; 4044 : 	_Link_node(_Res);
; 4045 : 
; 4046 : 	/* insert if_node */
; 4047 : 	_Node_if *_Node1 = new _Node_if(_Res);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN5@Begin_if

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [eax+4], 16			; 00000010H
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0

; 1850 : 		{	// construct

	mov	DWORD PTR [eax], OFFSET ??_7_Node_if@std@@6B@
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+24], 0

; 4044 : 	_Link_node(_Res);
; 4045 : 
; 4046 : 	/* insert if_node */
; 4047 : 	_Node_if *_Node1 = new _Node_if(_Res);

	jmp	SHORT $LN6@Begin_if
$LN5@Begin_if:
	xor	eax, eax
$LN6@Begin_if:

; 4048 : 	_Node_base *_Pos = _Start->_Next;

	mov	ecx, DWORD PTR __Start$[ebp]
	pop	edi
	mov	edx, DWORD PTR [ecx+12]

; 3694 : 	_Insert_before->_Prev->_Next = _To_insert;

	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+12], eax

; 3695 : 	_To_insert->_Prev = _Insert_before->_Prev;

	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx

; 3696 : 	_Insert_before->_Prev = _To_insert;

	mov	DWORD PTR [edx+16], eax

; 3697 : 	_To_insert->_Next = _Insert_before;

	mov	DWORD PTR [eax+12], edx

; 4049 : 	_Insert_node(_Pos, _Node1);
; 4050 : 	return (_Res);

	mov	eax, esi
	pop	esi

; 4051 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Begin_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_if
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_backreference@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Idx$ = 8						; size = 4
?_Add_backreference@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXI@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_backreference, COMDAT
; _this$ = ecx

; 4032 : 	{	// add back reference node

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 4033 : 	_Link_node(new _Node_back(_Idx));

	push	24					; 00000018H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx
	test	edx, edx
	je	SHORT $LN3@Add_backre

; 1771 : 		: _Node_base(_N_back, _Fl_none), _Idx(_Ix)

	mov	eax, DWORD PTR __Idx$[ebp]

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [edx+4], 15			; 0000000fH
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0

; 1772 : 		{	// construct

	mov	DWORD PTR [edx], OFFSET ??_7_Node_back@std@@6B@
	mov	DWORD PTR [edx+20], eax

; 4033 : 	_Link_node(new _Node_back(_Idx));

	jmp	SHORT $LN4@Add_backre
$LN3@Add_backre:
	xor	edx, edx
$LN4@Add_backre:

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN11@Add_backre

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [edx+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], edx
$LN11@Add_backre:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+12], edx

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [esi+4], edx
	pop	esi

; 4034 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Add_backreference@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXI@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_backreference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Begin_capture_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@I@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Idx$ = 8						; size = 4
?_Begin_capture_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@I@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_capture_group, COMDAT
; _this$ = ecx

; 4023 : 	{	// add capture group node

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 4024 : 	return (_Link_node(new _Node_capture(_Idx)));

	push	24					; 00000018H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx
	test	edx, edx
	je	SHORT $LN3@Begin_capt

; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)

	mov	eax, DWORD PTR __Idx$[ebp]

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [edx+4], 13			; 0000000dH
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0

; 1759 : 		{	// construct

	mov	DWORD PTR [edx], OFFSET ??_7_Node_capture@std@@6B@
	mov	DWORD PTR [edx+20], eax

; 4024 : 	return (_Link_node(new _Node_capture(_Idx)));

	jmp	SHORT $LN4@Begin_capt
$LN3@Begin_capt:
	xor	edx, edx
$LN4@Begin_capt:

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN11@Begin_capt

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [edx+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+16], edx
$LN11@Begin_capt:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	ecx, DWORD PTR [esi+4]

; 4024 : 	return (_Link_node(new _Node_capture(_Idx)));

	mov	eax, edx

; 3682 : 	_Current->_Next = _Nx;

	mov	DWORD PTR [ecx+12], edx

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [esi+4], edx
	pop	esi

; 4025 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Begin_capture_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@I@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_capture_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_End_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z
_TEXT	SEGMENT
__Nx$ = 8						; size = 4
?_End_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_assert_group, COMDAT
; _this$ = ecx

; 4013 : 	{	// add end of assert node

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 4014 : 	_End_group(_Nx);

	mov	esi, DWORD PTR __Nx$[ebp]
	push	edi
	push	esi
	mov	edi, ecx
	call	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group

; 4015 : 	_Current = _Nx;

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi

; 4016 : 	}

	pop	ebp
	ret	4
?_End_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_assert_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 4
__Neg$ = 8						; size = 1
?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_assert_group, COMDAT
; _this$ = ecx

; 3989 : 	{	// add assert node

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 3990 : 	_Node_assert *_Node1 = new _Node_assert(_Neg

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	test	esi, esi
	je	SHORT $LN4@Begin_asse
	xor	eax, eax

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [esi+8], 0

; 3990 : 	_Node_assert *_Node1 = new _Node_assert(_Neg

	cmp	BYTE PTR __Neg$[ebp], al

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [esi+12], 0

; 3990 : 	_Node_assert *_Node1 = new _Node_assert(_Neg

	setne	al

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [esi+16], 0

; 3990 : 	_Node_assert *_Node1 = new _Node_assert(_Neg

	add	eax, 10					; 0000000aH

; 1741 : 		{	// construct

	mov	DWORD PTR [esi], OFFSET ??_7_Node_assert@std@@6B@

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [esi+4], eax

; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)

	mov	DWORD PTR [esi+20], 0

; 3990 : 	_Node_assert *_Node1 = new _Node_assert(_Neg

	jmp	SHORT $LN27@Begin_asse
$LN4@Begin_asse:
	xor	esi, esi
$LN27@Begin_asse:

; 3991 : 		? _N_neg_assert : _N_assert);
; 3992 : 
; 3993 : 	_Node_base *_Node2;
; 3994 : 	_TRY_BEGIN
; 3995 : 	_Node2 = new _Node_base(_N_nop);

	push	20					; 00000014H
	mov	DWORD PTR $T3[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	test	edx, edx
	je	SHORT $LN6@Begin_asse

; 1677 : 		{	// construct

	mov	DWORD PTR [edx], OFFSET ??_7_Node_base@std@@6B@
	mov	DWORD PTR [edx+4], 1
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0

; 3991 : 		? _N_neg_assert : _N_assert);
; 3992 : 
; 3993 : 	_Node_base *_Node2;
; 3994 : 	_TRY_BEGIN
; 3995 : 	_Node2 = new _Node_base(_N_nop);

	jmp	SHORT $LN7@Begin_asse
$LN6@Begin_asse:
	xor	edx, edx
$LN7@Begin_asse:

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN23@Begin_asse

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [esi+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	ecx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+16], esi
$LN23@Begin_asse:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	ecx, DWORD PTR [edi+4]

; 3999 : 	_CATCH_END
; 4000 : 
; 4001 : 	_Link_node(_Node1);
; 4002 : 	_Node1->_Child = _Node2;
; 4003 : 	_Node2->_Prev = _Node1;
; 4004 : 	_Current = _Node2;
; 4005 : 	return (_Node1);

	mov	eax, esi

; 3682 : 	_Current->_Next = _Nx;

	mov	DWORD PTR [ecx+12], esi

; 4006 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR [esi+20], edx
	mov	DWORD PTR [edx+16], esi
	mov	DWORD PTR [edi+4], edx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z$0:

; 3996 : 	_CATCH_ALL
; 3997 : 	delete _Node1;

	mov	ecx, DWORD PTR $T3[ebp]
	test	ecx, ecx
	je	SHORT $LN8@Begin_asse
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN8@Begin_asse:

; 3998 : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN28@Begin_asse:
$LN26@Begin_asse:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_assert_group
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Back$ = 8						; size = 4
?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group, COMDAT
; _this$ = ecx

; 3976 : 	{	// add end of group node

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 3977 : 	_Node_type _Elt = _Back->_Kind == _N_group ? _N_end_group

	mov	edi, DWORD PTR __Back$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 8
	jne	SHORT $LN5@End_group
	lea	ebx, DWORD PTR [eax+1]
	jmp	SHORT $LN4@End_group
$LN5@End_group:
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN3@End_group
	lea	ebx, DWORD PTR [eax+2]
	jmp	SHORT $LN4@End_group
$LN3@End_group:
	xor	ebx, ebx
	cmp	eax, 11					; 0000000bH
	setne	bl
	lea	ebx, DWORD PTR [ebx*2+12]
$LN4@End_group:

; 3978 : 		: _Back->_Kind == _N_assert ? _N_end_assert
; 3979 : 		: _Back->_Kind == _N_neg_assert ? _N_end_assert
; 3980 : 		: _N_end_capture;
; 3981 : 	_Link_node(new _Node_end_group(_Elt, _Fl_none, _Back));

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN7@End_group

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1728 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_end_group@std@@6B@
	mov	DWORD PTR [ecx+20], edi

; 3978 : 		: _Back->_Kind == _N_assert ? _N_end_assert
; 3979 : 		: _Back->_Kind == _N_neg_assert ? _N_end_assert
; 3980 : 		: _N_end_capture;
; 3981 : 	_Link_node(new _Node_end_group(_Elt, _Fl_none, _Back));

	jmp	SHORT $LN8@End_group
$LN7@End_group:
	xor	ecx, ecx
$LN8@End_group:

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN15@End_group

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [ecx+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], ecx
$LN15@End_group:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [eax+12], ecx

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [esi+4], ecx
	pop	esi
	pop	ebx

; 3982 : 	}

	pop	ebp
	ret	4
?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Begin_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@XZ
_TEXT	SEGMENT
?_Begin_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@XZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_group, COMDAT
; _this$ = ecx

; 3968 : 	return (_New_node(_N_group));

	push	8
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 3969 : 	}

	ret	0
?_Begin_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@XZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_coll@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Diff$ = 16						; size = 4
?_Add_coll@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_coll, COMDAT
; _this$ = ecx

; 3956 : 	{	// add collation element to bracket expression

	npad	2
	push	ebp
	mov	ebp, esp

; 3957 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3958 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3959 : 	_Sequence<_Elem> **_Cur = &_Node->_Coll;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 20					; 00000014H

; 3960 : 	_Char_to_elts(_First, _Last, _Diff, _Cur);

	push	eax
	push	DWORD PTR __Diff$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	?_Char_to_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0HPAPAU?$_Sequence@_W@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Char_to_elts

; 3961 : 	}

	pop	ebp
	ret	12					; 0000000cH
?_Add_coll@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_coll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z
_TEXT	SEGMENT
$T2 = -80						; size = 24
__Str$ = -56						; size = 24
$T3 = -32						; size = 4
_this$1$ = -28						; size = 4
__Node$1$ = -24						; size = 4
__Ex$4 = -20						; size = 2
$T5 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Diff$ = 16						; size = 4
?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_equiv, COMDAT
; _this$ = ecx

; 3929 : 	{	// add elements of equivalence class to bracket expression

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	esi
	mov	esi, ecx
	push	edi

; 3930 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3931 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3932 : 	typename _RxTraits::string_type _Str =
; 3933 : 		_Traits.transform_primary(_First, _Last);

	push	DWORD PTR __Last$[ebp]
	mov	DWORD PTR _this$1$[ebp], esi
	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __Node$1$[ebp], eax
	lea	eax, DWORD PTR __Str$[ebp]
	push	eax
	call	??$transform_primary@PB_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PB_W0@Z ; std::_Regex_traits<wchar_t>::transform_primary<wchar_t const *>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3934 : 	for (unsigned int _Ch = 0; _Ch < _Bmp_max; ++_Ch)

	xor	edi, edi
$LL4@Add_equiv:

; 3937 : 		if (_Traits.transform_primary(&_Ex, &_Ex + 1) == _Str)

	mov	ecx, DWORD PTR [esi+12]
	movzx	eax, di
	mov	DWORD PTR __Ex$4[ebp], eax
	lea	eax, DWORD PTR __Ex$4[ebp+2]
	push	eax
	lea	eax, DWORD PTR __Ex$4[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$transform_primary@PA_W@?$_Regex_traits@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PA_W0@Z ; std::_Regex_traits<wchar_t>::transform_primary<wchar_t *>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	edx, DWORD PTR __Str$[ebp]
	cmovae	edx, DWORD PTR __Str$[ebp]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1844 : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [eax+16]

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN64@Add_equiv
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN64@Add_equiv:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3416 : 		return (_Traits_equal<_Traits>(this->_Myptr(), this->_Mysize(), _Right._Myptr(), _Right._Mysize()));

	mov	esi, DWORD PTR [esi]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	cmp	esi, DWORD PTR __Str$[ebp+16]
	jne	SHORT $LN72@Add_equiv
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN190@Add_equiv
$LL81@Add_equiv:

; 217  :             if (*_S1 != *_S2)

	mov	cx, WORD PTR [eax]
	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN195@Add_equiv

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	eax, 2
	add	edx, 2
	sub	esi, 1
	jne	SHORT $LL81@Add_equiv
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	BYTE PTR $T5[ebp], 1
	jmp	SHORT $LN73@Add_equiv
$LN195@Add_equiv:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	jne	SHORT $LN72@Add_equiv
$LN190@Add_equiv:
	mov	BYTE PTR $T5[ebp], 1
	jmp	SHORT $LN73@Add_equiv
$LN72@Add_equiv:
	mov	BYTE PTR $T5[ebp], 0
$LN73@Add_equiv:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN118@Add_equiv
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN183@Add_equiv

; 99   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN113@Add_equiv

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN183@Add_equiv

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN183@Add_equiv

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN183@Add_equiv

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN183@Add_equiv

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN113@Add_equiv:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN118@Add_equiv:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 3937 : 		if (_Traits.transform_primary(&_Ex, &_Ex + 1) == _Str)

	cmp	BYTE PTR $T5[ebp], 0

; 3938 : 			{	// insert equivalent character into bitmap
; 3939 : 			if (!_Node->_Small)

	mov	esi, DWORD PTR __Node$1$[ebp]
	je	SHORT $LN2@Add_equiv
	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN6@Add_equiv

; 3940 : 				_Node->_Small = new _Bitmap;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	test	eax, eax
	je	SHORT $LN9@Add_equiv
	xorps	xmm0, xmm0

; 1634 : 		_CSTD memset(_Chrs, '\0', _Bmp_size);

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 3940 : 				_Node->_Small = new _Bitmap;

	jmp	SHORT $LN10@Add_equiv
$LN9@Add_equiv:
	xor	eax, eax
$LN10@Add_equiv:
	mov	DWORD PTR [esi+24], eax
$LN6@Add_equiv:

; 1642 : 		_Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

	mov	edx, edi
	mov	eax, edi
	shr	edx, 3
	and	eax, 7
	add	edx, DWORD PTR [esi+24]
	movzx	ecx, BYTE PTR [edx]
	bts	ecx, eax
	mov	BYTE PTR [edx], cl
$LN2@Add_equiv:

; 3934 : 	for (unsigned int _Ch = 0; _Ch < _Bmp_max; ++_Ch)

	inc	edi
	cmp	edi, 256				; 00000100H
	jae	SHORT $LN191@Add_equiv
	mov	esi, DWORD PTR _this$1$[ebp]
	jmp	$LL4@Add_equiv
$LN191@Add_equiv:

; 3941 : 			_Node->_Small->_Mark(_Ch);
; 3942 : 			}
; 3943 : 		}
; 3944 : 	if (_Bmp_max < static_cast<unsigned int>((numeric_limits<_Elem>::max)()))
; 3945 : 		{	// map range
; 3946 : 		_Sequence<_Elem> **_Cur = &_Node->_Equiv;
; 3947 : 		_Char_to_elts(_First, _Last, _Diff, _Cur);

	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR [esi+40]
	push	eax
	push	DWORD PTR __Diff$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	?_Char_to_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0HPAPAU?$_Sequence@_W@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Char_to_elts
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR __Str$[ebp+20]
	pop	edi
	pop	esi
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN168@Add_equiv
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN162@Add_equiv
$LN183@Add_equiv:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN196@Add_equiv:
$LN162@Add_equiv:

; 99   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN163@Add_equiv

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN164@Add_equiv
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN197@Add_equiv:
$LN164@Add_equiv:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN165@Add_equiv
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN198@Add_equiv:
$LN165@Add_equiv:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN166@Add_equiv
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN199@Add_equiv:
$LN166@Add_equiv:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN167@Add_equiv
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN200@Add_equiv:
$LN167@Add_equiv:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN163@Add_equiv:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN168@Add_equiv:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 3949 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN194@Add_equiv:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z$0:
	lea	ecx, DWORD PTR __Str$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_equiv
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_named_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXF_N@Z
_TEXT	SEGMENT
__Cl$ = 8						; size = 2
__Negate$ = 12						; size = 1
?_Add_named_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXF_N@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_named_class, COMDAT
; _this$ = ecx

; 3881 : 	{	// add contents of named class to bracket expression

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 3882 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3883 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3884 : 	_Add_elts(_Node, _Cl, _Negate);

	mov	esi, DWORD PTR __Cl$[ebp]
	push	edi
	push	DWORD PTR __Negate$[ebp]
	mov	edi, DWORD PTR [ecx+4]
	push	esi
	push	edi
	call	?_Add_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPAV?$_Node_class@_WV?$regex_traits@_W@std@@@2@F_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_elts

; 3885 : 	if (_Bmp_max < static_cast<unsigned int>((numeric_limits<_Elem>::max)()))
; 3886 : 		_Node->_Classes =

	or	WORD PTR [edi+36], si
	pop	edi
	pop	esi

; 3887 : 			(_Regex_traits_base::char_class_type)(_Node->_Classes | _Cl);
; 3888 : 	}

	pop	ebp
	ret	8
?_Add_named_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXF_N@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_named_class
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_range@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W0@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_this$1$ = 8						; size = 4
$T1 = 8							; size = 4
$T2 = 8							; size = 4
__E0x$ = 8						; size = 2
__Len$1$ = 12						; size = 4
__E1x$ = 12						; size = 2
?_Add_range@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W0@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_range, COMDAT
; _this$ = ecx

; 3825 : 	{	// add character range to set

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 113  : _BITMASK_OPS(syntax_option_type)

	test	DWORD PTR [ecx+8], 256			; 00000100H
	push	ebx
	push	esi

; 3826 : 	unsigned int _E0 = (typename _RxTraits::_Uelem)_E0x;

	movzx	esi, WORD PTR __E0x$[ebp]
	push	edi

; 3827 : 	unsigned int _E1 = (typename _RxTraits::_Uelem)_E1x;

	movzx	edi, WORD PTR __E1x$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx

; 3828 : 	if (_Flags & regex_constants::icase)

	je	SHORT $LN8@Add_range

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [ecx+12]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	esi
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 3829 : 		{	// change to lowercase range
; 3830 : 		_E0 = _Traits.translate_nocase((_Elem)_E0);

	movzx	esi, ax

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR _this$1$[ebp]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	edi

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [eax+12]

; 301  : 		return (_Getctype()->tolower(_Ch));

	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z
	mov	ecx, DWORD PTR _this$1$[ebp]

; 3831 : 		_E1 = _Traits.translate_nocase((_Elem)_E1);

	movzx	edi, ax
$LN8@Add_range:

; 3832 : 		}
; 3833 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3834 : 		(_Node_class<_Elem, _RxTraits> *)_Current;

	mov	ebx, DWORD PTR [ecx+4]

; 3835 : 	for (; _E0 <= _E1 && _E1 < _Get_bmax(); ++_E0)

	cmp	esi, edi
	ja	$LN56@Add_range
	npad	2
$LL4@Add_range:
	cmp	edi, DWORD PTR [ecx+16]
	jae	SHORT $LN3@Add_range

; 3836 : 		{	// set a bit
; 3837 : 		if (!_Node->_Small)

	cmp	DWORD PTR [ebx+24], 0
	jne	SHORT $LN9@Add_range

; 3838 : 			_Node->_Small = new _Bitmap;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	test	eax, eax
	je	SHORT $LN16@Add_range
	xorps	xmm0, xmm0

; 1634 : 		_CSTD memset(_Chrs, '\0', _Bmp_size);

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 3838 : 			_Node->_Small = new _Bitmap;

	jmp	SHORT $LN17@Add_range
$LN16@Add_range:
	xor	eax, eax
$LN17@Add_range:
	mov	DWORD PTR [ebx+24], eax
$LN9@Add_range:

; 1642 : 		_Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

	mov	edx, esi
	mov	eax, esi
	shr	edx, 3
	and	eax, 7
	add	edx, DWORD PTR [ebx+24]

; 3835 : 	for (; _E0 <= _E1 && _E1 < _Get_bmax(); ++_E0)

	inc	esi

; 1642 : 		_Chrs[_Wide >> _Bmp_shift] |= (1 << (_Wide & _Bmp_mask));

	movzx	ecx, BYTE PTR [edx]
	bts	ecx, eax
	mov	BYTE PTR [edx], cl

; 3835 : 	for (; _E0 <= _E1 && _E1 < _Get_bmax(); ++_E0)

	mov	ecx, DWORD PTR _this$1$[ebp]
	cmp	esi, edi
	jbe	SHORT $LL4@Add_range
	pop	edi
	pop	esi
	pop	ebx

; 3852 : 		}
; 3853 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@Add_range:

; 3839 : 		_Node->_Small->_Mark(_E0);
; 3840 : 		}
; 3841 : 	if (_E1 < _E0)

	cmp	edi, esi
	jb	$LN56@Add_range

; 3842 : 		;
; 3843 : 	else if (_E1 - _E0 < _Get_tmax())

	mov	eax, edi
	sub	eax, esi
	cmp	eax, DWORD PTR [ecx+20]
	jae	SHORT $LN12@Add_range

; 3844 : 		for (; _E0 <= _E1; ++_E0)

	cmp	esi, edi
	ja	$LN56@Add_range
	npad	4
$LL7@Add_range:

; 3845 : 			_Add_char_to_array((_Elem)_E0);

	push	esi
	call	?_Add_char_to_array@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_array
	mov	ecx, DWORD PTR _this$1$[ebp]
	inc	esi
	cmp	esi, edi
	jbe	SHORT $LL7@Add_range
	pop	edi
	pop	esi
	pop	ebx

; 3852 : 		}
; 3853 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN12@Add_range:

; 3846 : 	else
; 3847 : 		{	// store remaining range as pair
; 3848 : 		if (!_Node->_Ranges)

	cmp	DWORD PTR [ebx+32], 0
	jne	SHORT $LN14@Add_range

; 3849 : 			_Node->_Ranges = new _Buf<_Elem>;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN18@Add_range

; 1562 : 		: _Sz(0), _Nchrs(0), _Chrs(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0

; 3849 : 			_Node->_Ranges = new _Buf<_Elem>;

	jmp	SHORT $LN19@Add_range
$LN18@Add_range:
	xor	eax, eax
$LN19@Add_range:
	mov	DWORD PTR [ebx+32], eax
$LN14@Add_range:

; 3850 : 		_Node->_Ranges->_Insert((_Elem)_E0);

	mov	edx, DWORD PTR [ebx+32]
	mov	DWORD PTR _this$1$[ebp], edx

; 1597 : 		if (_Sz <= _Nchrs)

	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [edx], eax
	ja	SHORT $LN47@Add_range

; 1598 : 			_Expand(_Nchrs + _Buf_incr);

	add	eax, 16					; 00000010H
	mov	DWORD PTR __Len$1$[ebp], eax

; 1617 : 		_Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));

	add	eax, eax
	push	eax
	push	DWORD PTR [edx+8]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 1618 : 		if (!_Tmp)

	test	eax, eax
	jne	SHORT $LN46@Add_range

; 1619 : 			_Xbad_alloc();

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN67@Add_range:
$LN46@Add_range:

; 1620 : 		_Chrs = _Tmp;

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1621 : 		_Sz = _Len;

	mov	eax, DWORD PTR __Len$1$[ebp]
	mov	DWORD PTR [edx], eax
$LN47@Add_range:

; 1599 : 		_Chrs[_Nchrs++] = _Ch;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	WORD PTR [eax+ecx*2], si
	inc	DWORD PTR [edx+4]

; 3851 : 		_Node->_Ranges->_Insert((_Elem)_E1);

	mov	esi, DWORD PTR [ebx+32]

; 1597 : 		if (_Sz <= _Nchrs)

	mov	ebx, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi], ebx
	ja	SHORT $LN55@Add_range

; 1598 : 			_Expand(_Nchrs + _Buf_incr);

	add	ebx, 16					; 00000010H

; 1617 : 		_Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));

	lea	eax, DWORD PTR [ebx+ebx]
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 1618 : 		if (!_Tmp)

	test	eax, eax
	jne	SHORT $LN54@Add_range

; 1619 : 			_Xbad_alloc();

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN68@Add_range:
$LN54@Add_range:

; 1620 : 		_Chrs = _Tmp;

	mov	DWORD PTR [esi+8], eax

; 1621 : 		_Sz = _Len;

	mov	DWORD PTR [esi], ebx
$LN55@Add_range:

; 1599 : 		_Chrs[_Nchrs++] = _Ch;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	mov	WORD PTR [eax+ecx*2], di
	inc	DWORD PTR [esi+4]
$LN56@Add_range:
	pop	edi
	pop	esi
	pop	ebx

; 3852 : 		}
; 3853 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN66@Add_range:
?_Add_range@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W0@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_char_to_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?_Add_char_to_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_class, COMDAT
; _this$ = ecx

; 3813 : 	{	// add character to bracket expression

	npad	2
	push	ebp
	mov	ebp, esp

; 3814 : 	if (static_cast<typename _RxTraits::_Uelem>(_Ch) < _Bmp_max)

	mov	eax, DWORD PTR __Ch$[ebp]
	mov	edx, 256				; 00000100H
	cmp	ax, dx
	jae	SHORT $LN2@Add_char_t

; 3815 : 		_Add_char_to_bitmap(_Ch);

	mov	DWORD PTR __Ch$[ebp], eax

; 3818 : 	}

	pop	ebp

; 3815 : 		_Add_char_to_bitmap(_Ch);

	jmp	?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap
$LN2@Add_char_t:

; 3816 : 	else
; 3817 : 		_Add_char_to_array(_Ch);

	mov	DWORD PTR __Ch$[ebp], eax

; 3818 : 	}

	pop	ebp

; 3816 : 	else
; 3817 : 		_Add_char_to_array(_Ch);

	jmp	?_Add_char_to_array@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_array
?_Add_char_to_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_class
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Add_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_class, COMDAT
; _this$ = ecx

; 3776 : 	{	// add bracket expression node

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 3777 : 	_Link_node(new _Node_class<_Elem, _RxTraits>);

	push	44					; 0000002cH
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx
	test	edx, edx
	je	SHORT $LN3@Add_class

; 1801 : 		_Classes((typename _RxTraits::char_class_type)0), _Equiv(0)

	xor	eax, eax

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [edx+4], 7
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0

; 1802 : 		{	// construct

	mov	DWORD PTR [edx], OFFSET ??_7?$_Node_class@_WV?$regex_traits@_W@std@@@std@@6B@
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+32], 0
	mov	WORD PTR [edx+36], ax
	mov	DWORD PTR [edx+40], eax

; 3777 : 	_Link_node(new _Node_class<_Elem, _RxTraits>);

	jmp	SHORT $LN4@Add_class
$LN3@Add_class:
	xor	edx, edx
$LN4@Add_class:

; 3676 : 	_Nx->_Prev = _Current;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+16], eax

; 3677 : 	if (_Current->_Next)

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN11@Add_class

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [edx+12], eax

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], edx
$LN11@Add_class:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+12], edx

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [esi+4], edx
	pop	esi

; 3778 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Add_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_class
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_char@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?_Add_char@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char, COMDAT
; _this$ = ecx

; 3761 : 	{	// append character

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 3762 : 	if (_Current->_Kind != _N_str || _Current->_Flags & _Fl_final)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax+4], 6
	jne	SHORT $LN3@Add_char
	test	BYTE PTR [eax+8], 4
	je	SHORT $LN2@Add_char
$LN3@Add_char:

; 3763 : 		_Add_str_node();

	call	?_Add_str_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_str_node
$LN2@Add_char:

; 113  : _BITMASK_OPS(syntax_option_type)

	mov	eax, DWORD PTR [esi+8]
	test	eax, 256				; 00000100H

; 3764 : 	if (_Flags & regex_constants::icase)

	je	SHORT $LN4@Add_char

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [esi+12]

; 301  : 		return (_Getctype()->tolower(_Ch));

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z

; 3765 : 		_Ch = _Traits.translate_nocase(_Ch);

	movzx	edi, ax

; 3766 : 	else if (_Flags & regex_constants::collate)

	jmp	SHORT $LN6@Add_char
$LN4@Add_char:

; 113  : _BITMASK_OPS(syntax_option_type)

	test	eax, 2048				; 00000800H

; 3766 : 	else if (_Flags & regex_constants::collate)

	je	SHORT $LN24@Add_char

; 3767 : 		_Ch = _Traits.translate(_Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [esi+12]
	call	?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z ; std::_Regex_traits<wchar_t>::translate
	movzx	edi, ax
	jmp	SHORT $LN6@Add_char
$LN24@Add_char:
	mov	edi, DWORD PTR __Ch$[ebp]
$LN6@Add_char:

; 3768 : 	_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Current;
; 3769 : 	_Node->_Data._Insert(_Ch);

	mov	esi, DWORD PTR [esi+4]

; 1597 : 		if (_Sz <= _Nchrs)

	mov	eax, DWORD PTR [esi+24]
	cmp	DWORD PTR [esi+20], eax
	ja	SHORT $LN21@Add_char
	push	ebx

; 1598 : 			_Expand(_Nchrs + _Buf_incr);

	lea	ebx, DWORD PTR [eax+16]

; 1617 : 		_Elem *_Tmp = (_Elem *)realloc(_Chrs, _Len * sizeof (_Elem));

	lea	eax, DWORD PTR [ebx+ebx]
	push	eax
	push	DWORD PTR [esi+28]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 1618 : 		if (!_Tmp)

	test	eax, eax
	jne	SHORT $LN20@Add_char

; 1619 : 			_Xbad_alloc();

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN27@Add_char:
$LN20@Add_char:

; 1620 : 		_Chrs = _Tmp;
; 1621 : 		_Sz = _Len;

	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+28], eax
	pop	ebx
$LN21@Add_char:

; 1599 : 		_Chrs[_Nchrs++] = _Ch;

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+28]
	mov	WORD PTR [eax+ecx*2], di
	inc	DWORD PTR [esi+24]
	pop	edi
	pop	esi

; 3770 : 	}

	pop	ebp
	ret	4
$LN26@Add_char:
?_Add_char@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_dot@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Add_dot@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_dot, COMDAT
; _this$ = ecx

; 3746 : 	_New_node(_N_dot);

	push	5
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 3747 : 	}

	ret	0
?_Add_dot@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_wbound@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Add_wbound@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_wbound, COMDAT
; _this$ = ecx

; 3738 : 	_New_node(_N_wbound);

	push	4
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 3739 : 	}

	ret	0
?_Add_wbound@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_wbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_eol@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Add_eol@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_eol, COMDAT
; _this$ = ecx

; 3730 : 	_New_node(_N_eol);

	push	3
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 3731 : 	}

	ret	0
?_Add_eol@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_eol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Add_bol@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Add_bol@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_bol, COMDAT
; _this$ = ecx

; 3722 : 	_New_node(_N_bol);

	push	2
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 3723 : 	}

	ret	0
?_Add_bol@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_bol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Getmark@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBEPAV_Node_base@2@XZ
_TEXT	SEGMENT
?_Getmark@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBEPAV_Node_base@2@XZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Getmark, COMDAT
; _this$ = ecx

; 3647 : 	return (_Current);

	mov	eax, DWORD PTR [ecx+4]

; 3648 : 	}

	ret	0
?_Getmark@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBEPAV_Node_base@2@XZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Getmark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Discard_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Discard_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Discard_pattern, COMDAT
; _this$ = ecx

; 4143 : 	{	// free memory

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 4144 : 	_Destroy_node(_Root);

	mov	esi, DWORD PTR [edi]

; 1694 : 	while (_Nx != _Ne && _Nx != 0)

	test	esi, esi
	je	SHORT $LN12@Discard_pa
$LN15@Discard_pa:

; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;

	mov	ecx, esi

; 1697 : 		_Nx = _Nx->_Next;

	lea	eax, DWORD PTR [esi+12]
	mov	esi, DWORD PTR [eax]

; 1698 : 		_Tmp->_Next = 0;

	mov	DWORD PTR [eax], 0

; 1699 : 		delete _Tmp;

	push	1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	test	esi, esi
	jne	SHORT $LN15@Discard_pa
$LN12@Discard_pa:

; 4145 : 	_Root = 0;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 4146 : 	}

	ret	0
?_Discard_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Discard_pattern
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Setlong@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Setlong@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Setlong, COMDAT
; _this$ = ecx

; 3623 : 	_Root->_Flags |= _Fl_longest;

	mov	eax, DWORD PTR [ecx]

; 1523 : 	return (_Left = _Node_flags((int)_Left | _Right));

	or	DWORD PTR [eax+8], 8

; 3624 : 	}

	ret	0
?_Setlong@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Setlong
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBE_NXZ PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Beg_expr, COMDAT
; _this$ = ecx

; 3666 : 	return (_Beg_expr(_Current)

	mov	ecx, DWORD PTR [ecx+4]

; 3656 : 	return (_Nx->_Kind == _N_begin

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 20					; 00000014H
	je	SHORT $LN4@Beg_expr
	cmp	eax, 8
	je	SHORT $LN4@Beg_expr
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN4@Beg_expr

; 3666 : 	return (_Beg_expr(_Current)

	cmp	eax, 2
	jne	SHORT $LN3@Beg_expr
	mov	eax, DWORD PTR [ecx+16]

; 3656 : 	return (_Nx->_Kind == _N_begin

	mov	eax, DWORD PTR [eax+4]
	cmp	eax, 20					; 00000014H
	je	SHORT $LN4@Beg_expr
	cmp	eax, 8
	je	SHORT $LN4@Beg_expr
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN4@Beg_expr
$LN3@Beg_expr:

; 3666 : 	return (_Beg_expr(_Current)

	xor	al, al

; 3667 : 		|| (_Current->_Kind == _N_bol && _Beg_expr(_Current->_Prev)));
; 3668 : 	}

	ret	0
$LN4@Beg_expr:

; 3666 : 	return (_Beg_expr(_Current)

	mov	al, 1

; 3667 : 		|| (_Current->_Kind == _N_bol && _Beg_expr(_Current->_Prev)));
; 3668 : 	}

	ret	0
?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Beg_expr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@W4syntax_option_type@regex_constants@1@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Tr$ = 8						; size = 4
__Fx$ = 12						; size = 4
??0?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@W4syntax_option_type@regex_constants@1@@Z PROC ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 3615 : 	{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)
; 1728 : 		{	// construct
; 1729 : 		}
; 1730 : 
; 1731 : 	_Node_base *_Back;
; 1732 : 	};
; 1733 : 
; 1734 : 	// CLASS _Node_assert
; 1735 : class _Node_assert
; 1736 : 	: public _Node_base
; 1737 : 	{	// node that holds an ECMAScript assertion
; 1738 : public:
; 1739 : 	_Node_assert(_Node_type _Ty, _Node_flags _Fl = _Fl_none)
; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)
; 1741 : 		{	// construct
; 1742 : 		}
; 1743 : 
; 1744 : 	~_Node_assert() _NOEXCEPT
; 1745 : 		{	// destroy branch
; 1746 : 		_Destroy_node(_Child);
; 1747 : 		}
; 1748 : 
; 1749 : 	_Node_base *_Child;
; 1750 : 	};
; 1751 : 
; 1752 : 	// TEMPLATE CLASS _Node_capture
; 1753 : class _Node_capture
; 1754 : 	: public _Node_base
; 1755 : 	{	// node that marks beginning of a capture group
; 1756 : public:
; 1757 : 	_Node_capture(unsigned int _Ix)
; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)
; 1759 : 		{	// construct
; 1760 : 		}
; 1761 : 
; 1762 : 	unsigned int _Idx;
; 1763 : 	};
; 1764 : 
; 1765 : 	// CLASS _Node_back
; 1766 : class _Node_back
; 1767 : 	: public _Node_base
; 1768 : 	{	// node that holds a back reference
; 1769 : public:
; 1770 : 	_Node_back(unsigned int _Ix)
; 1771 : 		: _Node_base(_N_back, _Fl_none), _Idx(_Ix)
; 1772 : 		{	// construct
; 1773 : 		}
; 1774 : 
; 1775 : 	unsigned int _Idx;
; 1776 : 	};
; 1777 : 
; 1778 : 	// TEMPLATE CLASS _Node_str
; 1779 : template<class _Elem>
; 1780 : 	class _Node_str
; 1781 : 		: public _Node_base
; 1782 : 	{	// node that holds text
; 1783 : public:
; 1784 : 	_Node_str(_Node_flags _Fl = _Fl_none)
; 1785 : 		: _Node_base(_N_str, _Fl)
; 1786 : 		{	// construct
; 1787 : 		}
; 1788 : 
; 1789 : 	_Buf<_Elem> _Data;
; 1790 : 	};
; 1791 : 
; 1792 : 	// TEMPLATE CLASS _Node_class
; 1793 : template<class _Elem,
; 1794 : 	class _RxTraits>
; 1795 : 	class _Node_class
; 1796 : 		: public _Node_base
; 1797 : 	{	// node that holds a character class (POSIX bracket expression)
; 1798 : public:
; 1799 : 	_Node_class(_Node_type _Ty = _N_class, _Node_flags _Fl = _Fl_none)
; 1800 : 		: _Node_base(_Ty, _Fl), _Coll(0), _Small(0), _Large(0), _Ranges(0),
; 1801 : 		_Classes((typename _RxTraits::char_class_type)0), _Equiv(0)
; 1802 : 		{	// construct
; 1803 : 		}
; 1804 : 
; 1805 : 	~_Node_class() _NOEXCEPT
; 1806 : 		{	// destroy
; 1807 : 		_Tidy(_Coll);
; 1808 : 		delete _Small;
; 1809 : 		delete _Large;
; 1810 : 		delete _Ranges;
; 1811 : 		_Tidy(_Equiv);
; 1812 : 		}
; 1813 : 
; 1814 : 	void _Tidy(_Sequence<_Elem> *_Head)
; 1815 : 		{	// clean up a list of sequences
; 1816 : 		while (_Head)
; 1817 : 			{	// delete the head of the list
; 1818 : 			_Sequence<_Elem> *_Temp = _Head;
; 1819 : 			_Head = _Head->_Next;
; 1820 : 			delete _Temp;
; 1821 : 			}
; 1822 : 		}
; 1823 : 
; 1824 : 	_Sequence<_Elem> *_Coll;
; 1825 : 	_Bitmap *_Small;
; 1826 : 	_Buf<_Elem> *_Large;
; 1827 : 	_Buf<_Elem> *_Ranges;
; 1828 : 	typename _RxTraits::char_class_type _Classes;
; 1829 : 	_Sequence<_Elem> *_Equiv;
; 1830 : 	};
; 1831 : 
; 1832 : 	// CLASS _Node_endif
; 1833 : class _Node_endif
; 1834 : 	: public _Node_base
; 1835 : 	{	// node that marks the end of an alternative
; 1836 : public:
; 1837 : 	_Node_endif()
; 1838 : 		: _Node_base(_N_endif, _Fl_none)
; 1839 : 		{	// construct
; 1840 : 		}
; 1841 : 	};
; 1842 : 
; 1843 : 	// CLASS _Node_if
; 1844 : class _Node_if
; 1845 : 	: public _Node_base
; 1846 : 	{	// node that marks the beginning of an alternative
; 1847 : public:
; 1848 : 	_Node_if(_Node_base *_End)
; 1849 : 		: _Node_base(_N_if, _Fl_none), _Endif((_Node_endif *)_End), _Child(0)
; 1850 : 		{	// construct
; 1851 : 		}
; 1852 : 
; 1853 : 	~_Node_if() _NOEXCEPT
; 1854 : 		{	// destroy branches of if node
; 1855 : 		_Node_if *_Cur = _Child;
; 1856 : 		while (_Cur)
; 1857 : 			{	// destroy branch
; 1858 : 			_Node_if *_Tmp = _Cur;
; 1859 : 			_Cur = _Cur->_Child;
; 1860 : 			_Tmp->_Child = 0;
; 1861 : 			_Destroy_node(_Tmp, _Endif);
; 1862 : 			}
; 1863 : 		}
; 1864 : 
; 1865 : 	_Node_endif *_Endif;
; 1866 : 	_Node_if *_Child;
; 1867 : 	};
; 1868 : 
; 1869 : 	// CLASS _Node_end_rep
; 1870 : class _Node_rep;
; 1871 : 
; 1872 : class _Node_end_rep
; 1873 : 	: public _Node_base
; 1874 : 	{	// node that marks the end of a repetition
; 1875 : public:
; 1876 : 	_Node_end_rep()
; 1877 : 		: _Node_base(_N_end_rep),
; 1878 : 			_Begin_rep(0)
; 1879 : 		{	// construct
; 1880 : 		}
; 1881 : 
; 1882 : 	_Node_rep *_Begin_rep;
; 1883 : 
; 1884 : private:
; 1885 : 	_Node_end_rep& operator=(const _Node_end_rep&);
; 1886 : 	};
; 1887 : 
; 1888 : 	// CLASS _Loop_vals_t
; 1889 : struct _Loop_vals_t
; 1890 : 	{	// storage for loop administration
; 1891 : 	int _Loop_idx;
; 1892 : 	void *_Loop_iter;
; 1893 : 	};
; 1894 : 
; 1895 : 	// CLASS _Node_rep
; 1896 : class _Node_rep
; 1897 : 	: public _Node_base
; 1898 : 	{	// node that marks the beginning of a repetition
; 1899 : public:
; 1900 : 	_Node_rep(bool _Greedy, int _Mn, int _Mx, _Node_end_rep *_End,
; 1901 : 		unsigned int _Number)
; 1902 : 		: _Node_base(_N_rep, _Greedy ? _Fl_greedy : _Fl_none),
; 1903 : 			_Min(_Mn),
; 1904 : 			_Max(_Mx),
; 1905 : 			_End_rep(_End),
; 1906 : 			_Loop_number(_Number),
; 1907 : 			_Simple_loop(-1)
; 1908 : 		{	// construct
; 1909 : 		}
; 1910 : 
; 1911 : 	const int _Min;
; 1912 : 	const int _Max;
; 1913 : 	_Node_end_rep *_End_rep;
; 1914 : 	unsigned int _Loop_number;
; 1915 : 	int _Simple_loop;	// -1 undetermined, 0 contains if/do, 1 simple
; 1916 : 
; 1917 : private:
; 1918 : 	_Node_rep& operator=(const _Node_rep&);
; 1919 : 	};
; 1920 : 
; 1921 : 	// TEMPLATE CLASS _Builder
; 1922 : template<class _FwdIt,
; 1923 : 	class _Elem,
; 1924 : 	class _RxTraits>
; 1925 : 	class _Builder
; 1926 : 	{	// provides operations used by _Parser to build the nfa
; 1927 : public:
; 1928 : 	typedef typename iterator_traits<_FwdIt>::difference_type _Difft;
; 1929 : 
; 1930 : 	_Builder(const _RxTraits& _Tr, regex_constants::syntax_option_type);
; 1931 : 	bool _Beg_expr() const;
; 1932 : 	void _Setlong();
; 1933 : 	void _Discard_pattern();
; 1934 : 	_Node_base *_Getmark() const;
; 1935 : 
; 1936 : 	void _Add_nop();
; 1937 : 	void _Add_bol();
; 1938 : 	void _Add_eol();
; 1939 : 	void _Add_wbound();
; 1940 : 	void _Add_dot();
; 1941 : 	void _Add_char(_Elem _Ch);
; 1942 : 	void _Add_class();
; 1943 : 	void _Add_char_to_class(_Elem _Ch);
; 1944 : 	void _Add_range(_Elem _E0, _Elem _E1);
; 1945 : 	void _Add_named_class(_Regex_traits_base::char_class_type, bool = false);
; 1946 : 	void _Add_equiv(_FwdIt, _FwdIt, _Difft);
; 1947 : 	void _Add_coll(_FwdIt, _FwdIt, _Difft);
; 1948 : 	_Node_base *_Begin_group();
; 1949 : 	void _End_group(_Node_base *_Back);
; 1950 : 	_Node_base *_Begin_assert_group(bool);
; 1951 : 	void _End_assert_group(_Node_base *);
; 1952 : 	_Node_base *_Begin_capture_group(unsigned int _Idx);
; 1953 : 	void _Add_backreference(unsigned int _Idx);
; 1954 : 	_Node_base *_Begin_if(_Node_base *_Start);
; 1955 : 	void _Else_if(_Node_base *, _Node_base *);
; 1956 : 	void _Add_rep(int _Min, int _Max, bool _Greedy);
; 1957 : 	void _Negate();
; 1958 : 	void _Mark_final();
; 1959 : 	_Root_node *_End_pattern();
; 1960 : 
; 1961 : private:
; 1962 : 	_Node_base *_Link_node(_Node_base *);
; 1963 : 	static void _Insert_node(_Node_base *, _Node_base *);
; 1964 : 	_Node_base *_New_node(_Node_type _Kind);
; 1965 : 	void _Add_str_node();
; 1966 : 	bool _Beg_expr(_Node_base *) const;
; 1967 : 	void _Add_char_to_bitmap(_Elem _Ch);
; 1968 : 	void _Add_char_to_array(_Elem _Ch);
; 1969 : 	void _Add_elts(_Node_class<_Elem, _RxTraits> *,
; 1970 : 		_Regex_traits_base::char_class_type, bool);
; 1971 : 	void _Char_to_elts(_FwdIt, _FwdIt, _Difft, _Sequence<_Elem> **);
; 1972 : 
; 1973 : 	_Root_node *_Root;
; 1974 : 	_Node_base *_Current;
; 1975 : 	regex_constants::syntax_option_type _Flags;
; 1976 : 	const _RxTraits& _Traits;
; 1977 : 	const int _Bmax; // Do not use; use _Get_bmax instead.
; 1978 : 	const int _Tmax; // Do not use; use _Get_tmax instead.
; 1979 : 
; 1980 : 	unsigned int _Get_bmax() const;
; 1981 : 	unsigned int _Get_tmax() const;
; 1982 : 
; 1983 : private:
; 1984 : 	_Builder& operator=(const _Builder&);
; 1985 : 	};
; 1986 : 
; 1987 : 	// TEMPLATE CLASS _Bt_state_t
; 1988 : template<class _BidIt>
; 1989 : 	class _Bt_state_t
; 1990 : 	{	// holds the state needed for backtracking
; 1991 : public:
; 1992 : 	_BidIt _Cur;
; 1993 : 	vector<bool> _Grp_valid;
; 1994 : 	};
; 1995 : 
; 1996 : 	// TEMPLATE CLASS _Tgt_state_t
; 1997 : template<class _BidIt>
; 1998 : 	class _Tgt_state_t
; 1999 : 	: public _Bt_state_t<_BidIt>
; 2000 : 	{	// holds the current state of the match
; 2001 : public:
; 2002 : 	struct _Grp_t
; 2003 : 		{	// stores a pair of iterators
; 2004 : 		_BidIt _Begin;
; 2005 : 		_BidIt _End;
; 2006 : 		};
; 2007 : 
; 2008 : 	vector<_Grp_t> _Grps;
; 2009 : 
; 2010 : 	void operator=(const _Bt_state_t<_BidIt>& _Other)
; 2011 : 		{	// assign from object of type _Bt_state_t<_BidIt>
; 2012 : 		*(_Bt_state_t<_BidIt> *)this = _Other;
; 2013 : 		}
; 2014 : 	};
; 2015 : 
; 2016 : 	// TEMPLATE CLASS _Matcher
; 2017 : template<class _BidIt,
; 2018 : 	class _Elem,
; 2019 : 	class _RxTraits,
; 2020 : 	class _It>
; 2021 : 	class _Matcher
; 2022 : 	{	// provides ways to match a regular expression to a text sequence
; 2023 : public:
; 2024 : 	_Matcher(_It _Pfirst, _It _Plast, const _RxTraits& _Tr,
; 2025 : 		_Root_node *_Re, unsigned int _Nx,
; 2026 : 		regex_constants::syntax_option_type _Sf,
; 2027 : 		regex_constants::match_flag_type _Mf)
; 2028 : 			: _First(_Pfirst), _End(_Plast), _Traits(_Tr), _Rep(_Re),
; 2029 : 				_Sflags(_Sf), _Mflags(_Mf), _Matched(false),
; 2030 : 				_Ncap(static_cast<int>(_Nx)),
; 2031 : 				_Longest((_Re->_Flags & _Fl_longest)
; 2032 : 					&& !(_Mf & regex_constants::match_any))
; 2033 : 		{	// construct
; 2034 : 		_Loop_vals.resize(_Re->_Loops);
; 2035 : 		_DEBUG_RANGE(_Pfirst, _Plast);
; 2036 : 		}
; 2037 : 
; 2038 : 	void _Setf(regex_constants::match_flag_type _Mf)
; 2039 : 		{	// set specified flags
; 2040 : 		_Mflags |= _Mf;
; 2041 : 		}
; 2042 : 
; 2043 : 	void _Clearf(regex_constants::match_flag_type _Mf)
; 2044 : 		{	// clear specified flags
; 2045 : 		_Mflags &= ~_Mf;
; 2046 : 		}
; 2047 : 
; 2048 : 	template<class _Alloc>
; 2049 : 		bool _Match(_It _Pfirst,
; 2050 : 			match_results<_BidIt, _Alloc> *_Matches,
; 2051 : 			bool _Full_match)
; 2052 : 		{	// try to match
; 2053 : 		_First = _Pfirst;
; 2054 : 		return (_Match(_Matches, _Full_match));
; 2055 : 		}
; 2056 : 
; 2057 : 	template<class _Alloc>
; 2058 : 		bool _Match(match_results<_BidIt, _Alloc> *_Matches,
; 2059 : 			bool _Full_match)
; 2060 : 		{	// try to match
; 2061 : 		if (_Matches)
; 2062 : 			{	// clear _Matches before doing work
; 2063 : 			_Matches->_Ready = true;
; 2064 : 			_Matches->_Resize(0);
; 2065 : 			}
; 2066 : 
; 2067 : 		_Begin = _First;
; 2068 : 		_Tgt_state._Cur = _First;
; 2069 : 		_Tgt_state._Grp_valid.resize(_Get_ncap());
; 2070 : 		_Tgt_state._Grps.resize(_Get_ncap());
; 2071 : 		_Cap = _Matches != 0;
; 2072 : 		_Full = _Full_match;
; 2073 : 		_Max_complexity_count = _REGEX_MAX_COMPLEXITY_COUNT;
; 2074 : 		_Max_stack_count = _REGEX_MAX_STACK_COUNT;
; 2075 : 
; 2076 : 		_Matched = false;
; 2077 : 
; 2078 : 		if (!_Match_pat(_Rep))
; 2079 : 			return (false);
; 2080 : 
; 2081 : 		if (_Matches)
; 2082 : 			{	// copy results to _Matches
; 2083 : 			_Matches->_Resize(_Get_ncap());
; 2084 : 			for (unsigned int _Idx = 0; _Idx < _Get_ncap(); ++_Idx)
; 2085 : 				{	// copy submatch _Idx
; 2086 : 				if (_Res._Grp_valid[_Idx])
; 2087 : 					{	// copy successful match
; 2088 : 					_Matches->_At(_Idx).matched = true;
; 2089 : 					_Matches->_At(_Idx).first = _Res._Grps[_Idx]._Begin;
; 2090 : 					_Matches->_At(_Idx).second = _Res._Grps[_Idx]._End;
; 2091 : 					}
; 2092 : 				else
; 2093 : 					{	// copy failed match
; 2094 : 					_Matches->_At(_Idx).matched = false;
; 2095 : 					_Matches->_At(_Idx).first = _End;
; 2096 : 					_Matches->_At(_Idx).second = _End;
; 2097 : 					}
; 2098 : 				}
; 2099 : 			_Matches->_Org = _Begin;
; 2100 : 			_Matches->_Pfx().first = _Begin;
; 2101 : 			_Matches->_Pfx().second = _Matches->_At(0).first;
; 2102 : 			_Matches->_Pfx().matched =
; 2103 : 				_Matches->_Pfx().first != _Matches->_Pfx().second;
; 2104 : 
; 2105 : 			_Matches->_Sfx().first = _Matches->_At(0).second;
; 2106 : 			_Matches->_Sfx().second = _End;
; 2107 : 			_Matches->_Sfx().matched =
; 2108 : 				_Matches->_Sfx().first != _Matches->_Sfx().second;
; 2109 : 
; 2110 : 			_Matches->_Null().first = _End;
; 2111 : 			_Matches->_Null().second = _End;
; 2112 : 			}
; 2113 : 		return (true);
; 2114 : 		}
; 2115 : 
; 2116 : 	_BidIt _Skip(_BidIt, _BidIt, _Node_base * = 0);
; 2117 : 
; 2118 : private:
; 2119 : 	_Tgt_state_t<_It> _Tgt_state;
; 2120 : 	_Tgt_state_t<_It> _Res;
; 2121 : 	vector<_Loop_vals_t> _Loop_vals;
; 2122 : 
; 2123 : 	bool _Do_if(_Node_if *);
; 2124 : 	bool _Do_rep0(_Node_rep *, bool);
; 2125 : 	bool _Do_rep(_Node_rep *, bool, int);
; 2126 : 	bool _Do_class(_Node_base *);
; 2127 : 	bool _Match_pat(_Node_base *);
; 2128 : 	bool _Better_match();
; 2129 : 	bool _Is_wbound() const;
; 2130 : 
; 2131 : 	unsigned int _Get_ncap() const;
; 2132 : 
; 2133 : 	_It _Begin;
; 2134 : 	_It _End;
; 2135 : 	_It _First;
; 2136 : 	_Node_base *_Rep;
; 2137 : 	regex_constants::syntax_option_type _Sflags;
; 2138 : 	regex_constants::match_flag_type _Mflags;
; 2139 : 	bool _Matched;
; 2140 : 	bool _Cap;
; 2141 : 	int _Ncap; // Do not use. Use _Get_ncap instead.
; 2142 : 	bool _Longest;
; 2143 : 	const _RxTraits& _Traits;
; 2144 : 	bool _Full;
; 2145 : 	long _Max_complexity_count;
; 2146 : 	long _Max_stack_count;
; 2147 : 
; 2148 : private:
; 2149 : 	_Matcher& operator=(const _Matcher&);
; 2150 : 	};
; 2151 : 
; 2152 : enum _Prs_ret
; 2153 : 	{	// indicate class element type
; 2154 : 	_Prs_none,
; 2155 : 	_Prs_chr,
; 2156 : 	_Prs_set
; 2157 : 	};
; 2158 : 
; 2159 : 	// TEMPLATE CLASS _Parser
; 2160 : template<class _FwdIt,
; 2161 : 	class _Elem,
; 2162 : 	class _RxTraits>
; 2163 : 	class _Parser
; 2164 : 	{	// parse a regular expression
; 2165 : public:
; 2166 : 	typedef typename _RxTraits::char_class_type char_class_type;
; 2167 : 
; 2168 : 	_Parser(const _RxTraits& _Tr, _FwdIt _Pfirst, _FwdIt _Plast,
; 2169 : 		regex_constants::syntax_option_type _Fx);
; 2170 : 	_Root_node *_Compile();
; 2171 : 
; 2172 : 	unsigned int _Mark_count() const
; 2173 : 		{	// return number of capture groups
; 2174 : 		return (_Grp_idx + 1);
; 2175 : 		}
; 2176 : 
; 2177 : private:
; 2178 : 	// lexing
; 2179 : 	void _Error(regex_constants::error_type);
; 2180 : 
; 2181 : 	bool _Is_esc() const;
; 2182 : 	void _Trans();
; 2183 : 	void _Next();
; 2184 : 	void _Expect(_Meta_type, regex_constants::error_type);
; 2185 : 
; 2186 : 	// parsing
; 2187 : 	int _Do_digits(int _Base, int _Count);
; 2188 : 	bool _DecimalDigits();
; 2189 : 	void _HexDigits(int);
; 2190 : 	bool _OctalDigits();
; 2191 : 	void _Do_ex_class(_Meta_type);
; 2192 : 	bool _CharacterClassEscape(bool);
; 2193 : 	_Prs_ret _ClassEscape(bool);
; 2194 : 	_Prs_ret _ClassAtom();
; 2195 : 	void _ClassRanges();
; 2196 : 	void _CharacterClass();
; 2197 : 	bool _IdentityEscape();
; 2198 : 	bool _IsIdentityEscape() const;
; 2199 : 	bool _Do_ffn(_Elem);
; 2200 : 	bool _Do_ffnx(_Elem);
; 2201 : 	bool _CharacterEscape();
; 2202 : 	void _AtomEscape();
; 2203 : 	void _Do_capture_group();
; 2204 : 	void _Do_noncapture_group();
; 2205 : 	void _Do_assert_group(bool);
; 2206 : 	bool _Wrapped_disjunction();
; 2207 : 	void _Quantifier();
; 2208 : 	bool _Alternative();
; 2209 : 	void _Disjunction();
; 2210 : 
; 2211 : 	_FwdIt _Pat;
; 2212 : 	_FwdIt _Begin;
; 2213 : 	_FwdIt _End;
; 2214 : 	int _Grp_idx;
; 2215 : 	int _Disj_count;
; 2216 : 	vector<bool> _Finished_grps;
; 2217 : 	_Builder<_FwdIt, _Elem, _RxTraits> _Nfa;
; 2218 : 	const _RxTraits& _Traits;
; 2219 : 	regex_constants::syntax_option_type _Flags;
; 2220 : 	int _Val;
; 2221 : 	_Elem _Char;
; 2222 : 	_Meta_type _Mchar;
; 2223 : 	unsigned int _L_flags;
; 2224 : 	};
; 2225 : 
; 2226 : enum _Lang_flags
; 2227 : 	{	// describe language properties
; 2228 : 	_L_ext_rep = 0x00000001,	// + and ? repetitions
; 2229 : 	_L_alt_pipe = 0x00000002,	// uses '|' for alternation
; 2230 : 	_L_alt_nl = 0x00000004,		// uses '\n' for alternation (grep, egrep)
; 2231 : 	_L_nex_grp = 0x00000008,	// has non-escaped capture groups
; 2232 : 	_L_nex_rep = 0x00000010,	// has non-escaped repeats
; 2233 : 	_L_nc_grp = 0x00000020,		// has non-capture groups (?:xxx)
; 2234 : 	_L_asrt_gen = 0x00000040,	// has generalized assertions (?=xxx), (?!xxx)
; 2235 : 	_L_asrt_wrd = 0x00000080,	// has word boundary assertions (\b, \B)
; 2236 : 	_L_bckr = 0x00000100,		// has backreferences (ERE doesn't)
; 2237 : 	_L_lim_bckr = 0x00000200,	// has limited backreferences (BRE \1-\9)
; 2238 : 	_L_ngr_rep = 0x00000400,	// has non-greedy repeats
; 2239 : 	_L_esc_uni = 0x00000800,	// has Unicode escape sequences
; 2240 : 	_L_esc_hex = 0x00001000,	// has hexadecimal escape sequences
; 2241 : 	_L_esc_oct = 0x00002000,	// has octal escape sequences
; 2242 : 	_L_esc_bsl = 0x00004000,	// has escape backslash in character classes
; 2243 : 	_L_esc_ffnx = 0x00008000,	// has extra file escapes (\a and \b)
; 2244 : 	_L_esc_ffn = 0x00010000,	// has limited file escapes (\[fnrtv])
; 2245 : 	_L_esc_wsd = 0x00020000,	// has w, s, and d character set escapes
; 2246 : 	_L_esc_ctrl = 0x00040000,	// has control escape
; 2247 : 	_L_no_nl = 0x00080000,		// no newline in pattern or matching text
; 2248 : 	_L_bzr_chr = 0x00100000,	// \0 is a valid character constant
; 2249 : 	_L_grp_esc = 0x00200000,	// \ is special character in group
; 2250 : 	_L_ident_ECMA = 0x00400000,	// ECMA identity escape (not identifierpart)
; 2251 : 	_L_ident_ERE = 0x00800000,	// ERE identity escape (.[\*^$, plus {+?}()
; 2252 : 	_L_ident_awk = 0x01000000,	// awk identity escape ( ERE plus "/)
; 2253 : 	_L_anch_rstr = 0x02000000,	// anchor restricted to beginning/end
; 2254 : 	_L_star_beg = 0x04000000,	// star okay at beginning of RE/expr (BRE)
; 2255 : 	_L_empty_grp = 0x08000000,	// empty group allowed (ERE prohibits "()")
; 2256 : 	_L_paren_bal = 0x10000000,	// ')'/'}'/']' special only after '('/'{'/']'
; 2257 : 	_L_brk_rstr = 0x20000000,	// ']' not special when first character in set
; 2258 : 	_L_mtch_long = 0x40000000,	// find longest match (ERE, BRE)
; 2259 : 	};
; 2260 : 
; 2261 : 	// CLASS _Regex_base
; 2262 : class _Regex_base
; 2263 : 	: public _Container_base
; 2264 : 	{	// base class for basic_regex to construct and destroy proxy
; 2265 : public:
; 2266 :  #if 0 < _ITERATOR_DEBUG_LEVEL
; 2267 : 	_Regex_base()
; 2268 : 		{	// construct proxy
; 2269 : 		this->_Myproxy = new _Container_proxy;
; 2270 : 		this->_Myproxy->_Mycont = this;
; 2271 : 		}
; 2272 : 
; 2273 : 	~_Regex_base() _NOEXCEPT
; 2274 : 		{	// destroy proxy
; 2275 : 		this->_Orphan_all();
; 2276 : 		delete this->_Myproxy;
; 2277 : 		this->_Myproxy = 0;
; 2278 : 		}
; 2279 :  #endif /* 0 < _ITERATOR_DEBUG_LEVEL */
; 2280 : 	};
; 2281 : 
; 2282 : 	// TEMPLATE CLASS basic_regex
; 2283 : template<class _Elem,
; 2284 : 	class _RxTraits = regex_traits<_Elem> >
; 2285 : 	class basic_regex
; 2286 : 		: public _Regex_base
; 2287 : 	{	// regular expression
; 2288 : public:
; 2289 : 	typedef basic_regex<_Elem, _RxTraits> _Myt;
; 2290 : 	typedef _Elem value_type;
; 2291 : 	typedef _RxTraits traits_type;
; 2292 : 	typedef typename _RxTraits::locale_type locale_type;
; 2293 : 	typedef typename _RxTraits::string_type string_type;
; 2294 : 	typedef regex_constants::syntax_option_type flag_type;
; 2295 : 
; 2296 : 	static constexpr flag_type icase = regex_constants::icase;
; 2297 : 	static constexpr flag_type nosubs = regex_constants::nosubs;
; 2298 : 	static constexpr flag_type optimize = regex_constants::optimize;
; 2299 : 	static constexpr flag_type collate = regex_constants::collate;
; 2300 : 	static constexpr flag_type ECMAScript = regex_constants::ECMAScript;
; 2301 : 	static constexpr flag_type basic = regex_constants::basic;
; 2302 : 	static constexpr flag_type extended = regex_constants::extended;
; 2303 : 	static constexpr flag_type awk = regex_constants::awk;
; 2304 : 	static constexpr flag_type grep = regex_constants::grep;
; 2305 : 	static constexpr flag_type egrep = regex_constants::egrep;
; 2306 : 
; 2307 : 	basic_regex()
; 2308 : 		: _Rep(0)
; 2309 : 		{	// construct empty object
; 2310 : 		}
; 2311 : 
; 2312 : 	explicit basic_regex(_In_z_ const _Elem *_Ptr,
; 2313 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2314 : 		: _Rep(0)
; 2315 : 		{	// construct from null terminated character sequence
; 2316 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),
; 2317 : 			_Flags, random_access_iterator_tag());
; 2318 : 		}
; 2319 : 
; 2320 : 	basic_regex(_In_reads_(_Count) const _Elem *_Ptr, size_t _Count,
; 2321 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2322 : 		: _Rep(0)
; 2323 : 		{	// construct from character sequence
; 2324 : 		if (_Ptr == 0)
; 2325 : 			_Xregex_error(regex_constants::error_parse);
; 2326 : 		_Reset(_Ptr, _Ptr + _Count, _Flags, random_access_iterator_tag());
; 2327 : 		}
; 2328 : 
; 2329 : 	template<class _STtraits,
; 2330 : 		class _STalloc>
; 2331 : 		explicit basic_regex(
; 2332 : 			const basic_string<_Elem, _STtraits, _STalloc>& _Str,
; 2333 : 			flag_type _Flags = regex_constants::ECMAScript)
; 2334 : 		: _Rep(0)
; 2335 : 		{	// construct from string object
; 2336 : 		_Reset(_Str.begin(), _Str.end(), _Flags, random_access_iterator_tag());
; 2337 : 		}
; 2338 : 
; 2339 : 	template<class _InIt>
; 2340 : 		basic_regex(_InIt _First, _InIt _Last,
; 2341 : 			flag_type _Flags)
; 2342 : 		: _Rep(0)
; 2343 : 		{	// construct from pair of iterators
; 2344 : 		_DEBUG_RANGE(_First, _Last);
; 2345 : 		_Reset(_First, _Last, _Flags, _Iter_cat_t<_InIt>());
; 2346 : 		}
; 2347 : 
; 2348 : 	template<class _InIt>
; 2349 : 		basic_regex(_InIt _First, _InIt _Last)
; 2350 : 		: _Rep(0)
; 2351 : 		{	// construct from pair of iterators
; 2352 : 		_DEBUG_RANGE(_First, _Last);
; 2353 : 		_Reset(_First, _Last, regex_constants::ECMAScript, _Iter_cat_t<_InIt>());
; 2354 : 		}
; 2355 : 
; 2356 : 	basic_regex(const _Myt& _Right)
; 2357 : 
; 2358 :  #if _ENHANCED_REGEX_VISUALIZER
; 2359 : 		: _Rep(0), _Traits(_Right._Traits),
; 2360 : 			_Visualization(_Right._Visualization)
; 2361 : 
; 2362 :  #else /* _ENHANCED_REGEX_VISUALIZER */
; 2363 : 		: _Rep(0), _Traits(_Right._Traits)
; 2364 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2365 : 
; 2366 : 		{	// construct copy of _Right
; 2367 : 		_Reset(_Right._Rep);
; 2368 : 		}
; 2369 : 
; 2370 : 	basic_regex(initializer_list<_Elem> _Ilist,
; 2371 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2372 : 		: _Rep(0)
; 2373 : 		{	// construct from initializer_list
; 2374 : 		_Reset(_Ilist.begin(), _Ilist.end(), _Flags,
; 2375 : 			random_access_iterator_tag());
; 2376 : 		}
; 2377 : 
; 2378 : 	_Myt& operator=(initializer_list<_Elem> _Ilist)
; 2379 : 		{	// replace with regular expression in initializer_list
; 2380 : 		return (assign(_Ilist));
; 2381 : 		}
; 2382 : 
; 2383 : 	_Myt& assign(initializer_list<_Elem> _Ilist,
; 2384 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2385 : 		{	// replace with regular expression in initializer_list
; 2386 : 		_Reset(_Ilist.begin(), _Ilist.end(),
; 2387 : 			_Flags, random_access_iterator_tag());
; 2388 : 		return (*this);
; 2389 : 		}
; 2390 : 
; 2391 : 	basic_regex(_Myt&& _Right) _NOEXCEPT
; 2392 : 		: _Rep(0)
; 2393 : 		{	// construct by moving _Right
; 2394 : 		_Assign_rv(_STD move(_Right));
; 2395 : 		}
; 2396 : 
; 2397 : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 2398 : 		{	// assign by moving _Right
; 2399 : 		_Assign_rv(_STD move(_Right));
; 2400 : 		return (*this);
; 2401 : 		}
; 2402 : 
; 2403 : 	void _Assign_rv(_Myt&& _Right)
; 2404 : 		{	// assign by moving _Right
; 2405 : 		if (this != _STD addressof(_Right))
; 2406 : 			{	// clear this and steal from _Right
; 2407 : 			_Tidy();
; 2408 : 
; 2409 :  #if _ENHANCED_REGEX_VISUALIZER
; 2410 : 			_Visualization = _STD move(_Right._Visualization);
; 2411 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2412 : 
; 2413 : 			_Rep = _Right._Rep;
; 2414 : 			_Right._Rep = 0;
; 2415 : 			}
; 2416 : 		}
; 2417 : 
; 2418 : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 2419 : 		{	// assign by moving _Right
; 2420 : 		_Assign_rv(_STD move(_Right));
; 2421 : 		return (*this);
; 2422 : 		}
; 2423 : 
; 2424 : 	~basic_regex() _NOEXCEPT
; 2425 : 		{	// destroy the object
; 2426 : 		_Tidy();
; 2427 : 		}
; 2428 : 
; 2429 : 	_Myt& operator=(const _Myt& _Right)
; 2430 : 		{	// replace with copy of _Right
; 2431 : 		return (assign(_Right));
; 2432 : 		}
; 2433 : 
; 2434 : 	_Myt& operator=(_In_z_ const _Elem *_Ptr)
; 2435 : 		{	// replace with regular expression constructed from _Ptr
; 2436 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),
; 2437 : 			ECMAScript, random_access_iterator_tag());
; 2438 : 		return (*this);
; 2439 : 		}
; 2440 : 
; 2441 : 	template<class _STtraits,
; 2442 : 		class _STalloc>
; 2443 : 		_Myt& operator=(
; 2444 : 			const basic_string<_Elem, _STtraits, _STalloc>& _Str)
; 2445 : 		{	// replace with regular expression constructed from _Str
; 2446 : 		_Reset(_Str.begin(), _Str.end(),
; 2447 : 			ECMAScript, random_access_iterator_tag());
; 2448 : 		return (*this);
; 2449 : 		}
; 2450 : 
; 2451 : 	unsigned int _Loop_count() const
; 2452 : 		{	// return number of loops
; 2453 : 		return (_Rep != 0 ? _Rep->_Loops : 0);
; 2454 : 		}
; 2455 : 
; 2456 : 	unsigned int mark_count() const
; 2457 : 		{	// return number of capture groups
; 2458 : 		return (_Rep != 0 ? _Rep->_Marks - 1 : 0);
; 2459 : 		}
; 2460 : 
; 2461 : 	_Myt& assign(const _Myt& _Right)
; 2462 : 		{	// replace with copy of _Right
; 2463 :  #if _ENHANCED_REGEX_VISUALIZER
; 2464 : 		_Visualization = _Right._Visualization;
; 2465 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2466 : 
; 2467 : 		_Reset(_Right._Rep);
; 2468 : 		return (*this);
; 2469 : 		}
; 2470 : 
; 2471 : 	_Myt& assign(_In_z_ const _Elem *_Ptr,
; 2472 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2473 : 		{	// replace with regular expression constructed from _Ptr
; 2474 : 		return (assign(_Ptr, _RxTraits::length(_Ptr), _Flags));
; 2475 : 		}
; 2476 : 
; 2477 : 	_Myt& assign(_In_reads_(_Count) const _Elem *_Ptr, size_t _Count,
; 2478 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2479 : 		{	// replace with regular expression constructed from _Ptr, _Count
; 2480 : 		_Reset(_Ptr, _Ptr + _Count,
; 2481 : 			_Flags, random_access_iterator_tag());
; 2482 : 		return (*this);
; 2483 : 		}
; 2484 : 
; 2485 : 	template<class _STtraits,
; 2486 : 		class _STalloc>
; 2487 : 		_Myt& assign(
; 2488 : 			const basic_string<_Elem, _STtraits, _STalloc>& _Str,
; 2489 : 			flag_type _Flags = regex_constants::ECMAScript)
; 2490 : 		{	// replace with regular expression constructed from _Str
; 2491 : 		_Reset(_Str.begin(), _Str.end(),
; 2492 : 			_Flags, random_access_iterator_tag());
; 2493 : 		return (*this);
; 2494 : 		}
; 2495 : 
; 2496 : 	template<class _InIt>
; 2497 : 		_Myt& assign(_InIt _First, _InIt _Last,
; 2498 : 			flag_type _Flags = regex_constants::ECMAScript)
; 2499 : 		{	// replace with regular expression constructed from [_First, _Last)
; 2500 : 		_DEBUG_RANGE(_First, _Last);
; 2501 : 		_Reset(_First, _Last, _Flags, _Iter_cat_t<_InIt>());
; 2502 : 		return (*this);
; 2503 : 		}
; 2504 : 
; 2505 : 	flag_type flags() const
; 2506 : 		{	// return syntax option flags
; 2507 : 		return (_Rep ? _Rep->_Fl : (flag_type)0);
; 2508 : 		}
; 2509 : 
; 2510 : 	locale_type imbue(locale_type _Loc)
; 2511 : 		{	// clear regular expression and set locale to argument
; 2512 : 		_Tidy();
; 2513 : 		return (_Traits.imbue(_Loc));
; 2514 : 		}
; 2515 : 
; 2516 : 	locale_type getloc() const
; 2517 : 		{	// return copy of locale object
; 2518 : 		return (_Traits.getloc());
; 2519 : 		}
; 2520 : 
; 2521 : 	void swap(_Myt& _Right) _THROW0()
; 2522 : 		{	// exchange contents with _Right
; 2523 : 		_STD swap(_Rep, _Right._Rep);
; 2524 : 
; 2525 :  #if _ENHANCED_REGEX_VISUALIZER
; 2526 : 		_Visualization.swap(_Right._Visualization);
; 2527 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2528 : 		}
; 2529 : 
; 2530 : 	_Root_node *_Get() const
; 2531 : 		{	// return pointer to root node
; 2532 : 		return (_Rep);
; 2533 : 		}
; 2534 : 
; 2535 : 	bool _Empty() const
; 2536 : 		{	// test if empty
; 2537 : 		return (_Rep == 0);
; 2538 : 		}
; 2539 : 
; 2540 : 	const _RxTraits& _Get_traits() const
; 2541 : 		{	// return reference to traits
; 2542 : 		return (_Traits);
; 2543 : 		}
; 2544 : 
; 2545 : private:
; 2546 : 	_Root_node *_Rep;
; 2547 : 	_RxTraits _Traits;
; 2548 : 
; 2549 :  #if _ENHANCED_REGEX_VISUALIZER
; 2550 : 	basic_string<_Elem> _Visualization;
; 2551 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2552 : 
; 2553 : 	void _Tidy()
; 2554 : 		{	// free all storage
; 2555 : 		if (_Rep != 0 && _MT_DECR(
; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);
; 2558 : 		_Rep = 0;
; 2559 : 		}
; 2560 : 
; 2561 : 	template<class _InIt>
; 2562 : 		void _Reset(_InIt _First, _InIt _Last,
; 2563 : 			flag_type _Flags, input_iterator_tag)
; 2564 : 		{	// build regular expression from input iterators
; 2565 : 		basic_string<_Iter_value_t<_InIt>> _Str(_First, _Last);
; 2566 : 
; 2567 : 		_Reset(_Str.begin(), _Str.end(),
; 2568 : 			_Flags, forward_iterator_tag());
; 2569 : 		}
; 2570 : 
; 2571 : 	template<class _FwdIt>
; 2572 : 		void _Reset(_FwdIt _First, _FwdIt _Last,
; 2573 : 			flag_type _Flags, forward_iterator_tag)
; 2574 : 		{	// build regular expression from forward iterators
; 2575 :  #if _ENHANCED_REGEX_VISUALIZER
; 2576 : 		_Visualization.assign(_First, _Last);
; 2577 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2578 : 
; 2579 : 		_Parser<_FwdIt, _Elem, _RxTraits>
; 2580 : 			_Prs(_Traits, _First, _Last, _Flags);
; 2581 : 		_Root_node *_Rx = _Prs._Compile();
; 2582 : 		_Reset(_Rx);
; 2583 : 		}
; 2584 : 
; 2585 : 	void _Reset(_Root_node *_Rx)
; 2586 : 		{	// build regular expression holding root node _Rx
; 2587 : 		if (_Rx != 0)
; 2588 : 			_MT_INCR(reinterpret_cast<_Atomic_counter_t&>(_Rx->_Refs));
; 2589 : 		_Tidy();
; 2590 : 		_Rep = _Rx;
; 2591 : 		}
; 2592 : 	};
; 2593 : 
; 2594 : template<class _Elem,
; 2595 : 	class _RxTraits>
; 2596 : 	void swap(basic_regex<_Elem, _RxTraits>& _Left,
; 2597 : 		basic_regex<_Elem, _RxTraits>& _Right) _THROW0()
; 2598 : 	{	// exchange contents of _Left with _Right
; 2599 : 	_Left.swap(_Right);
; 2600 : 	}
; 2601 : 
; 2602 : template<class _BidIt,
; 2603 : 	class _Alloc>
; 2604 : 	void swap(match_results<_BidIt, _Alloc>& _Left,
; 2605 : 		match_results<_BidIt, _Alloc>& _Right) _THROW0()
; 2606 : 	{	// exchange contents of _Left with _Right
; 2607 : 	_Left.swap(_Right);
; 2608 : 	}
; 2609 : 
; 2610 : typedef basic_regex<char> regex;
; 2611 : typedef basic_regex<wchar_t> wregex;
; 2612 : typedef match_results<const char *> cmatch;
; 2613 : typedef match_results<const wchar_t *> wcmatch;
; 2614 : typedef match_results<string::const_iterator> smatch;
; 2615 : typedef match_results<wstring::const_iterator> wsmatch;
; 2616 : 
; 2617 : #define _Isdigit(x) ('0' <= (x) && (x) <= '9')
; 2618 : 
; 2619 : 	// TEMPLATE FUNCTION _Format_default
; 2620 : template<class _BidIt,
; 2621 : 	class _Alloc,
; 2622 : 	class _InIt,
; 2623 : 	class _OutIt> inline
; 2624 : 	_OutIt _Format_default(
; 2625 : 		const match_results<_BidIt, _Alloc>& _Match,
; 2626 : 		_OutIt _Out, _InIt _First, _InIt _Last,
; 2627 : 		regex_constants::match_flag_type)
; 2628 : 	{	// format with ECMAScript rules
; 2629 : 	while (_First != _Last)
; 2630 : 		{	// process one character or escape sequence
; 2631 : 		if (*_First != '$')
; 2632 : 			*_Out++ = *_First++;
; 2633 : 		else if (++_First == _Last)
; 2634 : 			*_Out++ = '$';	// preserve $ at end
; 2635 : 		else if (*_First == '$')
; 2636 : 			{	// replace $$
; 2637 : 			*_Out++ = '$';
; 2638 : 			++_First;
; 2639 : 			}
; 2640 : 		else if (*_First == '`')
; 2641 : 			{	// replace $`
; 2642 : 			_Out = _Copy_no_deprecate(_Match.prefix().first,
; 2643 : 				_Match.prefix().second, _Out);
; 2644 : 			++_First;
; 2645 : 			}
; 2646 : 		else if (*_First == '\'')
; 2647 : 			{	// replace $'
; 2648 : 			_Out = _Copy_no_deprecate(_Match.suffix().first,
; 2649 : 				_Match.suffix().second, _Out);
; 2650 : 			++_First;
; 2651 : 			}
; 2652 : 		else if (*_First == '&')
; 2653 : 			{	// replace $&
; 2654 : 			++_First;
; 2655 : 			if (_Match.size() != 0)
; 2656 : 				_Out = _Copy_no_deprecate(_Match._At(0).first,
; 2657 : 					_Match._At(0).second, _Out);
; 2658 : 			}
; 2659 : 		else if (_Isdigit(*_First))
; 2660 : 			{	// replace capture group descriptors $n, $nn
; 2661 : 			int n = *_First++ - '0';
; 2662 : 			const bool _Two_digits = _First != _Last && _Isdigit(*_First);
; 2663 : 			if (_Two_digits)
; 2664 : 				{	// process second digit
; 2665 : 				n *= 10;
; 2666 : 				n += *_First++ - '0';
; 2667 : 				}
; 2668 : 			if (n == 0)
; 2669 : 				{	// preserve $0, $00
; 2670 : 				*_Out++ = '$';
; 2671 : 				*_Out++ = '0';
; 2672 : 				if (_Two_digits)
; 2673 : 					*_Out++ = '0';
; 2674 : 				}
; 2675 : 			else if (n < (int)_Match.size())
; 2676 : 				_Out = _Copy_no_deprecate(_Match._At(n).first,
; 2677 : 					_Match._At(n).second, _Out);
; 2678 : 			}
; 2679 : 		else
; 2680 : 			{	// replace $x
; 2681 : 			*_Out++ = '$';
; 2682 : 			*_Out++ = *_First++;
; 2683 : 			}
; 2684 : 		}
; 2685 : 	return (_Out);
; 2686 : 	}
; 2687 : 
; 2688 : 	// TEMPLATE FUNCTION _Format_sed
; 2689 : template<class _BidIt,
; 2690 : 	class _Alloc,
; 2691 : 	class _InIt,
; 2692 : 	class _OutIt> inline
; 2693 : 	_OutIt _Format_sed(const match_results<_BidIt, _Alloc>& _Match,
; 2694 : 		_OutIt _Out, _InIt _First, _InIt _Last,
; 2695 : 		regex_constants::match_flag_type)
; 2696 : 	{	// format with sed rules
; 2697 : 	while (_First != _Last)
; 2698 : 		{	// process one character or escape sequence
; 2699 : 		if (*_First == '&')
; 2700 : 			{	// replace with full match
; 2701 : 			++_First;
; 2702 : 			if (_Match.size() != 0)
; 2703 : 				_Out = _Copy_no_deprecate(_Match._At(0).first,
; 2704 : 					_Match._At(0).second, _Out);
; 2705 : 			}
; 2706 : 		else if (*_First != '\\')
; 2707 : 			*_Out++ = *_First++;
; 2708 : 		else if (++_First == _Last)
; 2709 : 			;	// drop backslash at end
; 2710 : 		else if (_Isdigit(*_First))
; 2711 : 			{	// replace \n, including \0
; 2712 : 			int n = *_First++ - '0';
; 2713 : 			if (n < (int)_Match.size())
; 2714 : 				_Out = _Copy_no_deprecate(_Match._At(n).first,
; 2715 : 					_Match._At(n).second, _Out);
; 2716 : 			}
; 2717 : 		else
; 2718 : 			*_Out++ = *_First++;	// replace \x, including \\, \&
; 2719 : 		}
; 2720 : 	return (_Out);
; 2721 : 	}
; 2722 : 
; 2723 : #undef _Isdigit
; 2724 : 
; 2725 : 	// TEMPLATE FUNCTION _Regex_match1
; 2726 : template<class _BidIt,
; 2727 : 	class _Alloc,
; 2728 : 	class _Elem,
; 2729 : 	class _RxTraits,
; 2730 : 	class _It> inline
; 2731 : 	bool _Regex_match1(_It _First, _It _Last,
; 2732 : 		match_results<_BidIt, _Alloc> *_Matches,
; 2733 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2734 : 		regex_constants::match_flag_type _Flgs,
; 2735 : 		bool _Full)
; 2736 : 	{	// try to match regular expression to target text
; 2737 : 	if (_Re._Empty())
; 2738 : 		return (false);
; 2739 : 	_Matcher<_BidIt, _Elem, _RxTraits, _It> _Mx(_First, _Last,
; 2740 : 		_Re._Get_traits(), _Re._Get(), _Re.mark_count() + 1, _Re.flags(),
; 2741 : 			_Flgs);
; 2742 : 	return (_Mx._Match(_Matches, _Full));
; 2743 : 	}
; 2744 : 
; 2745 : 	// TEMPLATE FUNCTION regex_match
; 2746 : template<class _BidIt,
; 2747 : 	class _Alloc,
; 2748 : 	class _Elem,
; 2749 : 	class _RxTraits> inline
; 2750 : 	bool regex_match(_BidIt _First, _BidIt _Last,
; 2751 : 		match_results<_BidIt, _Alloc>& _Matches,
; 2752 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2753 : 		regex_constants::match_flag_type _Flgs =
; 2754 : 			regex_constants::match_default)
; 2755 : 	{	// try to match regular expression to target text
; 2756 : 	_DEBUG_RANGE(_First, _Last);
; 2757 : 	return (_Regex_match1(_First, _Last,
; 2758 : 		&_Matches, _Re, _Flgs, true));
; 2759 : 	}
; 2760 : 
; 2761 : template<class _BidIt,
; 2762 : 	class _Elem,
; 2763 : 	class _RxTraits> inline
; 2764 : 	bool regex_match(_BidIt _First, _BidIt _Last,
; 2765 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2766 : 		regex_constants::match_flag_type _Flgs =
; 2767 : 			regex_constants::match_default)
; 2768 : 	{	// try to match regular expression to target text
; 2769 : 	_DEBUG_RANGE(_First, _Last);
; 2770 : 	return (_Regex_match1(_Unchecked(_First), _Unchecked(_Last),
; 2771 : 		static_cast<match_results<decltype(_Unchecked(_First))> *>(0), _Re,
; 2772 : 			_Flgs | regex_constants::match_any, true));
; 2773 : 	}
; 2774 : 
; 2775 : template<class _Elem,
; 2776 : 	class _RxTraits> inline
; 2777 : 	bool regex_match(_In_z_ const _Elem *_Str,
; 2778 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2779 : 		regex_constants::match_flag_type _Flgs =
; 2780 : 			regex_constants::match_default)
; 2781 : 	{	// try to match regular expression to target text
; 2782 : 	const _Elem *_Last = _Str + char_traits<_Elem>::length(_Str);
; 2783 : 	return (_Regex_match1(_Str, _Last,
; 2784 : 		static_cast<match_results<const _Elem *> *>(0), _Re,
; 2785 : 			_Flgs | regex_constants::match_any, true));
; 2786 : 	}
; 2787 : 
; 2788 : template<class _Elem,
; 2789 : 	class _Alloc,
; 2790 : 	class _RxTraits> inline
; 2791 : 	bool regex_match(_In_z_ const _Elem *_Str,
; 2792 : 		match_results<const _Elem *, _Alloc>& _Matches,
; 2793 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2794 : 		regex_constants::match_flag_type _Flgs =
; 2795 : 			regex_constants::match_default)
; 2796 : 	{	// try to match regular expression to target text
; 2797 : 	const _Elem *_Last = _Str + char_traits<_Elem>::length(_Str);
; 2798 : 	return (_Regex_match1(_Str, _Last,
; 2799 : 		&_Matches, _Re, _Flgs, true));
; 2800 : 	}
; 2801 : 
; 2802 : template<class _StTraits,
; 2803 : 	class _StAlloc,
; 2804 : 	class _Alloc,
; 2805 : 	class _Elem,
; 2806 : 	class _RxTraits> inline
; 2807 : 	bool regex_match(
; 2808 : 		const basic_string<_Elem, _StTraits, _StAlloc>& _Str,
; 2809 : 		match_results<typename basic_string<_Elem, _StTraits, _StAlloc>::
; 2810 : 			const_iterator, _Alloc>& _Matches,
; 2811 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2812 : 		regex_constants::match_flag_type _Flgs =
; 2813 : 			regex_constants::match_default)
; 2814 : 	{	// try to match regular expression to target text
; 2815 : 	return (_Regex_match1(_Str.begin(), _Str.end(),
; 2816 : 		&_Matches, _Re, _Flgs, true));
; 2817 : 	}
; 2818 : 
; 2819 : template<class _StTraits,
; 2820 : 	class _StAlloc,
; 2821 : 	class _Alloc,
; 2822 : 	class _Elem,
; 2823 : 	class _RxTraits>
; 2824 : 	bool regex_match(
; 2825 : 		const basic_string<_Elem, _StTraits, _StAlloc>&&,
; 2826 : 		match_results<typename basic_string<_Elem, _StTraits, _StAlloc>::
; 2827 : 			const_iterator, _Alloc>&,
; 2828 : 		const basic_regex<_Elem, _RxTraits>&,
; 2829 : 		regex_constants::match_flag_type =
; 2830 : 			regex_constants::match_default) = delete;
; 2831 : 
; 2832 : template<class _StTraits,
; 2833 : 	class _StAlloc,
; 2834 : 	class _Elem,
; 2835 : 	class _RxTraits> inline
; 2836 : 	bool regex_match(
; 2837 : 		const basic_string<_Elem, _StTraits, _StAlloc>& _Str,
; 2838 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2839 : 		regex_constants::match_flag_type _Flgs =
; 2840 : 			regex_constants::match_default)
; 2841 : 	{	// try to match regular expression to target text
; 2842 : 	typedef typename basic_string<_Elem, _StTraits, _StAlloc>
; 2843 : 		::const_iterator _Iter;
; 2844 : 	return (_Regex_match1(_Unchecked(_Str.begin()), _Unchecked(_Str.end()),
; 2845 : 		static_cast<match_results<decltype(_Unchecked(_Str.begin()))> *>(0), _Re,
; 2846 : 			_Flgs | regex_constants::match_any, true));
; 2847 : 	}
; 2848 : 
; 2849 : 	// TEMPLATE FUNCTION _Regex_search1
; 2850 : template<class _BidIt,
; 2851 : 	class _Alloc,
; 2852 : 	class _Elem,
; 2853 : 	class _RxTraits,
; 2854 : 	class _It> inline
; 2855 : 	bool _Regex_search1(_It _First, _It _Last,
; 2856 : 		match_results<_BidIt, _Alloc> *_Matches,
; 2857 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2858 : 		regex_constants::match_flag_type _Flgs,
; 2859 : 		_It _Org)
; 2860 : 	{	// search for regular expression match in target text
; 2861 : 	if (_Re._Empty())
; 2862 : 		return (false);
; 2863 : 	bool _Found = false;
; 2864 : 	_It _Begin = _First;
; 2865 : 	_Matcher<_BidIt, _Elem, _RxTraits, _It> _Mx(_First, _Last,
; 2866 : 		_Re._Get_traits(), _Re._Get(), _Re.mark_count() + 1, _Re.flags(),
; 2867 : 			_Flgs);
; 2868 : 
; 2869 : 	if (_Mx._Match(_Matches, false))
; 2870 : 		_Found = true;
; 2871 : 	else if (_First == _Last
; 2872 : 		|| _Flgs & regex_constants::match_continuous)
; 2873 : 		;
; 2874 : 	else
; 2875 : 		{	// try more on suffixes
; 2876 : 		_Mx._Setf(regex_constants::match_prev_avail);
; 2877 : 		_Mx._Clearf(regex_constants::_Match_not_null);
; 2878 : 		while ((_First = _Mx._Skip(++_First, _Last)) != _Last)
; 2879 : 			if (_Mx._Match(_First, _Matches, false))
; 2880 : 				{	// found match starting at _First
; 2881 : 				_Found = true;
; 2882 : 				break;
; 2883 : 				}
; 2884 : 		if (!_Found && _Mx._Match(_Last, _Matches, false))
; 2885 : 			_Found = true;
; 2886 : 		}
; 2887 : 	if (_Found && _Matches)
; 2888 : 		{	// update _Matches
; 2889 : 		_Matches->_Org = _Org;
; 2890 : 		_Matches->_Pfx().first = _Begin;
; 2891 : 		_Matches->_Pfx().matched =
; 2892 : 			_Matches->_Pfx().first != _Matches->_Pfx().second;
; 2893 : 		}
; 2894 : 	return (_Found);
; 2895 : 	}
; 2896 : 
; 2897 : 	// TEMPLATE FUNCTION regex_search
; 2898 : template<class _BidIt,
; 2899 : 	class _Alloc,
; 2900 : 	class _Elem,
; 2901 : 	class _RxTraits> inline
; 2902 : 	bool regex_search(_BidIt _First, _BidIt _Last,
; 2903 : 		match_results<_BidIt, _Alloc>& _Matches,
; 2904 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2905 : 		regex_constants::match_flag_type _Flgs =
; 2906 : 			regex_constants::match_default)
; 2907 : 	{	// search for regular expression match in target text
; 2908 : 	_DEBUG_RANGE(_First, _Last);
; 2909 : 	return (_Regex_search1(_First, _Last, &_Matches, _Re, _Flgs, _First));
; 2910 : 	}
; 2911 : 
; 2912 : template<class _BidIt,
; 2913 : 	class _Elem,
; 2914 : 	class _RxTraits> inline
; 2915 : 	bool regex_search(_BidIt _First, _BidIt _Last,
; 2916 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2917 : 		regex_constants::match_flag_type _Flgs =
; 2918 : 			regex_constants::match_default)
; 2919 : 	{	// search for regular expression match in target text
; 2920 : 	_DEBUG_RANGE(_First, _Last);
; 2921 : 	return (_Regex_search1(_Unchecked(_First), _Unchecked(_Last),
; 2922 : 		static_cast<match_results<decltype(_Unchecked(_First))> *>(0), _Re,
; 2923 : 			_Flgs | regex_constants::match_any, _Unchecked(_First)));
; 2924 : 	}
; 2925 : 
; 2926 : template<class _Elem,
; 2927 : 	class _RxTraits> inline
; 2928 : 	bool regex_search(_In_z_ const _Elem *_Str,
; 2929 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2930 : 		regex_constants::match_flag_type _Flgs =
; 2931 : 			regex_constants::match_default)
; 2932 : 	{	// search for regular expression match in target text
; 2933 : 	const _Elem *_Last = _Str + char_traits<_Elem>::length(_Str);
; 2934 : 	return (_Regex_search1(_Str, _Last,
; 2935 : 		static_cast<match_results<const _Elem *> *>(0), _Re,
; 2936 : 			_Flgs | regex_constants::match_any, _Str));
; 2937 : 	}
; 2938 : 
; 2939 : template<class _Elem,
; 2940 : 	class _Alloc,
; 2941 : 	class _RxTraits> inline
; 2942 : 	bool regex_search(_In_z_ const _Elem *_Str,
; 2943 : 		match_results<const _Elem *, _Alloc>& _Matches,
; 2944 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2945 : 		regex_constants::match_flag_type _Flgs =
; 2946 : 			regex_constants::match_default)
; 2947 : 	{	// search for regular expression match in target text
; 2948 : 	const _Elem *_Last = _Str + char_traits<_Elem>::length(_Str);
; 2949 : 	return (_Regex_search1(_Str, _Last, &_Matches, _Re, _Flgs, _Str));
; 2950 : 	}
; 2951 : 
; 2952 : template<class _StTraits,
; 2953 : 	class _StAlloc,
; 2954 : 	class _Alloc,
; 2955 : 	class _Elem,
; 2956 : 	class _RxTraits> inline
; 2957 : 	bool regex_search(
; 2958 : 		const basic_string<_Elem, _StTraits, _StAlloc>& _Str,
; 2959 : 		match_results<typename basic_string<_Elem, _StTraits, _StAlloc>
; 2960 : 			::const_iterator, _Alloc>& _Matches,
; 2961 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2962 : 		regex_constants::match_flag_type _Flgs =
; 2963 : 			regex_constants::match_default)
; 2964 : 	{	// search for regular expression match in target text
; 2965 : 	return (_Regex_search1(_Str.begin(), _Str.end(),
; 2966 : 		&_Matches, _Re, _Flgs, _Str.begin()));
; 2967 : 	}
; 2968 : 
; 2969 : template<class _StTraits,
; 2970 : 	class _StAlloc,
; 2971 : 	class _Alloc,
; 2972 : 	class _Elem,
; 2973 : 	class _RxTraits>
; 2974 : 	bool regex_search(
; 2975 : 		const basic_string<_Elem, _StTraits, _StAlloc>&&,
; 2976 : 		match_results<typename basic_string<_Elem, _StTraits, _StAlloc>
; 2977 : 			::const_iterator, _Alloc>&,
; 2978 : 		const basic_regex<_Elem, _RxTraits>&,
; 2979 : 		regex_constants::match_flag_type =
; 2980 : 			regex_constants::match_default) = delete;
; 2981 : 
; 2982 : template<class _StTraits,
; 2983 : 	class _StAlloc,
; 2984 : 	class _Elem,
; 2985 : 	class _RxTraits> inline
; 2986 : 	bool regex_search(
; 2987 : 		const basic_string<_Elem, _StTraits, _StAlloc>& _Str,
; 2988 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2989 : 		regex_constants::match_flag_type _Flgs =
; 2990 : 			regex_constants::match_default)
; 2991 : 	{	// search for regular expression match in target text
; 2992 : 	typedef typename basic_string<_Elem, _StTraits, _StAlloc>
; 2993 : 		::const_pointer _Iter;
; 2994 : 
; 2995 : 	_Iter _First = _Str.c_str();
; 2996 : 	_Iter _Last = _First + _Str.size();
; 2997 : 	return (_Regex_search1(_First, _Last,
; 2998 : 		static_cast<match_results<_Iter> *>(0), _Re,
; 2999 : 			_Flgs | regex_constants::match_any, _First));
; 3000 : 	}
; 3001 : 
; 3002 : 	// TEMPLATE FUNCTION regex_replace
; 3003 : template<class _OutIt,
; 3004 : 	class _BidIt,
; 3005 : 	class _RxTraits,
; 3006 : 	class _Elem,
; 3007 : 	class _Traits,
; 3008 : 	class _Alloc> inline
; 3009 : 	_OutIt _Regex_replace1(_OutIt _Result,
; 3010 : 		_BidIt _First, _BidIt _Last,
; 3011 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3012 : 		const basic_string<_Elem, _Traits, _Alloc>& _Fmt,
; 3013 : 		regex_constants::match_flag_type _Flgs)
; 3014 : 	{	// search and replace
; 3015 : 	match_results<_BidIt> _Matches;
; 3016 : 	_BidIt _Pos = _First;
; 3017 : 	regex_constants::match_flag_type _Flags = _Flgs;
; 3018 : 	regex_constants::match_flag_type _Not_null =
; 3019 : 		(regex_constants::match_flag_type)0;
; 3020 : 
; 3021 : 	while (_Regex_search1(_Pos, _Last, &_Matches, _Re, _Flags | _Not_null, _Pos))
; 3022 : 		{	// replace at each match
; 3023 : 		if (!(_Flgs & regex_constants::format_no_copy))
; 3024 : 			_Result = _Copy_no_deprecate(_Matches.prefix().first,
; 3025 : 				_Matches.prefix().second, _Result);
; 3026 : 		_Result = _Matches._Format1(_Result,
; 3027 : 			_Unchecked(_Fmt.begin()), _Unchecked(_Fmt.end()), _Flags);
; 3028 : 
; 3029 : 		_Pos = _Matches[0].second;
; 3030 : 		if (_Pos == _Last
; 3031 : 			|| _Flgs & regex_constants::format_first_only)
; 3032 : 			break;
; 3033 : 
; 3034 : 		if (_Matches[0].first == _Matches[0].second)
; 3035 : 			_Not_null = regex_constants::_Match_not_null;
; 3036 : 		else
; 3037 : 			{	// non-null match, recognize earlier text
; 3038 : 			_Not_null = (regex_constants::match_flag_type)0;
; 3039 : 			_Flags |= regex_constants::match_prev_avail;
; 3040 : 			}
; 3041 : 		}
; 3042 : 	return (_Flgs & regex_constants::format_no_copy
; 3043 : 		? _Result : _Copy_no_deprecate(_Pos, _Last, _Result));
; 3044 : 	}
; 3045 : 
; 3046 : template<class _OutIt,
; 3047 : 	class _BidIt,
; 3048 : 	class _RxTraits,
; 3049 : 	class _Elem,
; 3050 : 	class _Traits,
; 3051 : 	class _Alloc> inline
; 3052 : 	_OutIt regex_replace(_OutIt _Result,
; 3053 : 		_BidIt _First, _BidIt _Last,
; 3054 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3055 : 		const basic_string<_Elem, _Traits, _Alloc>& _Fmt,
; 3056 : 		regex_constants::match_flag_type _Flgs =
; 3057 : 			regex_constants::match_default)
; 3058 : 	{	// search and replace, iterator result, string format
; 3059 : 	_DEPRECATE_UNCHECKED(regex_replace, _Result);
; 3060 : 	_DEBUG_RANGE(_First, _Last);
; 3061 : 	return (_Rechecked(_Result,
; 3062 : 		_Regex_replace1(_Unchecked_idl0(_Result), _Unchecked(_First), _Unchecked(_Last),
; 3063 : 		_Re, _Fmt, _Flgs)));
; 3064 : 	}
; 3065 : 
; 3066 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 3067 : template<class _OutTy,
; 3068 : 	size_t _OutSize,
; 3069 : 	class _BidIt,
; 3070 : 	class _RxTraits,
; 3071 : 	class _Elem,
; 3072 : 	class _Traits,
; 3073 : 	class _Alloc> inline
; 3074 : 	_OutTy *regex_replace(_OutTy (&_Result)[_OutSize],
; 3075 : 		_BidIt _First, _BidIt _Last,
; 3076 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3077 : 		const basic_string<_Elem, _Traits, _Alloc>& _Fmt,
; 3078 : 		regex_constants::match_flag_type _Flgs =
; 3079 : 			regex_constants::match_default)
; 3080 : 	{	// search and replace, array result, string format
; 3081 : 	return (_Unchecked(_STD regex_replace(
; 3082 : 		_Array_iterator<_OutTy, _OutSize>(_Result),
; 3083 : 		_First, _Last, _Re, _Fmt, _Flgs)));
; 3084 : 	}
; 3085 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 3086 : 
; 3087 : template<class _OutIt,
; 3088 : 	class _BidIt,
; 3089 : 	class _RxTraits,
; 3090 : 	class _Elem> inline
; 3091 : 	_OutIt regex_replace(_OutIt _Result,
; 3092 : 		_BidIt _First, _BidIt _Last,
; 3093 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3094 : 		const _Elem *_Ptr,
; 3095 : 		regex_constants::match_flag_type _Flgs =
; 3096 : 			regex_constants::match_default)
; 3097 : 	{	// search and replace, iterator result, NTBS format
; 3098 : 	const basic_string<_Elem> _Fmt(_Ptr);
; 3099 : 	return (_STD regex_replace(_Result,
; 3100 : 		_First, _Last, _Re, _Fmt, _Flgs));
; 3101 : 	}
; 3102 : 
; 3103 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 3104 : template<class _OutTy,
; 3105 : 	size_t _OutSize,
; 3106 : 	class _BidIt,
; 3107 : 	class _RxTraits,
; 3108 : 	class _Elem> inline
; 3109 : 	_OutTy *regex_replace(_OutTy (&_Result)[_OutSize],
; 3110 : 		_BidIt _First, _BidIt _Last,
; 3111 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3112 : 		const _Elem *_Ptr,
; 3113 : 		regex_constants::match_flag_type _Flgs =
; 3114 : 			regex_constants::match_default)
; 3115 : 	{	// search and replace, array result, NTBS format
; 3116 : 	const basic_string<_Elem> _Fmt(_Ptr);
; 3117 : 	return (_STD regex_replace(_Result,
; 3118 : 		_First, _Last, _Re, _Fmt, _Flgs));
; 3119 : 	}
; 3120 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 3121 : 
; 3122 : template<class _RxTraits,
; 3123 : 	class _Elem,
; 3124 : 	class _Traits1,
; 3125 : 	class _Alloc1,
; 3126 : 	class _Traits2,
; 3127 : 	class _Alloc2>
; 3128 : 	basic_string<_Elem, _Traits1, _Alloc1> regex_replace(
; 3129 : 		const basic_string<_Elem, _Traits1, _Alloc1>& _Str,
; 3130 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3131 : 		const basic_string<_Elem, _Traits2, _Alloc2>& _Fmt,
; 3132 : 		regex_constants::match_flag_type _Flgs =
; 3133 : 			regex_constants::match_default)
; 3134 : 	{	// search and replace, string result, string target, string format
; 3135 : 	basic_string<_Elem, _Traits1, _Alloc1> _Res;
; 3136 : 	_STD regex_replace(_STD back_inserter(_Res), _Str.begin(), _Str.end(),
; 3137 : 		_Re, _Fmt, _Flgs);
; 3138 : 	return (_Res);
; 3139 : 	}
; 3140 : 
; 3141 : template<class _RxTraits,
; 3142 : 	class _Elem,
; 3143 : 	class _Traits1,
; 3144 : 	class _Alloc1>
; 3145 : 	basic_string<_Elem, _Traits1, _Alloc1> regex_replace(
; 3146 : 		const basic_string<_Elem, _Traits1, _Alloc1>& _Str,
; 3147 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3148 : 		const _Elem *_Ptr,
; 3149 : 		regex_constants::match_flag_type _Flgs =
; 3150 : 			regex_constants::match_default)
; 3151 : 	{	// search and replace, string result, string target, NTBS format
; 3152 : 	basic_string<_Elem, _Traits1, _Alloc1> _Res;
; 3153 : 	const basic_string<_Elem> _Fmt(_Ptr);
; 3154 : 	_STD regex_replace(_STD back_inserter(_Res), _Str.begin(), _Str.end(),
; 3155 : 		_Re, _Fmt, _Flgs);
; 3156 : 	return (_Res);
; 3157 : 	}
; 3158 : 
; 3159 : template<class _RxTraits,
; 3160 : 	class _Elem,
; 3161 : 	class _Traits2,
; 3162 : 	class _Alloc2>
; 3163 : 	basic_string<_Elem> regex_replace(
; 3164 : 		const _Elem *_Pstr,
; 3165 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3166 : 		const basic_string<_Elem, _Traits2, _Alloc2>& _Fmt,
; 3167 : 		regex_constants::match_flag_type _Flgs =
; 3168 : 			regex_constants::match_default)
; 3169 : 	{	// search and replace, string result, NTBS target, string format
; 3170 : 	basic_string<_Elem> _Res;
; 3171 : 	const basic_string<_Elem> _Str(_Pstr);
; 3172 : 	_STD regex_replace(_STD back_inserter(_Res), _Str.begin(), _Str.end(),
; 3173 : 		_Re, _Fmt, _Flgs);
; 3174 : 	return (_Res);
; 3175 : 	}
; 3176 : 
; 3177 : template<class _RxTraits,
; 3178 : 	class _Elem>
; 3179 : 	basic_string<_Elem> regex_replace(
; 3180 : 		const _Elem *_Pstr,
; 3181 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3182 : 		const _Elem *_Ptr,
; 3183 : 		regex_constants::match_flag_type _Flgs =
; 3184 : 			regex_constants::match_default)
; 3185 : 	{	// search and replace, string result, NTBS target, NTBS format
; 3186 : 	basic_string<_Elem> _Res;
; 3187 : 	const basic_string<_Elem> _Str(_Pstr);
; 3188 : 	const basic_string<_Elem> _Fmt(_Ptr);
; 3189 : 	_STD regex_replace(_STD back_inserter(_Res), _Str.begin(), _Str.end(),
; 3190 : 		_Re, _Fmt, _Flgs);
; 3191 : 	return (_Res);
; 3192 : 	}
; 3193 : 
; 3194 : 	// TEMPLATE CLASS regex_iterator
; 3195 : template<class _BidIt,
; 3196 : 	class _Elem = _Iter_value_t<_BidIt>,
; 3197 : 	class _RxTraits = regex_traits<_Elem> >
; 3198 : 	class regex_iterator
; 3199 : 		: public _Iterator012<forward_iterator_tag,
; 3200 : 			match_results<_BidIt>,
; 3201 : 			ptrdiff_t,
; 3202 : 			match_results<_BidIt> *,
; 3203 : 			match_results<_BidIt>&,
; 3204 : 			_Iterator_base>
; 3205 : 	{	// iterator for full regular expression matches
; 3206 : public:
; 3207 : 	typedef regex_iterator<_BidIt, _Elem, _RxTraits> _Myt;
; 3208 : 	typedef basic_regex<_Elem, _RxTraits> regex_type;
; 3209 : 	typedef match_results<_BidIt> value_type;
; 3210 : 	typedef ptrdiff_t difference_type;
; 3211 : 	typedef const value_type *pointer;
; 3212 : 	typedef const value_type& reference;
; 3213 : 	typedef forward_iterator_tag iterator_category;
; 3214 : 
; 3215 : 	regex_iterator()
; 3216 : 		: _MyRe(0)
; 3217 : 		{	// construct end of sequence iterator
; 3218 : 		}
; 3219 : 
; 3220 : 	regex_iterator(_BidIt _First, _BidIt _Last,
; 3221 : 		const regex_type& _Re,
; 3222 : 		regex_constants::match_flag_type _Fl =
; 3223 : 			regex_constants::match_default)
; 3224 : 		: _Begin(_First), _End(_Last), _MyRe(&_Re), _Flags(_Fl)
; 3225 : 		{	// construct from regular expression and target text
; 3226 : 		_DEBUG_RANGE(_Begin, _End);
; 3227 : 		if (!_Regex_search1(_Begin, _End, &_MyVal, *_MyRe, _Flags, _Begin))
; 3228 : 			_MyRe = 0;
; 3229 : 		else
; 3230 : 			this->_Adopt(_MyRe);
; 3231 : 		}
; 3232 : 
; 3233 : 	regex_iterator(_BidIt, _BidIt,
; 3234 : 		const regex_type&&,
; 3235 : 		regex_constants::match_flag_type =
; 3236 : 			regex_constants::match_default) = delete;
; 3237 : 
; 3238 : 	bool operator==(const _Myt& _Right) const
; 3239 : 		{	// test for equality
; 3240 : 		if (_MyRe != _Right._MyRe)
; 3241 : 			return (false);
; 3242 : 		else if (_MyRe == 0)
; 3243 : 			return (true);
; 3244 : 		return (_Begin == _Right._Begin
; 3245 : 			&& _End == _Right._End
; 3246 : 			&& _Flags == _Right._Flags
; 3247 : 			&& _MyVal._At(0) == _Right._MyVal._At(0));
; 3248 : 		}
; 3249 : 
; 3250 : 	bool operator!=(const _Myt& _Right) const
; 3251 : 		{	// test for inequality
; 3252 : 		return (!(*this == _Right));
; 3253 : 		}
; 3254 : 
; 3255 : 	const value_type& operator*() const
; 3256 : 		{	// return designated match
; 3257 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3258 : 		if (_MyRe == 0)
; 3259 : 			{	// report error
; 3260 : 			_DEBUG_ERROR("regex_iterator not dereferencable");
; 3261 : 			}
; 3262 : 
; 3263 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3264 : 		_SCL_SECURE_VALIDATE_RANGE(_MyRe != 0);
; 3265 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3266 : 
; 3267 : 		return (_MyVal);
; 3268 : 		}
; 3269 : 
; 3270 : 	pointer operator->() const
; 3271 : 		{	// return pointer to designated match
; 3272 : 		return (pointer_traits<pointer>::pointer_to(**this));
; 3273 : 		}
; 3274 : 
; 3275 : 	_Myt& operator++()
; 3276 : 		{	// preincrement
; 3277 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3278 : 		if (_MyRe == 0)
; 3279 : 			{	// report error
; 3280 : 			_DEBUG_ERROR("regex_iterator not incrementable");
; 3281 : 			}
; 3282 : 
; 3283 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3284 : 		_SCL_SECURE_VALIDATE_RANGE(_MyRe != 0);
; 3285 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3286 : 
; 3287 : 		if (_MyRe == 0)
; 3288 : 			return (*this);
; 3289 : 
; 3290 : 		_BidIt _Start = _MyVal._At(0).second;
; 3291 : 
; 3292 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3293 : 		if (this->_Getcont() == 0)
; 3294 : 			{	// report error
; 3295 : 			_DEBUG_ERROR("regex_iterator orphaned");
; 3296 : 			}
; 3297 : 
; 3298 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3299 : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 3300 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3301 : 
; 3302 : 		if (_MyVal._At(0).first == _MyVal._At(0).second)
; 3303 : 			{	// handle zero-length match
; 3304 : 			if (_Start == _End)
; 3305 : 				{	// store end-of-sequence iterator
; 3306 : 				_MyRe = 0;
; 3307 : 
; 3308 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3309 : 		this->_Orphan_me();
; 3310 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3311 : 
; 3312 : 				return (*this);
; 3313 : 				}
; 3314 : 
; 3315 : 			// _DEBUG_RANGE(_Start, _End) checked in constructor
; 3316 : 			if (_Regex_search1(_Start, _End, &_MyVal, *_MyRe,
; 3317 : 				_Flags | regex_constants::match_not_null
; 3318 : 					| regex_constants::match_continuous,
; 3319 : 				_Begin))
; 3320 : 				return (*this);
; 3321 : 			++_Start;
; 3322 : 			}
; 3323 : 		_Flags = _Flags | regex_constants::match_prev_avail;
; 3324 : 
; 3325 : 		// _DEBUG_RANGE(_Start, _End) checked in constructor
; 3326 : 		if (_Regex_search1(_Start, _End, &_MyVal, *_MyRe, _Flags, _Begin))
; 3327 : 			return (*this);
; 3328 : 		else
; 3329 : 			{	// mark at end of sequence
; 3330 : 			_MyRe = 0;
; 3331 : 			return (*this);
; 3332 : 			}
; 3333 : 		}
; 3334 : 
; 3335 : 	_Myt operator++(int)
; 3336 : 		{	// postincrement
; 3337 : 		_Myt _Tmp = *this;
; 3338 : 		++*this;
; 3339 : 		return (_Tmp);
; 3340 : 		}
; 3341 : 
; 3342 : 	bool _Atend() const
; 3343 : 		{	// test for end iterator
; 3344 : 		return (_MyRe == 0);
; 3345 : 		}
; 3346 : 
; 3347 : private:
; 3348 : 	_BidIt _Begin, _End;			// input sequence
; 3349 : 	const regex_type *_MyRe;		// pointer to basic_regex object
; 3350 : 	regex_constants::match_flag_type _Flags;
; 3351 : 	match_results<_BidIt> _MyVal;	// lookahead value (if _MyRe not null)
; 3352 : 	};
; 3353 : 
; 3354 : typedef regex_iterator<const char *> cregex_iterator;
; 3355 : typedef regex_iterator<const wchar_t *> wcregex_iterator;
; 3356 : typedef regex_iterator<string::const_iterator> sregex_iterator;
; 3357 : typedef regex_iterator<wstring::const_iterator> wsregex_iterator;
; 3358 : 
; 3359 : 	// TEMPLATE CLASS regex_token_iterator
; 3360 : template<class _BidIt,
; 3361 : 	class _Elem = _Iter_value_t<_BidIt>,
; 3362 : 	class _RxTraits = regex_traits<_Elem> >
; 3363 : class regex_token_iterator
; 3364 : 	{	// iterator for regular expression submatches
; 3365 : public:
; 3366 : 	typedef regex_iterator<_BidIt, _Elem, _RxTraits> _Position;
; 3367 : 	typedef regex_token_iterator<_BidIt, _Elem, _RxTraits> _Myt;
; 3368 : 	typedef basic_regex<_Elem, _RxTraits> regex_type;
; 3369 : 	typedef sub_match<_BidIt> value_type;
; 3370 : 	typedef ptrdiff_t difference_type;
; 3371 : 	typedef const value_type *pointer;
; 3372 : 	typedef const value_type &reference;
; 3373 : 	typedef forward_iterator_tag iterator_category;
; 3374 : 
; 3375 : 	regex_token_iterator()
; 3376 : 		: _Res(0)
; 3377 : 		{	// construct end of sequence iterator
; 3378 : 		}
; 3379 : 
; 3380 : 	regex_token_iterator(_BidIt _First, _BidIt _Last,
; 3381 : 		const regex_type& _Re, int _Sub = 0,
; 3382 : 		regex_constants::match_flag_type _Fl =
; 3383 : 			regex_constants::match_default)
; 3384 : 		: _Pos(_First, _Last, _Re, _Fl), _Cur(0), _Subs(&_Sub, &_Sub + 1)
; 3385 : 		{	// construct from RE, target text, and single submatch specifier
; 3386 : 		_Init(_First, _Last);
; 3387 : 		}
; 3388 : 
; 3389 : 	regex_token_iterator(_BidIt _First, _BidIt _Last,
; 3390 : 		const regex_type& _Re, const vector<int>& _Subx,
; 3391 : 		regex_constants::match_flag_type _Fl =
; 3392 : 			regex_constants::match_default)
; 3393 : 		: _Pos(_First, _Last, _Re, _Fl), _Cur(0),
; 3394 : 			_Subs(_Subx.begin(), _Subx.end())
; 3395 : 		{	// construct from RE, target text, and vector submatch specifier
; 3396 : 		if (_Subs.empty())
; 3397 : 			_Res = 0;	// treat empty vector as end of sequence
; 3398 : 		else
; 3399 : 			_Init(_First, _Last);
; 3400 : 		}
; 3401 : 
; 3402 : 	template<size_t _Nx>
; 3403 : 		regex_token_iterator(_BidIt _First, _BidIt _Last,
; 3404 : 			const regex_type& _Re,
; 3405 : 			const int (&_Subx)[_Nx],
; 3406 : 			regex_constants::match_flag_type _Fl =
; 3407 : 				regex_constants::match_default)
; 3408 : 		: _Pos(_First, _Last, _Re, _Fl), _Cur(0),
; 3409 : 			_Subs(_Subx, _Subx + _Nx)
; 3410 : 		{	// construct from RE, target text, and array submatch specifier
; 3411 : 		_Init(_First, _Last);
; 3412 : 		}
; 3413 : 
; 3414 : 	regex_token_iterator(_BidIt _First, _BidIt _Last,
; 3415 : 		const regex_type& _Re,
; 3416 : 		initializer_list<int> _Ilist,
; 3417 : 		regex_constants::match_flag_type _Fl =
; 3418 : 			regex_constants::match_default)
; 3419 : 		: _Pos(_First, _Last, _Re, _Fl), _Cur(0),
; 3420 : 			_Subs(_Ilist.begin(), _Ilist.end())
; 3421 : 		{	// construct from RE, target text, and ilist submatch specifier
; 3422 : 		_Init(_First, _Last);
; 3423 : 		}
; 3424 : 
; 3425 : 	regex_token_iterator(_BidIt, _BidIt,
; 3426 : 		const regex_type&&, int = 0,
; 3427 : 		regex_constants::match_flag_type =
; 3428 : 			regex_constants::match_default) = delete;
; 3429 : 
; 3430 : 	regex_token_iterator(_BidIt, _BidIt,
; 3431 : 		const regex_type&&, const vector<int>&,
; 3432 : 		regex_constants::match_flag_type =
; 3433 : 			regex_constants::match_default) = delete;
; 3434 : 
; 3435 : 	template<size_t _Nx>
; 3436 : 		regex_token_iterator(_BidIt, _BidIt,
; 3437 : 			const regex_type&&,
; 3438 : 			const int (&)[_Nx],
; 3439 : 			regex_constants::match_flag_type =
; 3440 : 				regex_constants::match_default) = delete;
; 3441 : 
; 3442 : 	regex_token_iterator(_BidIt, _BidIt,
; 3443 : 		const regex_type&&,
; 3444 : 		initializer_list<int>,
; 3445 : 		regex_constants::match_flag_type =
; 3446 : 			regex_constants::match_default) = delete;
; 3447 : 
; 3448 : 	regex_token_iterator(const regex_token_iterator& _Right)
; 3449 : 		: _Pos(_Right._Pos), _Cur(_Right._Cur),
; 3450 : 			_Suffix(_Right._Suffix), _Subs(_Right._Subs)
; 3451 : 		{	// construct copy of _Right
; 3452 : 		if (_Right._Res == 0)
; 3453 : 			_Res = 0;
; 3454 : 		else if (_Right._Res == &_Right._Suffix)
; 3455 : 			_Res = &_Suffix;
; 3456 : 		else
; 3457 : 			_Res = _Current();
; 3458 : 		}
; 3459 : 
; 3460 : 	regex_token_iterator& operator=(const regex_token_iterator& _Right)
; 3461 : 		{	// assign from _Right
; 3462 : 		if (this != _STD addressof(_Right))
; 3463 : 			{	// copy from _Right
; 3464 : 			_Pos = _Right._Pos;
; 3465 : 			_Cur = _Right._Cur;
; 3466 : 			_Suffix = _Right._Suffix;
; 3467 : 			_Subs = _Right._Subs;
; 3468 : 			if (_Right._Res == 0)
; 3469 : 				_Res = 0;
; 3470 : 			else if (_Right._Res == &_Right._Suffix)
; 3471 : 				_Res = &_Suffix;
; 3472 : 			else
; 3473 : 				_Res = _Current();
; 3474 : 			}
; 3475 : 		return (*this);
; 3476 : 		}
; 3477 : 
; 3478 : 	bool operator==(const _Myt& _Right) const
; 3479 : 		{	// test for equality
; 3480 : 		if (_Res == 0 || _Right._Res == 0)
; 3481 : 			return (_Res == _Right._Res);
; 3482 : 		else if (*_Res == *_Right._Res
; 3483 : 			&& _Pos == _Right._Pos
; 3484 : 			&& _Subs == _Right._Subs)
; 3485 : 			return (true);
; 3486 : 		else
; 3487 : 			return (false);
; 3488 : 		}
; 3489 : 
; 3490 : 	bool operator!=(const _Myt& _Right) const
; 3491 : 		{	// test for inequality
; 3492 : 		return (!(*this == _Right));
; 3493 : 		}
; 3494 : 
; 3495 : 	const value_type& operator*() const
; 3496 : 		{	// return designated submatch
; 3497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3498 : 		if (_Res == 0)
; 3499 : 			{	// report error
; 3500 : 			_DEBUG_ERROR("regex_token_iterator not dereferencable");
; 3501 : 			}
; 3502 : 
; 3503 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3504 : 		_SCL_SECURE_VALIDATE_RANGE(_Res != 0);
; 3505 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3506 : 
; 3507 : 		_Analysis_assume_(_Res != 0);
; 3508 : 
; 3509 : 		return (*_Res);
; 3510 : 		}
; 3511 : 
; 3512 : 	pointer operator->() const
; 3513 : 		{	// return pointer to designated submatch
; 3514 : 		return (pointer_traits<pointer>::pointer_to(**this));
; 3515 : 		}
; 3516 : 
; 3517 : 	_Myt& operator++()
; 3518 : 		{	// preincrement
; 3519 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3520 : 		if (_Res == 0)
; 3521 : 			{	// report error
; 3522 : 			_DEBUG_ERROR("regex_token_iterator not incrementable");
; 3523 : 			}
; 3524 : 
; 3525 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3526 : 		_SCL_SECURE_VALIDATE_RANGE(_Res != 0);
; 3527 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3528 : 
; 3529 : 		_Position _Prev(_Pos);
; 3530 : 		if (_Res == 0)
; 3531 : 			;
; 3532 : 		else if (_Res == &_Suffix)
; 3533 : 			_Res = 0;
; 3534 : 		else if (++_Cur < _Subs.size())
; 3535 : 			_Res = _Current();
; 3536 : 		else
; 3537 : 			{	// advance to next full match
; 3538 : 			_Cur = 0;
; 3539 : 			++_Pos;
; 3540 : 			if (!_Pos._Atend())
; 3541 : 				_Res = _Current();
; 3542 : 			else if (_Has_suffix() && _Prev->suffix().length() != 0)
; 3543 : 				{	// mark suffix
; 3544 : 				_Suffix.matched = true;
; 3545 : 				_Suffix.first = _Prev->suffix().first;
; 3546 : 				_Suffix.second = _Prev->suffix().second;
; 3547 : 				_Res = &_Suffix;
; 3548 : 				}
; 3549 : 			else
; 3550 : 				_Res = 0;
; 3551 : 			}
; 3552 : 		return (*this);
; 3553 : 		}
; 3554 : 
; 3555 : 	_Myt operator++(int)
; 3556 : 		{	// postincrement
; 3557 : 		_Myt _Tmp = *this;
; 3558 : 		++*this;
; 3559 : 		return (_Tmp);
; 3560 : 		}
; 3561 : 
; 3562 : private:
; 3563 : 	_Position _Pos;
; 3564 : 	const value_type *_Res;
; 3565 : 	value_type _Suffix;
; 3566 : 	size_t _Cur;
; 3567 : 	vector<int> _Subs;
; 3568 : 
; 3569 : 	bool _Has_suffix() const
; 3570 : 		{	// check for suffix specifier
; 3571 : 		return (_STD find(_Subs.begin(), _Subs.end(), -1) != _Subs.end());
; 3572 : 		}
; 3573 : 
; 3574 : 	void _Init(_BidIt _First, _BidIt _Last)
; 3575 : 		{	// initialize
; 3576 : 		_DEBUG_RANGE(_First, _Last);
; 3577 : 		if (!_Pos._Atend())
; 3578 : 			_Res = _Current();
; 3579 : 		else if (_Has_suffix())
; 3580 : 			{	// mark suffix (no match)
; 3581 : 			_Suffix.matched = true;
; 3582 : 			_Suffix.first = _First;
; 3583 : 			_Suffix.second = _Last;
; 3584 : 			_Res = &_Suffix;
; 3585 : 			}
; 3586 : 		else
; 3587 : 			_Res = 0;
; 3588 : 		}
; 3589 : 
; 3590 : 	const value_type *_Current() const
; 3591 : 		{	// return pointer to current submatch
; 3592 : 		return (&(_Subs[_Cur] == -1
; 3593 : 			? _Pos->prefix() : (*_Pos)[_Subs[_Cur]]));
; 3594 : 		}
; 3595 : 	};
; 3596 : 
; 3597 : typedef regex_token_iterator<const char *> cregex_token_iterator;
; 3598 : typedef regex_token_iterator<const wchar_t *> wcregex_token_iterator;
; 3599 : typedef regex_token_iterator<string::const_iterator> sregex_token_iterator;
; 3600 : typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
; 3601 : 
; 3602 : 	// IMPLEMENTATION OF _Builder
; 3603 : template<class _FwdIt,
; 3604 : 	class _Elem,
; 3605 : 	class _RxTraits> inline
; 3606 : 	_Builder<_FwdIt, _Elem, _RxTraits>::_Builder(
; 3607 : 		const _RxTraits& _Tr,
; 3608 : 		regex_constants::syntax_option_type _Fx)
; 3609 : 	: _Root(new _Root_node),

	push	36					; 00000024H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN3@Builder

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [eax+4], 20			; 00000014H
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0

; 1710 : 		{	// construct

	mov	DWORD PTR [eax], OFFSET ??_7_Root_node@std@@6B@
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0

; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)
; 1728 : 		{	// construct
; 1729 : 		}
; 1730 : 
; 1731 : 	_Node_base *_Back;
; 1732 : 	};
; 1733 : 
; 1734 : 	// CLASS _Node_assert
; 1735 : class _Node_assert
; 1736 : 	: public _Node_base
; 1737 : 	{	// node that holds an ECMAScript assertion
; 1738 : public:
; 1739 : 	_Node_assert(_Node_type _Ty, _Node_flags _Fl = _Fl_none)
; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)
; 1741 : 		{	// construct
; 1742 : 		}
; 1743 : 
; 1744 : 	~_Node_assert() _NOEXCEPT
; 1745 : 		{	// destroy branch
; 1746 : 		_Destroy_node(_Child);
; 1747 : 		}
; 1748 : 
; 1749 : 	_Node_base *_Child;
; 1750 : 	};
; 1751 : 
; 1752 : 	// TEMPLATE CLASS _Node_capture
; 1753 : class _Node_capture
; 1754 : 	: public _Node_base
; 1755 : 	{	// node that marks beginning of a capture group
; 1756 : public:
; 1757 : 	_Node_capture(unsigned int _Ix)
; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)
; 1759 : 		{	// construct
; 1760 : 		}
; 1761 : 
; 1762 : 	unsigned int _Idx;
; 1763 : 	};
; 1764 : 
; 1765 : 	// CLASS _Node_back
; 1766 : class _Node_back
; 1767 : 	: public _Node_base
; 1768 : 	{	// node that holds a back reference
; 1769 : public:
; 1770 : 	_Node_back(unsigned int _Ix)
; 1771 : 		: _Node_base(_N_back, _Fl_none), _Idx(_Ix)
; 1772 : 		{	// construct
; 1773 : 		}
; 1774 : 
; 1775 : 	unsigned int _Idx;
; 1776 : 	};
; 1777 : 
; 1778 : 	// TEMPLATE CLASS _Node_str
; 1779 : template<class _Elem>
; 1780 : 	class _Node_str
; 1781 : 		: public _Node_base
; 1782 : 	{	// node that holds text
; 1783 : public:
; 1784 : 	_Node_str(_Node_flags _Fl = _Fl_none)
; 1785 : 		: _Node_base(_N_str, _Fl)
; 1786 : 		{	// construct
; 1787 : 		}
; 1788 : 
; 1789 : 	_Buf<_Elem> _Data;
; 1790 : 	};
; 1791 : 
; 1792 : 	// TEMPLATE CLASS _Node_class
; 1793 : template<class _Elem,
; 1794 : 	class _RxTraits>
; 1795 : 	class _Node_class
; 1796 : 		: public _Node_base
; 1797 : 	{	// node that holds a character class (POSIX bracket expression)
; 1798 : public:
; 1799 : 	_Node_class(_Node_type _Ty = _N_class, _Node_flags _Fl = _Fl_none)
; 1800 : 		: _Node_base(_Ty, _Fl), _Coll(0), _Small(0), _Large(0), _Ranges(0),
; 1801 : 		_Classes((typename _RxTraits::char_class_type)0), _Equiv(0)
; 1802 : 		{	// construct
; 1803 : 		}
; 1804 : 
; 1805 : 	~_Node_class() _NOEXCEPT
; 1806 : 		{	// destroy
; 1807 : 		_Tidy(_Coll);
; 1808 : 		delete _Small;
; 1809 : 		delete _Large;
; 1810 : 		delete _Ranges;
; 1811 : 		_Tidy(_Equiv);
; 1812 : 		}
; 1813 : 
; 1814 : 	void _Tidy(_Sequence<_Elem> *_Head)
; 1815 : 		{	// clean up a list of sequences
; 1816 : 		while (_Head)
; 1817 : 			{	// delete the head of the list
; 1818 : 			_Sequence<_Elem> *_Temp = _Head;
; 1819 : 			_Head = _Head->_Next;
; 1820 : 			delete _Temp;
; 1821 : 			}
; 1822 : 		}
; 1823 : 
; 1824 : 	_Sequence<_Elem> *_Coll;
; 1825 : 	_Bitmap *_Small;
; 1826 : 	_Buf<_Elem> *_Large;
; 1827 : 	_Buf<_Elem> *_Ranges;
; 1828 : 	typename _RxTraits::char_class_type _Classes;
; 1829 : 	_Sequence<_Elem> *_Equiv;
; 1830 : 	};
; 1831 : 
; 1832 : 	// CLASS _Node_endif
; 1833 : class _Node_endif
; 1834 : 	: public _Node_base
; 1835 : 	{	// node that marks the end of an alternative
; 1836 : public:
; 1837 : 	_Node_endif()
; 1838 : 		: _Node_base(_N_endif, _Fl_none)
; 1839 : 		{	// construct
; 1840 : 		}
; 1841 : 	};
; 1842 : 
; 1843 : 	// CLASS _Node_if
; 1844 : class _Node_if
; 1845 : 	: public _Node_base
; 1846 : 	{	// node that marks the beginning of an alternative
; 1847 : public:
; 1848 : 	_Node_if(_Node_base *_End)
; 1849 : 		: _Node_base(_N_if, _Fl_none), _Endif((_Node_endif *)_End), _Child(0)
; 1850 : 		{	// construct
; 1851 : 		}
; 1852 : 
; 1853 : 	~_Node_if() _NOEXCEPT
; 1854 : 		{	// destroy branches of if node
; 1855 : 		_Node_if *_Cur = _Child;
; 1856 : 		while (_Cur)
; 1857 : 			{	// destroy branch
; 1858 : 			_Node_if *_Tmp = _Cur;
; 1859 : 			_Cur = _Cur->_Child;
; 1860 : 			_Tmp->_Child = 0;
; 1861 : 			_Destroy_node(_Tmp, _Endif);
; 1862 : 			}
; 1863 : 		}
; 1864 : 
; 1865 : 	_Node_endif *_Endif;
; 1866 : 	_Node_if *_Child;
; 1867 : 	};
; 1868 : 
; 1869 : 	// CLASS _Node_end_rep
; 1870 : class _Node_rep;
; 1871 : 
; 1872 : class _Node_end_rep
; 1873 : 	: public _Node_base
; 1874 : 	{	// node that marks the end of a repetition
; 1875 : public:
; 1876 : 	_Node_end_rep()
; 1877 : 		: _Node_base(_N_end_rep),
; 1878 : 			_Begin_rep(0)
; 1879 : 		{	// construct
; 1880 : 		}
; 1881 : 
; 1882 : 	_Node_rep *_Begin_rep;
; 1883 : 
; 1884 : private:
; 1885 : 	_Node_end_rep& operator=(const _Node_end_rep&);
; 1886 : 	};
; 1887 : 
; 1888 : 	// CLASS _Loop_vals_t
; 1889 : struct _Loop_vals_t
; 1890 : 	{	// storage for loop administration
; 1891 : 	int _Loop_idx;
; 1892 : 	void *_Loop_iter;
; 1893 : 	};
; 1894 : 
; 1895 : 	// CLASS _Node_rep
; 1896 : class _Node_rep
; 1897 : 	: public _Node_base
; 1898 : 	{	// node that marks the beginning of a repetition
; 1899 : public:
; 1900 : 	_Node_rep(bool _Greedy, int _Mn, int _Mx, _Node_end_rep *_End,
; 1901 : 		unsigned int _Number)
; 1902 : 		: _Node_base(_N_rep, _Greedy ? _Fl_greedy : _Fl_none),
; 1903 : 			_Min(_Mn),
; 1904 : 			_Max(_Mx),
; 1905 : 			_End_rep(_End),
; 1906 : 			_Loop_number(_Number),
; 1907 : 			_Simple_loop(-1)
; 1908 : 		{	// construct
; 1909 : 		}
; 1910 : 
; 1911 : 	const int _Min;
; 1912 : 	const int _Max;
; 1913 : 	_Node_end_rep *_End_rep;
; 1914 : 	unsigned int _Loop_number;
; 1915 : 	int _Simple_loop;	// -1 undetermined, 0 contains if/do, 1 simple
; 1916 : 
; 1917 : private:
; 1918 : 	_Node_rep& operator=(const _Node_rep&);
; 1919 : 	};
; 1920 : 
; 1921 : 	// TEMPLATE CLASS _Builder
; 1922 : template<class _FwdIt,
; 1923 : 	class _Elem,
; 1924 : 	class _RxTraits>
; 1925 : 	class _Builder
; 1926 : 	{	// provides operations used by _Parser to build the nfa
; 1927 : public:
; 1928 : 	typedef typename iterator_traits<_FwdIt>::difference_type _Difft;
; 1929 : 
; 1930 : 	_Builder(const _RxTraits& _Tr, regex_constants::syntax_option_type);
; 1931 : 	bool _Beg_expr() const;
; 1932 : 	void _Setlong();
; 1933 : 	void _Discard_pattern();
; 1934 : 	_Node_base *_Getmark() const;
; 1935 : 
; 1936 : 	void _Add_nop();
; 1937 : 	void _Add_bol();
; 1938 : 	void _Add_eol();
; 1939 : 	void _Add_wbound();
; 1940 : 	void _Add_dot();
; 1941 : 	void _Add_char(_Elem _Ch);
; 1942 : 	void _Add_class();
; 1943 : 	void _Add_char_to_class(_Elem _Ch);
; 1944 : 	void _Add_range(_Elem _E0, _Elem _E1);
; 1945 : 	void _Add_named_class(_Regex_traits_base::char_class_type, bool = false);
; 1946 : 	void _Add_equiv(_FwdIt, _FwdIt, _Difft);
; 1947 : 	void _Add_coll(_FwdIt, _FwdIt, _Difft);
; 1948 : 	_Node_base *_Begin_group();
; 1949 : 	void _End_group(_Node_base *_Back);
; 1950 : 	_Node_base *_Begin_assert_group(bool);
; 1951 : 	void _End_assert_group(_Node_base *);
; 1952 : 	_Node_base *_Begin_capture_group(unsigned int _Idx);
; 1953 : 	void _Add_backreference(unsigned int _Idx);
; 1954 : 	_Node_base *_Begin_if(_Node_base *_Start);
; 1955 : 	void _Else_if(_Node_base *, _Node_base *);
; 1956 : 	void _Add_rep(int _Min, int _Max, bool _Greedy);
; 1957 : 	void _Negate();
; 1958 : 	void _Mark_final();
; 1959 : 	_Root_node *_End_pattern();
; 1960 : 
; 1961 : private:
; 1962 : 	_Node_base *_Link_node(_Node_base *);
; 1963 : 	static void _Insert_node(_Node_base *, _Node_base *);
; 1964 : 	_Node_base *_New_node(_Node_type _Kind);
; 1965 : 	void _Add_str_node();
; 1966 : 	bool _Beg_expr(_Node_base *) const;
; 1967 : 	void _Add_char_to_bitmap(_Elem _Ch);
; 1968 : 	void _Add_char_to_array(_Elem _Ch);
; 1969 : 	void _Add_elts(_Node_class<_Elem, _RxTraits> *,
; 1970 : 		_Regex_traits_base::char_class_type, bool);
; 1971 : 	void _Char_to_elts(_FwdIt, _FwdIt, _Difft, _Sequence<_Elem> **);
; 1972 : 
; 1973 : 	_Root_node *_Root;
; 1974 : 	_Node_base *_Current;
; 1975 : 	regex_constants::syntax_option_type _Flags;
; 1976 : 	const _RxTraits& _Traits;
; 1977 : 	const int _Bmax; // Do not use; use _Get_bmax instead.
; 1978 : 	const int _Tmax; // Do not use; use _Get_tmax instead.
; 1979 : 
; 1980 : 	unsigned int _Get_bmax() const;
; 1981 : 	unsigned int _Get_tmax() const;
; 1982 : 
; 1983 : private:
; 1984 : 	_Builder& operator=(const _Builder&);
; 1985 : 	};
; 1986 : 
; 1987 : 	// TEMPLATE CLASS _Bt_state_t
; 1988 : template<class _BidIt>
; 1989 : 	class _Bt_state_t
; 1990 : 	{	// holds the state needed for backtracking
; 1991 : public:
; 1992 : 	_BidIt _Cur;
; 1993 : 	vector<bool> _Grp_valid;
; 1994 : 	};
; 1995 : 
; 1996 : 	// TEMPLATE CLASS _Tgt_state_t
; 1997 : template<class _BidIt>
; 1998 : 	class _Tgt_state_t
; 1999 : 	: public _Bt_state_t<_BidIt>
; 2000 : 	{	// holds the current state of the match
; 2001 : public:
; 2002 : 	struct _Grp_t
; 2003 : 		{	// stores a pair of iterators
; 2004 : 		_BidIt _Begin;
; 2005 : 		_BidIt _End;
; 2006 : 		};
; 2007 : 
; 2008 : 	vector<_Grp_t> _Grps;
; 2009 : 
; 2010 : 	void operator=(const _Bt_state_t<_BidIt>& _Other)
; 2011 : 		{	// assign from object of type _Bt_state_t<_BidIt>
; 2012 : 		*(_Bt_state_t<_BidIt> *)this = _Other;
; 2013 : 		}
; 2014 : 	};
; 2015 : 
; 2016 : 	// TEMPLATE CLASS _Matcher
; 2017 : template<class _BidIt,
; 2018 : 	class _Elem,
; 2019 : 	class _RxTraits,
; 2020 : 	class _It>
; 2021 : 	class _Matcher
; 2022 : 	{	// provides ways to match a regular expression to a text sequence
; 2023 : public:
; 2024 : 	_Matcher(_It _Pfirst, _It _Plast, const _RxTraits& _Tr,
; 2025 : 		_Root_node *_Re, unsigned int _Nx,
; 2026 : 		regex_constants::syntax_option_type _Sf,
; 2027 : 		regex_constants::match_flag_type _Mf)
; 2028 : 			: _First(_Pfirst), _End(_Plast), _Traits(_Tr), _Rep(_Re),
; 2029 : 				_Sflags(_Sf), _Mflags(_Mf), _Matched(false),
; 2030 : 				_Ncap(static_cast<int>(_Nx)),
; 2031 : 				_Longest((_Re->_Flags & _Fl_longest)
; 2032 : 					&& !(_Mf & regex_constants::match_any))
; 2033 : 		{	// construct
; 2034 : 		_Loop_vals.resize(_Re->_Loops);
; 2035 : 		_DEBUG_RANGE(_Pfirst, _Plast);
; 2036 : 		}
; 2037 : 
; 2038 : 	void _Setf(regex_constants::match_flag_type _Mf)
; 2039 : 		{	// set specified flags
; 2040 : 		_Mflags |= _Mf;
; 2041 : 		}
; 2042 : 
; 2043 : 	void _Clearf(regex_constants::match_flag_type _Mf)
; 2044 : 		{	// clear specified flags
; 2045 : 		_Mflags &= ~_Mf;
; 2046 : 		}
; 2047 : 
; 2048 : 	template<class _Alloc>
; 2049 : 		bool _Match(_It _Pfirst,
; 2050 : 			match_results<_BidIt, _Alloc> *_Matches,
; 2051 : 			bool _Full_match)
; 2052 : 		{	// try to match
; 2053 : 		_First = _Pfirst;
; 2054 : 		return (_Match(_Matches, _Full_match));
; 2055 : 		}
; 2056 : 
; 2057 : 	template<class _Alloc>
; 2058 : 		bool _Match(match_results<_BidIt, _Alloc> *_Matches,
; 2059 : 			bool _Full_match)
; 2060 : 		{	// try to match
; 2061 : 		if (_Matches)
; 2062 : 			{	// clear _Matches before doing work
; 2063 : 			_Matches->_Ready = true;
; 2064 : 			_Matches->_Resize(0);
; 2065 : 			}
; 2066 : 
; 2067 : 		_Begin = _First;
; 2068 : 		_Tgt_state._Cur = _First;
; 2069 : 		_Tgt_state._Grp_valid.resize(_Get_ncap());
; 2070 : 		_Tgt_state._Grps.resize(_Get_ncap());
; 2071 : 		_Cap = _Matches != 0;
; 2072 : 		_Full = _Full_match;
; 2073 : 		_Max_complexity_count = _REGEX_MAX_COMPLEXITY_COUNT;
; 2074 : 		_Max_stack_count = _REGEX_MAX_STACK_COUNT;
; 2075 : 
; 2076 : 		_Matched = false;
; 2077 : 
; 2078 : 		if (!_Match_pat(_Rep))
; 2079 : 			return (false);
; 2080 : 
; 2081 : 		if (_Matches)
; 2082 : 			{	// copy results to _Matches
; 2083 : 			_Matches->_Resize(_Get_ncap());
; 2084 : 			for (unsigned int _Idx = 0; _Idx < _Get_ncap(); ++_Idx)
; 2085 : 				{	// copy submatch _Idx
; 2086 : 				if (_Res._Grp_valid[_Idx])
; 2087 : 					{	// copy successful match
; 2088 : 					_Matches->_At(_Idx).matched = true;
; 2089 : 					_Matches->_At(_Idx).first = _Res._Grps[_Idx]._Begin;
; 2090 : 					_Matches->_At(_Idx).second = _Res._Grps[_Idx]._End;
; 2091 : 					}
; 2092 : 				else
; 2093 : 					{	// copy failed match
; 2094 : 					_Matches->_At(_Idx).matched = false;
; 2095 : 					_Matches->_At(_Idx).first = _End;
; 2096 : 					_Matches->_At(_Idx).second = _End;
; 2097 : 					}
; 2098 : 				}
; 2099 : 			_Matches->_Org = _Begin;
; 2100 : 			_Matches->_Pfx().first = _Begin;
; 2101 : 			_Matches->_Pfx().second = _Matches->_At(0).first;
; 2102 : 			_Matches->_Pfx().matched =
; 2103 : 				_Matches->_Pfx().first != _Matches->_Pfx().second;
; 2104 : 
; 2105 : 			_Matches->_Sfx().first = _Matches->_At(0).second;
; 2106 : 			_Matches->_Sfx().second = _End;
; 2107 : 			_Matches->_Sfx().matched =
; 2108 : 				_Matches->_Sfx().first != _Matches->_Sfx().second;
; 2109 : 
; 2110 : 			_Matches->_Null().first = _End;
; 2111 : 			_Matches->_Null().second = _End;
; 2112 : 			}
; 2113 : 		return (true);
; 2114 : 		}
; 2115 : 
; 2116 : 	_BidIt _Skip(_BidIt, _BidIt, _Node_base * = 0);
; 2117 : 
; 2118 : private:
; 2119 : 	_Tgt_state_t<_It> _Tgt_state;
; 2120 : 	_Tgt_state_t<_It> _Res;
; 2121 : 	vector<_Loop_vals_t> _Loop_vals;
; 2122 : 
; 2123 : 	bool _Do_if(_Node_if *);
; 2124 : 	bool _Do_rep0(_Node_rep *, bool);
; 2125 : 	bool _Do_rep(_Node_rep *, bool, int);
; 2126 : 	bool _Do_class(_Node_base *);
; 2127 : 	bool _Match_pat(_Node_base *);
; 2128 : 	bool _Better_match();
; 2129 : 	bool _Is_wbound() const;
; 2130 : 
; 2131 : 	unsigned int _Get_ncap() const;
; 2132 : 
; 2133 : 	_It _Begin;
; 2134 : 	_It _End;
; 2135 : 	_It _First;
; 2136 : 	_Node_base *_Rep;
; 2137 : 	regex_constants::syntax_option_type _Sflags;
; 2138 : 	regex_constants::match_flag_type _Mflags;
; 2139 : 	bool _Matched;
; 2140 : 	bool _Cap;
; 2141 : 	int _Ncap; // Do not use. Use _Get_ncap instead.
; 2142 : 	bool _Longest;
; 2143 : 	const _RxTraits& _Traits;
; 2144 : 	bool _Full;
; 2145 : 	long _Max_complexity_count;
; 2146 : 	long _Max_stack_count;
; 2147 : 
; 2148 : private:
; 2149 : 	_Matcher& operator=(const _Matcher&);
; 2150 : 	};
; 2151 : 
; 2152 : enum _Prs_ret
; 2153 : 	{	// indicate class element type
; 2154 : 	_Prs_none,
; 2155 : 	_Prs_chr,
; 2156 : 	_Prs_set
; 2157 : 	};
; 2158 : 
; 2159 : 	// TEMPLATE CLASS _Parser
; 2160 : template<class _FwdIt,
; 2161 : 	class _Elem,
; 2162 : 	class _RxTraits>
; 2163 : 	class _Parser
; 2164 : 	{	// parse a regular expression
; 2165 : public:
; 2166 : 	typedef typename _RxTraits::char_class_type char_class_type;
; 2167 : 
; 2168 : 	_Parser(const _RxTraits& _Tr, _FwdIt _Pfirst, _FwdIt _Plast,
; 2169 : 		regex_constants::syntax_option_type _Fx);
; 2170 : 	_Root_node *_Compile();
; 2171 : 
; 2172 : 	unsigned int _Mark_count() const
; 2173 : 		{	// return number of capture groups
; 2174 : 		return (_Grp_idx + 1);
; 2175 : 		}
; 2176 : 
; 2177 : private:
; 2178 : 	// lexing
; 2179 : 	void _Error(regex_constants::error_type);
; 2180 : 
; 2181 : 	bool _Is_esc() const;
; 2182 : 	void _Trans();
; 2183 : 	void _Next();
; 2184 : 	void _Expect(_Meta_type, regex_constants::error_type);
; 2185 : 
; 2186 : 	// parsing
; 2187 : 	int _Do_digits(int _Base, int _Count);
; 2188 : 	bool _DecimalDigits();
; 2189 : 	void _HexDigits(int);
; 2190 : 	bool _OctalDigits();
; 2191 : 	void _Do_ex_class(_Meta_type);
; 2192 : 	bool _CharacterClassEscape(bool);
; 2193 : 	_Prs_ret _ClassEscape(bool);
; 2194 : 	_Prs_ret _ClassAtom();
; 2195 : 	void _ClassRanges();
; 2196 : 	void _CharacterClass();
; 2197 : 	bool _IdentityEscape();
; 2198 : 	bool _IsIdentityEscape() const;
; 2199 : 	bool _Do_ffn(_Elem);
; 2200 : 	bool _Do_ffnx(_Elem);
; 2201 : 	bool _CharacterEscape();
; 2202 : 	void _AtomEscape();
; 2203 : 	void _Do_capture_group();
; 2204 : 	void _Do_noncapture_group();
; 2205 : 	void _Do_assert_group(bool);
; 2206 : 	bool _Wrapped_disjunction();
; 2207 : 	void _Quantifier();
; 2208 : 	bool _Alternative();
; 2209 : 	void _Disjunction();
; 2210 : 
; 2211 : 	_FwdIt _Pat;
; 2212 : 	_FwdIt _Begin;
; 2213 : 	_FwdIt _End;
; 2214 : 	int _Grp_idx;
; 2215 : 	int _Disj_count;
; 2216 : 	vector<bool> _Finished_grps;
; 2217 : 	_Builder<_FwdIt, _Elem, _RxTraits> _Nfa;
; 2218 : 	const _RxTraits& _Traits;
; 2219 : 	regex_constants::syntax_option_type _Flags;
; 2220 : 	int _Val;
; 2221 : 	_Elem _Char;
; 2222 : 	_Meta_type _Mchar;
; 2223 : 	unsigned int _L_flags;
; 2224 : 	};
; 2225 : 
; 2226 : enum _Lang_flags
; 2227 : 	{	// describe language properties
; 2228 : 	_L_ext_rep = 0x00000001,	// + and ? repetitions
; 2229 : 	_L_alt_pipe = 0x00000002,	// uses '|' for alternation
; 2230 : 	_L_alt_nl = 0x00000004,		// uses '\n' for alternation (grep, egrep)
; 2231 : 	_L_nex_grp = 0x00000008,	// has non-escaped capture groups
; 2232 : 	_L_nex_rep = 0x00000010,	// has non-escaped repeats
; 2233 : 	_L_nc_grp = 0x00000020,		// has non-capture groups (?:xxx)
; 2234 : 	_L_asrt_gen = 0x00000040,	// has generalized assertions (?=xxx), (?!xxx)
; 2235 : 	_L_asrt_wrd = 0x00000080,	// has word boundary assertions (\b, \B)
; 2236 : 	_L_bckr = 0x00000100,		// has backreferences (ERE doesn't)
; 2237 : 	_L_lim_bckr = 0x00000200,	// has limited backreferences (BRE \1-\9)
; 2238 : 	_L_ngr_rep = 0x00000400,	// has non-greedy repeats
; 2239 : 	_L_esc_uni = 0x00000800,	// has Unicode escape sequences
; 2240 : 	_L_esc_hex = 0x00001000,	// has hexadecimal escape sequences
; 2241 : 	_L_esc_oct = 0x00002000,	// has octal escape sequences
; 2242 : 	_L_esc_bsl = 0x00004000,	// has escape backslash in character classes
; 2243 : 	_L_esc_ffnx = 0x00008000,	// has extra file escapes (\a and \b)
; 2244 : 	_L_esc_ffn = 0x00010000,	// has limited file escapes (\[fnrtv])
; 2245 : 	_L_esc_wsd = 0x00020000,	// has w, s, and d character set escapes
; 2246 : 	_L_esc_ctrl = 0x00040000,	// has control escape
; 2247 : 	_L_no_nl = 0x00080000,		// no newline in pattern or matching text
; 2248 : 	_L_bzr_chr = 0x00100000,	// \0 is a valid character constant
; 2249 : 	_L_grp_esc = 0x00200000,	// \ is special character in group
; 2250 : 	_L_ident_ECMA = 0x00400000,	// ECMA identity escape (not identifierpart)
; 2251 : 	_L_ident_ERE = 0x00800000,	// ERE identity escape (.[\*^$, plus {+?}()
; 2252 : 	_L_ident_awk = 0x01000000,	// awk identity escape ( ERE plus "/)
; 2253 : 	_L_anch_rstr = 0x02000000,	// anchor restricted to beginning/end
; 2254 : 	_L_star_beg = 0x04000000,	// star okay at beginning of RE/expr (BRE)
; 2255 : 	_L_empty_grp = 0x08000000,	// empty group allowed (ERE prohibits "()")
; 2256 : 	_L_paren_bal = 0x10000000,	// ')'/'}'/']' special only after '('/'{'/']'
; 2257 : 	_L_brk_rstr = 0x20000000,	// ']' not special when first character in set
; 2258 : 	_L_mtch_long = 0x40000000,	// find longest match (ERE, BRE)
; 2259 : 	};
; 2260 : 
; 2261 : 	// CLASS _Regex_base
; 2262 : class _Regex_base
; 2263 : 	: public _Container_base
; 2264 : 	{	// base class for basic_regex to construct and destroy proxy
; 2265 : public:
; 2266 :  #if 0 < _ITERATOR_DEBUG_LEVEL
; 2267 : 	_Regex_base()
; 2268 : 		{	// construct proxy
; 2269 : 		this->_Myproxy = new _Container_proxy;
; 2270 : 		this->_Myproxy->_Mycont = this;
; 2271 : 		}
; 2272 : 
; 2273 : 	~_Regex_base() _NOEXCEPT
; 2274 : 		{	// destroy proxy
; 2275 : 		this->_Orphan_all();
; 2276 : 		delete this->_Myproxy;
; 2277 : 		this->_Myproxy = 0;
; 2278 : 		}
; 2279 :  #endif /* 0 < _ITERATOR_DEBUG_LEVEL */
; 2280 : 	};
; 2281 : 
; 2282 : 	// TEMPLATE CLASS basic_regex
; 2283 : template<class _Elem,
; 2284 : 	class _RxTraits = regex_traits<_Elem> >
; 2285 : 	class basic_regex
; 2286 : 		: public _Regex_base
; 2287 : 	{	// regular expression
; 2288 : public:
; 2289 : 	typedef basic_regex<_Elem, _RxTraits> _Myt;
; 2290 : 	typedef _Elem value_type;
; 2291 : 	typedef _RxTraits traits_type;
; 2292 : 	typedef typename _RxTraits::locale_type locale_type;
; 2293 : 	typedef typename _RxTraits::string_type string_type;
; 2294 : 	typedef regex_constants::syntax_option_type flag_type;
; 2295 : 
; 2296 : 	static constexpr flag_type icase = regex_constants::icase;
; 2297 : 	static constexpr flag_type nosubs = regex_constants::nosubs;
; 2298 : 	static constexpr flag_type optimize = regex_constants::optimize;
; 2299 : 	static constexpr flag_type collate = regex_constants::collate;
; 2300 : 	static constexpr flag_type ECMAScript = regex_constants::ECMAScript;
; 2301 : 	static constexpr flag_type basic = regex_constants::basic;
; 2302 : 	static constexpr flag_type extended = regex_constants::extended;
; 2303 : 	static constexpr flag_type awk = regex_constants::awk;
; 2304 : 	static constexpr flag_type grep = regex_constants::grep;
; 2305 : 	static constexpr flag_type egrep = regex_constants::egrep;
; 2306 : 
; 2307 : 	basic_regex()
; 2308 : 		: _Rep(0)
; 2309 : 		{	// construct empty object
; 2310 : 		}
; 2311 : 
; 2312 : 	explicit basic_regex(_In_z_ const _Elem *_Ptr,
; 2313 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2314 : 		: _Rep(0)
; 2315 : 		{	// construct from null terminated character sequence
; 2316 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),
; 2317 : 			_Flags, random_access_iterator_tag());
; 2318 : 		}
; 2319 : 
; 2320 : 	basic_regex(_In_reads_(_Count) const _Elem *_Ptr, size_t _Count,
; 2321 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2322 : 		: _Rep(0)
; 2323 : 		{	// construct from character sequence
; 2324 : 		if (_Ptr == 0)
; 2325 : 			_Xregex_error(regex_constants::error_parse);
; 2326 : 		_Reset(_Ptr, _Ptr + _Count, _Flags, random_access_iterator_tag());
; 2327 : 		}
; 2328 : 
; 2329 : 	template<class _STtraits,
; 2330 : 		class _STalloc>
; 2331 : 		explicit basic_regex(
; 2332 : 			const basic_string<_Elem, _STtraits, _STalloc>& _Str,
; 2333 : 			flag_type _Flags = regex_constants::ECMAScript)
; 2334 : 		: _Rep(0)
; 2335 : 		{	// construct from string object
; 2336 : 		_Reset(_Str.begin(), _Str.end(), _Flags, random_access_iterator_tag());
; 2337 : 		}
; 2338 : 
; 2339 : 	template<class _InIt>
; 2340 : 		basic_regex(_InIt _First, _InIt _Last,
; 2341 : 			flag_type _Flags)
; 2342 : 		: _Rep(0)
; 2343 : 		{	// construct from pair of iterators
; 2344 : 		_DEBUG_RANGE(_First, _Last);
; 2345 : 		_Reset(_First, _Last, _Flags, _Iter_cat_t<_InIt>());
; 2346 : 		}
; 2347 : 
; 2348 : 	template<class _InIt>
; 2349 : 		basic_regex(_InIt _First, _InIt _Last)
; 2350 : 		: _Rep(0)
; 2351 : 		{	// construct from pair of iterators
; 2352 : 		_DEBUG_RANGE(_First, _Last);
; 2353 : 		_Reset(_First, _Last, regex_constants::ECMAScript, _Iter_cat_t<_InIt>());
; 2354 : 		}
; 2355 : 
; 2356 : 	basic_regex(const _Myt& _Right)
; 2357 : 
; 2358 :  #if _ENHANCED_REGEX_VISUALIZER
; 2359 : 		: _Rep(0), _Traits(_Right._Traits),
; 2360 : 			_Visualization(_Right._Visualization)
; 2361 : 
; 2362 :  #else /* _ENHANCED_REGEX_VISUALIZER */
; 2363 : 		: _Rep(0), _Traits(_Right._Traits)
; 2364 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2365 : 
; 2366 : 		{	// construct copy of _Right
; 2367 : 		_Reset(_Right._Rep);
; 2368 : 		}
; 2369 : 
; 2370 : 	basic_regex(initializer_list<_Elem> _Ilist,
; 2371 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2372 : 		: _Rep(0)
; 2373 : 		{	// construct from initializer_list
; 2374 : 		_Reset(_Ilist.begin(), _Ilist.end(), _Flags,
; 2375 : 			random_access_iterator_tag());
; 2376 : 		}
; 2377 : 
; 2378 : 	_Myt& operator=(initializer_list<_Elem> _Ilist)
; 2379 : 		{	// replace with regular expression in initializer_list
; 2380 : 		return (assign(_Ilist));
; 2381 : 		}
; 2382 : 
; 2383 : 	_Myt& assign(initializer_list<_Elem> _Ilist,
; 2384 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2385 : 		{	// replace with regular expression in initializer_list
; 2386 : 		_Reset(_Ilist.begin(), _Ilist.end(),
; 2387 : 			_Flags, random_access_iterator_tag());
; 2388 : 		return (*this);
; 2389 : 		}
; 2390 : 
; 2391 : 	basic_regex(_Myt&& _Right) _NOEXCEPT
; 2392 : 		: _Rep(0)
; 2393 : 		{	// construct by moving _Right
; 2394 : 		_Assign_rv(_STD move(_Right));
; 2395 : 		}
; 2396 : 
; 2397 : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 2398 : 		{	// assign by moving _Right
; 2399 : 		_Assign_rv(_STD move(_Right));
; 2400 : 		return (*this);
; 2401 : 		}
; 2402 : 
; 2403 : 	void _Assign_rv(_Myt&& _Right)
; 2404 : 		{	// assign by moving _Right
; 2405 : 		if (this != _STD addressof(_Right))
; 2406 : 			{	// clear this and steal from _Right
; 2407 : 			_Tidy();
; 2408 : 
; 2409 :  #if _ENHANCED_REGEX_VISUALIZER
; 2410 : 			_Visualization = _STD move(_Right._Visualization);
; 2411 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2412 : 
; 2413 : 			_Rep = _Right._Rep;
; 2414 : 			_Right._Rep = 0;
; 2415 : 			}
; 2416 : 		}
; 2417 : 
; 2418 : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 2419 : 		{	// assign by moving _Right
; 2420 : 		_Assign_rv(_STD move(_Right));
; 2421 : 		return (*this);
; 2422 : 		}
; 2423 : 
; 2424 : 	~basic_regex() _NOEXCEPT
; 2425 : 		{	// destroy the object
; 2426 : 		_Tidy();
; 2427 : 		}
; 2428 : 
; 2429 : 	_Myt& operator=(const _Myt& _Right)
; 2430 : 		{	// replace with copy of _Right
; 2431 : 		return (assign(_Right));
; 2432 : 		}
; 2433 : 
; 2434 : 	_Myt& operator=(_In_z_ const _Elem *_Ptr)
; 2435 : 		{	// replace with regular expression constructed from _Ptr
; 2436 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),
; 2437 : 			ECMAScript, random_access_iterator_tag());
; 2438 : 		return (*this);
; 2439 : 		}
; 2440 : 
; 2441 : 	template<class _STtraits,
; 2442 : 		class _STalloc>
; 2443 : 		_Myt& operator=(
; 2444 : 			const basic_string<_Elem, _STtraits, _STalloc>& _Str)
; 2445 : 		{	// replace with regular expression constructed from _Str
; 2446 : 		_Reset(_Str.begin(), _Str.end(),
; 2447 : 			ECMAScript, random_access_iterator_tag());
; 2448 : 		return (*this);
; 2449 : 		}
; 2450 : 
; 2451 : 	unsigned int _Loop_count() const
; 2452 : 		{	// return number of loops
; 2453 : 		return (_Rep != 0 ? _Rep->_Loops : 0);
; 2454 : 		}
; 2455 : 
; 2456 : 	unsigned int mark_count() const
; 2457 : 		{	// return number of capture groups
; 2458 : 		return (_Rep != 0 ? _Rep->_Marks - 1 : 0);
; 2459 : 		}
; 2460 : 
; 2461 : 	_Myt& assign(const _Myt& _Right)
; 2462 : 		{	// replace with copy of _Right
; 2463 :  #if _ENHANCED_REGEX_VISUALIZER
; 2464 : 		_Visualization = _Right._Visualization;
; 2465 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2466 : 
; 2467 : 		_Reset(_Right._Rep);
; 2468 : 		return (*this);
; 2469 : 		}
; 2470 : 
; 2471 : 	_Myt& assign(_In_z_ const _Elem *_Ptr,
; 2472 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2473 : 		{	// replace with regular expression constructed from _Ptr
; 2474 : 		return (assign(_Ptr, _RxTraits::length(_Ptr), _Flags));
; 2475 : 		}
; 2476 : 
; 2477 : 	_Myt& assign(_In_reads_(_Count) const _Elem *_Ptr, size_t _Count,
; 2478 : 		flag_type _Flags = regex_constants::ECMAScript)
; 2479 : 		{	// replace with regular expression constructed from _Ptr, _Count
; 2480 : 		_Reset(_Ptr, _Ptr + _Count,
; 2481 : 			_Flags, random_access_iterator_tag());
; 2482 : 		return (*this);
; 2483 : 		}
; 2484 : 
; 2485 : 	template<class _STtraits,
; 2486 : 		class _STalloc>
; 2487 : 		_Myt& assign(
; 2488 : 			const basic_string<_Elem, _STtraits, _STalloc>& _Str,
; 2489 : 			flag_type _Flags = regex_constants::ECMAScript)
; 2490 : 		{	// replace with regular expression constructed from _Str
; 2491 : 		_Reset(_Str.begin(), _Str.end(),
; 2492 : 			_Flags, random_access_iterator_tag());
; 2493 : 		return (*this);
; 2494 : 		}
; 2495 : 
; 2496 : 	template<class _InIt>
; 2497 : 		_Myt& assign(_InIt _First, _InIt _Last,
; 2498 : 			flag_type _Flags = regex_constants::ECMAScript)
; 2499 : 		{	// replace with regular expression constructed from [_First, _Last)
; 2500 : 		_DEBUG_RANGE(_First, _Last);
; 2501 : 		_Reset(_First, _Last, _Flags, _Iter_cat_t<_InIt>());
; 2502 : 		return (*this);
; 2503 : 		}
; 2504 : 
; 2505 : 	flag_type flags() const
; 2506 : 		{	// return syntax option flags
; 2507 : 		return (_Rep ? _Rep->_Fl : (flag_type)0);
; 2508 : 		}
; 2509 : 
; 2510 : 	locale_type imbue(locale_type _Loc)
; 2511 : 		{	// clear regular expression and set locale to argument
; 2512 : 		_Tidy();
; 2513 : 		return (_Traits.imbue(_Loc));
; 2514 : 		}
; 2515 : 
; 2516 : 	locale_type getloc() const
; 2517 : 		{	// return copy of locale object
; 2518 : 		return (_Traits.getloc());
; 2519 : 		}
; 2520 : 
; 2521 : 	void swap(_Myt& _Right) _THROW0()
; 2522 : 		{	// exchange contents with _Right
; 2523 : 		_STD swap(_Rep, _Right._Rep);
; 2524 : 
; 2525 :  #if _ENHANCED_REGEX_VISUALIZER
; 2526 : 		_Visualization.swap(_Right._Visualization);
; 2527 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2528 : 		}
; 2529 : 
; 2530 : 	_Root_node *_Get() const
; 2531 : 		{	// return pointer to root node
; 2532 : 		return (_Rep);
; 2533 : 		}
; 2534 : 
; 2535 : 	bool _Empty() const
; 2536 : 		{	// test if empty
; 2537 : 		return (_Rep == 0);
; 2538 : 		}
; 2539 : 
; 2540 : 	const _RxTraits& _Get_traits() const
; 2541 : 		{	// return reference to traits
; 2542 : 		return (_Traits);
; 2543 : 		}
; 2544 : 
; 2545 : private:
; 2546 : 	_Root_node *_Rep;
; 2547 : 	_RxTraits _Traits;
; 2548 : 
; 2549 :  #if _ENHANCED_REGEX_VISUALIZER
; 2550 : 	basic_string<_Elem> _Visualization;
; 2551 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2552 : 
; 2553 : 	void _Tidy()
; 2554 : 		{	// free all storage
; 2555 : 		if (_Rep != 0 && _MT_DECR(
; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);
; 2558 : 		_Rep = 0;
; 2559 : 		}
; 2560 : 
; 2561 : 	template<class _InIt>
; 2562 : 		void _Reset(_InIt _First, _InIt _Last,
; 2563 : 			flag_type _Flags, input_iterator_tag)
; 2564 : 		{	// build regular expression from input iterators
; 2565 : 		basic_string<_Iter_value_t<_InIt>> _Str(_First, _Last);
; 2566 : 
; 2567 : 		_Reset(_Str.begin(), _Str.end(),
; 2568 : 			_Flags, forward_iterator_tag());
; 2569 : 		}
; 2570 : 
; 2571 : 	template<class _FwdIt>
; 2572 : 		void _Reset(_FwdIt _First, _FwdIt _Last,
; 2573 : 			flag_type _Flags, forward_iterator_tag)
; 2574 : 		{	// build regular expression from forward iterators
; 2575 :  #if _ENHANCED_REGEX_VISUALIZER
; 2576 : 		_Visualization.assign(_First, _Last);
; 2577 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2578 : 
; 2579 : 		_Parser<_FwdIt, _Elem, _RxTraits>
; 2580 : 			_Prs(_Traits, _First, _Last, _Flags);
; 2581 : 		_Root_node *_Rx = _Prs._Compile();
; 2582 : 		_Reset(_Rx);
; 2583 : 		}
; 2584 : 
; 2585 : 	void _Reset(_Root_node *_Rx)
; 2586 : 		{	// build regular expression holding root node _Rx
; 2587 : 		if (_Rx != 0)
; 2588 : 			_MT_INCR(reinterpret_cast<_Atomic_counter_t&>(_Rx->_Refs));
; 2589 : 		_Tidy();
; 2590 : 		_Rep = _Rx;
; 2591 : 		}
; 2592 : 	};
; 2593 : 
; 2594 : template<class _Elem,
; 2595 : 	class _RxTraits>
; 2596 : 	void swap(basic_regex<_Elem, _RxTraits>& _Left,
; 2597 : 		basic_regex<_Elem, _RxTraits>& _Right) _THROW0()
; 2598 : 	{	// exchange contents of _Left with _Right
; 2599 : 	_Left.swap(_Right);
; 2600 : 	}
; 2601 : 
; 2602 : template<class _BidIt,
; 2603 : 	class _Alloc>
; 2604 : 	void swap(match_results<_BidIt, _Alloc>& _Left,
; 2605 : 		match_results<_BidIt, _Alloc>& _Right) _THROW0()
; 2606 : 	{	// exchange contents of _Left with _Right
; 2607 : 	_Left.swap(_Right);
; 2608 : 	}
; 2609 : 
; 2610 : typedef basic_regex<char> regex;
; 2611 : typedef basic_regex<wchar_t> wregex;
; 2612 : typedef match_results<const char *> cmatch;
; 2613 : typedef match_results<const wchar_t *> wcmatch;
; 2614 : typedef match_results<string::const_iterator> smatch;
; 2615 : typedef match_results<wstring::const_iterator> wsmatch;
; 2616 : 
; 2617 : #define _Isdigit(x) ('0' <= (x) && (x) <= '9')
; 2618 : 
; 2619 : 	// TEMPLATE FUNCTION _Format_default
; 2620 : template<class _BidIt,
; 2621 : 	class _Alloc,
; 2622 : 	class _InIt,
; 2623 : 	class _OutIt> inline
; 2624 : 	_OutIt _Format_default(
; 2625 : 		const match_results<_BidIt, _Alloc>& _Match,
; 2626 : 		_OutIt _Out, _InIt _First, _InIt _Last,
; 2627 : 		regex_constants::match_flag_type)
; 2628 : 	{	// format with ECMAScript rules
; 2629 : 	while (_First != _Last)
; 2630 : 		{	// process one character or escape sequence
; 2631 : 		if (*_First != '$')
; 2632 : 			*_Out++ = *_First++;
; 2633 : 		else if (++_First == _Last)
; 2634 : 			*_Out++ = '$';	// preserve $ at end
; 2635 : 		else if (*_First == '$')
; 2636 : 			{	// replace $$
; 2637 : 			*_Out++ = '$';
; 2638 : 			++_First;
; 2639 : 			}
; 2640 : 		else if (*_First == '`')
; 2641 : 			{	// replace $`
; 2642 : 			_Out = _Copy_no_deprecate(_Match.prefix().first,
; 2643 : 				_Match.prefix().second, _Out);
; 2644 : 			++_First;
; 2645 : 			}
; 2646 : 		else if (*_First == '\'')
; 2647 : 			{	// replace $'
; 2648 : 			_Out = _Copy_no_deprecate(_Match.suffix().first,
; 2649 : 				_Match.suffix().second, _Out);
; 2650 : 			++_First;
; 2651 : 			}
; 2652 : 		else if (*_First == '&')
; 2653 : 			{	// replace $&
; 2654 : 			++_First;
; 2655 : 			if (_Match.size() != 0)
; 2656 : 				_Out = _Copy_no_deprecate(_Match._At(0).first,
; 2657 : 					_Match._At(0).second, _Out);
; 2658 : 			}
; 2659 : 		else if (_Isdigit(*_First))
; 2660 : 			{	// replace capture group descriptors $n, $nn
; 2661 : 			int n = *_First++ - '0';
; 2662 : 			const bool _Two_digits = _First != _Last && _Isdigit(*_First);
; 2663 : 			if (_Two_digits)
; 2664 : 				{	// process second digit
; 2665 : 				n *= 10;
; 2666 : 				n += *_First++ - '0';
; 2667 : 				}
; 2668 : 			if (n == 0)
; 2669 : 				{	// preserve $0, $00
; 2670 : 				*_Out++ = '$';
; 2671 : 				*_Out++ = '0';
; 2672 : 				if (_Two_digits)
; 2673 : 					*_Out++ = '0';
; 2674 : 				}
; 2675 : 			else if (n < (int)_Match.size())
; 2676 : 				_Out = _Copy_no_deprecate(_Match._At(n).first,
; 2677 : 					_Match._At(n).second, _Out);
; 2678 : 			}
; 2679 : 		else
; 2680 : 			{	// replace $x
; 2681 : 			*_Out++ = '$';
; 2682 : 			*_Out++ = *_First++;
; 2683 : 			}
; 2684 : 		}
; 2685 : 	return (_Out);
; 2686 : 	}
; 2687 : 
; 2688 : 	// TEMPLATE FUNCTION _Format_sed
; 2689 : template<class _BidIt,
; 2690 : 	class _Alloc,
; 2691 : 	class _InIt,
; 2692 : 	class _OutIt> inline
; 2693 : 	_OutIt _Format_sed(const match_results<_BidIt, _Alloc>& _Match,
; 2694 : 		_OutIt _Out, _InIt _First, _InIt _Last,
; 2695 : 		regex_constants::match_flag_type)
; 2696 : 	{	// format with sed rules
; 2697 : 	while (_First != _Last)
; 2698 : 		{	// process one character or escape sequence
; 2699 : 		if (*_First == '&')
; 2700 : 			{	// replace with full match
; 2701 : 			++_First;
; 2702 : 			if (_Match.size() != 0)
; 2703 : 				_Out = _Copy_no_deprecate(_Match._At(0).first,
; 2704 : 					_Match._At(0).second, _Out);
; 2705 : 			}
; 2706 : 		else if (*_First != '\\')
; 2707 : 			*_Out++ = *_First++;
; 2708 : 		else if (++_First == _Last)
; 2709 : 			;	// drop backslash at end
; 2710 : 		else if (_Isdigit(*_First))
; 2711 : 			{	// replace \n, including \0
; 2712 : 			int n = *_First++ - '0';
; 2713 : 			if (n < (int)_Match.size())
; 2714 : 				_Out = _Copy_no_deprecate(_Match._At(n).first,
; 2715 : 					_Match._At(n).second, _Out);
; 2716 : 			}
; 2717 : 		else
; 2718 : 			*_Out++ = *_First++;	// replace \x, including \\, \&
; 2719 : 		}
; 2720 : 	return (_Out);
; 2721 : 	}
; 2722 : 
; 2723 : #undef _Isdigit
; 2724 : 
; 2725 : 	// TEMPLATE FUNCTION _Regex_match1
; 2726 : template<class _BidIt,
; 2727 : 	class _Alloc,
; 2728 : 	class _Elem,
; 2729 : 	class _RxTraits,
; 2730 : 	class _It> inline
; 2731 : 	bool _Regex_match1(_It _First, _It _Last,
; 2732 : 		match_results<_BidIt, _Alloc> *_Matches,
; 2733 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2734 : 		regex_constants::match_flag_type _Flgs,
; 2735 : 		bool _Full)
; 2736 : 	{	// try to match regular expression to target text
; 2737 : 	if (_Re._Empty())
; 2738 : 		return (false);
; 2739 : 	_Matcher<_BidIt, _Elem, _RxTraits, _It> _Mx(_First, _Last,
; 2740 : 		_Re._Get_traits(), _Re._Get(), _Re.mark_count() + 1, _Re.flags(),
; 2741 : 			_Flgs);
; 2742 : 	return (_Mx._Match(_Matches, _Full));
; 2743 : 	}
; 2744 : 
; 2745 : 	// TEMPLATE FUNCTION regex_match
; 2746 : template<class _BidIt,
; 2747 : 	class _Alloc,
; 2748 : 	class _Elem,
; 2749 : 	class _RxTraits> inline
; 2750 : 	bool regex_match(_BidIt _First, _BidIt _Last,
; 2751 : 		match_results<_BidIt, _Alloc>& _Matches,
; 2752 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2753 : 		regex_constants::match_flag_type _Flgs =
; 2754 : 			regex_constants::match_default)
; 2755 : 	{	// try to match regular expression to target text
; 2756 : 	_DEBUG_RANGE(_First, _Last);
; 2757 : 	return (_Regex_match1(_First, _Last,
; 2758 : 		&_Matches, _Re, _Flgs, true));
; 2759 : 	}
; 2760 : 
; 2761 : template<class _BidIt,
; 2762 : 	class _Elem,
; 2763 : 	class _RxTraits> inline
; 2764 : 	bool regex_match(_BidIt _First, _BidIt _Last,
; 2765 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2766 : 		regex_constants::match_flag_type _Flgs =
; 2767 : 			regex_constants::match_default)
; 2768 : 	{	// try to match regular expression to target text
; 2769 : 	_DEBUG_RANGE(_First, _Last);
; 2770 : 	return (_Regex_match1(_Unchecked(_First), _Unchecked(_Last),
; 2771 : 		static_cast<match_results<decltype(_Unchecked(_First))> *>(0), _Re,
; 2772 : 			_Flgs | regex_constants::match_any, true));
; 2773 : 	}
; 2774 : 
; 2775 : template<class _Elem,
; 2776 : 	class _RxTraits> inline
; 2777 : 	bool regex_match(_In_z_ const _Elem *_Str,
; 2778 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2779 : 		regex_constants::match_flag_type _Flgs =
; 2780 : 			regex_constants::match_default)
; 2781 : 	{	// try to match regular expression to target text
; 2782 : 	const _Elem *_Last = _Str + char_traits<_Elem>::length(_Str);
; 2783 : 	return (_Regex_match1(_Str, _Last,
; 2784 : 		static_cast<match_results<const _Elem *> *>(0), _Re,
; 2785 : 			_Flgs | regex_constants::match_any, true));
; 2786 : 	}
; 2787 : 
; 2788 : template<class _Elem,
; 2789 : 	class _Alloc,
; 2790 : 	class _RxTraits> inline
; 2791 : 	bool regex_match(_In_z_ const _Elem *_Str,
; 2792 : 		match_results<const _Elem *, _Alloc>& _Matches,
; 2793 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2794 : 		regex_constants::match_flag_type _Flgs =
; 2795 : 			regex_constants::match_default)
; 2796 : 	{	// try to match regular expression to target text
; 2797 : 	const _Elem *_Last = _Str + char_traits<_Elem>::length(_Str);
; 2798 : 	return (_Regex_match1(_Str, _Last,
; 2799 : 		&_Matches, _Re, _Flgs, true));
; 2800 : 	}
; 2801 : 
; 2802 : template<class _StTraits,
; 2803 : 	class _StAlloc,
; 2804 : 	class _Alloc,
; 2805 : 	class _Elem,
; 2806 : 	class _RxTraits> inline
; 2807 : 	bool regex_match(
; 2808 : 		const basic_string<_Elem, _StTraits, _StAlloc>& _Str,
; 2809 : 		match_results<typename basic_string<_Elem, _StTraits, _StAlloc>::
; 2810 : 			const_iterator, _Alloc>& _Matches,
; 2811 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2812 : 		regex_constants::match_flag_type _Flgs =
; 2813 : 			regex_constants::match_default)
; 2814 : 	{	// try to match regular expression to target text
; 2815 : 	return (_Regex_match1(_Str.begin(), _Str.end(),
; 2816 : 		&_Matches, _Re, _Flgs, true));
; 2817 : 	}
; 2818 : 
; 2819 : template<class _StTraits,
; 2820 : 	class _StAlloc,
; 2821 : 	class _Alloc,
; 2822 : 	class _Elem,
; 2823 : 	class _RxTraits>
; 2824 : 	bool regex_match(
; 2825 : 		const basic_string<_Elem, _StTraits, _StAlloc>&&,
; 2826 : 		match_results<typename basic_string<_Elem, _StTraits, _StAlloc>::
; 2827 : 			const_iterator, _Alloc>&,
; 2828 : 		const basic_regex<_Elem, _RxTraits>&,
; 2829 : 		regex_constants::match_flag_type =
; 2830 : 			regex_constants::match_default) = delete;
; 2831 : 
; 2832 : template<class _StTraits,
; 2833 : 	class _StAlloc,
; 2834 : 	class _Elem,
; 2835 : 	class _RxTraits> inline
; 2836 : 	bool regex_match(
; 2837 : 		const basic_string<_Elem, _StTraits, _StAlloc>& _Str,
; 2838 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2839 : 		regex_constants::match_flag_type _Flgs =
; 2840 : 			regex_constants::match_default)
; 2841 : 	{	// try to match regular expression to target text
; 2842 : 	typedef typename basic_string<_Elem, _StTraits, _StAlloc>
; 2843 : 		::const_iterator _Iter;
; 2844 : 	return (_Regex_match1(_Unchecked(_Str.begin()), _Unchecked(_Str.end()),
; 2845 : 		static_cast<match_results<decltype(_Unchecked(_Str.begin()))> *>(0), _Re,
; 2846 : 			_Flgs | regex_constants::match_any, true));
; 2847 : 	}
; 2848 : 
; 2849 : 	// TEMPLATE FUNCTION _Regex_search1
; 2850 : template<class _BidIt,
; 2851 : 	class _Alloc,
; 2852 : 	class _Elem,
; 2853 : 	class _RxTraits,
; 2854 : 	class _It> inline
; 2855 : 	bool _Regex_search1(_It _First, _It _Last,
; 2856 : 		match_results<_BidIt, _Alloc> *_Matches,
; 2857 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2858 : 		regex_constants::match_flag_type _Flgs,
; 2859 : 		_It _Org)
; 2860 : 	{	// search for regular expression match in target text
; 2861 : 	if (_Re._Empty())
; 2862 : 		return (false);
; 2863 : 	bool _Found = false;
; 2864 : 	_It _Begin = _First;
; 2865 : 	_Matcher<_BidIt, _Elem, _RxTraits, _It> _Mx(_First, _Last,
; 2866 : 		_Re._Get_traits(), _Re._Get(), _Re.mark_count() + 1, _Re.flags(),
; 2867 : 			_Flgs);
; 2868 : 
; 2869 : 	if (_Mx._Match(_Matches, false))
; 2870 : 		_Found = true;
; 2871 : 	else if (_First == _Last
; 2872 : 		|| _Flgs & regex_constants::match_continuous)
; 2873 : 		;
; 2874 : 	else
; 2875 : 		{	// try more on suffixes
; 2876 : 		_Mx._Setf(regex_constants::match_prev_avail);
; 2877 : 		_Mx._Clearf(regex_constants::_Match_not_null);
; 2878 : 		while ((_First = _Mx._Skip(++_First, _Last)) != _Last)
; 2879 : 			if (_Mx._Match(_First, _Matches, false))
; 2880 : 				{	// found match starting at _First
; 2881 : 				_Found = true;
; 2882 : 				break;
; 2883 : 				}
; 2884 : 		if (!_Found && _Mx._Match(_Last, _Matches, false))
; 2885 : 			_Found = true;
; 2886 : 		}
; 2887 : 	if (_Found && _Matches)
; 2888 : 		{	// update _Matches
; 2889 : 		_Matches->_Org = _Org;
; 2890 : 		_Matches->_Pfx().first = _Begin;
; 2891 : 		_Matches->_Pfx().matched =
; 2892 : 			_Matches->_Pfx().first != _Matches->_Pfx().second;
; 2893 : 		}
; 2894 : 	return (_Found);
; 2895 : 	}
; 2896 : 
; 2897 : 	// TEMPLATE FUNCTION regex_search
; 2898 : template<class _BidIt,
; 2899 : 	class _Alloc,
; 2900 : 	class _Elem,
; 2901 : 	class _RxTraits> inline
; 2902 : 	bool regex_search(_BidIt _First, _BidIt _Last,
; 2903 : 		match_results<_BidIt, _Alloc>& _Matches,
; 2904 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2905 : 		regex_constants::match_flag_type _Flgs =
; 2906 : 			regex_constants::match_default)
; 2907 : 	{	// search for regular expression match in target text
; 2908 : 	_DEBUG_RANGE(_First, _Last);
; 2909 : 	return (_Regex_search1(_First, _Last, &_Matches, _Re, _Flgs, _First));
; 2910 : 	}
; 2911 : 
; 2912 : template<class _BidIt,
; 2913 : 	class _Elem,
; 2914 : 	class _RxTraits> inline
; 2915 : 	bool regex_search(_BidIt _First, _BidIt _Last,
; 2916 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2917 : 		regex_constants::match_flag_type _Flgs =
; 2918 : 			regex_constants::match_default)
; 2919 : 	{	// search for regular expression match in target text
; 2920 : 	_DEBUG_RANGE(_First, _Last);
; 2921 : 	return (_Regex_search1(_Unchecked(_First), _Unchecked(_Last),
; 2922 : 		static_cast<match_results<decltype(_Unchecked(_First))> *>(0), _Re,
; 2923 : 			_Flgs | regex_constants::match_any, _Unchecked(_First)));
; 2924 : 	}
; 2925 : 
; 2926 : template<class _Elem,
; 2927 : 	class _RxTraits> inline
; 2928 : 	bool regex_search(_In_z_ const _Elem *_Str,
; 2929 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2930 : 		regex_constants::match_flag_type _Flgs =
; 2931 : 			regex_constants::match_default)
; 2932 : 	{	// search for regular expression match in target text
; 2933 : 	const _Elem *_Last = _Str + char_traits<_Elem>::length(_Str);
; 2934 : 	return (_Regex_search1(_Str, _Last,
; 2935 : 		static_cast<match_results<const _Elem *> *>(0), _Re,
; 2936 : 			_Flgs | regex_constants::match_any, _Str));
; 2937 : 	}
; 2938 : 
; 2939 : template<class _Elem,
; 2940 : 	class _Alloc,
; 2941 : 	class _RxTraits> inline
; 2942 : 	bool regex_search(_In_z_ const _Elem *_Str,
; 2943 : 		match_results<const _Elem *, _Alloc>& _Matches,
; 2944 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2945 : 		regex_constants::match_flag_type _Flgs =
; 2946 : 			regex_constants::match_default)
; 2947 : 	{	// search for regular expression match in target text
; 2948 : 	const _Elem *_Last = _Str + char_traits<_Elem>::length(_Str);
; 2949 : 	return (_Regex_search1(_Str, _Last, &_Matches, _Re, _Flgs, _Str));
; 2950 : 	}
; 2951 : 
; 2952 : template<class _StTraits,
; 2953 : 	class _StAlloc,
; 2954 : 	class _Alloc,
; 2955 : 	class _Elem,
; 2956 : 	class _RxTraits> inline
; 2957 : 	bool regex_search(
; 2958 : 		const basic_string<_Elem, _StTraits, _StAlloc>& _Str,
; 2959 : 		match_results<typename basic_string<_Elem, _StTraits, _StAlloc>
; 2960 : 			::const_iterator, _Alloc>& _Matches,
; 2961 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2962 : 		regex_constants::match_flag_type _Flgs =
; 2963 : 			regex_constants::match_default)
; 2964 : 	{	// search for regular expression match in target text
; 2965 : 	return (_Regex_search1(_Str.begin(), _Str.end(),
; 2966 : 		&_Matches, _Re, _Flgs, _Str.begin()));
; 2967 : 	}
; 2968 : 
; 2969 : template<class _StTraits,
; 2970 : 	class _StAlloc,
; 2971 : 	class _Alloc,
; 2972 : 	class _Elem,
; 2973 : 	class _RxTraits>
; 2974 : 	bool regex_search(
; 2975 : 		const basic_string<_Elem, _StTraits, _StAlloc>&&,
; 2976 : 		match_results<typename basic_string<_Elem, _StTraits, _StAlloc>
; 2977 : 			::const_iterator, _Alloc>&,
; 2978 : 		const basic_regex<_Elem, _RxTraits>&,
; 2979 : 		regex_constants::match_flag_type =
; 2980 : 			regex_constants::match_default) = delete;
; 2981 : 
; 2982 : template<class _StTraits,
; 2983 : 	class _StAlloc,
; 2984 : 	class _Elem,
; 2985 : 	class _RxTraits> inline
; 2986 : 	bool regex_search(
; 2987 : 		const basic_string<_Elem, _StTraits, _StAlloc>& _Str,
; 2988 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 2989 : 		regex_constants::match_flag_type _Flgs =
; 2990 : 			regex_constants::match_default)
; 2991 : 	{	// search for regular expression match in target text
; 2992 : 	typedef typename basic_string<_Elem, _StTraits, _StAlloc>
; 2993 : 		::const_pointer _Iter;
; 2994 : 
; 2995 : 	_Iter _First = _Str.c_str();
; 2996 : 	_Iter _Last = _First + _Str.size();
; 2997 : 	return (_Regex_search1(_First, _Last,
; 2998 : 		static_cast<match_results<_Iter> *>(0), _Re,
; 2999 : 			_Flgs | regex_constants::match_any, _First));
; 3000 : 	}
; 3001 : 
; 3002 : 	// TEMPLATE FUNCTION regex_replace
; 3003 : template<class _OutIt,
; 3004 : 	class _BidIt,
; 3005 : 	class _RxTraits,
; 3006 : 	class _Elem,
; 3007 : 	class _Traits,
; 3008 : 	class _Alloc> inline
; 3009 : 	_OutIt _Regex_replace1(_OutIt _Result,
; 3010 : 		_BidIt _First, _BidIt _Last,
; 3011 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3012 : 		const basic_string<_Elem, _Traits, _Alloc>& _Fmt,
; 3013 : 		regex_constants::match_flag_type _Flgs)
; 3014 : 	{	// search and replace
; 3015 : 	match_results<_BidIt> _Matches;
; 3016 : 	_BidIt _Pos = _First;
; 3017 : 	regex_constants::match_flag_type _Flags = _Flgs;
; 3018 : 	regex_constants::match_flag_type _Not_null =
; 3019 : 		(regex_constants::match_flag_type)0;
; 3020 : 
; 3021 : 	while (_Regex_search1(_Pos, _Last, &_Matches, _Re, _Flags | _Not_null, _Pos))
; 3022 : 		{	// replace at each match
; 3023 : 		if (!(_Flgs & regex_constants::format_no_copy))
; 3024 : 			_Result = _Copy_no_deprecate(_Matches.prefix().first,
; 3025 : 				_Matches.prefix().second, _Result);
; 3026 : 		_Result = _Matches._Format1(_Result,
; 3027 : 			_Unchecked(_Fmt.begin()), _Unchecked(_Fmt.end()), _Flags);
; 3028 : 
; 3029 : 		_Pos = _Matches[0].second;
; 3030 : 		if (_Pos == _Last
; 3031 : 			|| _Flgs & regex_constants::format_first_only)
; 3032 : 			break;
; 3033 : 
; 3034 : 		if (_Matches[0].first == _Matches[0].second)
; 3035 : 			_Not_null = regex_constants::_Match_not_null;
; 3036 : 		else
; 3037 : 			{	// non-null match, recognize earlier text
; 3038 : 			_Not_null = (regex_constants::match_flag_type)0;
; 3039 : 			_Flags |= regex_constants::match_prev_avail;
; 3040 : 			}
; 3041 : 		}
; 3042 : 	return (_Flgs & regex_constants::format_no_copy
; 3043 : 		? _Result : _Copy_no_deprecate(_Pos, _Last, _Result));
; 3044 : 	}
; 3045 : 
; 3046 : template<class _OutIt,
; 3047 : 	class _BidIt,
; 3048 : 	class _RxTraits,
; 3049 : 	class _Elem,
; 3050 : 	class _Traits,
; 3051 : 	class _Alloc> inline
; 3052 : 	_OutIt regex_replace(_OutIt _Result,
; 3053 : 		_BidIt _First, _BidIt _Last,
; 3054 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3055 : 		const basic_string<_Elem, _Traits, _Alloc>& _Fmt,
; 3056 : 		regex_constants::match_flag_type _Flgs =
; 3057 : 			regex_constants::match_default)
; 3058 : 	{	// search and replace, iterator result, string format
; 3059 : 	_DEPRECATE_UNCHECKED(regex_replace, _Result);
; 3060 : 	_DEBUG_RANGE(_First, _Last);
; 3061 : 	return (_Rechecked(_Result,
; 3062 : 		_Regex_replace1(_Unchecked_idl0(_Result), _Unchecked(_First), _Unchecked(_Last),
; 3063 : 		_Re, _Fmt, _Flgs)));
; 3064 : 	}
; 3065 : 
; 3066 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 3067 : template<class _OutTy,
; 3068 : 	size_t _OutSize,
; 3069 : 	class _BidIt,
; 3070 : 	class _RxTraits,
; 3071 : 	class _Elem,
; 3072 : 	class _Traits,
; 3073 : 	class _Alloc> inline
; 3074 : 	_OutTy *regex_replace(_OutTy (&_Result)[_OutSize],
; 3075 : 		_BidIt _First, _BidIt _Last,
; 3076 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3077 : 		const basic_string<_Elem, _Traits, _Alloc>& _Fmt,
; 3078 : 		regex_constants::match_flag_type _Flgs =
; 3079 : 			regex_constants::match_default)
; 3080 : 	{	// search and replace, array result, string format
; 3081 : 	return (_Unchecked(_STD regex_replace(
; 3082 : 		_Array_iterator<_OutTy, _OutSize>(_Result),
; 3083 : 		_First, _Last, _Re, _Fmt, _Flgs)));
; 3084 : 	}
; 3085 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 3086 : 
; 3087 : template<class _OutIt,
; 3088 : 	class _BidIt,
; 3089 : 	class _RxTraits,
; 3090 : 	class _Elem> inline
; 3091 : 	_OutIt regex_replace(_OutIt _Result,
; 3092 : 		_BidIt _First, _BidIt _Last,
; 3093 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3094 : 		const _Elem *_Ptr,
; 3095 : 		regex_constants::match_flag_type _Flgs =
; 3096 : 			regex_constants::match_default)
; 3097 : 	{	// search and replace, iterator result, NTBS format
; 3098 : 	const basic_string<_Elem> _Fmt(_Ptr);
; 3099 : 	return (_STD regex_replace(_Result,
; 3100 : 		_First, _Last, _Re, _Fmt, _Flgs));
; 3101 : 	}
; 3102 : 
; 3103 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 3104 : template<class _OutTy,
; 3105 : 	size_t _OutSize,
; 3106 : 	class _BidIt,
; 3107 : 	class _RxTraits,
; 3108 : 	class _Elem> inline
; 3109 : 	_OutTy *regex_replace(_OutTy (&_Result)[_OutSize],
; 3110 : 		_BidIt _First, _BidIt _Last,
; 3111 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3112 : 		const _Elem *_Ptr,
; 3113 : 		regex_constants::match_flag_type _Flgs =
; 3114 : 			regex_constants::match_default)
; 3115 : 	{	// search and replace, array result, NTBS format
; 3116 : 	const basic_string<_Elem> _Fmt(_Ptr);
; 3117 : 	return (_STD regex_replace(_Result,
; 3118 : 		_First, _Last, _Re, _Fmt, _Flgs));
; 3119 : 	}
; 3120 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 3121 : 
; 3122 : template<class _RxTraits,
; 3123 : 	class _Elem,
; 3124 : 	class _Traits1,
; 3125 : 	class _Alloc1,
; 3126 : 	class _Traits2,
; 3127 : 	class _Alloc2>
; 3128 : 	basic_string<_Elem, _Traits1, _Alloc1> regex_replace(
; 3129 : 		const basic_string<_Elem, _Traits1, _Alloc1>& _Str,
; 3130 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3131 : 		const basic_string<_Elem, _Traits2, _Alloc2>& _Fmt,
; 3132 : 		regex_constants::match_flag_type _Flgs =
; 3133 : 			regex_constants::match_default)
; 3134 : 	{	// search and replace, string result, string target, string format
; 3135 : 	basic_string<_Elem, _Traits1, _Alloc1> _Res;
; 3136 : 	_STD regex_replace(_STD back_inserter(_Res), _Str.begin(), _Str.end(),
; 3137 : 		_Re, _Fmt, _Flgs);
; 3138 : 	return (_Res);
; 3139 : 	}
; 3140 : 
; 3141 : template<class _RxTraits,
; 3142 : 	class _Elem,
; 3143 : 	class _Traits1,
; 3144 : 	class _Alloc1>
; 3145 : 	basic_string<_Elem, _Traits1, _Alloc1> regex_replace(
; 3146 : 		const basic_string<_Elem, _Traits1, _Alloc1>& _Str,
; 3147 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3148 : 		const _Elem *_Ptr,
; 3149 : 		regex_constants::match_flag_type _Flgs =
; 3150 : 			regex_constants::match_default)
; 3151 : 	{	// search and replace, string result, string target, NTBS format
; 3152 : 	basic_string<_Elem, _Traits1, _Alloc1> _Res;
; 3153 : 	const basic_string<_Elem> _Fmt(_Ptr);
; 3154 : 	_STD regex_replace(_STD back_inserter(_Res), _Str.begin(), _Str.end(),
; 3155 : 		_Re, _Fmt, _Flgs);
; 3156 : 	return (_Res);
; 3157 : 	}
; 3158 : 
; 3159 : template<class _RxTraits,
; 3160 : 	class _Elem,
; 3161 : 	class _Traits2,
; 3162 : 	class _Alloc2>
; 3163 : 	basic_string<_Elem> regex_replace(
; 3164 : 		const _Elem *_Pstr,
; 3165 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3166 : 		const basic_string<_Elem, _Traits2, _Alloc2>& _Fmt,
; 3167 : 		regex_constants::match_flag_type _Flgs =
; 3168 : 			regex_constants::match_default)
; 3169 : 	{	// search and replace, string result, NTBS target, string format
; 3170 : 	basic_string<_Elem> _Res;
; 3171 : 	const basic_string<_Elem> _Str(_Pstr);
; 3172 : 	_STD regex_replace(_STD back_inserter(_Res), _Str.begin(), _Str.end(),
; 3173 : 		_Re, _Fmt, _Flgs);
; 3174 : 	return (_Res);
; 3175 : 	}
; 3176 : 
; 3177 : template<class _RxTraits,
; 3178 : 	class _Elem>
; 3179 : 	basic_string<_Elem> regex_replace(
; 3180 : 		const _Elem *_Pstr,
; 3181 : 		const basic_regex<_Elem, _RxTraits>& _Re,
; 3182 : 		const _Elem *_Ptr,
; 3183 : 		regex_constants::match_flag_type _Flgs =
; 3184 : 			regex_constants::match_default)
; 3185 : 	{	// search and replace, string result, NTBS target, NTBS format
; 3186 : 	basic_string<_Elem> _Res;
; 3187 : 	const basic_string<_Elem> _Str(_Pstr);
; 3188 : 	const basic_string<_Elem> _Fmt(_Ptr);
; 3189 : 	_STD regex_replace(_STD back_inserter(_Res), _Str.begin(), _Str.end(),
; 3190 : 		_Re, _Fmt, _Flgs);
; 3191 : 	return (_Res);
; 3192 : 	}
; 3193 : 
; 3194 : 	// TEMPLATE CLASS regex_iterator
; 3195 : template<class _BidIt,
; 3196 : 	class _Elem = _Iter_value_t<_BidIt>,
; 3197 : 	class _RxTraits = regex_traits<_Elem> >
; 3198 : 	class regex_iterator
; 3199 : 		: public _Iterator012<forward_iterator_tag,
; 3200 : 			match_results<_BidIt>,
; 3201 : 			ptrdiff_t,
; 3202 : 			match_results<_BidIt> *,
; 3203 : 			match_results<_BidIt>&,
; 3204 : 			_Iterator_base>
; 3205 : 	{	// iterator for full regular expression matches
; 3206 : public:
; 3207 : 	typedef regex_iterator<_BidIt, _Elem, _RxTraits> _Myt;
; 3208 : 	typedef basic_regex<_Elem, _RxTraits> regex_type;
; 3209 : 	typedef match_results<_BidIt> value_type;
; 3210 : 	typedef ptrdiff_t difference_type;
; 3211 : 	typedef const value_type *pointer;
; 3212 : 	typedef const value_type& reference;
; 3213 : 	typedef forward_iterator_tag iterator_category;
; 3214 : 
; 3215 : 	regex_iterator()
; 3216 : 		: _MyRe(0)
; 3217 : 		{	// construct end of sequence iterator
; 3218 : 		}
; 3219 : 
; 3220 : 	regex_iterator(_BidIt _First, _BidIt _Last,
; 3221 : 		const regex_type& _Re,
; 3222 : 		regex_constants::match_flag_type _Fl =
; 3223 : 			regex_constants::match_default)
; 3224 : 		: _Begin(_First), _End(_Last), _MyRe(&_Re), _Flags(_Fl)
; 3225 : 		{	// construct from regular expression and target text
; 3226 : 		_DEBUG_RANGE(_Begin, _End);
; 3227 : 		if (!_Regex_search1(_Begin, _End, &_MyVal, *_MyRe, _Flags, _Begin))
; 3228 : 			_MyRe = 0;
; 3229 : 		else
; 3230 : 			this->_Adopt(_MyRe);
; 3231 : 		}
; 3232 : 
; 3233 : 	regex_iterator(_BidIt, _BidIt,
; 3234 : 		const regex_type&&,
; 3235 : 		regex_constants::match_flag_type =
; 3236 : 			regex_constants::match_default) = delete;
; 3237 : 
; 3238 : 	bool operator==(const _Myt& _Right) const
; 3239 : 		{	// test for equality
; 3240 : 		if (_MyRe != _Right._MyRe)
; 3241 : 			return (false);
; 3242 : 		else if (_MyRe == 0)
; 3243 : 			return (true);
; 3244 : 		return (_Begin == _Right._Begin
; 3245 : 			&& _End == _Right._End
; 3246 : 			&& _Flags == _Right._Flags
; 3247 : 			&& _MyVal._At(0) == _Right._MyVal._At(0));
; 3248 : 		}
; 3249 : 
; 3250 : 	bool operator!=(const _Myt& _Right) const
; 3251 : 		{	// test for inequality
; 3252 : 		return (!(*this == _Right));
; 3253 : 		}
; 3254 : 
; 3255 : 	const value_type& operator*() const
; 3256 : 		{	// return designated match
; 3257 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3258 : 		if (_MyRe == 0)
; 3259 : 			{	// report error
; 3260 : 			_DEBUG_ERROR("regex_iterator not dereferencable");
; 3261 : 			}
; 3262 : 
; 3263 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3264 : 		_SCL_SECURE_VALIDATE_RANGE(_MyRe != 0);
; 3265 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3266 : 
; 3267 : 		return (_MyVal);
; 3268 : 		}
; 3269 : 
; 3270 : 	pointer operator->() const
; 3271 : 		{	// return pointer to designated match
; 3272 : 		return (pointer_traits<pointer>::pointer_to(**this));
; 3273 : 		}
; 3274 : 
; 3275 : 	_Myt& operator++()
; 3276 : 		{	// preincrement
; 3277 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3278 : 		if (_MyRe == 0)
; 3279 : 			{	// report error
; 3280 : 			_DEBUG_ERROR("regex_iterator not incrementable");
; 3281 : 			}
; 3282 : 
; 3283 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3284 : 		_SCL_SECURE_VALIDATE_RANGE(_MyRe != 0);
; 3285 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3286 : 
; 3287 : 		if (_MyRe == 0)
; 3288 : 			return (*this);
; 3289 : 
; 3290 : 		_BidIt _Start = _MyVal._At(0).second;
; 3291 : 
; 3292 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3293 : 		if (this->_Getcont() == 0)
; 3294 : 			{	// report error
; 3295 : 			_DEBUG_ERROR("regex_iterator orphaned");
; 3296 : 			}
; 3297 : 
; 3298 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3299 : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 3300 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3301 : 
; 3302 : 		if (_MyVal._At(0).first == _MyVal._At(0).second)
; 3303 : 			{	// handle zero-length match
; 3304 : 			if (_Start == _End)
; 3305 : 				{	// store end-of-sequence iterator
; 3306 : 				_MyRe = 0;
; 3307 : 
; 3308 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3309 : 		this->_Orphan_me();
; 3310 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3311 : 
; 3312 : 				return (*this);
; 3313 : 				}
; 3314 : 
; 3315 : 			// _DEBUG_RANGE(_Start, _End) checked in constructor
; 3316 : 			if (_Regex_search1(_Start, _End, &_MyVal, *_MyRe,
; 3317 : 				_Flags | regex_constants::match_not_null
; 3318 : 					| regex_constants::match_continuous,
; 3319 : 				_Begin))
; 3320 : 				return (*this);
; 3321 : 			++_Start;
; 3322 : 			}
; 3323 : 		_Flags = _Flags | regex_constants::match_prev_avail;
; 3324 : 
; 3325 : 		// _DEBUG_RANGE(_Start, _End) checked in constructor
; 3326 : 		if (_Regex_search1(_Start, _End, &_MyVal, *_MyRe, _Flags, _Begin))
; 3327 : 			return (*this);
; 3328 : 		else
; 3329 : 			{	// mark at end of sequence
; 3330 : 			_MyRe = 0;
; 3331 : 			return (*this);
; 3332 : 			}
; 3333 : 		}
; 3334 : 
; 3335 : 	_Myt operator++(int)
; 3336 : 		{	// postincrement
; 3337 : 		_Myt _Tmp = *this;
; 3338 : 		++*this;
; 3339 : 		return (_Tmp);
; 3340 : 		}
; 3341 : 
; 3342 : 	bool _Atend() const
; 3343 : 		{	// test for end iterator
; 3344 : 		return (_MyRe == 0);
; 3345 : 		}
; 3346 : 
; 3347 : private:
; 3348 : 	_BidIt _Begin, _End;			// input sequence
; 3349 : 	const regex_type *_MyRe;		// pointer to basic_regex object
; 3350 : 	regex_constants::match_flag_type _Flags;
; 3351 : 	match_results<_BidIt> _MyVal;	// lookahead value (if _MyRe not null)
; 3352 : 	};
; 3353 : 
; 3354 : typedef regex_iterator<const char *> cregex_iterator;
; 3355 : typedef regex_iterator<const wchar_t *> wcregex_iterator;
; 3356 : typedef regex_iterator<string::const_iterator> sregex_iterator;
; 3357 : typedef regex_iterator<wstring::const_iterator> wsregex_iterator;
; 3358 : 
; 3359 : 	// TEMPLATE CLASS regex_token_iterator
; 3360 : template<class _BidIt,
; 3361 : 	class _Elem = _Iter_value_t<_BidIt>,
; 3362 : 	class _RxTraits = regex_traits<_Elem> >
; 3363 : class regex_token_iterator
; 3364 : 	{	// iterator for regular expression submatches
; 3365 : public:
; 3366 : 	typedef regex_iterator<_BidIt, _Elem, _RxTraits> _Position;
; 3367 : 	typedef regex_token_iterator<_BidIt, _Elem, _RxTraits> _Myt;
; 3368 : 	typedef basic_regex<_Elem, _RxTraits> regex_type;
; 3369 : 	typedef sub_match<_BidIt> value_type;
; 3370 : 	typedef ptrdiff_t difference_type;
; 3371 : 	typedef const value_type *pointer;
; 3372 : 	typedef const value_type &reference;
; 3373 : 	typedef forward_iterator_tag iterator_category;
; 3374 : 
; 3375 : 	regex_token_iterator()
; 3376 : 		: _Res(0)
; 3377 : 		{	// construct end of sequence iterator
; 3378 : 		}
; 3379 : 
; 3380 : 	regex_token_iterator(_BidIt _First, _BidIt _Last,
; 3381 : 		const regex_type& _Re, int _Sub = 0,
; 3382 : 		regex_constants::match_flag_type _Fl =
; 3383 : 			regex_constants::match_default)
; 3384 : 		: _Pos(_First, _Last, _Re, _Fl), _Cur(0), _Subs(&_Sub, &_Sub + 1)
; 3385 : 		{	// construct from RE, target text, and single submatch specifier
; 3386 : 		_Init(_First, _Last);
; 3387 : 		}
; 3388 : 
; 3389 : 	regex_token_iterator(_BidIt _First, _BidIt _Last,
; 3390 : 		const regex_type& _Re, const vector<int>& _Subx,
; 3391 : 		regex_constants::match_flag_type _Fl =
; 3392 : 			regex_constants::match_default)
; 3393 : 		: _Pos(_First, _Last, _Re, _Fl), _Cur(0),
; 3394 : 			_Subs(_Subx.begin(), _Subx.end())
; 3395 : 		{	// construct from RE, target text, and vector submatch specifier
; 3396 : 		if (_Subs.empty())
; 3397 : 			_Res = 0;	// treat empty vector as end of sequence
; 3398 : 		else
; 3399 : 			_Init(_First, _Last);
; 3400 : 		}
; 3401 : 
; 3402 : 	template<size_t _Nx>
; 3403 : 		regex_token_iterator(_BidIt _First, _BidIt _Last,
; 3404 : 			const regex_type& _Re,
; 3405 : 			const int (&_Subx)[_Nx],
; 3406 : 			regex_constants::match_flag_type _Fl =
; 3407 : 				regex_constants::match_default)
; 3408 : 		: _Pos(_First, _Last, _Re, _Fl), _Cur(0),
; 3409 : 			_Subs(_Subx, _Subx + _Nx)
; 3410 : 		{	// construct from RE, target text, and array submatch specifier
; 3411 : 		_Init(_First, _Last);
; 3412 : 		}
; 3413 : 
; 3414 : 	regex_token_iterator(_BidIt _First, _BidIt _Last,
; 3415 : 		const regex_type& _Re,
; 3416 : 		initializer_list<int> _Ilist,
; 3417 : 		regex_constants::match_flag_type _Fl =
; 3418 : 			regex_constants::match_default)
; 3419 : 		: _Pos(_First, _Last, _Re, _Fl), _Cur(0),
; 3420 : 			_Subs(_Ilist.begin(), _Ilist.end())
; 3421 : 		{	// construct from RE, target text, and ilist submatch specifier
; 3422 : 		_Init(_First, _Last);
; 3423 : 		}
; 3424 : 
; 3425 : 	regex_token_iterator(_BidIt, _BidIt,
; 3426 : 		const regex_type&&, int = 0,
; 3427 : 		regex_constants::match_flag_type =
; 3428 : 			regex_constants::match_default) = delete;
; 3429 : 
; 3430 : 	regex_token_iterator(_BidIt, _BidIt,
; 3431 : 		const regex_type&&, const vector<int>&,
; 3432 : 		regex_constants::match_flag_type =
; 3433 : 			regex_constants::match_default) = delete;
; 3434 : 
; 3435 : 	template<size_t _Nx>
; 3436 : 		regex_token_iterator(_BidIt, _BidIt,
; 3437 : 			const regex_type&&,
; 3438 : 			const int (&)[_Nx],
; 3439 : 			regex_constants::match_flag_type =
; 3440 : 				regex_constants::match_default) = delete;
; 3441 : 
; 3442 : 	regex_token_iterator(_BidIt, _BidIt,
; 3443 : 		const regex_type&&,
; 3444 : 		initializer_list<int>,
; 3445 : 		regex_constants::match_flag_type =
; 3446 : 			regex_constants::match_default) = delete;
; 3447 : 
; 3448 : 	regex_token_iterator(const regex_token_iterator& _Right)
; 3449 : 		: _Pos(_Right._Pos), _Cur(_Right._Cur),
; 3450 : 			_Suffix(_Right._Suffix), _Subs(_Right._Subs)
; 3451 : 		{	// construct copy of _Right
; 3452 : 		if (_Right._Res == 0)
; 3453 : 			_Res = 0;
; 3454 : 		else if (_Right._Res == &_Right._Suffix)
; 3455 : 			_Res = &_Suffix;
; 3456 : 		else
; 3457 : 			_Res = _Current();
; 3458 : 		}
; 3459 : 
; 3460 : 	regex_token_iterator& operator=(const regex_token_iterator& _Right)
; 3461 : 		{	// assign from _Right
; 3462 : 		if (this != _STD addressof(_Right))
; 3463 : 			{	// copy from _Right
; 3464 : 			_Pos = _Right._Pos;
; 3465 : 			_Cur = _Right._Cur;
; 3466 : 			_Suffix = _Right._Suffix;
; 3467 : 			_Subs = _Right._Subs;
; 3468 : 			if (_Right._Res == 0)
; 3469 : 				_Res = 0;
; 3470 : 			else if (_Right._Res == &_Right._Suffix)
; 3471 : 				_Res = &_Suffix;
; 3472 : 			else
; 3473 : 				_Res = _Current();
; 3474 : 			}
; 3475 : 		return (*this);
; 3476 : 		}
; 3477 : 
; 3478 : 	bool operator==(const _Myt& _Right) const
; 3479 : 		{	// test for equality
; 3480 : 		if (_Res == 0 || _Right._Res == 0)
; 3481 : 			return (_Res == _Right._Res);
; 3482 : 		else if (*_Res == *_Right._Res
; 3483 : 			&& _Pos == _Right._Pos
; 3484 : 			&& _Subs == _Right._Subs)
; 3485 : 			return (true);
; 3486 : 		else
; 3487 : 			return (false);
; 3488 : 		}
; 3489 : 
; 3490 : 	bool operator!=(const _Myt& _Right) const
; 3491 : 		{	// test for inequality
; 3492 : 		return (!(*this == _Right));
; 3493 : 		}
; 3494 : 
; 3495 : 	const value_type& operator*() const
; 3496 : 		{	// return designated submatch
; 3497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3498 : 		if (_Res == 0)
; 3499 : 			{	// report error
; 3500 : 			_DEBUG_ERROR("regex_token_iterator not dereferencable");
; 3501 : 			}
; 3502 : 
; 3503 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3504 : 		_SCL_SECURE_VALIDATE_RANGE(_Res != 0);
; 3505 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3506 : 
; 3507 : 		_Analysis_assume_(_Res != 0);
; 3508 : 
; 3509 : 		return (*_Res);
; 3510 : 		}
; 3511 : 
; 3512 : 	pointer operator->() const
; 3513 : 		{	// return pointer to designated submatch
; 3514 : 		return (pointer_traits<pointer>::pointer_to(**this));
; 3515 : 		}
; 3516 : 
; 3517 : 	_Myt& operator++()
; 3518 : 		{	// preincrement
; 3519 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3520 : 		if (_Res == 0)
; 3521 : 			{	// report error
; 3522 : 			_DEBUG_ERROR("regex_token_iterator not incrementable");
; 3523 : 			}
; 3524 : 
; 3525 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 3526 : 		_SCL_SECURE_VALIDATE_RANGE(_Res != 0);
; 3527 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 3528 : 
; 3529 : 		_Position _Prev(_Pos);
; 3530 : 		if (_Res == 0)
; 3531 : 			;
; 3532 : 		else if (_Res == &_Suffix)
; 3533 : 			_Res = 0;
; 3534 : 		else if (++_Cur < _Subs.size())
; 3535 : 			_Res = _Current();
; 3536 : 		else
; 3537 : 			{	// advance to next full match
; 3538 : 			_Cur = 0;
; 3539 : 			++_Pos;
; 3540 : 			if (!_Pos._Atend())
; 3541 : 				_Res = _Current();
; 3542 : 			else if (_Has_suffix() && _Prev->suffix().length() != 0)
; 3543 : 				{	// mark suffix
; 3544 : 				_Suffix.matched = true;
; 3545 : 				_Suffix.first = _Prev->suffix().first;
; 3546 : 				_Suffix.second = _Prev->suffix().second;
; 3547 : 				_Res = &_Suffix;
; 3548 : 				}
; 3549 : 			else
; 3550 : 				_Res = 0;
; 3551 : 			}
; 3552 : 		return (*this);
; 3553 : 		}
; 3554 : 
; 3555 : 	_Myt operator++(int)
; 3556 : 		{	// postincrement
; 3557 : 		_Myt _Tmp = *this;
; 3558 : 		++*this;
; 3559 : 		return (_Tmp);
; 3560 : 		}
; 3561 : 
; 3562 : private:
; 3563 : 	_Position _Pos;
; 3564 : 	const value_type *_Res;
; 3565 : 	value_type _Suffix;
; 3566 : 	size_t _Cur;
; 3567 : 	vector<int> _Subs;
; 3568 : 
; 3569 : 	bool _Has_suffix() const
; 3570 : 		{	// check for suffix specifier
; 3571 : 		return (_STD find(_Subs.begin(), _Subs.end(), -1) != _Subs.end());
; 3572 : 		}
; 3573 : 
; 3574 : 	void _Init(_BidIt _First, _BidIt _Last)
; 3575 : 		{	// initialize
; 3576 : 		_DEBUG_RANGE(_First, _Last);
; 3577 : 		if (!_Pos._Atend())
; 3578 : 			_Res = _Current();
; 3579 : 		else if (_Has_suffix())
; 3580 : 			{	// mark suffix (no match)
; 3581 : 			_Suffix.matched = true;
; 3582 : 			_Suffix.first = _First;
; 3583 : 			_Suffix.second = _Last;
; 3584 : 			_Res = &_Suffix;
; 3585 : 			}
; 3586 : 		else
; 3587 : 			_Res = 0;
; 3588 : 		}
; 3589 : 
; 3590 : 	const value_type *_Current() const
; 3591 : 		{	// return pointer to current submatch
; 3592 : 		return (&(_Subs[_Cur] == -1
; 3593 : 			? _Pos->prefix() : (*_Pos)[_Subs[_Cur]]));
; 3594 : 		}
; 3595 : 	};
; 3596 : 
; 3597 : typedef regex_token_iterator<const char *> cregex_token_iterator;
; 3598 : typedef regex_token_iterator<const wchar_t *> wcregex_token_iterator;
; 3599 : typedef regex_token_iterator<string::const_iterator> sregex_token_iterator;
; 3600 : typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
; 3601 : 
; 3602 : 	// IMPLEMENTATION OF _Builder
; 3603 : template<class _FwdIt,
; 3604 : 	class _Elem,
; 3605 : 	class _RxTraits> inline
; 3606 : 	_Builder<_FwdIt, _Elem, _RxTraits>::_Builder(
; 3607 : 		const _RxTraits& _Tr,
; 3608 : 		regex_constants::syntax_option_type _Fx)
; 3609 : 	: _Root(new _Root_node),

	jmp	SHORT $LN4@Builder
$LN3@Builder:
	xor	eax, eax
$LN4@Builder:

; 3610 : 		_Current(_Root),
; 3611 : 		_Flags(_Fx),

	mov	ecx, DWORD PTR __Fx$[ebp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax

; 3612 : 		_Traits(_Tr),

	mov	eax, DWORD PTR __Tr$[ebp]
	mov	DWORD PTR [esi+12], eax

; 3613 : 		_Bmax(static_cast<int>(_Fx & regex_constants::collate ? 0U : _Bmp_max)),

	mov	eax, ecx
	mov	DWORD PTR [esi+8], ecx
	shr	eax, 3

; 3614 : 		_Tmax(static_cast<int>(_Fx & regex_constants::collate ? 0U : _ARRAY_THRESHOLD))

	shr	ecx, 9
	not	eax
	and	eax, 256				; 00000100H
	not	ecx
	mov	DWORD PTR [esi+16], eax
	and	ecx, 4
	mov	DWORD PTR [esi+20], ecx

; 3616 : 	}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@W4syntax_option_type@regex_constants@1@@Z ENDP ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
__Pos2$1$ = -4						; size = 4
?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Disjunction, COMDAT
; _this$ = ecx

; 5625 : 	{	// check for valid disjunction

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 3647 : 	return (_Current);

	mov	ebx, DWORD PTR [edi+40]

; 5626 : 	_Node_base *_Pos1 = _Nfa._Getmark();
; 5627 : 	if (_Alternative())

	call	?_Alternative@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Alternative
	test	al, al
	jne	SHORT $LN7@Disjunctio

; 5628 : 		;
; 5629 : 	else if (_Mchar != _Meta_bar)

	cmp	DWORD PTR [edi+76], 124			; 0000007cH
	jne	$LN3@Disjunctio

; 3968 : 	return (_New_node(_N_group));

	push	8
	lea	ecx, DWORD PTR [edi+36]
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 5630 : 		return;	// zero-length alternative not followed by '|'
; 5631 : 	else
; 5632 : 		{	// zero-length leading alternative
; 5633 : 		_Node_base *_Pos3 = _Nfa._Begin_group();
; 5634 : 		_Nfa._End_group(_Pos3);

	push	eax
	lea	ecx, DWORD PTR [edi+36]
	call	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group
$LN7@Disjunctio:

; 5635 : 		}
; 5636 : 
; 5637 : 	_Node_base *_Pos2 = _Nfa._Begin_if(_Pos1);

	push	ebx
	lea	ecx, DWORD PTR [edi+36]
	call	?_Begin_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@PAV32@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_if

; 5638 : 	while (_Mchar == _Meta_bar)

	cmp	DWORD PTR [edi+76], 124			; 0000007cH
	mov	DWORD PTR __Pos2$1$[ebp], eax
	jne	$LN3@Disjunctio
	npad	4
$LL2@Disjunctio:

; 4988 : 	if (_Pat != _End)

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	je	SHORT $LN15@Disjunctio

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [ecx], 92			; 0000005cH
	jne	SHORT $LN16@Disjunctio

; 4893 : 	return (++_Ch0 != _End

	add	ecx, 2
	cmp	ecx, eax
	je	SHORT $LN16@Disjunctio
	mov	eax, DWORD PTR [edi+80]
	test	al, 8
	jne	SHORT $LN21@Disjunctio
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN42@Disjunctio
	cmp	edx, 41					; 00000029H
	je	SHORT $LN42@Disjunctio
$LN21@Disjunctio:
	test	al, 16					; 00000010H
	jne	SHORT $LN16@Disjunctio
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN42@Disjunctio
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN16@Disjunctio
$LN42@Disjunctio:

; 4991 : 			++_Pat;

	mov	DWORD PTR [edi], ecx
$LN16@Disjunctio:

; 4992 : 		++_Pat;

	add	DWORD PTR [edi], 2
$LN15@Disjunctio:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, edi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5639 : 		{	// append terms as long as we keep finding | characters
; 5640 : 		_Next();
; 5641 : 		if (!_Alternative())

	mov	ecx, edi
	call	?_Alternative@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Alternative
	test	al, al
	jne	SHORT $LN8@Disjunctio

; 3706 : 	return (_Link_node(new _Node_base(_Kind)));

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN30@Disjunctio

; 1677 : 		{	// construct

	mov	DWORD PTR [eax], OFFSET ??_7_Node_base@std@@6B@
	mov	DWORD PTR [eax+4], 8
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0

; 3706 : 	return (_Link_node(new _Node_base(_Kind)));

	jmp	SHORT $LN31@Disjunctio
$LN30@Disjunctio:
	xor	eax, eax
$LN31@Disjunctio:

; 3676 : 	_Nx->_Prev = _Current;

	mov	ecx, DWORD PTR [edi+40]
	mov	DWORD PTR [eax+16], ecx

; 3677 : 	if (_Current->_Next)

	mov	ecx, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN36@Disjunctio

; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;

	mov	DWORD PTR [eax+12], ecx

; 3680 : 		_Current->_Next->_Prev = _Nx;

	mov	ecx, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+16], eax
$LN36@Disjunctio:

; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;

	mov	ecx, DWORD PTR [edi+40]

; 5642 : 			{	// zero-length trailing alternative
; 5643 : 			_Node_base *_Pos3 = _Nfa._Begin_group();
; 5644 : 			_Nfa._End_group(_Pos3);

	push	eax

; 3682 : 	_Current->_Next = _Nx;

	mov	DWORD PTR [ecx+12], eax

; 5642 : 			{	// zero-length trailing alternative
; 5643 : 			_Node_base *_Pos3 = _Nfa._Begin_group();
; 5644 : 			_Nfa._End_group(_Pos3);

	lea	ecx, DWORD PTR [edi+36]

; 3683 : 	_Current = _Nx;

	mov	DWORD PTR [edi+40], eax

; 5642 : 			{	// zero-length trailing alternative
; 5643 : 			_Node_base *_Pos3 = _Nfa._Begin_group();
; 5644 : 			_Nfa._End_group(_Pos3);

	call	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group
$LN8@Disjunctio:

; 5645 : 			}
; 5646 : 		_Nfa._Else_if(_Pos1, _Pos2);

	push	DWORD PTR __Pos2$1$[ebp]
	lea	ecx, DWORD PTR [edi+36]
	push	ebx
	call	?_Else_if@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@0@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Else_if
	cmp	DWORD PTR [edi+76], 124			; 0000007cH
	je	$LL2@Disjunctio
$LN3@Disjunctio:
	pop	edi
	pop	esi
	pop	ebx

; 5647 : 		}
; 5648 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Disjunction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Alternative@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ
_TEXT	SEGMENT
?_Alternative@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Alternative, COMDAT
; _this$ = ecx

; 5543 : 	{	// check for valid alternative

	npad	2
	push	esi
	mov	esi, ecx

; 5544 : 	bool _Found = false;

	xor	cl, cl

; 5545 : 	for (; ; )
; 5546 : 		{	// concatenate valid elements
; 5547 : 		bool _Quant = true;
; 5548 : 		if (_Mchar == _Meta_eos || _Mchar == _Meta_bar
; 5549 : 			|| (_Mchar == _Meta_rpar && _Disj_count != 0))

	cmp	DWORD PTR [esi+76], -1
	je	$LN7@Alternativ
	push	ebx
$LL2@Alternativ:
	mov	eax, DWORD PTR [esi+76]
	cmp	eax, 124				; 0000007cH
	je	$LN73@Alternativ
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN8@Alternativ
	cmp	DWORD PTR [esi+16], 0
	jne	$LN73@Alternativ

; 5551 : 		else if (_Mchar == _Meta_rpar && !(_L_flags & _L_paren_bal))

	test	DWORD PTR [esi+80], 268435456		; 10000000H
	je	$LN75@Alternativ
$LN8@Alternativ:

; 5553 : 		else if (_Mchar == _Meta_dot)

	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN10@Alternativ

; 3746 : 	_New_node(_N_dot);

	push	5

; 5554 : 			{	// add dot node
; 5555 : 			_Nfa._Add_dot();

	lea	ecx, DWORD PTR [esi+36]

; 3746 : 	_New_node(_N_dot);

	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	cmp	eax, ecx
	je	SHORT $LN38@Alternativ

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN39@Alternativ

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, ecx
	je	SHORT $LN39@Alternativ
	mov	ecx, DWORD PTR [esi+80]
	test	cl, 8
	jne	SHORT $LN44@Alternativ
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN70@Alternativ
	cmp	edx, 41					; 00000029H
	je	SHORT $LN70@Alternativ
$LN44@Alternativ:
	test	cl, 16					; 00000010H
	jne	SHORT $LN39@Alternativ
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN70@Alternativ
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN39@Alternativ
$LN70@Alternativ:

; 4991 : 			++_Pat;

	mov	DWORD PTR [esi], eax
$LN39@Alternativ:

; 4992 : 		++_Pat;

	add	DWORD PTR [esi], 2
$LN38@Alternativ:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, esi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 4995 : 	}

	jmp	$LN71@Alternativ
$LN10@Alternativ:

; 5556 : 			_Next();
; 5557 : 			}
; 5558 : 		else if (_Mchar == _Meta_esc)

	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN12@Alternativ

; 5559 : 			{	// check for valid escape sequence
; 5560 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5561 : 			if ((_L_flags & _L_asrt_wrd) && _Char == _Esc_word)

	mov	eax, DWORD PTR [esi+80]
	and	eax, 128				; 00000080H
	je	SHORT $LN14@Alternativ
	cmp	WORD PTR [esi+72], 98			; 00000062H
	jne	SHORT $LN14@Alternativ

; 3738 : 	_New_node(_N_wbound);

	push	4

; 5562 : 				{	// add word assert
; 5563 : 				_Nfa._Add_wbound();

	lea	ecx, DWORD PTR [esi+36]

; 3738 : 	_New_node(_N_wbound);

	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 5564 : 				_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5565 : 				_Quant = false;

	jmp	$LN33@Alternativ
$LN14@Alternativ:

; 5566 : 				}
; 5567 : 			else if ((_L_flags & _L_asrt_wrd) && _Char == _Esc_not_word)

	test	eax, eax
	je	SHORT $LN16@Alternativ
	cmp	WORD PTR [esi+72], 66			; 00000042H
	jne	SHORT $LN16@Alternativ

; 3738 : 	_New_node(_N_wbound);

	push	4

; 5568 : 				{	// add not-word assert
; 5569 : 				_Nfa._Add_wbound();

	lea	ecx, DWORD PTR [esi+36]

; 3738 : 	_New_node(_N_wbound);

	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 3631 : 	_Current->_Flags ^= _Fl_negate;

	mov	eax, DWORD PTR [esi+40]

; 5570 : 				_Nfa._Negate();
; 5571 : 				_Next();

	mov	ecx, esi

; 1528 : 	return (_Left = _Node_flags((int)_Left ^ _Right));

	xor	DWORD PTR [eax+8], 1

; 5570 : 				_Nfa._Negate();
; 5571 : 				_Next();

	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5572 : 				_Quant = false;
; 5573 : 				}
; 5574 : 			else

	jmp	$LN33@Alternativ
$LN16@Alternativ:

; 5575 : 				_AtomEscape();

	mov	ecx, esi
	call	?_AtomEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_AtomEscape
	jmp	$LN71@Alternativ
$LN12@Alternativ:

; 5576 : 			}
; 5577 : 		else if (_Mchar == _Meta_lsq)

	cmp	eax, 91					; 0000005bH
	jne	SHORT $LN18@Alternativ

; 5578 : 			{	// add bracket expression
; 5579 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5580 : 			_CharacterClass();

	mov	ecx, esi
	call	?_CharacterClass@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClass

; 5581 : 			_Expect(_Meta_rsq, regex_constants::error_brack);

	push	4
	push	93					; 0000005dH
	mov	ecx, esi
	call	?_Expect@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Expect
	jmp	$LN71@Alternativ
$LN18@Alternativ:

; 5582 : 			}
; 5583 : 		else if (_Mchar == _Meta_lpar)

	cmp	eax, 40					; 00000028H
	jne	SHORT $LN20@Alternativ

; 5584 : 			{	// check for valid group
; 5585 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5586 : 			_Quant = _Wrapped_disjunction();

	mov	ecx, esi
	call	?_Wrapped_disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Wrapped_disjunction

; 5587 : 			_Expect(_Meta_rpar, regex_constants::error_paren);

	push	5
	push	41					; 00000029H
	mov	ecx, esi
	mov	bl, al
	call	?_Expect@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Expect

; 5614 : 			}
; 5615 : 		if (_Quant)

	test	bl, bl
	je	SHORT $LN33@Alternativ
	jmp	SHORT $LN71@Alternativ
$LN20@Alternativ:

; 5588 : 			}
; 5589 : 		else if (_Mchar == _Meta_caret)

	cmp	eax, 94					; 0000005eH
	jne	SHORT $LN22@Alternativ

; 3722 : 	_New_node(_N_bol);

	push	2

; 5590 : 			{	// add bol node
; 5591 : 			_Nfa._Add_bol();

	lea	ecx, DWORD PTR [esi+36]

; 3722 : 	_New_node(_N_bol);

	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 5592 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5593 : 			_Quant = false;

	jmp	SHORT $LN33@Alternativ
$LN22@Alternativ:

; 5594 : 			}
; 5595 : 		else if (_Mchar == _Meta_dlr)

	cmp	eax, 36					; 00000024H
	jne	SHORT $LN24@Alternativ

; 3730 : 	_New_node(_N_eol);

	push	3

; 5596 : 			{	// add eol node
; 5597 : 			_Nfa._Add_eol();

	lea	ecx, DWORD PTR [esi+36]

; 3730 : 	_New_node(_N_eol);

	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 5598 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5599 : 			_Quant = false;
; 5600 : 			}
; 5601 : 		else if (_Mchar == _Meta_star

	jmp	SHORT $LN33@Alternativ
$LN24@Alternativ:

; 5602 : 			|| _Mchar == _Meta_plus
; 5603 : 			|| _Mchar == _Meta_query
; 5604 : 			|| _Mchar == _Meta_lbr)

	cmp	eax, 42					; 0000002aH
	je	SHORT $LN28@Alternativ
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN28@Alternativ
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN28@Alternativ
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN28@Alternativ

; 5606 : 		else if (_Mchar == _Meta_rbr && !(_L_flags & _L_paren_bal))

	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN29@Alternativ
	test	DWORD PTR [esi+80], 268435456		; 10000000H
	je	SHORT $LN65@Alternativ
$LN29@Alternativ:

; 5608 : 		else if (_Mchar == _Meta_rsq && !(_L_flags & _L_paren_bal))

	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN31@Alternativ
	test	DWORD PTR [esi+80], 268435456		; 10000000H
	je	SHORT $LN66@Alternativ
$LN31@Alternativ:

; 5610 : 		else
; 5611 : 			{	// add character
; 5612 : 			_Nfa._Add_char(_Char);

	movzx	eax, WORD PTR [esi+72]
	lea	ecx, DWORD PTR [esi+36]
	push	eax
	call	?_Add_char@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char

; 5613 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next
$LN71@Alternativ:

; 5616 : 			_Quantifier();

	mov	ecx, esi
	call	?_Quantifier@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Quantifier
$LN33@Alternativ:

; 5617 : 		_Found = true;

	cmp	DWORD PTR [esi+76], -1
	mov	cl, 1
	jne	$LL2@Alternativ
$LN73@Alternativ:
	pop	ebx
$LN7@Alternativ:

; 5550 : 			return (_Found);

	mov	al, cl
	pop	esi

; 5618 : 		}
; 5619 : 	}

	ret	0
$LN75@Alternativ:

; 5552 : 			_Error(regex_constants::error_paren);

	push	5
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN76@Alternativ:
$LN65@Alternativ:

; 5607 : 			_Error(regex_constants::error_brace);

	push	6
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN77@Alternativ:
$LN66@Alternativ:

; 5609 : 			_Error(regex_constants::error_brack);

	push	4
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN78@Alternativ:
$LN28@Alternativ:

; 5605 : 			_Error(regex_constants::error_badrepeat);

	push	10					; 0000000aH
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN79@Alternativ:
$LN74@Alternativ:
	int	3
?_Alternative@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Alternative
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Quantifier@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Quantifier@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Quantifier, COMDAT
; _this$ = ecx

; 5496 : 	{	// check for quantifier following atom

	npad	2
	push	ebx
	push	esi
	mov	esi, ecx

; 5497 : 	int _Min = 0;

	xor	ebx, ebx
	push	edi

; 5498 : 	int _Max = -1;

	or	edi, -1

; 5499 : 	if (_Mchar == _Meta_star)

	mov	eax, DWORD PTR [esi+76]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN17@Quantifier

; 5500 : 		;
; 5501 : 	else if (_Mchar == _Meta_plus)

	cmp	eax, 43					; 0000002bH
	jne	$LN4@Quantifier

; 5502 : 		_Min = 1;

	lea	ebx, DWORD PTR [edi+2]
$LN17@Quantifier:

; 3639 : 	_Current->_Flags |= _Fl_final;

	mov	eax, DWORD PTR [esi+40]

; 1523 : 	return (_Left = _Node_flags((int)_Left | _Right));

	or	DWORD PTR [eax+8], 4

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	cmp	eax, ecx
	je	SHORT $LN29@Quantifier

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN30@Quantifier

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, ecx
	je	SHORT $LN30@Quantifier
	mov	ecx, DWORD PTR [esi+80]
	test	cl, 8
	jne	SHORT $LN35@Quantifier
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN40@Quantifier
	cmp	edx, 41					; 00000029H
	je	SHORT $LN40@Quantifier
$LN35@Quantifier:
	test	cl, 16					; 00000010H
	jne	SHORT $LN30@Quantifier
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN40@Quantifier
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN30@Quantifier
$LN40@Quantifier:

; 4991 : 			++_Pat;

	mov	DWORD PTR [esi], eax
$LN30@Quantifier:

; 4992 : 		++_Pat;

	add	DWORD PTR [esi], 2
$LN29@Quantifier:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, esi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5525 : 		}
; 5526 : 	else
; 5527 : 		return;
; 5528 : 	_Nfa._Mark_final();
; 5529 : 	_Next();
; 5530 : 	if ((_L_flags & _L_ngr_rep) && _Mchar == _Meta_query)

	test	DWORD PTR [esi+80], 1024		; 00000400H
	je	$LN19@Quantifier
	cmp	DWORD PTR [esi+76], 63			; 0000003fH
	jne	$LN19@Quantifier

; 5531 : 		{	// add non-greedy repeat node
; 5532 : 		_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5533 : 		_Nfa._Add_rep(_Min, _Max, false);

	push	0

; 5534 : 		}
; 5535 : 	else
; 5536 : 		_Nfa._Add_rep(_Min, _Max, true);

	push	edi
	push	ebx
	lea	ecx, DWORD PTR [esi+36]
	call	?_Add_rep@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXHH_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_rep
	pop	edi
	pop	esi
	pop	ebx

; 5537 : 	}

	ret	0
$LN4@Quantifier:

; 5503 : 	else if (_Mchar == _Meta_query)

	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN6@Quantifier

; 5504 : 		_Max = 1;

	lea	edi, DWORD PTR [eax-62]
	jmp	$LN17@Quantifier
$LN6@Quantifier:

; 5505 : 	else if (_Mchar == _Meta_lbr)

	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN8@Quantifier

; 5506 : 		{	// check for valid bracketed value
; 5507 : 		_Next();

	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5031 : 	return (_Do_digits(10, INT_MAX) != INT_MAX);

	push	2147483647				; 7fffffffH
	push	10					; 0000000aH
	mov	ecx, esi
	call	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
	cmp	eax, 2147483647				; 7fffffffH

; 5508 : 		if (!_DecimalDigits())

	je	SHORT $LN45@Quantifier

; 5510 : 		_Min = _Val;
; 5511 : 		if (_Mchar != _Meta_comma)

	cmp	DWORD PTR [esi+76], 44			; 0000002cH
	mov	ebx, DWORD PTR [esi+68]
	je	SHORT $LN11@Quantifier

; 5512 : 			_Max = _Min;

	mov	edi, ebx

; 5513 : 		else

	jmp	SHORT $LN16@Quantifier
$LN11@Quantifier:

; 5514 : 			{	// check for decimal constant following comma
; 5515 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5516 : 			if (_Mchar == _Meta_rbr)

	cmp	DWORD PTR [esi+76], 125			; 0000007dH
	je	SHORT $LN43@Quantifier

; 5517 : 				;
; 5518 : 			else if (!_DecimalDigits())

	mov	ecx, esi
	call	?_DecimalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_DecimalDigits
	test	al, al
	je	SHORT $LN47@Quantifier

; 5520 : 			else
; 5521 : 				_Max = _Val;

	mov	edi, DWORD PTR [esi+68]
$LN16@Quantifier:

; 5522 : 			}
; 5523 : 		if (_Mchar != _Meta_rbr || (_Max != -1 && _Max < _Min))

	cmp	DWORD PTR [esi+76], 125			; 0000007dH
	jne	SHORT $LN48@Quantifier
$LN43@Quantifier:
	cmp	edi, -1
	je	$LN17@Quantifier
	cmp	edi, ebx
	jge	$LN17@Quantifier
	jmp	SHORT $LN48@Quantifier
$LN19@Quantifier:

; 5534 : 		}
; 5535 : 	else
; 5536 : 		_Nfa._Add_rep(_Min, _Max, true);

	push	1
	push	edi
	push	ebx
	lea	ecx, DWORD PTR [esi+36]
	call	?_Add_rep@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXHH_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_rep
$LN8@Quantifier:

; 5537 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN45@Quantifier:

; 5509 : 			_Error(regex_constants::error_badbrace);

	push	7
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN49@Quantifier:
$LN47@Quantifier:

; 5519 : 				_Error(regex_constants::error_badbrace);

	push	7
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN50@Quantifier:
$LN48@Quantifier:

; 5524 : 			_Error(regex_constants::error_badbrace);

	push	7
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN51@Quantifier:
$LN41@Quantifier:
	int	3
?_Quantifier@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Quantifier
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Wrapped_disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ
_TEXT	SEGMENT
?_Wrapped_disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Wrapped_disjunction, COMDAT
; _this$ = ecx

; 5288 : 	{	// add disjunction inside group

	npad	2
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 5289 : 	++_Disj_count;

	inc	DWORD PTR [ebx+16]

; 5290 : 	if (!(_L_flags & _L_empty_grp) && _Mchar == _Meta_rpar)

	mov	eax, DWORD PTR [ebx+80]
	test	eax, 134217728				; 08000000H
	jne	SHORT $LN2@Wrapped_di
	cmp	DWORD PTR [ebx+76], 41			; 00000029H
	je	$LN114@Wrapped_di
$LN2@Wrapped_di:

; 5292 : 	else if ((_L_flags & _L_nc_grp) && _Mchar == _Meta_query)

	test	al, 32					; 00000020H
	je	SHORT $LN4@Wrapped_di
	cmp	DWORD PTR [ebx+76], 63			; 0000003fH
	jne	SHORT $LN4@Wrapped_di

; 5293 : 		{	// check for valid ECMAScript (?x ... ) group
; 5294 : 		_Next();

	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5295 : 		_Meta_type _Ch =_Mchar;

	mov	esi, DWORD PTR [ebx+76]

; 5296 : 		_Next();

	mov	ecx, ebx
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5297 : 		if (_Ch == _Meta_colon)

	cmp	esi, 58					; 0000003aH
	je	SHORT $LN113@Wrapped_di

; 5298 : 			_Do_noncapture_group();
; 5299 : 		else if (_Ch == _Meta_exc)
; 5300 : 			{	// process assert group, negating
; 5301 : 			_Do_assert_group(true);

	mov	ecx, ebx
	cmp	esi, 33					; 00000021H
	jne	SHORT $LN8@Wrapped_di
	push	1
	call	?_Do_assert_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_N@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_assert_group

; 5302 : 			--_Disj_count;

	dec	DWORD PTR [ebx+16]

; 5303 : 			return (false);

	xor	al, al
	pop	edi
	pop	esi
	pop	ebx

; 5320 : 	}

	ret	0
$LN8@Wrapped_di:

; 5304 : 			}
; 5305 : 		else if (_Ch == _Meta_equal)

	cmp	esi, 61					; 0000003dH
	jne	SHORT $LN10@Wrapped_di

; 5306 : 			{	// process assert group
; 5307 : 			_Do_assert_group(false);

	push	0
	call	?_Do_assert_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_N@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_assert_group

; 5308 : 			--_Disj_count;

	dec	DWORD PTR [ebx+16]

; 5309 : 			return (false);

	xor	al, al
	pop	edi
	pop	esi
	pop	ebx

; 5320 : 	}

	ret	0
$LN4@Wrapped_di:

; 113  : _BITMASK_OPS(syntax_option_type)

	test	DWORD PTR [ebx+64], 512			; 00000200H

; 5313 : 		}
; 5314 : 	else if (_Flags & regex_constants::nosubs)

	je	SHORT $LN12@Wrapped_di
$LN113@Wrapped_di:

; 3968 : 	return (_New_node(_N_group));

	push	8
	lea	ecx, DWORD PTR [ebx+36]
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 5270 : 	_Disjunction();

	mov	ecx, ebx
	mov	esi, eax
	call	?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Disjunction

; 5271 : 	_Nfa._End_group(_Pos1);

	push	esi
	lea	ecx, DWORD PTR [ebx+36]
	call	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group

; 5318 : 		--_Disj_count;

	dec	DWORD PTR [ebx+16]

; 5319 : 	return (true);

	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx

; 5320 : 	}

	ret	0
$LN12@Wrapped_di:

; 5315 : 		_Do_noncapture_group();
; 5316 : 	else
; 5317 : 		_Do_capture_group();

	call	?_Do_capture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_capture_group

; 5318 : 		--_Disj_count;

	dec	DWORD PTR [ebx+16]

; 5319 : 	return (true);

	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx

; 5320 : 	}

	ret	0
$LN114@Wrapped_di:

; 5291 : 		_Error(regex_constants::error_paren);

	push	5
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN116@Wrapped_di:
$LN10@Wrapped_di:

; 5310 : 			}
; 5311 : 		else
; 5312 : 			_Error(regex_constants::error_syntax);

	push	14					; 0000000eH
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN117@Wrapped_di:
$LN112@Wrapped_di:
	int	3
?_Wrapped_disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Wrapped_disjunction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_assert_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_N@Z
_TEXT	SEGMENT
__Neg$ = 8						; size = 1
?_Do_assert_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_N@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_assert_group, COMDAT
; _this$ = ecx

; 5278 : 	{	// add assert group

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 5279 : 	_Node_base *_Pos1 = _Nfa._Begin_assert_group(_Neg);

	push	DWORD PTR __Neg$[ebp]
	mov	edi, ecx
	lea	ecx, DWORD PTR [edi+36]
	call	?_Begin_assert_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_assert_group

; 5280 : 	_Disjunction();

	mov	ecx, edi
	mov	esi, eax
	call	?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Disjunction

; 4014 : 	_End_group(_Nx);

	push	esi
	lea	ecx, DWORD PTR [edi+36]
	call	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group

; 4015 : 	_Current = _Nx;

	mov	DWORD PTR [edi+40], esi
	pop	edi
	pop	esi
	pop	ebx

; 5281 : 	_Nfa._End_assert_group(_Pos1);
; 5282 : 	}

	pop	ebp
	ret	4
?_Do_assert_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_N@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_assert_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_noncapture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Do_noncapture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_noncapture_group, COMDAT
; _this$ = ecx

; 5268 : 	{	// add non-capture group

	npad	2
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 3968 : 	return (_New_node(_N_group));

	push	8
	lea	ecx, DWORD PTR [edi+36]
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 5269 : 	_Node_base *_Pos1 = _Nfa._Begin_group();
; 5270 : 	_Disjunction();

	mov	ecx, edi
	mov	esi, eax
	call	?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Disjunction

; 5271 : 	_Nfa._End_group(_Pos1);

	push	esi
	lea	ecx, DWORD PTR [edi+36]
	call	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group
	pop	edi
	pop	esi
	pop	ebx

; 5272 : 	}

	ret	0
?_Do_noncapture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_noncapture_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_capture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Do_capture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_capture_group, COMDAT
; _this$ = ecx

; 5254 : 	{	// add capture group

	npad	2
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 5255 : //	if (_MAX_GRP <= ++_Grp_idx)
; 5256 : //		_Error(regex_constants::error_complexity);
; 5257 : 	_Node_base *_Pos1 = _Nfa._Begin_capture_group(++_Grp_idx);

	inc	DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [ebx+36]
	push	DWORD PTR [ebx+12]
	call	?_Begin_capture_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@I@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_capture_group

; 5258 : 	_Disjunction();

	mov	ecx, ebx
	mov	edi, eax
	call	?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Disjunction

; 5259 : 	_Nfa._End_group(_Pos1);

	push	edi
	lea	ecx, DWORD PTR [ebx+36]
	call	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group

; 5260 : 	_Finished_grps.resize(_Grp_idx + 1);

	mov	ecx, DWORD PTR [ebx+12]
	inc	ecx
	push	0
	push	ecx
	lea	ecx, DWORD PTR [ebx+20]
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2093 : 		_Myoff += _Off;

	mov	edx, DWORD PTR [edi+20]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	eax, edx

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [ebx+20]

; 2095 : 		_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	shr	eax, 5
	pop	edi
	pop	esi

; 2094 : 		_Myptr += _Myoff / _VBITS;

	lea	ecx, DWORD PTR [ecx+eax*4]

; 2144 : 			*(_Vbase *)_Getptr() |= _Mask();

	mov	eax, DWORD PTR [ecx]
	bts	eax, edx
	mov	DWORD PTR [ecx], eax
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 5262 : 	}

	ret	0
?_Do_capture_group@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_capture_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_AtomEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_AtomEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_AtomEscape, COMDAT
; _this$ = ecx

; 5468 : 	{	// check for valid atom escape

	npad	2
	push	esi
	mov	esi, ecx

; 5469 : 	if ((_L_flags & _L_bckr) && _DecimalDigits())

	test	DWORD PTR [esi+80], 256			; 00000100H
	je	SHORT $LN2@AtomEscape

; 5031 : 	return (_Do_digits(10, INT_MAX) != INT_MAX);

	push	2147483647				; 7fffffffH
	push	10					; 0000000aH
	call	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
	cmp	eax, 2147483647				; 7fffffffH

; 5469 : 	if ((_L_flags & _L_bckr) && _DecimalDigits())

	je	SHORT $LN2@AtomEscape

; 5470 : 		{	// check for valid back reference
; 5471 : 		if (_Val == 0)

	push	edi
	mov	edi, DWORD PTR [esi+68]
	test	edi, edi
	jne	SHORT $LN4@AtomEscape

; 5472 : 			{	// handle \0
; 5473 : 			if (!(_L_flags & _L_bzr_chr))

	test	DWORD PTR [esi+80], 1048576		; 00100000H
	je	$LN70@AtomEscape

; 5475 : 			else
; 5476 : 				_Nfa._Add_char((_Elem)_Val);

	movzx	eax, di
	lea	ecx, DWORD PTR [esi+36]
	push	eax
	call	?_Add_char@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char
	pop	edi
$LN14@AtomEscape:
	pop	esi

; 5490 : 	}

	ret	0
$LN4@AtomEscape:

; 5481 : 			|| !_Finished_grps[_Val])

	test	DWORD PTR [esi+80], 512			; 00000200H
	je	SHORT $LN11@AtomEscape
	cmp	edi, 9
	ja	SHORT $LN10@AtomEscape
$LN11@AtomEscape:
	cmp	DWORD PTR [esi+12], edi
	jl	SHORT $LN10@AtomEscape
	cmp	DWORD PTR [esi+32], edi
	jbe	SHORT $LN10@AtomEscape
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [esi+20]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	eax, edi
	shr	eax, 5
	lea	edx, DWORD PTR [ecx+eax*4]

; 2095 : 		_Myoff %= _VBITS;

	mov	ecx, edi
	and	ecx, 31					; 0000001fH

; 2181 : 		return ((_Vbase)(1) << this->_Myoff);

	mov	eax, 1
	shl	eax, cl

; 2157 : 		return ((*_Getptr() & _Mask()) != 0);

	test	eax, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 5481 : 			|| !_Finished_grps[_Val])

	je	SHORT $LN10@AtomEscape

; 5483 : 		else
; 5484 : 			_Nfa._Add_backreference(_Val);

	push	edi
	lea	ecx, DWORD PTR [esi+36]
	call	?_Add_backreference@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXI@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_backreference
	pop	edi
	pop	esi

; 5490 : 	}

	ret	0
$LN2@AtomEscape:

; 5485 : 		}
; 5486 : 	else if (_CharacterEscape())

	mov	ecx, esi
	call	?_CharacterEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterEscape
	test	al, al
	je	SHORT $LN12@AtomEscape

; 5487 : 		_Nfa._Add_char((_Elem)_Val);

	movzx	eax, WORD PTR [esi+68]
	lea	ecx, DWORD PTR [esi+36]
	push	eax
	call	?_Add_char@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char
	pop	esi

; 5490 : 	}

	ret	0
$LN12@AtomEscape:

; 5488 : 	else if (!(_L_flags & _L_esc_wsd) || !_CharacterClassEscape(true))

	test	DWORD PTR [esi+80], 131072		; 00020000H
	je	SHORT $LN72@AtomEscape
	push	1
	mov	ecx, esi
	call	?_CharacterClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_N@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClassEscape
	test	al, al
	jne	SHORT $LN14@AtomEscape
	jmp	SHORT $LN72@AtomEscape
$LN70@AtomEscape:

; 5474 : 				_Error(regex_constants::error_escape);

	push	2
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN73@AtomEscape:
$LN10@AtomEscape:

; 5482 : 			_Error(regex_constants::error_backref);

	push	3
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN74@AtomEscape:
$LN72@AtomEscape:

; 5489 : 		_Error(regex_constants::error_escape);

	push	2
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN75@AtomEscape:
$LN69@AtomEscape:
	int	3
?_AtomEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_AtomEscape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_CharacterEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ
_TEXT	SEGMENT
?_CharacterEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterEscape, COMDAT
; _this$ = ecx

; 5424 : 	{	// check for valid character escape

	npad	2
	push	esi
	mov	esi, ecx

; 5425 : 	if (_Mchar == _Meta_eos)

	cmp	DWORD PTR [esi+76], -1
	je	$LN52@CharacterE

; 5427 : 
; 5428 : 	if ((_L_flags & _L_esc_ffn && _Do_ffn(_Char))
; 5429 : 		|| (_L_flags & _L_esc_ffnx && _Do_ffnx(_Char)))

	test	DWORD PTR [esi+80], 65536		; 00010000H
	je	SHORT $LN6@CharacterE
	movzx	eax, WORD PTR [esi+72]
	push	eax
	call	?_Do_ffn@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffn
	test	al, al
	jne	SHORT $LN5@CharacterE
$LN6@CharacterE:
	mov	eax, DWORD PTR [esi+80]
	test	eax, 32768				; 00008000H
	je	SHORT $LN3@CharacterE
	movzx	ecx, WORD PTR [esi+72]

; 5411 : 	if (_Ch == _Esc_ctrl_a)

	cmp	ecx, 97					; 00000061H
	jne	SHORT $LN20@CharacterE

; 5412 : 		_Val = '\a';

	mov	DWORD PTR [esi+68], 7
	jmp	SHORT $LN5@CharacterE
$LN20@CharacterE:

; 5413 : 	else if (_Ch == _Esc_ctrl_b)

	cmp	ecx, 98					; 00000062H
	jne	SHORT $LN3@CharacterE

; 5414 : 		_Val = '\b';

	mov	DWORD PTR [esi+68], 8
$LN5@CharacterE:

; 5430 : 		_Next();

	mov	ecx, esi
$LN49@CharacterE:
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next
$LN16@CharacterE:

; 5456 : 
; 5457 : 	if ((numeric_limits<typename _RxTraits::_Uelem>::max)()
; 5458 : 		< (unsigned int)_Val)

	cmp	DWORD PTR [esi+68], 65535		; 0000ffffH
	ja	$LN55@CharacterE

; 5459 : 		_Error(regex_constants::error_escape);
; 5460 : 	_Val = (_Elem)_Val;

	movzx	eax, WORD PTR [esi+68]
	mov	DWORD PTR [esi+68], eax

; 5461 : 	return (true);

	mov	al, 1
	pop	esi

; 5462 : 	}

	ret	0
$LN3@CharacterE:

; 5431 : 	else if (_Char == _Esc_ctrl && (_L_flags & _L_esc_ctrl))

	movzx	ecx, WORD PTR [esi+72]
	cmp	ecx, 99					; 00000063H
	jne	SHORT $LN7@CharacterE
	test	eax, 262144				; 00040000H
	je	SHORT $LN7@CharacterE

; 5432 : 		{	// handle control escape sequence
; 5433 : 		_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5434 : 		if (!_Traits.isctype(_Char, _RxTraits::_Ch_alpha))

	mov	eax, DWORD PTR [esi+60]
	movzx	edx, WORD PTR [esi+72]

; 330  : 			return (_Getctype()->is(_Fx, _Ch));

	push	edx
	push	259					; 00000103H
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z

; 5435 : 			_Error(regex_constants::error_escape);

	mov	ecx, esi
	test	al, al
	je	SHORT $LN54@CharacterE

; 5436 : 		_Val = (char)(_Char % 32);

	movsx	eax, BYTE PTR [esi+72]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR [esi+68], eax

; 5437 : 		_Next();

	jmp	SHORT $LN49@CharacterE
$LN7@CharacterE:

; 5438 : 		}
; 5439 : 	else if (_Char == _Esc_hex && (_L_flags & _L_esc_hex))

	cmp	ecx, 120				; 00000078H
	jne	SHORT $LN10@CharacterE
	test	eax, 4096				; 00001000H
	je	SHORT $LN10@CharacterE

; 5440 : 		{	// handle hexadecimal escape sequence
; 5441 : 		_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5039 : 	if (_Do_digits(16, _Count) != 0)

	push	2
$LN50@CharacterE:
	push	16					; 00000010H
	mov	ecx, esi
	call	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
	test	eax, eax
	je	SHORT $LN16@CharacterE
	jmp	SHORT $LN55@CharacterE
$LN10@CharacterE:

; 5442 : 		_HexDigits(2);
; 5443 : 		}
; 5444 : 	else if (_Char == _Esc_uni && (_L_flags & _L_esc_uni))

	cmp	ecx, 117				; 00000075H
	jne	SHORT $LN12@CharacterE
	test	eax, 2048				; 00000800H
	je	SHORT $LN12@CharacterE

; 5445 : 		{	// handle unicode escape sequence
; 5446 : 		_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5039 : 	if (_Do_digits(16, _Count) != 0)

	push	4

; 5040 : 		_Error(regex_constants::error_escape);

	jmp	SHORT $LN50@CharacterE
$LN12@CharacterE:

; 5447 : 		_HexDigits(4);
; 5448 : 		}
; 5449 : 	else if ((_L_flags & _L_esc_oct) && _OctalDigits())

	test	eax, 8192				; 00002000H
	je	SHORT $LN14@CharacterE

; 5048 : 	return (_Do_digits(8, 3) != 3);

	push	3
	push	8
	mov	ecx, esi
	call	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
	cmp	eax, 3

; 5447 : 		_HexDigits(4);
; 5448 : 		}
; 5449 : 	else if ((_L_flags & _L_esc_oct) && _OctalDigits())

	je	SHORT $LN14@CharacterE

; 5450 : 		{	// handle octal escape sequence
; 5451 : 		if (_Val == 0)

	cmp	DWORD PTR [esi+68], 0
	jne	$LN16@CharacterE

; 5452 : 			_Error(regex_constants::error_escape);

	jmp	SHORT $LN55@CharacterE
$LN14@CharacterE:

; 5453 : 		}
; 5454 : 	else
; 5455 : 		return (_IdentityEscape());

	mov	ecx, esi
	pop	esi
	jmp	?_IdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_IdentityEscape
$LN52@CharacterE:

; 5426 : 		_Error(regex_constants::error_escape);

	push	2
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN56@CharacterE:
$LN54@CharacterE:

; 5435 : 			_Error(regex_constants::error_escape);

	push	2
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN57@CharacterE:
$LN55@CharacterE:

; 5040 : 		_Error(regex_constants::error_escape);

	push	2
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN58@CharacterE:
$LN48@CharacterE:
	int	3
?_CharacterEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterEscape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_ffnx@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?_Do_ffnx@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffnx, COMDAT
; _this$ = ecx

; 5410 : 	{	// check for the remaining file format escape characters

	npad	2
	push	ebp
	mov	ebp, esp

; 5411 : 	if (_Ch == _Esc_ctrl_a)

	mov	ax, WORD PTR __Ch$[ebp]
	cmp	ax, 97					; 00000061H
	jne	SHORT $LN2@Do_ffnx

; 5412 : 		_Val = '\a';

	mov	DWORD PTR [ecx+68], 7

; 5417 : 	return (true);

	mov	al, 1

; 5418 : 	}

	pop	ebp
	ret	4
$LN2@Do_ffnx:

; 5413 : 	else if (_Ch == _Esc_ctrl_b)

	cmp	ax, 98					; 00000062H
	jne	SHORT $LN4@Do_ffnx

; 5414 : 		_Val = '\b';

	mov	DWORD PTR [ecx+68], 8

; 5417 : 	return (true);

	mov	al, 1

; 5418 : 	}

	pop	ebp
	ret	4
$LN4@Do_ffnx:

; 5415 : 	else
; 5416 : 		return (false);

	xor	al, al

; 5418 : 	}

	pop	ebp
	ret	4
?_Do_ffnx@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffnx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_ffn@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?_Do_ffn@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffn, COMDAT
; _this$ = ecx

; 5390 : 	{	// check for limited file format escape characters

	npad	2
	push	ebp
	mov	ebp, esp

; 5391 : 	if (_Ch == _Esc_ctrl_f)

	mov	ax, WORD PTR __Ch$[ebp]
	cmp	ax, 102					; 00000066H
	jne	SHORT $LN2@Do_ffn

; 5392 : 		_Val = '\f';

	mov	DWORD PTR [ecx+68], 12			; 0000000cH

; 5403 : 	return (true);

	mov	al, 1

; 5404 : 	}

	pop	ebp
	ret	4
$LN2@Do_ffn:

; 5393 : 	else if (_Ch == _Esc_ctrl_n)

	cmp	ax, 110					; 0000006eH
	jne	SHORT $LN4@Do_ffn

; 5394 : 		_Val = '\n';

	mov	DWORD PTR [ecx+68], 10			; 0000000aH

; 5403 : 	return (true);

	mov	al, 1

; 5404 : 	}

	pop	ebp
	ret	4
$LN4@Do_ffn:

; 5395 : 	else if (_Ch == _Esc_ctrl_r)

	cmp	ax, 114					; 00000072H
	jne	SHORT $LN6@Do_ffn

; 5396 : 		_Val = '\r';

	mov	DWORD PTR [ecx+68], 13			; 0000000dH

; 5403 : 	return (true);

	mov	al, 1

; 5404 : 	}

	pop	ebp
	ret	4
$LN6@Do_ffn:

; 5397 : 	else if (_Ch == _Esc_ctrl_t)

	cmp	ax, 116					; 00000074H
	jne	SHORT $LN8@Do_ffn

; 5398 : 		_Val = '\t';

	mov	DWORD PTR [ecx+68], 9

; 5403 : 	return (true);

	mov	al, 1

; 5404 : 	}

	pop	ebp
	ret	4
$LN8@Do_ffn:

; 5399 : 	else if (_Ch == _Esc_ctrl_v)

	cmp	ax, 118					; 00000076H
	jne	SHORT $LN10@Do_ffn

; 5400 : 		_Val = '\v';

	mov	DWORD PTR [ecx+68], 11			; 0000000bH

; 5403 : 	return (true);

	mov	al, 1

; 5404 : 	}

	pop	ebp
	ret	4
$LN10@Do_ffn:

; 5401 : 	else
; 5402 : 		return (false);

	xor	al, al

; 5404 : 	}

	pop	ebp
	ret	4
?_Do_ffn@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_IsIdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_IsIdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_IsIdentityEscape, COMDAT
; _this$ = ecx

; 5327 : 	if (_L_flags & _L_ident_ECMA)

	mov	edx, DWORD PTR [ecx+80]

; 5328 : 		// ECMAScript identity escape characters
; 5329 : 		switch (_Char)

	movzx	eax, WORD PTR [ecx+72]
	test	edx, 4194304				; 00400000H
	je	SHORT $LN6@IsIdentity
	add	eax, -68				; ffffffbcH
	cmp	eax, 51					; 00000033H
	ja	SHORT $LN8@IsIdentity
	movzx	eax, BYTE PTR $LN14@IsIdentity[eax]
	jmp	DWORD PTR $LN17@IsIdentity[eax*4]
$LN8@IsIdentity:

; 5330 : 			{
; 5331 : 			case 'c':	// ASCII control character
; 5332 : 			case 'd':	// digit
; 5333 : 			case 'D':
; 5334 : 			case 's':	// whitespace
; 5335 : 			case 'S':
; 5336 : 			case 'w':	// word character
; 5337 : 			case 'W':
; 5338 : 				return (false);
; 5339 : 			default:
; 5340 : 				return (true);

	mov	al, 1

; 5368 : 		}
; 5369 : 	}

	ret	0
$LN6@IsIdentity:

; 5341 : 			}
; 5342 : 
; 5343 : 	switch (_Char)

	add	eax, -34				; ffffffdeH
	cmp	eax, 91					; 0000005bH
	ja	SHORT $LN12@IsIdentity
	movzx	eax, BYTE PTR $LN15@IsIdentity[eax]
	jmp	DWORD PTR $LN18@IsIdentity[eax*4]
$LN10@IsIdentity:

; 5344 : 		{
; 5345 : 		case _Meta_dot:
; 5346 : 		case _Meta_lsq:
; 5347 : 		case _Meta_esc:
; 5348 : 		case _Meta_star:
; 5349 : 		case _Meta_bar:
; 5350 : 		case _Meta_caret:
; 5351 : 		case _Meta_dlr:
; 5352 : 			// BRE, ERE, awk identity escape characters
; 5353 : 			return (true);
; 5354 : 		case _Meta_lpar:
; 5355 : 		case _Meta_rpar:
; 5356 : 		case _Meta_plus:
; 5357 : 		case _Meta_query:
; 5358 : 		case _Meta_lbr:
; 5359 : 		case _Meta_rbr:
; 5360 : 			// additional ERE identity escape characters
; 5361 : 			return ((_L_flags & _L_ident_ERE) != 0);

	shr	edx, 23					; 00000017H
	and	edx, 1
	mov	al, dl

; 5368 : 		}
; 5369 : 	}

	ret	0
$LN11@IsIdentity:

; 5362 : 		case '"':
; 5363 : 		case '/':
; 5364 : 			// additional awk identity escape characters
; 5365 : 			return ((_L_flags & _L_ident_awk) != 0);

	shr	edx, 24					; 00000018H
	and	edx, 1
	mov	al, dl

; 5368 : 		}
; 5369 : 	}

	ret	0
$LN12@IsIdentity:

; 5366 : 		default:
; 5367 : 			return (false);

	xor	al, al

; 5368 : 		}
; 5369 : 	}

	ret	0
	npad	1
$LN17@IsIdentity:
	DD	$LN12@IsIdentity
	DD	$LN8@IsIdentity
$LN14@IsIdentity:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
$LN18@IsIdentity:
	DD	$LN11@IsIdentity
	DD	$LN8@IsIdentity
	DD	$LN10@IsIdentity
	DD	$LN12@IsIdentity
$LN15@IsIdentity:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
	DB	1
	DB	2
	DB	3
	DB	3
	DB	1
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
	DB	2
?_IsIdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_IsIdentityEscape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_IdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ
_TEXT	SEGMENT
?_IdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_IdentityEscape, COMDAT
; _this$ = ecx

; 5375 : 	{	// check whether an escape is valid, and process it if so

	npad	2
	push	esi
	mov	esi, ecx

; 5376 : 	if (_IsIdentityEscape())

	call	?_IsIdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_IsIdentityEscape
	test	al, al
	je	SHORT $LN2@IdentityEs

; 5377 : 		{
; 5378 : 		_Val = _Char;

	movzx	eax, WORD PTR [esi+72]

; 4988 : 	if (_Pat != _End)

	mov	ecx, DWORD PTR [esi+8]

; 5377 : 		{
; 5378 : 		_Val = _Char;

	mov	DWORD PTR [esi+68], eax

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [esi]
	cmp	eax, ecx
	je	SHORT $LN6@IdentityEs

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN7@IdentityEs

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, ecx
	je	SHORT $LN7@IdentityEs
	mov	ecx, DWORD PTR [esi+80]
	test	cl, 8
	jne	SHORT $LN12@IdentityEs
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN17@IdentityEs
	cmp	edx, 41					; 00000029H
	je	SHORT $LN17@IdentityEs
$LN12@IdentityEs:
	test	cl, 16					; 00000010H
	jne	SHORT $LN7@IdentityEs
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN17@IdentityEs
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN7@IdentityEs
$LN17@IdentityEs:

; 4991 : 			++_Pat;

	mov	DWORD PTR [esi], eax
$LN7@IdentityEs:

; 4992 : 		++_Pat;

	add	DWORD PTR [esi], 2
$LN6@IdentityEs:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, esi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5379 : 		_Next();
; 5380 : 		return (true);

	mov	al, 1
	pop	esi

; 5384 : 	}

	ret	0
$LN2@IdentityEs:

; 5381 : 		}
; 5382 : 	else
; 5383 : 		return (false);

	xor	al, al
	pop	esi

; 5384 : 	}

	ret	0
?_IdentityEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_IdentityEscape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_CharacterClass@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_CharacterClass@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClass, COMDAT
; _this$ = ecx

; 5235 : 	{	// add bracket expression

	npad	2
	push	esi
	mov	esi, ecx
	push	edi

; 5236 : 	_Nfa._Add_class();

	lea	ecx, DWORD PTR [esi+36]
	call	?_Add_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_class

; 5237 : 	if (_Mchar == _Meta_caret)

	cmp	DWORD PTR [esi+76], 94			; 0000005eH
	jne	SHORT $LN2@CharacterC

; 3631 : 	_Current->_Flags ^= _Fl_negate;

	mov	eax, DWORD PTR [esi+40]

; 1528 : 	return (_Left = _Node_flags((int)_Left ^ _Right));

	xor	DWORD PTR [eax+8], 1

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	cmp	eax, ecx
	je	SHORT $LN10@CharacterC

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN11@CharacterC

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, ecx
	je	SHORT $LN11@CharacterC
	mov	ecx, DWORD PTR [esi+80]
	test	cl, 8
	jne	SHORT $LN16@CharacterC
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN25@CharacterC
	cmp	edx, 41					; 00000029H
	je	SHORT $LN25@CharacterC
$LN16@CharacterC:
	test	cl, 16					; 00000010H
	jne	SHORT $LN11@CharacterC
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN25@CharacterC
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN11@CharacterC
$LN25@CharacterC:

; 4991 : 			++_Pat;

	mov	DWORD PTR [esi], eax
$LN11@CharacterC:

; 4992 : 		++_Pat;

	add	DWORD PTR [esi], 2
$LN10@CharacterC:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, esi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans
$LN2@CharacterC:

; 5238 : 		{	// negate bracket expression
; 5239 : 		_Nfa._Negate();
; 5240 : 		_Next();
; 5241 : 		}
; 5242 : 	if ((_L_flags & _L_brk_rstr) && _Mchar == _Meta_rsq)

	test	DWORD PTR [esi+80], 536870912		; 20000000H
	je	SHORT $LN3@CharacterC
	cmp	DWORD PTR [esi+76], 93			; 0000005dH
	jne	SHORT $LN3@CharacterC

; 3815 : 		_Add_char_to_bitmap(_Ch);

	push	93					; 0000005dH
	lea	ecx, DWORD PTR [esi+36]
	call	?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap

; 5243 : 		{	// insert initial ] when not special
; 5244 : 		_Nfa._Add_char_to_class(_Meta_rsq);
; 5245 : 		_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next
$LN3@CharacterC:

; 5246 : 		}
; 5247 : 	_ClassRanges();

	pop	edi
	mov	ecx, esi
	pop	esi
	jmp	?_ClassRanges@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassRanges
?_CharacterClass@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_ClassRanges@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_ClassRanges@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassRanges, COMDAT
; _this$ = ecx

; 5193 : 	{	// check for valid class ranges

	npad	2
	push	esi
	mov	esi, ecx

; 5194 : 	_Prs_ret _Ret;
; 5195 : 
; 5196 : 	for (; ; )
; 5197 : 		{	// process characters through end of bracket expression
; 5198 : 		if ((_Ret = _ClassAtom()) == _Prs_none)

	call	?_ClassAtom@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@XZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassAtom
	test	eax, eax
	je	$LN56@ClassRange
	push	ebx
	mov	ebx, 256				; 00000100H
	push	edi
	npad	7
$LL2@ClassRange:

; 5199 : 			return;
; 5200 : 		else if (_Ret == _Prs_set)

	cmp	eax, 2
	je	$LN44@ClassRange

; 5201 : 			;
; 5202 : 		else if (_Val == 0 && !(_L_flags & _L_bzr_chr))

	cmp	DWORD PTR [esi+68], 0
	jne	SHORT $LN9@ClassRange
	test	DWORD PTR [esi+80], 1048576		; 00100000H
	je	$LN60@ClassRange
$LN9@ClassRange:

; 5204 : 		else if (_Mchar == _Meta_dash)

	cmp	DWORD PTR [esi+76], 45			; 0000002dH
	jne	$LN11@ClassRange

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	cmp	eax, ecx
	je	SHORT $LN21@ClassRange

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN22@ClassRange

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, ecx
	je	SHORT $LN22@ClassRange
	mov	ecx, DWORD PTR [esi+80]
	test	cl, 8
	jne	SHORT $LN27@ClassRange
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN55@ClassRange
	cmp	edx, 41					; 00000029H
	je	SHORT $LN55@ClassRange
$LN27@ClassRange:
	test	cl, 16					; 00000010H
	jne	SHORT $LN22@ClassRange
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN55@ClassRange
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN22@ClassRange
$LN55@ClassRange:

; 4991 : 			++_Pat;

	mov	DWORD PTR [esi], eax
$LN22@ClassRange:

; 4992 : 		++_Pat;

	add	DWORD PTR [esi], 2
$LN21@ClassRange:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, esi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5205 : 			{	// check for valid range
; 5206 : 			_Next();
; 5207 : 			_Elem _Chr1 = (_Elem)_Val;

	movzx	edi, WORD PTR [esi+68]

; 5208 : 			if ((_Ret = _ClassAtom()) == _Prs_none)

	mov	ecx, esi
	call	?_ClassAtom@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@XZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassAtom
	test	eax, eax
	je	SHORT $LN50@ClassRange

; 5211 : 				_Nfa._Add_char_to_class(_Meta_dash);
; 5212 : 				return;
; 5213 : 				}
; 5214 : 			else if (_Ret == _Prs_set)

	cmp	eax, 2
	je	$LN52@ClassRange

; 113  : _BITMASK_OPS(syntax_option_type)

	test	DWORD PTR [esi+64], 2048		; 00000800H

; 5215 : 				_Error(regex_constants::error_range);	// set follows dash
; 5216 : 			else if (_Flags & regex_constants::collate)

	je	SHORT $LN17@ClassRange

; 5217 : 				{	// translate ends of range
; 5218 : 				_Val = _Traits.translate((_Elem)_Val);

	movzx	eax, WORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+60]
	push	eax
	call	?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z ; std::_Regex_traits<wchar_t>::translate

; 5219 : 				_Chr1 = _Traits.translate(_Chr1);

	mov	ecx, DWORD PTR [esi+60]
	movzx	eax, ax
	push	edi
	mov	DWORD PTR [esi+68], eax
	call	?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z ; std::_Regex_traits<wchar_t>::translate
	movzx	edi, ax
$LN17@ClassRange:

; 5220 : 				}
; 5221 : 			if ((typename _RxTraits::_Uelem)_Val
; 5222 : 				< (typename _RxTraits::_Uelem)_Chr1)

	movzx	eax, WORD PTR [esi+68]
	cmp	ax, di
	jb	SHORT $LN52@ClassRange

; 5224 : 			_Nfa._Add_range(_Chr1, (_Elem)_Val);

	push	eax
	push	edi
	lea	ecx, DWORD PTR [esi+36]
	call	?_Add_range@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEX_W0@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_range

; 5225 : 			}
; 5226 : 		else

	jmp	SHORT $LN44@ClassRange
$LN11@ClassRange:

; 5227 : 			_Nfa._Add_char_to_class((_Elem)_Val);

	movzx	eax, WORD PTR [esi+68]
	lea	ecx, DWORD PTR [esi+36]

; 3815 : 		_Add_char_to_bitmap(_Ch);

	push	eax
	cmp	ax, bx
	jae	SHORT $LN43@ClassRange
	call	?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap

; 3816 : 	else

	jmp	SHORT $LN44@ClassRange
$LN43@ClassRange:

; 3817 : 		_Add_char_to_array(_Ch);

	call	?_Add_char_to_array@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_array
$LN44@ClassRange:

; 5194 : 	_Prs_ret _Ret;
; 5195 : 
; 5196 : 	for (; ; )
; 5197 : 		{	// process characters through end of bracket expression
; 5198 : 		if ((_Ret = _ClassAtom()) == _Prs_none)

	mov	ecx, esi
	call	?_ClassAtom@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@XZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassAtom
	test	eax, eax
	jne	$LL2@ClassRange
	pop	edi
	pop	ebx
	pop	esi

; 5228 : 		}
; 5229 : 	}

	ret	0
$LN50@ClassRange:

; 5209 : 				{	// treat - as ordinary character
; 5210 : 				_Nfa._Add_char_to_class((_Elem)_Val);

	movzx	eax, WORD PTR [esi+68]
	add	esi, 36					; 00000024H

; 3815 : 		_Add_char_to_bitmap(_Ch);

	mov	ecx, esi
	push	eax
	cmp	ax, bx
	jae	SHORT $LN33@ClassRange
	call	?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap
	push	45					; 0000002dH
	mov	ecx, esi
	call	?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap
	pop	edi
	pop	ebx
	pop	esi

; 5228 : 		}
; 5229 : 	}

	ret	0
$LN33@ClassRange:

; 3817 : 		_Add_char_to_array(_Ch);

	call	?_Add_char_to_array@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_array

; 3815 : 		_Add_char_to_bitmap(_Ch);

	push	45					; 0000002dH
	mov	ecx, esi
	call	?_Add_char_to_bitmap@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEX_W@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_char_to_bitmap
	pop	edi
	pop	ebx
$LN56@ClassRange:
	pop	esi

; 5228 : 		}
; 5229 : 	}

	ret	0
$LN60@ClassRange:

; 5203 : 			_Error(regex_constants::error_escape);

	push	2
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN61@ClassRange:
$LN52@ClassRange:

; 5223 : 				_Error(regex_constants::error_range);

	push	8
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN62@ClassRange:
$LN59@ClassRange:
	int	3
?_ClassRanges@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassRanges
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_ClassAtom@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@XZ
_TEXT	SEGMENT
?_ClassAtom@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@XZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassAtom, COMDAT
; _this$ = ecx

; 5146 : 	{	// check for class atom

	npad	2
	push	esi
	mov	esi, ecx

; 5147 : 	if (_Mchar == _Meta_esc)

	mov	eax, DWORD PTR [esi+76]
	cmp	eax, 92					; 0000005cH
	jne	$LN2@ClassAtom

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	cmp	eax, ecx
	je	SHORT $LN19@ClassAtom

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN20@ClassAtom

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, ecx
	je	SHORT $LN20@ClassAtom
	mov	ecx, DWORD PTR [esi+80]
	test	cl, 8
	jne	SHORT $LN25@ClassAtom
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN30@ClassAtom
	cmp	edx, 41					; 00000029H
	je	SHORT $LN30@ClassAtom
$LN25@ClassAtom:
	test	cl, 16					; 00000010H
	jne	SHORT $LN20@ClassAtom
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN30@ClassAtom
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN20@ClassAtom
$LN30@ClassAtom:

; 4991 : 			++_Pat;

	mov	DWORD PTR [esi], eax
$LN20@ClassAtom:

; 4992 : 		++_Pat;

	add	DWORD PTR [esi], 2
$LN19@ClassAtom:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, esi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5148 : 		{	// check for valid escape sequence
; 5149 : 		_Next();
; 5150 : 		if (_L_flags & _L_grp_esc)

	mov	eax, DWORD PTR [esi+80]
	test	eax, 2097152				; 00200000H
	je	SHORT $LN4@ClassAtom

; 5151 : 			return (_ClassEscape(false));

	push	0
	mov	ecx, esi
	call	?_ClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassEscape
	pop	esi

; 5186 : 		}
; 5187 : 	}

	ret	0
$LN4@ClassAtom:

; 5152 : 		else if ((_L_flags & _L_esc_ffn && _Do_ffn(_Char))
; 5153 : 			|| (_L_flags & _L_esc_ffnx && _Do_ffnx(_Char)))

	test	eax, 65536				; 00010000H
	je	SHORT $LN8@ClassAtom
	movzx	eax, WORD PTR [esi+72]
	mov	ecx, esi
	push	eax
	call	?_Do_ffn@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffn
	test	al, al
	jne	SHORT $LN7@ClassAtom
$LN8@ClassAtom:
	test	DWORD PTR [esi+80], 32768		; 00008000H
	je	SHORT $LN6@ClassAtom
	movzx	eax, WORD PTR [esi+72]
	mov	ecx, esi
	push	eax
	call	?_Do_ffnx@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_W@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ffnx
	test	al, al
	je	SHORT $LN6@ClassAtom
$LN7@ClassAtom:

; 5154 : 			{	// advance to next character
; 5155 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5156 : 			return (_Prs_chr);

	mov	eax, 1
	pop	esi

; 5186 : 		}
; 5187 : 	}

	ret	0
$LN6@ClassAtom:

; 5157 : 			}
; 5158 : 		_Val = _Meta_esc;

	mov	DWORD PTR [esi+68], 92			; 0000005cH

; 5159 : 		return (_Prs_chr);

	mov	eax, 1
	pop	esi

; 5186 : 		}
; 5187 : 	}

	ret	0
$LN2@ClassAtom:

; 5160 : 		}
; 5161 : 	else if (_Mchar == _Meta_lsq)

	cmp	eax, 91					; 0000005bH
	jne	SHORT $LN9@ClassAtom

; 5162 : 		{	// check for valid delimited expression
; 5163 : 		_Next();

	push	edi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5164 : 		if (_Mchar == _Meta_colon
; 5165 : 			|| _Mchar == _Meta_equal
; 5166 : 			|| _Mchar == _Meta_dot)

	mov	edi, DWORD PTR [esi+76]
	cmp	edi, 58					; 0000003aH
	je	SHORT $LN13@ClassAtom
	cmp	edi, 61					; 0000003dH
	je	SHORT $LN13@ClassAtom
	cmp	edi, 46					; 0000002eH
	je	SHORT $LN13@ClassAtom

; 5172 : 			}
; 5173 : 		else
; 5174 : 			{	// handle ordinary [
; 5175 : 			_Val = _Meta_lsq;

	pop	edi
	mov	DWORD PTR [esi+68], 91			; 0000005bH

; 5176 : 			return (_Prs_chr);

	mov	eax, 1
	pop	esi

; 5186 : 		}
; 5187 : 	}

	ret	0
$LN13@ClassAtom:

; 5167 : 			{	// handle delimited expression
; 5168 : 			_Meta_type _St = _Mchar;
; 5169 : 			_Next();

	mov	ecx, esi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5170 : 			_Do_ex_class(_St);

	push	edi
	mov	ecx, esi
	call	?_Do_ex_class@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ex_class
	pop	edi

; 5171 : 			return (_Prs_set);

	mov	eax, 2
	pop	esi

; 5186 : 		}
; 5187 : 	}

	ret	0
$LN9@ClassAtom:

; 5177 : 			}
; 5178 : 		}
; 5179 : 	else if (_Mchar == _Meta_rsq || _Mchar == _Meta_eos)

	cmp	eax, 93					; 0000005dH
	je	SHORT $LN16@ClassAtom
	cmp	eax, -1
	je	SHORT $LN16@ClassAtom

; 5181 : 	else
; 5182 : 		{	// handle ordinary character
; 5183 : 		_Val = _Char;

	movzx	eax, WORD PTR [esi+72]
	mov	DWORD PTR [esi+68], eax

; 5184 : 		_Next();

	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5185 : 		return (_Prs_chr);

	mov	eax, 1
	pop	esi

; 5186 : 		}
; 5187 : 	}

	ret	0
$LN16@ClassAtom:

; 5180 : 		return (_Prs_none);

	xor	eax, eax
	pop	esi

; 5186 : 		}
; 5187 : 	}

	ret	0
?_ClassAtom@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@XZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassAtom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_ClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z
_TEXT	SEGMENT
__Addit$ = 8						; size = 1
?_ClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassEscape, COMDAT
; _this$ = ecx

; 5123 : 	{	// check for class escape

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 5124 : 	if ((_L_flags & _L_esc_bsl)
; 5125 : 		&& _Char == _Esc_bsl)

	mov	eax, DWORD PTR [esi+80]
	test	eax, 16384				; 00004000H
	je	SHORT $LN2@ClassEscap
	cmp	WORD PTR [esi+72], 92			; 0000005cH
	jne	SHORT $LN2@ClassEscap

; 5126 : 		{	// handle escape backslash if allowed
; 5127 : 		_Val = _Esc_bsl;

	mov	DWORD PTR [esi+68], 92			; 0000005cH

; 5128 : 		_Next();

	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next
$LN7@ClassEscap:

; 5129 : 		return (_Prs_chr);

	mov	eax, 1
	pop	esi

; 5140 : 	}

	pop	ebp
	ret	4
$LN2@ClassEscap:

; 5130 : 		}
; 5131 : 	else if ((_L_flags & _L_esc_wsd) && _CharacterClassEscape(_Addit))

	test	eax, 131072				; 00020000H
	je	SHORT $LN4@ClassEscap
	push	DWORD PTR __Addit$[ebp]
	call	?_CharacterClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_N@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClassEscape
	test	al, al
	je	SHORT $LN4@ClassEscap

; 5132 : 		return (_Prs_set);

	mov	eax, 2
	pop	esi

; 5140 : 	}

	pop	ebp
	ret	4
$LN4@ClassEscap:

; 5031 : 	return (_Do_digits(10, INT_MAX) != INT_MAX);

	push	2147483647				; 7fffffffH
	push	10					; 0000000aH
	mov	ecx, esi
	call	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
	cmp	eax, 2147483647				; 7fffffffH

; 5133 : 	else if (_DecimalDigits())

	je	SHORT $LN6@ClassEscap

; 5134 : 		{	// check for invalid value
; 5135 : 		if (_Val != 0)

	cmp	DWORD PTR [esi+68], 0
	je	SHORT $LN7@ClassEscap
	jmp	SHORT $LN12@ClassEscap
$LN6@ClassEscap:

; 5137 : 		return (_Prs_chr);
; 5138 : 		}
; 5139 : 	return (_CharacterEscape() ? _Prs_chr : _Prs_none);

	mov	ecx, esi
	call	?_CharacterEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterEscape
	xor	ecx, ecx
	test	al, al
	pop	esi
	setne	cl
	mov	eax, ecx

; 5140 : 	}

	pop	ebp
	ret	4
$LN12@ClassEscap:

; 5136 : 			_Error(regex_constants::error_escape);

	push	2
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN14@ClassEscap:
$LN11@ClassEscap:
	int	3
?_ClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE?AW4_Prs_ret@2@_N@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_ClassEscape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_CharacterClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_N@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Addit$ = 8						; size = 1
?_CharacterClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_N@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClassEscape, COMDAT
; _this$ = ecx

; 5103 : 	{	// check for character class escape

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	edi, ecx

; 5104 : 	typename _RxTraits::char_class_type _Cls;
; 5105 : 	_FwdIt _Ch0 = _Pat;

	mov	ecx, DWORD PTR [edi]

; 5106 : 	if (_Ch0 == _End
; 5107 : 		|| (_Cls = _Traits.lookup_classname(_Pat, ++_Ch0,

	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN3@CharacterC
	mov	eax, DWORD PTR [edi+64]
	shr	eax, 8
	and	al, 1
	movzx	eax, al
	push	eax
	lea	eax, DWORD PTR [ecx+2]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [edi+60]
	call	??$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z ; std::_Regex_traits<wchar_t>::lookup_classname<wchar_t const *>
	movzx	ebx, ax
	test	bx, bx
	je	SHORT $LN3@CharacterC

; 5110 : 
; 5111 : 	if (_Addit)

	cmp	BYTE PTR __Addit$[ebp], 0
	je	SHORT $LN4@CharacterC

; 5112 : 		_Nfa._Add_class();

	lea	ecx, DWORD PTR [edi+36]
	call	?_Add_class@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_class
$LN4@CharacterC:

; 5113 : 	_Nfa._Add_named_class(_Cls,

	mov	eax, DWORD PTR [edi+60]
	movzx	edx, WORD PTR [edi+72]
	push	esi

; 330  : 			return (_Getctype()->is(_Fx, _Ch));

	push	edx
	mov	ecx, DWORD PTR [eax+4]
	push	1
	call	DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z

; 3883 : 		(_Node_class<_Elem, _RxTraits> *)_Current;

	mov	esi, DWORD PTR [edi+40]

; 5113 : 	_Nfa._Add_named_class(_Cls,

	lea	ecx, DWORD PTR [edi+36]

; 330  : 			return (_Getctype()->is(_Fx, _Ch));

	mov	BYTE PTR $T1[ebp], al

; 3884 : 	_Add_elts(_Node, _Cl, _Negate);

	push	DWORD PTR $T1[ebp]
	push	ebx
	push	esi
	call	?_Add_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPAV?$_Node_class@_WV?$regex_traits@_W@std@@@2@F_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_elts

; 3885 : 	if (_Bmp_max < static_cast<unsigned int>((numeric_limits<_Elem>::max)()))
; 3886 : 		_Node->_Classes =

	or	WORD PTR [esi+36], bx

; 5114 : 		_Traits.isctype(_Char, _RxTraits::_Ch_upper));
; 5115 : 	_Next();

	mov	ecx, edi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next
	pop	esi
	pop	edi

; 5116 : 	return (true);

	mov	al, 1
	pop	ebx

; 5117 : 	}

	pop	ebp
	ret	4
$LN3@CharacterC:
	pop	edi

; 5108 : 			(_Flags & regex_constants::icase) != 0)) == 0)
; 5109 : 		return (false);

	xor	al, al
	pop	ebx

; 5117 : 	}

	pop	ebp
	ret	4
?_CharacterClassEscape@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_N_N@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_CharacterClassEscape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_ex_class@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@@Z
_TEXT	SEGMENT
__Beg$1$ = -4						; size = 4
__Errtype$1$ = 8					; size = 4
__End_arg$ = 8						; size = 4
?_Do_ex_class@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ex_class, COMDAT
; _this$ = ecx

; 5055 : 	{	// handle delimited expressions within bracket expression

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi

; 5056 : 	regex_constants::error_type _Errtype =
; 5057 : 		(_End_arg == _Meta_colon ? regex_constants::error_ctype

	mov	esi, DWORD PTR __End_arg$[ebp]
	push	edi
	mov	edi, ecx
	cmp	esi, 58					; 0000003aH
	jne	SHORT $LN19@Do_ex_clas
	mov	DWORD PTR __Errtype$1$[ebp], 1
	jmp	SHORT $LN18@Do_ex_clas
$LN19@Do_ex_clas:
	cmp	esi, 61					; 0000003dH
	jne	SHORT $LN17@Do_ex_clas
	mov	DWORD PTR __Errtype$1$[ebp], 0
	jmp	SHORT $LN18@Do_ex_clas
$LN17@Do_ex_clas:
	xor	ecx, ecx
	mov	eax, 14					; 0000000eH
	cmp	esi, 46					; 0000002eH
	cmove	eax, ecx
	mov	DWORD PTR __Errtype$1$[ebp], eax
$LN18@Do_ex_clas:

; 5058 : 			: _End_arg == _Meta_equal ? regex_constants::error_collate
; 5059 : 			: _End_arg == _Meta_dot ? regex_constants::error_collate
; 5060 : 			: regex_constants::error_syntax);
; 5061 : 	_FwdIt _Beg = _Pat;

	mov	ecx, DWORD PTR [edi]

; 5062 : 	_Iter_diff_t<_FwdIt> _Diff = 0;

	xor	ebx, ebx

; 5063 : 
; 5064 : 	while (_Mchar != _Meta_colon && _Mchar != _Meta_equal
; 5065 : 		&& _Mchar != _Meta_dot && _Mchar != _Meta_eos)

	cmp	DWORD PTR [edi+76], 58			; 0000003aH
	mov	DWORD PTR __Beg$1$[ebp], ecx
	je	SHORT $LN3@Do_ex_clas
$LL2@Do_ex_clas:
	mov	eax, DWORD PTR [edi+76]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN48@Do_ex_clas
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN48@Do_ex_clas
	cmp	eax, -1
	je	SHORT $LN48@Do_ex_clas

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
	je	SHORT $LN22@Do_ex_clas

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN23@Do_ex_clas

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, ecx
	je	SHORT $LN23@Do_ex_clas
	mov	ecx, DWORD PTR [edi+80]
	test	cl, 8
	jne	SHORT $LN28@Do_ex_clas
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN47@Do_ex_clas
	cmp	edx, 41					; 00000029H
	je	SHORT $LN47@Do_ex_clas
$LN28@Do_ex_clas:
	test	cl, 16					; 00000010H
	jne	SHORT $LN23@Do_ex_clas
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN47@Do_ex_clas
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN23@Do_ex_clas
$LN47@Do_ex_clas:

; 4991 : 			++_Pat;

	mov	DWORD PTR [edi], eax
$LN23@Do_ex_clas:

; 4992 : 		++_Pat;

	add	DWORD PTR [edi], 2
$LN22@Do_ex_clas:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, edi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5066 : 		{	// advance to end delimiter
; 5067 : 		_Next();
; 5068 : 		++_Diff;

	inc	ebx
	cmp	DWORD PTR [edi+76], 58			; 0000003aH
	jne	SHORT $LL2@Do_ex_clas
$LN48@Do_ex_clas:
	mov	ecx, DWORD PTR __Beg$1$[ebp]
$LN3@Do_ex_clas:

; 5069 : 		}
; 5070 : 	if (_Mchar != _End_arg)

	cmp	DWORD PTR [edi+76], esi
	jne	$LN50@Do_ex_clas

; 5072 : 	else if (_End_arg == _Meta_colon)

	cmp	esi, 58					; 0000003aH
	jne	SHORT $LN6@Do_ex_clas

; 5073 : 		{	// handle named character class
; 5074 : 		typename _RxTraits::char_class_type _Cls =
; 5075 : 			_Traits.lookup_classname(_Beg, _Pat,

	mov	eax, DWORD PTR [edi+64]
	shr	eax, 8
	and	al, 1
	movzx	eax, al
	push	eax
	push	DWORD PTR [edi]
	push	ecx
	mov	ecx, DWORD PTR [edi+60]
	call	??$lookup_classname@PB_W@?$_Regex_traits@_W@std@@QBEFPB_W0_N@Z ; std::_Regex_traits<wchar_t>::lookup_classname<wchar_t const *>
	movzx	ebx, ax

; 5076 : 				(_Flags & regex_constants::icase) != 0);
; 5077 : 		if (!_Cls)

	test	bx, bx
	je	SHORT $LN52@Do_ex_clas

; 3883 : 		(_Node_class<_Elem, _RxTraits> *)_Current;

	mov	esi, DWORD PTR [edi+40]

; 5079 : 		_Nfa._Add_named_class(_Cls);

	lea	ecx, DWORD PTR [edi+36]

; 3884 : 	_Add_elts(_Node, _Cl, _Negate);

	push	0
	push	ebx
	push	esi
	call	?_Add_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPAV?$_Node_class@_WV?$regex_traits@_W@std@@@2@F_N@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_elts

; 3885 : 	if (_Bmp_max < static_cast<unsigned int>((numeric_limits<_Elem>::max)()))
; 3886 : 		_Node->_Classes =

	or	WORD PTR [esi+36], bx

; 3887 : 			(_Regex_traits_base::char_class_type)(_Node->_Classes | _Cl);
; 3888 : 	}

	jmp	SHORT $LN15@Do_ex_clas
$LN6@Do_ex_clas:

; 5080 : 		}
; 5081 : 	else if (_End_arg == _Meta_equal)

	cmp	esi, 61					; 0000003dH
	jne	SHORT $LN9@Do_ex_clas

; 5082 : 		{	// process =
; 5083 : 		if (_Beg == _Pat)

	mov	eax, DWORD PTR [edi]
	cmp	ecx, eax
	je	SHORT $LN53@Do_ex_clas

; 5085 : 		else
; 5086 : 			_Nfa._Add_equiv(_Beg, _Pat, _Diff);

	push	ebx
	push	eax
	push	ecx
	lea	ecx, DWORD PTR [edi+36]
	call	?_Add_equiv@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPB_W0H@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Add_equiv
	jmp	SHORT $LN15@Do_ex_clas
$LN9@Do_ex_clas:

; 5087 : 		}
; 5088 : 	else if (_End_arg == _Meta_dot)

	cmp	esi, 46					; 0000002eH
	jne	SHORT $LN15@Do_ex_clas

; 5089 : 		{	// process .
; 5090 : 		if (_Beg == _Pat)

	mov	edx, DWORD PTR [edi]
	cmp	ecx, edx
	je	SHORT $LN54@Do_ex_clas

; 3959 : 	_Sequence<_Elem> **_Cur = &_Node->_Coll;

	mov	eax, DWORD PTR [edi+40]

; 5092 : 		else
; 5093 : 			_Nfa._Add_coll(_Beg, _Pat, _Diff);

	lea	ecx, DWORD PTR [edi+36]

; 3959 : 	_Sequence<_Elem> **_Cur = &_Node->_Coll;

	add	eax, 20					; 00000014H

; 3960 : 	_Char_to_elts(_First, _Last, _Diff, _Cur);

	push	eax
	push	ebx
	push	edx
	push	DWORD PTR __Beg$1$[ebp]
	call	?_Char_to_elts@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0HPAPAU?$_Sequence@_W@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Char_to_elts
$LN15@Do_ex_clas:

; 5094 : 		}
; 5095 : 	_Next();

	mov	ecx, edi
	call	?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next

; 5096 : 	_Expect(_Meta_rsq, _Errtype);

	push	DWORD PTR __Errtype$1$[ebp]
	mov	ecx, edi
	push	93					; 0000005dH
	call	?_Expect@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Expect
	pop	edi
	pop	esi
	pop	ebx

; 5097 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN50@Do_ex_clas:

; 5071 : 		_Error(_Errtype);

	push	DWORD PTR __Errtype$1$[ebp]
	mov	ecx, edi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN55@Do_ex_clas:
$LN52@Do_ex_clas:

; 5078 : 			_Error(regex_constants::error_ctype);

	push	1
	mov	ecx, edi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN56@Do_ex_clas:
$LN53@Do_ex_clas:

; 5084 : 			_Error(regex_constants::error_collate);

	push	0
	mov	ecx, edi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN57@Do_ex_clas:
$LN54@Do_ex_clas:

; 5091 : 			_Error(regex_constants::error_collate);

	push	0
	mov	ecx, edi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN58@Do_ex_clas:
$LN49@Do_ex_clas:
	int	3
?_Do_ex_class@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_ex_class
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_OctalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ
_TEXT	SEGMENT
?_OctalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_OctalDigits, COMDAT
; _this$ = ecx

; 5048 : 	return (_Do_digits(8, 3) != 3);

	push	3
	push	8
	call	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
	xor	ecx, ecx
	cmp	eax, 3
	setne	al

; 5049 : 	}

	ret	0
?_OctalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_OctalDigits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_HexDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXH@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_HexDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXH@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_HexDigits, COMDAT
; _this$ = ecx

; 5038 : 	{	// check for _Count hex digits

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 5039 : 	if (_Do_digits(16, _Count) != 0)

	push	DWORD PTR __Count$[ebp]
	mov	esi, ecx
	push	16					; 00000010H
	call	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
	test	eax, eax
	jne	SHORT $LN5@HexDigits
	pop	esi

; 5041 : 	}

	pop	ebp
	ret	4
$LN5@HexDigits:

; 5040 : 		_Error(regex_constants::error_escape);

	push	2
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN7@HexDigits:
$LN4@HexDigits:
	int	3
?_HexDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXH@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_HexDigits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_DecimalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ
_TEXT	SEGMENT
?_DecimalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_DecimalDigits, COMDAT
; _this$ = ecx

; 5031 : 	return (_Do_digits(10, INT_MAX) != INT_MAX);

	push	2147483647				; 7fffffffH
	push	10					; 0000000aH
	call	?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
	xor	ecx, ecx
	cmp	eax, 2147483647				; 7fffffffH
	setne	al

; 5032 : 	}

	ret	0
?_DecimalDigits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAE_NXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_DecimalDigits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits, COMDAT
; _this$ = ecx

; 5013 : 	{	// translate digits to numeric value

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 5014 : 	int _Chv;
; 5015 : 	_Val = 0;
; 5016 : 	while (_Count != 0 && (_Chv = _Traits.value(_Char, _Base)) != -1)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [esi+68], 0
	test	edi, edi
	je	$LN37@Do_digits
	push	ebx
	mov	ebx, DWORD PTR __Base$[ebp]
$LN41@Do_digits:
	movzx	ecx, WORD PTR [esi+72]
	mov	eax, 48					; 00000030H

; 451  : 			|| (_Base == 8 && L'0' <= _Ch && _Ch <= L'7'))

	cmp	ebx, 8
	je	SHORT $LN32@Do_digits
	cmp	ax, cx
	ja	SHORT $LN6@Do_digits
	cmp	ecx, 57					; 00000039H
	jbe	SHORT $LN8@Do_digits
$LN6@Do_digits:

; 453  : 		else if (_Base != 16)

	cmp	ebx, 16					; 00000010H
	jne	$LN39@Do_digits

; 454  : 			;
; 455  : 		else if (L'a' <= _Ch && _Ch <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN12@Do_digits

; 456  : 			return (_Ch - L'a' + 10);

	sub	ecx, 87					; 00000057H
	jmp	SHORT $LN5@Do_digits
$LN12@Do_digits:

; 457  : 		else if (L'A' <= _Ch && _Ch <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN39@Do_digits

; 458  : 			return (_Ch - L'A' + 10);

	sub	ecx, 55					; 00000037H
	jmp	SHORT $LN5@Do_digits
$LN32@Do_digits:

; 451  : 			|| (_Base == 8 && L'0' <= _Ch && _Ch <= L'7'))

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 7
	ja	SHORT $LN39@Do_digits
$LN8@Do_digits:

; 452  : 			return (_Ch - L'0');

	sub	ecx, 48					; 00000030H
$LN5@Do_digits:

; 5014 : 	int _Chv;
; 5015 : 	_Val = 0;
; 5016 : 	while (_Count != 0 && (_Chv = _Traits.value(_Char, _Base)) != -1)

	cmp	ecx, -1
	je	SHORT $LN39@Do_digits

; 5017 : 		{	// append next digit
; 5018 : 		--_Count;
; 5019 : 		_Val *= _Base;

	mov	eax, DWORD PTR [esi+68]
	dec	edi
	imul	eax, ebx

; 5020 : 		_Val += _Chv;

	add	eax, ecx

; 4988 : 	if (_Pat != _End)

	mov	ecx, DWORD PTR [esi+8]

; 5020 : 		_Val += _Chv;

	mov	DWORD PTR [esi+68], eax

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [esi]
	cmp	eax, ecx
	je	SHORT $LN17@Do_digits

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN18@Do_digits

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, ecx
	je	SHORT $LN18@Do_digits
	mov	ecx, DWORD PTR [esi+80]
	test	cl, 8
	jne	SHORT $LN23@Do_digits
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN33@Do_digits
	cmp	edx, 41					; 00000029H
	je	SHORT $LN33@Do_digits
$LN23@Do_digits:
	test	cl, 16					; 00000010H
	jne	SHORT $LN18@Do_digits
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN33@Do_digits
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN18@Do_digits
$LN33@Do_digits:

; 4991 : 			++_Pat;

	mov	DWORD PTR [esi], eax
$LN18@Do_digits:

; 4992 : 		++_Pat;

	add	DWORD PTR [esi], 2
$LN17@Do_digits:

; 4993 : 		}
; 4994 : 	_Trans();

	mov	ecx, esi
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5014 : 	int _Chv;
; 5015 : 	_Val = 0;
; 5016 : 	while (_Count != 0 && (_Chv = _Traits.value(_Char, _Base)) != -1)

	test	edi, edi
	jne	$LN41@Do_digits
$LN39@Do_digits:
	pop	ebx

; 5021 : 		_Next();
; 5022 : 		}
; 5023 : 	return (_Count);

	mov	eax, edi
	pop	edi
	pop	esi

; 5024 : 	}

	pop	ebp
	ret	8
$LN37@Do_digits:

; 5021 : 		_Next();
; 5022 : 		}
; 5023 : 	return (_Count);

	mov	eax, edi
	pop	edi
	pop	esi

; 5024 : 	}

	pop	ebp
	ret	8
?_Do_digits@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEHHH@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Do_digits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Expect@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z
_TEXT	SEGMENT
__St$ = 8						; size = 4
__Code$ = 12						; size = 4
?_Expect@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Expect, COMDAT
; _this$ = ecx

; 5002 : 	{	// check whether current meta-character is _St

	npad	2
	push	ebp
	mov	ebp, esp

; 5003 : 	if (_Mchar != _St)

	mov	eax, DWORD PTR [ecx+76]
	cmp	eax, DWORD PTR __St$[ebp]
	jne	SHORT $LN19@Expect

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+8]
	cmp	eax, edx
	je	SHORT $LN5@Expect

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN6@Expect

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, edx
	je	SHORT $LN6@Expect
	mov	edx, DWORD PTR [ecx+80]
	push	esi
	test	dl, 8
	jne	SHORT $LN11@Expect
	movzx	esi, WORD PTR [eax]
	cmp	esi, 40					; 00000028H
	je	SHORT $LN16@Expect
	cmp	esi, 41					; 00000029H
	je	SHORT $LN16@Expect
$LN11@Expect:
	test	dl, 16					; 00000010H
	jne	SHORT $LN17@Expect
	movzx	edx, WORD PTR [eax]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN16@Expect
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN17@Expect
$LN16@Expect:

; 4991 : 			++_Pat;

	mov	DWORD PTR [ecx], eax
$LN17@Expect:
	pop	esi
$LN6@Expect:

; 4992 : 		++_Pat;

	add	DWORD PTR [ecx], 2
$LN5@Expect:

; 4993 : 		}
; 4994 : 	_Trans();

	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5005 : 	_Next();
; 5006 : 	}

	pop	ebp
	ret	8
$LN19@Expect:

; 5004 : 		_Error(_Code);

	push	DWORD PTR __Code$[ebp]
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN21@Expect:
$LN18@Expect:
	int	3
?_Expect@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4_Meta_type@2@W4error_type@regex_constants@2@@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Expect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next, COMDAT
; _this$ = ecx

; 4988 : 	if (_Pat != _End)

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+8]
	cmp	eax, edx
	je	SHORT $LN2@Next

; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())

	cmp	WORD PTR [eax], 92			; 0000005cH
	jne	SHORT $LN3@Next

; 4893 : 	return (++_Ch0 != _End

	add	eax, 2
	cmp	eax, edx
	je	SHORT $LN3@Next
	mov	edx, DWORD PTR [ecx+80]
	push	esi
	test	dl, 8
	jne	SHORT $LN8@Next
	movzx	esi, WORD PTR [eax]
	cmp	esi, 40					; 00000028H
	je	SHORT $LN13@Next
	cmp	esi, 41					; 00000029H
	je	SHORT $LN13@Next
$LN8@Next:
	test	dl, 16					; 00000010H
	jne	SHORT $LN14@Next
	movzx	edx, WORD PTR [eax]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN13@Next
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN14@Next
$LN13@Next:

; 4991 : 			++_Pat;

	mov	DWORD PTR [ecx], eax
$LN14@Next:
	pop	esi
$LN3@Next:

; 4992 : 		++_Pat;

	add	DWORD PTR [ecx], 2
$LN2@Next:

; 4993 : 		}
; 4994 : 	_Trans();

	jmp	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans
?_Next@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans, COMDAT
; _this$ = ecx

; 4904 : 	{	// map character to meta-character

	npad	2
	push	esi
	mov	esi, ecx

; 4905 : 	static constexpr char _Meta_map[] = {
; 4906 : 		_Meta_lpar, _Meta_rpar, _Meta_dlr, _Meta_caret,
; 4907 : 		_Meta_dot, _Meta_star, _Meta_plus, _Meta_query,
; 4908 : 		_Meta_lsq, _Meta_rsq, _Meta_bar, _Meta_esc,
; 4909 : 		_Meta_dash, _Meta_lbr, _Meta_rbr, _Meta_comma,
; 4910 : 		_Meta_colon, _Meta_equal, _Meta_exc, _Meta_nl,
; 4911 : 		_Meta_cr, _Meta_bsp,
; 4912 : 		0};	// array of meta chars
; 4913 : 
; 4914 : 	if (_Pat == _End)

	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN4@Trans

; 4915 : 		_Mchar = _Meta_eos, _Char = (_Elem)_Meta_eos;

	mov	eax, 65535				; 0000ffffH
	mov	DWORD PTR [esi+76], -1
	mov	WORD PTR [esi+72], ax

; 4916 : 	else

	jmp	SHORT $LN5@Trans
$LN4@Trans:

; 4917 : 		{	// map current character
; 4918 : 		_Char = *_Pat;

	movzx	eax, WORD PTR [eax]

; 4919 : 		_Mchar = _CSTD strchr(_Meta_map, _Char) != 0

	push	eax
	push	OFFSET ?_Meta_map@?1??_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ@4QBDB ; `std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans'::`2'::_Meta_map
	mov	WORD PTR [esi+72], ax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@Trans
	movzx	eax, WORD PTR [esi+72]
	jmp	SHORT $LN26@Trans
$LN25@Trans:
	xor	eax, eax
$LN26@Trans:
	mov	DWORD PTR [esi+76], eax
$LN5@Trans:

; 4920 : 			? (_Meta_type)_Char : _Meta_chr;
; 4921 : 		}
; 4922 : 	switch (_Char)

	movzx	eax, WORD PTR [esi+72]
	add	eax, -10				; fffffff6H
	cmp	eax, 115				; 00000073H
	ja	$LN23@Trans
	movzx	eax, BYTE PTR $LN27@Trans[eax]
	jmp	DWORD PTR $LN31@Trans[eax*4]
$LN6@Trans:

; 4923 : 		{	// handle special cases
; 4924 : 		case _Meta_esc:
; 4925 : 			if (_Is_esc())

	mov	ecx, esi
	call	?_Is_esc@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Is_esc
	test	al, al
	je	$LN23@Trans

; 4926 : 				{	// replace escape sequence
; 4927 : 				_FwdIt _Ch0 = _Pat;
; 4928 : 				_Mchar = _Meta_type(_Char = *++_Ch0);

	mov	eax, DWORD PTR [esi]
	movzx	eax, WORD PTR [eax+2]
	mov	WORD PTR [esi+72], ax
	mov	DWORD PTR [esi+76], eax
	pop	esi

; 4979 : 			break;
; 4980 : 		}
; 4981 : 	}

	ret	0
$LN8@Trans:

; 4929 : 				}
; 4930 : 			break;
; 4931 : 
; 4932 : 		case _Meta_nl:
; 4933 : 			if ((_L_flags & _L_alt_nl) && _Disj_count == 0)

	test	BYTE PTR [esi+80], 4
	je	$LN23@Trans
	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN23@Trans

; 4934 : 				_Mchar = _Meta_bar;

	mov	DWORD PTR [esi+76], 124			; 0000007cH
	pop	esi

; 4979 : 			break;
; 4980 : 		}
; 4981 : 	}

	ret	0
$LN10@Trans:

; 4935 : 			break;
; 4936 : 
; 4937 : 		case _Meta_lpar:
; 4938 : 		case _Meta_rpar:
; 4939 : 			if (!(_L_flags & _L_nex_grp))

	test	BYTE PTR [esi+80], 8

; 4940 : 				_Mchar = _Meta_chr;
; 4941 : 			break;

	jmp	SHORT $LN28@Trans
$LN12@Trans:

; 4942 : 
; 4943 : 		case _Meta_lbr:
; 4944 : 		case _Meta_rbr:
; 4945 : 			if (!(_L_flags & _L_nex_rep))

	test	BYTE PTR [esi+80], 16			; 00000010H

; 4946 : 				_Mchar = _Meta_chr;
; 4947 : 			break;

	jmp	SHORT $LN28@Trans
$LN14@Trans:

; 4948 : 
; 4949 : 		case _Meta_star:
; 4950 : 			if ((_L_flags & _L_star_beg)
; 4951 : 				&& _Nfa._Beg_expr())

	test	DWORD PTR [esi+80], 67108864		; 04000000H
	je	SHORT $LN23@Trans
	lea	ecx, DWORD PTR [esi+36]
	call	?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBE_NXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Beg_expr
	test	al, al
	je	SHORT $LN23@Trans

; 4978 : 				_Mchar = _Meta_chr;

	mov	DWORD PTR [esi+76], 0
	pop	esi

; 4979 : 			break;
; 4980 : 		}
; 4981 : 	}

	ret	0
$LN16@Trans:

; 4952 : 				_Mchar = _Meta_chr;
; 4953 : 			break;
; 4954 : 
; 4955 : 		case _Meta_caret:
; 4956 : 			if ((_L_flags & _L_anch_rstr)
; 4957 : 				&& !_Nfa._Beg_expr())

	test	DWORD PTR [esi+80], 33554432		; 02000000H
	je	SHORT $LN23@Trans
	lea	ecx, DWORD PTR [esi+36]
	call	?_Beg_expr@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QBE_NXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Beg_expr
	test	al, al

; 4958 : 			_Mchar = _Meta_chr;
; 4959 : 			break;

	jmp	SHORT $LN28@Trans
$LN18@Trans:

; 4960 : 
; 4961 : 		case _Meta_dlr:
; 4962 : 			{	// check if $ is special
; 4963 : 			_FwdIt _Ch0 = _Pat;
; 4964 : 			if ((_L_flags & _L_anch_rstr)
; 4965 : 				&& ++_Ch0 != _End && *_Ch0 != _Meta_nl)

	test	DWORD PTR [esi+80], 33554432		; 02000000H
	je	SHORT $LN23@Trans
	mov	eax, DWORD PTR [esi]
	add	eax, 2
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN23@Trans
	cmp	WORD PTR [eax], 10			; 0000000aH
	je	SHORT $LN23@Trans

; 4978 : 				_Mchar = _Meta_chr;

	mov	DWORD PTR [esi+76], 0
	pop	esi

; 4979 : 			break;
; 4980 : 		}
; 4981 : 	}

	ret	0
$LN20@Trans:

; 4966 : 				_Mchar = _Meta_chr;
; 4967 : 			break;
; 4968 : 			}
; 4969 : 
; 4970 : 		case _Meta_plus:
; 4971 : 		case _Meta_query:
; 4972 : 			if (!(_L_flags & _L_ext_rep))

	test	BYTE PTR [esi+80], 1

; 4973 : 				_Mchar = _Meta_chr;
; 4974 : 			break;

	jmp	SHORT $LN28@Trans
$LN22@Trans:

; 4975 : 
; 4976 : 		case _Meta_bar:
; 4977 : 			if (!(_L_flags & _L_alt_pipe))

	test	BYTE PTR [esi+80], 2
$LN28@Trans:
	jne	SHORT $LN23@Trans

; 4978 : 				_Mchar = _Meta_chr;

	mov	DWORD PTR [esi+76], 0
$LN23@Trans:
	pop	esi

; 4979 : 			break;
; 4980 : 		}
; 4981 : 	}

	ret	0
	npad	2
$LN31@Trans:
	DD	$LN8@Trans
	DD	$LN18@Trans
	DD	$LN10@Trans
	DD	$LN14@Trans
	DD	$LN20@Trans
	DD	$LN6@Trans
	DD	$LN16@Trans
	DD	$LN12@Trans
	DD	$LN22@Trans
	DD	$LN23@Trans
$LN27@Trans:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	2
	DB	2
	DB	3
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	8
	DB	7
?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Is_esc@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_Is_esc@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Is_esc, COMDAT
; _this$ = ecx

; 4892 : 	_FwdIt _Ch0 = _Pat;
; 4893 : 	return (++_Ch0 != _End

	mov	eax, DWORD PTR [ecx]
	add	eax, 2
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN7@Is_esc
	mov	ecx, DWORD PTR [ecx+80]
	test	cl, 8
	jne	SHORT $LN4@Is_esc
	movzx	edx, WORD PTR [eax]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN3@Is_esc
	cmp	edx, 41					; 00000029H
	je	SHORT $LN3@Is_esc
$LN4@Is_esc:
	test	cl, 16					; 00000010H
	jne	SHORT $LN7@Is_esc
	movzx	eax, WORD PTR [eax]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN3@Is_esc
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN7@Is_esc
$LN3@Is_esc:
	mov	al, 1

; 4894 : 		&& ((!(_L_flags & _L_nex_grp)
; 4895 : 			&& (*_Ch0 == _Meta_lpar || *_Ch0 == _Meta_rpar))
; 4896 : 		|| (!(_L_flags & _L_nex_rep)
; 4897 : 			&& (*_Ch0 == _Meta_lbr || *_Ch0 == _Meta_rbr))));
; 4898 : 	}

	ret	0
$LN7@Is_esc:

; 4892 : 	_FwdIt _Ch0 = _Pat;
; 4893 : 	return (++_Ch0 != _End

	xor	al, al

; 4894 : 		&& ((!(_L_flags & _L_nex_grp)
; 4895 : 			&& (*_Ch0 == _Meta_lpar || *_Ch0 == _Meta_rpar))
; 4896 : 		|| (!(_L_flags & _L_nex_rep)
; 4897 : 			&& (*_Ch0 == _Meta_lbr || *_Ch0 == _Meta_rbr))));
; 4898 : 	}

	ret	0
?_Is_esc@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@ABE_NXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Is_esc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error, COMDAT
; _this$ = ecx

; 4883 : 	{	// handle error

	npad	2
	push	ebp
	mov	ebp, esp

; 4884 : 	_Xregex_error(_Code);

	push	DWORD PTR __Code$[ebp]
	call	DWORD PTR __imp_?_Xregex_error@std@@YAXW4error_type@regex_constants@1@@Z
$LN4@Error:
$LN3@Error:
	int	3
?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Mark_count@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Mark_count@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QBEIXZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Mark_count, COMDAT
; _this$ = ecx

; 2174 : 		return (_Grp_idx + 1);

	mov	eax, DWORD PTR [ecx+12]
	inc	eax

; 2175 : 		}

	ret	0
?_Mark_count@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QBEIXZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Mark_count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Compile, COMDAT
; _this$ = ecx

; 5704 : 	{	// compile regular expression

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 5705 : 	_Root_node *_Res = 0;
; 5706 : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 5707 : 	_Node_base *_Pos1 = _Nfa._Begin_capture_group(0);

	push	0
	lea	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR _this$[ebp], esi
	call	?_Begin_capture_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Node_base@2@I@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Begin_capture_group

; 5708 : 	_Disjunction();

	mov	ecx, esi
	mov	ebx, eax
	call	?_Disjunction@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Disjunction

; 5709 : 	if (_Pat != _End)

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [esi+8]
	je	SHORT $LN3@Compile

; 5710 : 		_Error(regex_constants::error_syntax);

	push	14					; 0000000eH
	mov	ecx, esi
	call	?_Error@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXW4error_type@regex_constants@2@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Error
$LN15@Compile:
$LN3@Compile:

; 5711 : 	_Nfa._End_group(_Pos1);

	push	ebx
	lea	ecx, DWORD PTR [esi+36]
	call	?_End_group@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXPAV_Node_base@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_End_group

; 4135 : 	_New_node(_N_end);

	push	21					; 00000015H
	lea	ecx, DWORD PTR [esi+36]
	call	?_New_node@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@AAEPAV_Node_base@2@W4_Node_type@2@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_New_node

; 4136 : 	return (_Root);

	mov	edi, DWORD PTR [esi+36]

; 5712 : 	_Res = _Nfa._End_pattern();
; 5713 : 	_Res->_Fl = _Flags;

	mov	eax, DWORD PTR [esi+64]

; 5714 : 	_Res->_Marks = _Mark_count();
; 5715 : 	_Calculate_loop_simplicity(_Res, 0, 0);

	push	0
	push	0
	mov	DWORD PTR [edi+20], eax

; 2174 : 		return (_Grp_idx + 1);

	mov	ecx, DWORD PTR [esi+12]
	inc	ecx

; 5714 : 	_Res->_Marks = _Mark_count();
; 5715 : 	_Calculate_loop_simplicity(_Res, 0, 0);

	push	edi
	mov	DWORD PTR [edi+28], ecx
	call	?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ; std::_Calculate_loop_simplicity

; 5719 : 	_CATCH_END
; 5720 : 	return (_Res);
; 5721 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	add	esp, 12					; 0000000cH
	mov	eax, edi
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ$0:

; 5716 : 	_CATCH_ALL
; 5717 : 	_Nfa._Discard_pattern();

	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+36]
	call	?_Discard_pattern@?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAEXXZ ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Discard_pattern

; 5718 : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN16@Compile:
$LN14@Compile:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ:
	mov	eax, OFFSET __ehfuncinfo$?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Compile
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Tr$ = 8						; size = 4
_this$ = 12						; size = 4
__Pfirst$ = 12						; size = 4
$T2 = 15						; size = 1
$T3 = 16						; size = 4
__Plast$ = 16						; size = 4
__Fx$ = 20						; size = 4
??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z PROC ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 5733 : 	{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx

; 3624 : 	}
; 3625 : 
; 3626 : template<class _FwdIt,
; 3627 : 	class _Elem,
; 3628 : 	class _RxTraits> inline
; 3629 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Negate()
; 3630 : 	{	// set flag
; 3631 : 	_Current->_Flags ^= _Fl_negate;
; 3632 : 	}
; 3633 : 
; 3634 : template<class _FwdIt,
; 3635 : 	class _Elem,
; 3636 : 	class _RxTraits> inline
; 3637 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Mark_final()
; 3638 : 	{	// set flag
; 3639 : 	_Current->_Flags |= _Fl_final;
; 3640 : 	}
; 3641 : 
; 3642 : template<class _FwdIt,
; 3643 : 	class _Elem,
; 3644 : 	class _RxTraits> inline
; 3645 : 	_Node_base *_Builder<_FwdIt, _Elem, _RxTraits>::_Getmark() const
; 3646 : 	{	// return current node
; 3647 : 	return (_Current);
; 3648 : 	}
; 3649 : 
; 3650 : template<class _FwdIt,
; 3651 : 	class _Elem,
; 3652 : 	class _RxTraits> inline
; 3653 : 	bool _Builder<_FwdIt,
; 3654 : 		_Elem, _RxTraits>::_Beg_expr(_Node_base *_Nx) const
; 3655 : 	{	// test for beginning of expression or subexpression
; 3656 : 	return (_Nx->_Kind == _N_begin
; 3657 : 		|| _Nx->_Kind == _N_group
; 3658 : 		|| _Nx->_Kind == _N_capture);
; 3659 : 	}
; 3660 : 
; 3661 : template<class _FwdIt,
; 3662 : 	class _Elem,
; 3663 : 	class _RxTraits> inline
; 3664 : 	bool _Builder<_FwdIt, _Elem, _RxTraits>::_Beg_expr() const
; 3665 : 	{	// test for beginning of expression or subexpression
; 3666 : 	return (_Beg_expr(_Current)
; 3667 : 		|| (_Current->_Kind == _N_bol && _Beg_expr(_Current->_Prev)));
; 3668 : 	}
; 3669 : 
; 3670 : template<class _FwdIt,
; 3671 : 	class _Elem,
; 3672 : 	class _RxTraits> inline
; 3673 : 	_Node_base *_Builder<_FwdIt, _Elem, _RxTraits>::_Link_node(
; 3674 : 		_Node_base *_Nx)
; 3675 : 	{	// insert _Nx at current location
; 3676 : 	_Nx->_Prev = _Current;
; 3677 : 	if (_Current->_Next)
; 3678 : 		{	// set back pointer
; 3679 : 		_Nx->_Next = _Current->_Next;
; 3680 : 		_Current->_Next->_Prev = _Nx;
; 3681 : 		}
; 3682 : 	_Current->_Next = _Nx;
; 3683 : 	_Current = _Nx;
; 3684 : 	return (_Nx);
; 3685 : 	}
; 3686 : 
; 3687 : template<class _FwdIt,
; 3688 : 	class _Elem,
; 3689 : 	class _RxTraits> inline
; 3690 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Insert_node(
; 3691 : 		_Node_base *_Insert_before,
; 3692 : 		_Node_base *_To_insert)
; 3693 : 	{	// insert _To_insert into the graph before the node _Insert_before
; 3694 : 	_Insert_before->_Prev->_Next = _To_insert;
; 3695 : 	_To_insert->_Prev = _Insert_before->_Prev;
; 3696 : 	_Insert_before->_Prev = _To_insert;
; 3697 : 	_To_insert->_Next = _Insert_before;
; 3698 : 	}
; 3699 : 
; 3700 : template<class _FwdIt,
; 3701 : 	class _Elem,
; 3702 : 	class _RxTraits> inline
; 3703 : 	_Node_base *_Builder<_FwdIt, _Elem, _RxTraits>::_New_node(
; 3704 : 		_Node_type _Kind)
; 3705 : 	{	// allocate and link simple node
; 3706 : 	return (_Link_node(new _Node_base(_Kind)));
; 3707 : 	}
; 3708 : 
; 3709 : template<class _FwdIt,
; 3710 : 	class _Elem,
; 3711 : 	class _RxTraits> inline
; 3712 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_nop()
; 3713 : 	{	// add nop node
; 3714 : 	_New_node(_N_nop);
; 3715 : 	}
; 3716 : 
; 3717 : template<class _FwdIt,
; 3718 : 	class _Elem,
; 3719 : 	class _RxTraits> inline
; 3720 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_bol()
; 3721 : 	{	// add bol node
; 3722 : 	_New_node(_N_bol);
; 3723 : 	}
; 3724 : 
; 3725 : template<class _FwdIt,
; 3726 : 	class _Elem,
; 3727 : 	class _RxTraits> inline
; 3728 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_eol()
; 3729 : 	{	// add eol node
; 3730 : 	_New_node(_N_eol);
; 3731 : 	}
; 3732 : 
; 3733 : template<class _FwdIt,
; 3734 : 	class _Elem,
; 3735 : 	class _RxTraits> inline
; 3736 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_wbound()
; 3737 : 	{	// add wbound node
; 3738 : 	_New_node(_N_wbound);
; 3739 : 	}
; 3740 : 
; 3741 : template<class _FwdIt,
; 3742 : 	class _Elem,
; 3743 : 	class _RxTraits> inline
; 3744 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_dot()
; 3745 : 	{	// add dot node
; 3746 : 	_New_node(_N_dot);
; 3747 : 	}
; 3748 : 
; 3749 : template<class _FwdIt,
; 3750 : 	class _Elem,
; 3751 : 	class _RxTraits> inline
; 3752 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_str_node()
; 3753 : 	{	// add string node
; 3754 : 	_Link_node(new _Node_str<_Elem>);
; 3755 : 	}
; 3756 : 
; 3757 : template<class _FwdIt,
; 3758 : 	class _Elem,
; 3759 : 	class _RxTraits> inline
; 3760 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_char(_Elem _Ch)
; 3761 : 	{	// append character
; 3762 : 	if (_Current->_Kind != _N_str || _Current->_Flags & _Fl_final)
; 3763 : 		_Add_str_node();
; 3764 : 	if (_Flags & regex_constants::icase)
; 3765 : 		_Ch = _Traits.translate_nocase(_Ch);
; 3766 : 	else if (_Flags & regex_constants::collate)
; 3767 : 		_Ch = _Traits.translate(_Ch);
; 3768 : 	_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Current;
; 3769 : 	_Node->_Data._Insert(_Ch);
; 3770 : 	}
; 3771 : 
; 3772 : template<class _FwdIt,
; 3773 : 	class _Elem,
; 3774 : 	class _RxTraits> inline
; 3775 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_class()
; 3776 : 	{	// add bracket expression node
; 3777 : 	_Link_node(new _Node_class<_Elem, _RxTraits>);
; 3778 : 	}
; 3779 : 
; 3780 : template<class _FwdIt,
; 3781 : 	class _Elem,
; 3782 : 	class _RxTraits> inline
; 3783 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_char_to_bitmap(_Elem _Ch)
; 3784 : 	{	// add character to accelerator table
; 3785 : 	if (_Flags & regex_constants::icase)
; 3786 : 		_Ch = _Traits.translate_nocase(_Ch);
; 3787 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3788 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3789 : 
; 3790 : 	if (!_Node->_Small)
; 3791 : 		_Node->_Small = new _Bitmap;
; 3792 : 	_Node->_Small->_Mark(static_cast<typename _RxTraits::_Uelem>(_Ch));
; 3793 : 	}
; 3794 : 
; 3795 : template<class _FwdIt,
; 3796 : 	class _Elem,
; 3797 : 	class _RxTraits> inline
; 3798 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_char_to_array(_Elem _Ch)
; 3799 : 	{	// append character to character array
; 3800 : 	if (_Flags & regex_constants::icase)
; 3801 : 		_Ch = _Traits.translate_nocase(_Ch);
; 3802 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3803 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3804 : 	if (!_Node->_Large)
; 3805 : 		_Node->_Large = new _Buf<_Elem>;
; 3806 : 	_Node->_Large->_Insert(_Ch);
; 3807 : 	}
; 3808 : 
; 3809 : template<class _FwdIt,
; 3810 : 	class _Elem,
; 3811 : 	class _RxTraits> inline
; 3812 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_char_to_class(_Elem _Ch)
; 3813 : 	{	// add character to bracket expression
; 3814 : 	if (static_cast<typename _RxTraits::_Uelem>(_Ch) < _Bmp_max)
; 3815 : 		_Add_char_to_bitmap(_Ch);
; 3816 : 	else
; 3817 : 		_Add_char_to_array(_Ch);
; 3818 : 	}
; 3819 : 
; 3820 : template<class _FwdIt,
; 3821 : 	class _Elem,
; 3822 : 	class _RxTraits> inline
; 3823 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_range(_Elem _E0x,
; 3824 : 		_Elem _E1x)
; 3825 : 	{	// add character range to set
; 3826 : 	unsigned int _E0 = (typename _RxTraits::_Uelem)_E0x;
; 3827 : 	unsigned int _E1 = (typename _RxTraits::_Uelem)_E1x;
; 3828 : 	if (_Flags & regex_constants::icase)
; 3829 : 		{	// change to lowercase range
; 3830 : 		_E0 = _Traits.translate_nocase((_Elem)_E0);
; 3831 : 		_E1 = _Traits.translate_nocase((_Elem)_E1);
; 3832 : 		}
; 3833 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3834 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3835 : 	for (; _E0 <= _E1 && _E1 < _Get_bmax(); ++_E0)
; 3836 : 		{	// set a bit
; 3837 : 		if (!_Node->_Small)
; 3838 : 			_Node->_Small = new _Bitmap;
; 3839 : 		_Node->_Small->_Mark(_E0);
; 3840 : 		}
; 3841 : 	if (_E1 < _E0)
; 3842 : 		;
; 3843 : 	else if (_E1 - _E0 < _Get_tmax())
; 3844 : 		for (; _E0 <= _E1; ++_E0)
; 3845 : 			_Add_char_to_array((_Elem)_E0);
; 3846 : 	else
; 3847 : 		{	// store remaining range as pair
; 3848 : 		if (!_Node->_Ranges)
; 3849 : 			_Node->_Ranges = new _Buf<_Elem>;
; 3850 : 		_Node->_Ranges->_Insert((_Elem)_E0);
; 3851 : 		_Node->_Ranges->_Insert((_Elem)_E1);
; 3852 : 		}
; 3853 : 	}
; 3854 : 
; 3855 : template<class _FwdIt,
; 3856 : 	class _Elem,
; 3857 : 	class _RxTraits> inline
; 3858 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_elts(
; 3859 : 		_Node_class<_Elem, _RxTraits> *_Node,
; 3860 : 		_Regex_traits_base::char_class_type _Cl,
; 3861 : 		bool _Negate)
; 3862 : 	{	// add characters in named class to set
; 3863 : 	for (unsigned int _Ch = 0; _Ch < _Bmp_max; ++_Ch)
; 3864 : 		{	// add elements or their inverse
; 3865 : 		bool _Matches = _Traits.isctype(static_cast<_Elem>(_Ch), _Cl);
; 3866 : 		if (_Matches != _Negate)
; 3867 : 			{	// add contents of named class to accelerator table
; 3868 : 			if (!_Node->_Small)
; 3869 : 				_Node->_Small = new _Bitmap;
; 3870 : 			_Node->_Small->_Mark(_Ch);
; 3871 : 			}
; 3872 : 		}
; 3873 : 	}
; 3874 : 
; 3875 : template<class _FwdIt,
; 3876 : 	class _Elem,
; 3877 : 	class _RxTraits> inline
; 3878 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_named_class(
; 3879 : 		typename _Regex_traits_base::char_class_type _Cl,
; 3880 : 		bool _Negate)
; 3881 : 	{	// add contents of named class to bracket expression
; 3882 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3883 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3884 : 	_Add_elts(_Node, _Cl, _Negate);
; 3885 : 	if (_Bmp_max < static_cast<unsigned int>((numeric_limits<_Elem>::max)()))
; 3886 : 		_Node->_Classes =
; 3887 : 			(_Regex_traits_base::char_class_type)(_Node->_Classes | _Cl);
; 3888 : 	}
; 3889 : 
; 3890 : template<class _FwdIt,
; 3891 : 	class _Elem,
; 3892 : 	class _RxTraits> inline
; 3893 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Char_to_elts(
; 3894 : 		_FwdIt _First, _FwdIt _Last, _Difft _Diff,
; 3895 : 		_Sequence<_Elem> **_Cur)
; 3896 : 	{	// add collation element to element sequence
; 3897 : 	while (*_Cur && (unsigned int)_Diff < (*_Cur)->_Sz)
; 3898 : 		_Cur = &(*_Cur)->_Next;
; 3899 : 	if (!(*_Cur) || (unsigned int)_Diff != (*_Cur)->_Sz)
; 3900 : 		{	// add new sequence holding elements of the same length
; 3901 : 		_Sequence<_Elem> *_Node = *_Cur;
; 3902 : 		*_Cur = new _Sequence<_Elem>((unsigned int)_Diff);
; 3903 : 		(*_Cur)->_Next = _Node;
; 3904 : 		}
; 3905 : 	(*_Cur)->_Data._Insert(_First, _Last);
; 3906 : 	}
; 3907 : 
; 3908 : template<class _FwdIt,
; 3909 : 	class _Elem,
; 3910 : 	class _RxTraits> inline
; 3911 : 	unsigned int _Builder<_FwdIt, _Elem, _RxTraits>::_Get_bmax() const
; 3912 : 	{
; 3913 : 	return (static_cast<unsigned int>(_Bmax));
; 3914 : 	}
; 3915 : 
; 3916 : template<class _FwdIt,
; 3917 : 	class _Elem,
; 3918 : 	class _RxTraits> inline
; 3919 : 	unsigned int _Builder<_FwdIt, _Elem, _RxTraits>::_Get_tmax() const
; 3920 : 	{
; 3921 : 	return (static_cast<unsigned int>(_Tmax));
; 3922 : 	}
; 3923 : 
; 3924 : template<class _FwdIt,
; 3925 : 	class _Elem,
; 3926 : 	class _RxTraits> inline
; 3927 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_equiv(
; 3928 : 		_FwdIt _First, _FwdIt _Last, _Difft _Diff)
; 3929 : 	{	// add elements of equivalence class to bracket expression
; 3930 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3931 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3932 : 	typename _RxTraits::string_type _Str =
; 3933 : 		_Traits.transform_primary(_First, _Last);
; 3934 : 	for (unsigned int _Ch = 0; _Ch < _Bmp_max; ++_Ch)
; 3935 : 		{	// add elements
; 3936 : 		_Elem _Ex = (_Elem)_Ch;
; 3937 : 		if (_Traits.transform_primary(&_Ex, &_Ex + 1) == _Str)
; 3938 : 			{	// insert equivalent character into bitmap
; 3939 : 			if (!_Node->_Small)
; 3940 : 				_Node->_Small = new _Bitmap;
; 3941 : 			_Node->_Small->_Mark(_Ch);
; 3942 : 			}
; 3943 : 		}
; 3944 : 	if (_Bmp_max < static_cast<unsigned int>((numeric_limits<_Elem>::max)()))
; 3945 : 		{	// map range
; 3946 : 		_Sequence<_Elem> **_Cur = &_Node->_Equiv;
; 3947 : 		_Char_to_elts(_First, _Last, _Diff, _Cur);
; 3948 : 		}
; 3949 : 	}
; 3950 : 
; 3951 : template<class _FwdIt,
; 3952 : 	class _Elem,
; 3953 : 	class _RxTraits> inline
; 3954 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_coll(
; 3955 : 		_FwdIt _First, _FwdIt _Last, _Difft _Diff)
; 3956 : 	{	// add collation element to bracket expression
; 3957 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 3958 : 		(_Node_class<_Elem, _RxTraits> *)_Current;
; 3959 : 	_Sequence<_Elem> **_Cur = &_Node->_Coll;
; 3960 : 	_Char_to_elts(_First, _Last, _Diff, _Cur);
; 3961 : 	}
; 3962 : 
; 3963 : template<class _FwdIt,
; 3964 : 	class _Elem,
; 3965 : 	class _RxTraits> inline
; 3966 : 	_Node_base *_Builder<_FwdIt, _Elem, _RxTraits>::_Begin_group()
; 3967 : 	{	// add group node
; 3968 : 	return (_New_node(_N_group));
; 3969 : 	}
; 3970 : 
; 3971 : template<class _FwdIt,
; 3972 : 	class _Elem,
; 3973 : 	class _RxTraits> inline
; 3974 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_End_group(
; 3975 : 		_Node_base *_Back)
; 3976 : 	{	// add end of group node
; 3977 : 	_Node_type _Elt = _Back->_Kind == _N_group ? _N_end_group
; 3978 : 		: _Back->_Kind == _N_assert ? _N_end_assert
; 3979 : 		: _Back->_Kind == _N_neg_assert ? _N_end_assert
; 3980 : 		: _N_end_capture;
; 3981 : 	_Link_node(new _Node_end_group(_Elt, _Fl_none, _Back));
; 3982 : 	}
; 3983 : 
; 3984 : template<class _FwdIt,
; 3985 : 	class _Elem,
; 3986 : 	class _RxTraits> inline
; 3987 : 	_Node_base *_Builder<_FwdIt, _Elem, _RxTraits>::_Begin_assert_group(
; 3988 : 		bool _Neg)
; 3989 : 	{	// add assert node
; 3990 : 	_Node_assert *_Node1 = new _Node_assert(_Neg
; 3991 : 		? _N_neg_assert : _N_assert);
; 3992 : 
; 3993 : 	_Node_base *_Node2;
; 3994 : 	_TRY_BEGIN
; 3995 : 	_Node2 = new _Node_base(_N_nop);
; 3996 : 	_CATCH_ALL
; 3997 : 	delete _Node1;
; 3998 : 	_RERAISE;
; 3999 : 	_CATCH_END
; 4000 : 
; 4001 : 	_Link_node(_Node1);
; 4002 : 	_Node1->_Child = _Node2;
; 4003 : 	_Node2->_Prev = _Node1;
; 4004 : 	_Current = _Node2;
; 4005 : 	return (_Node1);
; 4006 : 	}
; 4007 : 
; 4008 : template<class _FwdIt,
; 4009 : 	class _Elem,
; 4010 : 	class _RxTraits> inline
; 4011 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_End_assert_group(
; 4012 : 		_Node_base *_Nx)
; 4013 : 	{	// add end of assert node
; 4014 : 	_End_group(_Nx);
; 4015 : 	_Current = _Nx;
; 4016 : 	}
; 4017 : 
; 4018 : template<class _FwdIt,
; 4019 : 	class _Elem,
; 4020 : 	class _RxTraits> inline
; 4021 : 	_Node_base *_Builder<_FwdIt, _Elem, _RxTraits>::_Begin_capture_group(
; 4022 : 		unsigned int _Idx)
; 4023 : 	{	// add capture group node
; 4024 : 	return (_Link_node(new _Node_capture(_Idx)));
; 4025 : 	}
; 4026 : 
; 4027 : template<class _FwdIt,
; 4028 : 	class _Elem,
; 4029 : 	class _RxTraits> inline
; 4030 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_backreference(
; 4031 : 		unsigned int _Idx)
; 4032 : 	{	// add back reference node
; 4033 : 	_Link_node(new _Node_back(_Idx));
; 4034 : 	}
; 4035 : 
; 4036 : template<class _FwdIt,
; 4037 : 	class _Elem,
; 4038 : 	class _RxTraits> inline
; 4039 : 	_Node_base *_Builder<_FwdIt, _Elem, _RxTraits>::_Begin_if(
; 4040 : 		_Node_base *_Start)
; 4041 : 	{	// add if node
; 4042 : 	/* append endif node */
; 4043 : 	_Node_base *_Res = new _Node_endif;
; 4044 : 	_Link_node(_Res);
; 4045 : 
; 4046 : 	/* insert if_node */
; 4047 : 	_Node_if *_Node1 = new _Node_if(_Res);
; 4048 : 	_Node_base *_Pos = _Start->_Next;
; 4049 : 	_Insert_node(_Pos, _Node1);
; 4050 : 	return (_Res);
; 4051 : 	}
; 4052 : 
; 4053 : template<class _FwdIt,
; 4054 : 	class _Elem,
; 4055 : 	class _RxTraits> inline
; 4056 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Else_if(
; 4057 : 		_Node_base *_Start, _Node_base *_End)
; 4058 : 	{	// add else node
; 4059 : 	_Node_if *_Parent = (_Node_if *)_Start->_Next;
; 4060 : 	_Node_base *_First = _End->_Next;
; 4061 : 	_End->_Next = 0;
; 4062 : 	_Node_base *_Last = _Current;
; 4063 : 	_Current = _End;
; 4064 : 	_End->_Next = 0;
; 4065 : 	_Last->_Next = _End;
; 4066 : 	while (_Parent->_Child)
; 4067 : 		_Parent = _Parent->_Child;
; 4068 : 	_Parent->_Child = new _Node_if(_End);
; 4069 : 	_Parent->_Child->_Next = _First;
; 4070 : 	_First->_Prev = _Parent->_Child;
; 4071 : 	}
; 4072 : 
; 4073 : template<class _FwdIt,
; 4074 : 	class _Elem,
; 4075 : 	class _RxTraits> inline
; 4076 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Add_rep(
; 4077 : 		int _Min, int _Max, bool _Greedy)
; 4078 : 	{	// add repeat node
; 4079 : 	if (_Current->_Kind == _N_str
; 4080 : 		&& ((_Node_str<_Elem> *)_Current)->_Data._Size() != 1)
; 4081 : 		{	// move final character to new string node
; 4082 : 		_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Current;
; 4083 : 		_Add_char(_Node->_Data._Del());
; 4084 : 		}
; 4085 : 
; 4086 : 	_Node_base *_Pos = _Current;
; 4087 : 	if (_Pos->_Kind == _N_end_group
; 4088 : 		|| _Pos->_Kind == _N_end_capture)
; 4089 : 		_Pos = ((_Node_end_group *)_Pos)->_Back;
; 4090 : 
; 4091 : 	if (_Min == 0 && _Max == 1)
; 4092 : 		{	// rewrite zero-or-one quantifiers as alternations to make the
; 4093 : 			// "simple loop" optimization more likely to engage
; 4094 : 		_Node_endif *_End = new _Node_endif;
; 4095 : 		_Node_if *_If_expr = new _Node_if(_End);
; 4096 : 		_Node_if *_If_empty_str = new _Node_if(_End);
; 4097 : 		_Node_base *_Gbegin = new _Node_base(_N_group);
; 4098 : 		_Node_end_group *_Gend = new _Node_end_group(_N_end_group, _Fl_none, _Gbegin);
; 4099 : 
; 4100 : 		_If_empty_str->_Next = _Gbegin;
; 4101 : 		_Gbegin->_Prev = _If_empty_str;
; 4102 : 
; 4103 : 		_Gbegin->_Next = _Gend;
; 4104 : 		_Gend->_Prev = _Gbegin;
; 4105 : 
; 4106 : 		_Gend->_Next = _End;
; 4107 : 
; 4108 : 		_If_expr->_Child = _If_empty_str;
; 4109 : 
; 4110 : 		_Link_node(_End);
; 4111 : 		_Insert_node(_Pos, _If_expr);
; 4112 : 
; 4113 : 		if (!_Greedy)
; 4114 : 			{
; 4115 : 			_Swap_adl(_If_expr->_Next->_Prev, _If_empty_str->_Next->_Prev);
; 4116 : 			_Swap_adl(_If_expr->_Next, _If_empty_str->_Next);
; 4117 : 			}
; 4118 : 		}
; 4119 : 	else
; 4120 : 		{
; 4121 : 		_Node_end_rep *_Node0 = new _Node_end_rep();
; 4122 : 		_Node_rep *_Nx =
; 4123 : 			new _Node_rep(_Greedy, _Min, _Max, _Node0, _Root->_Loops++);
; 4124 : 		_Node0->_Begin_rep = _Nx;
; 4125 : 		_Link_node(_Node0);
; 4126 : 		_Insert_node(_Pos, _Nx);
; 4127 : 		}
; 4128 : 	}
; 4129 : 
; 4130 : template<class _FwdIt,
; 4131 : 	class _Elem,
; 4132 : 	class _RxTraits> inline
; 4133 : 	_Root_node *_Builder<_FwdIt, _Elem, _RxTraits>::_End_pattern()
; 4134 : 	{	// wrap up
; 4135 : 	_New_node(_N_end);
; 4136 : 	return (_Root);
; 4137 : 	}
; 4138 : 
; 4139 : template<class _FwdIt,
; 4140 : 	class _Elem,
; 4141 : 	class _RxTraits> inline
; 4142 : 	void _Builder<_FwdIt, _Elem, _RxTraits>::_Discard_pattern()
; 4143 : 	{	// free memory
; 4144 : 	_Destroy_node(_Root);
; 4145 : 	_Root = 0;
; 4146 : 	}
; 4147 : 
; 4148 : 	// IMPLEMENTATION OF _Matcher
; 4149 : template<class _BidIt,
; 4150 : 	class _Elem,
; 4151 : 	class _RxTraits,
; 4152 : 	class _It> inline
; 4153 : 	bool _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Do_if(
; 4154 : 		_Node_if *_Node)
; 4155 : 	{	// apply if node
; 4156 : 	_Tgt_state_t<_It> _St = _Tgt_state;
; 4157 : 
; 4158 : 	// look for the first match
; 4159 : 	for (; _Node; _Node = _Node->_Child)
; 4160 : 		{	// process one branch of if
; 4161 : 		_Tgt_state = _St; // rewind to where the alternation starts in input
; 4162 : 		if (_Match_pat(_Node->_Next)) // try to match this branch
; 4163 : 			break;
; 4164 : 		}
; 4165 : 
; 4166 : 	// if none of the if branches matched, fail to match
; 4167 : 	if (!_Node)
; 4168 : 		return (false);
; 4169 : 
; 4170 : 	// if we aren't looking for the longest match, that's it
; 4171 : 	if (!_Longest)
; 4172 : 		return (true);
; 4173 : 
; 4174 : 	// see if there is a longer match
; 4175 : 	_Tgt_state_t<_It> _Final = _Tgt_state;
; 4176 : 	size_t _Final_len = _STD distance(_St._Cur, _Tgt_state._Cur);
; 4177 : 	for (;;)
; 4178 : 		{	// process one branch of if
; 4179 : 		_Node = _Node->_Child;
; 4180 : 		if (!_Node)
; 4181 : 			break;
; 4182 : 
; 4183 : 		_Tgt_state = _St;
; 4184 : 		if (_Match_pat(_Node->_Next))
; 4185 : 			{	// record match if it is longer
; 4186 : 			size_t _Len = _STD distance(_St._Cur, _Tgt_state._Cur);
; 4187 : 			if (_Final_len < _Len)
; 4188 : 				{	// memorize longest so far
; 4189 : 				_Final = _Tgt_state;
; 4190 : 				_Final_len = _Len;
; 4191 : 				}
; 4192 : 			}
; 4193 : 		}
; 4194 : 
; 4195 : 	// set the input end to the longest match
; 4196 : 	_Tgt_state = _Final;
; 4197 : 	return (true);
; 4198 : 	}
; 4199 : 
; 4200 : template<class _BidIt,
; 4201 : 	class _Elem,
; 4202 : 	class _RxTraits,
; 4203 : 	class _It> inline
; 4204 : 	bool _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Do_rep0(
; 4205 : 		_Node_rep *_Node, bool _Greedy)
; 4206 : 	{	// apply repetition to loop with no nested if/do
; 4207 : 	int _Ix = 0;
; 4208 : 	_Tgt_state_t<_It> _St = _Tgt_state;
; 4209 : 
; 4210 : 	for (; _Ix < _Node->_Min; ++_Ix)
; 4211 : 		{	// do minimum number of reps
; 4212 : 		_It _Cur = _Tgt_state._Cur;
; 4213 : 		if (!_Match_pat(_Node->_Next))
; 4214 : 			{	// didn't match minimum number of reps, fail
; 4215 : 			_Tgt_state = _St;
; 4216 : 			return (false);
; 4217 : 			}
; 4218 : 		else if (_Cur == _Tgt_state._Cur)
; 4219 : 			_Ix = _Node->_Min - 1;	// skip matches that don't change state
; 4220 : 		}
; 4221 : 
; 4222 : 	_Tgt_state_t<_It> _Final = _Tgt_state;
; 4223 : 	bool _Matched0 = false;
; 4224 : 	_It _Saved_pos = _Tgt_state._Cur;
; 4225 : 
; 4226 : 	if (!_Match_pat(_Node->_End_rep->_Next))
; 4227 : 		;	// no full match yet
; 4228 : 	else if (!_Greedy)
; 4229 : 		return (true);	// go with current match
; 4230 : 	else
; 4231 : 		{	// record an acceptable match and continue
; 4232 : 		_Final = _Tgt_state;
; 4233 : 		_Matched0 = true;
; 4234 : 		}
; 4235 : 
; 4236 : 	while (_Node->_Max == -1 || _Ix++ < _Node->_Max)
; 4237 : 		{	// try another rep/tail match
; 4238 : 		_Tgt_state._Cur = _Saved_pos;
; 4239 : 		_Tgt_state._Grp_valid = _St._Grp_valid;
; 4240 : 		if (!_Match_pat(_Node->_Next))
; 4241 : 			break;	// rep match failed, quit loop
; 4242 : 
; 4243 : 		_It _Mid = _Tgt_state._Cur;
; 4244 : 		if (!_Match_pat(_Node->_End_rep->_Next))
; 4245 : 			;	// tail match failed, continue
; 4246 : 		else if (!_Greedy)
; 4247 : 			return (true);	// go with current match
; 4248 : 		else
; 4249 : 			{	// record match and continue
; 4250 : 			_Final = _Tgt_state;
; 4251 : 			_Matched0 = true;
; 4252 : 			}
; 4253 : 
; 4254 : 		if (_Saved_pos == _Mid)
; 4255 : 			break;	// rep match ate no additional elements, quit loop
; 4256 : 		_Saved_pos = _Mid;
; 4257 : 		}
; 4258 : 
; 4259 : 	_Tgt_state = _Matched0 ? _Final : _St;
; 4260 : 	return (_Matched0);
; 4261 : 	}
; 4262 : 
; 4263 : template<class _BidIt,
; 4264 : 	class _Elem,
; 4265 : 	class _RxTraits,
; 4266 : 	class _It> inline
; 4267 : 	bool _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Do_rep(
; 4268 : 		_Node_rep *_Node, bool _Greedy, int _Init_idx)
; 4269 : 	{	// apply repetition
; 4270 : 	if (_Node->_Simple_loop == 1)
; 4271 : 		return (_Do_rep0(_Node, _Greedy));
; 4272 : 
; 4273 : 	bool _Matched0 = false;
; 4274 : 	_Tgt_state_t<_It> _St = _Tgt_state;
; 4275 : 	_Loop_vals_t *_Psav = &_Loop_vals[_Node->_Loop_number];
; 4276 : 	int _Loop_idx_sav = _Psav->_Loop_idx;
; 4277 : 	_It *_Loop_iter_sav = (_It *)_Psav->_Loop_iter;
; 4278 : 	_It _Cur_iter = _Tgt_state._Cur;
; 4279 : 
; 4280 : 	bool _Progress = _Init_idx == 0 || *_Loop_iter_sav != _Cur_iter;
; 4281 : 
; 4282 : 	if (0 <= _Node->_Max && _Node->_Max <= _Init_idx)
; 4283 : 		_Matched0 = _Match_pat(_Node->_End_rep->_Next);	// reps done, try tail
; 4284 : 	else if (_Init_idx < _Node->_Min)
; 4285 : 		{	// try a required rep
; 4286 : 		if (!_Progress)
; 4287 : 			_Matched0 = _Match_pat(_Node->_End_rep->_Next);	// empty, try tail
; 4288 : 		else
; 4289 : 			{	// try another required match
; 4290 : 			_Psav->_Loop_idx = _Init_idx + 1;
; 4291 : 			_Psav->_Loop_iter = &_Cur_iter;
; 4292 : 			_Matched0 = _Match_pat(_Node->_Next);
; 4293 : 			}
; 4294 : 		}
; 4295 : 	else if (!_Greedy)
; 4296 : 		{	// not greedy, favor minimum number of reps
; 4297 : 		_Matched0 = _Match_pat(_Node->_End_rep->_Next);
; 4298 : 		if (!_Matched0 && _Progress)
; 4299 : 			{	// tail failed, try another rep
; 4300 : 			_Tgt_state = _St;
; 4301 : 			_Psav->_Loop_idx = _Init_idx + 1;
; 4302 : 			_Psav->_Loop_iter = &_Cur_iter;
; 4303 : 			_Matched0 = _Match_pat(_Node->_Next);
; 4304 : 			}
; 4305 : 		}
; 4306 : 	else
; 4307 : 		{	// greedy, favor maximum number of reps
; 4308 : 		if (_Progress)
; 4309 : 			{	// try another rep
; 4310 : 			_Psav->_Loop_idx = _Init_idx + 1;
; 4311 : 			_Psav->_Loop_iter = &_Cur_iter;
; 4312 : 			_Matched0 = _Match_pat(_Node->_Next);
; 4313 : 			}
; 4314 : 		if (!_Progress && 1 < _Init_idx)
; 4315 : 			;
; 4316 : 		else if (!_Matched0)
; 4317 : 			{	// rep failed, try tail
; 4318 : 			_Psav->_Loop_idx = _Loop_idx_sav;
; 4319 : 			_Psav->_Loop_iter = _Loop_iter_sav;
; 4320 : 			_Tgt_state = _St;
; 4321 : 			_Matched0 = _Match_pat(_Node->_End_rep->_Next);
; 4322 : 			}
; 4323 : 		}
; 4324 : 
; 4325 : 	if (!_Matched0)
; 4326 : 		_Tgt_state = _St;
; 4327 : 	_Psav->_Loop_idx = _Loop_idx_sav;
; 4328 : 	_Psav->_Loop_iter = _Loop_iter_sav;
; 4329 : 	return (_Matched0);
; 4330 : 	}
; 4331 : 
; 4332 : template<class _BidIt1,
; 4333 : 	class _BidIt2,
; 4334 : 	class _Pr> inline
; 4335 : 	_BidIt1 _Cmp_chrange(_BidIt1 _Begin1, _BidIt1 _End1,
; 4336 : 		_BidIt2 _Begin2, _BidIt2 _End2, _Pr _Pred)
; 4337 : 	{	// compare character ranges
; 4338 : 	_BidIt1 _Res = _Begin1;
; 4339 : 	while (_Begin1 != _End1 && _Begin2 != _End2)
; 4340 : 		if (!_Pred(*_Begin1++, *_Begin2++))
; 4341 : 			return (_Res);
; 4342 : 	return (_Begin2 == _End2 ? _Begin1 : _Res);
; 4343 : 	}
; 4344 : 
; 4345 : template<class _BidIt1,
; 4346 : 	class _BidIt2,
; 4347 : 	class _RxTraits> inline
; 4348 : 	_BidIt1 _Compare(_BidIt1 _Begin1, _BidIt1 _End1,
; 4349 : 		_BidIt2 _Begin2, _BidIt2 _End2, const _RxTraits& _Traits,
; 4350 : 		regex_constants::syntax_option_type _Sflags)
; 4351 : 	{	// compare character ranges
; 4352 : 	_BidIt1 _Res = _End1;
; 4353 : 	if (_Sflags & regex_constants::icase)
; 4354 : 		_Res = _Cmp_chrange(_Begin1, _End1, _Begin2, _End2,
; 4355 : 			_Cmp_icase<_RxTraits>(_Traits));
; 4356 : 	else if (_Sflags & regex_constants::collate)
; 4357 : 		_Res = _Cmp_chrange(_Begin1, _End1, _Begin2, _End2,
; 4358 : 			_Cmp_collate<_RxTraits>(_Traits));
; 4359 : 	else
; 4360 : 		_Res = _Cmp_chrange(_Begin1, _End1, _Begin2, _End2,
; 4361 : 			_Cmp_cs<_RxTraits>());
; 4362 : 	return (_Res);
; 4363 : 	}
; 4364 : 
; 4365 : template<class _Elem> inline
; 4366 : 	bool _Lookup_range(unsigned int _Ch, const _Buf<_Elem> *_Bufptr)
; 4367 : 	{	// check whether _Ch is in _Buf
; 4368 : 	typedef typename make_unsigned<_Elem>::type _Uelem;
; 4369 : 	for (unsigned int _Ix = 0; _Ix < _Bufptr->_Size(); _Ix += 2)
; 4370 : 		{	// check current position
; 4371 : 		if ((_Uelem)_Bufptr->_At(_Ix) <= _Ch
; 4372 : 			&& _Ch <= (_Uelem)_Bufptr->_At(_Ix + 1))
; 4373 : 				return (true);
; 4374 : 		}
; 4375 : 	return (false);
; 4376 : 	}
; 4377 : 
; 4378 : template<class _Elem,
; 4379 : 	class _RxTraits> inline
; 4380 : 	bool _Lookup_equiv(typename _RxTraits::_Uelem _Ch,
; 4381 : 		const _Sequence<_Elem> *_Eq,
; 4382 : 		const _RxTraits& _Traits)
; 4383 : 	{	// check whether _Ch is in _Eq
; 4384 : 	typename _RxTraits::string_type _Str0;
; 4385 : 	typename _RxTraits::string_type _Str1(1, _Ch);
; 4386 : 	_Str1 = _Traits.transform_primary(_Str1.begin(), _Str1.end());
; 4387 : 	while (_Eq)
; 4388 : 		{	// look for sequence of elements that are the right size
; 4389 : 		for (unsigned int _Ix = 0; _Ix < _Eq->_Data._Size(); _Ix += _Eq->_Sz)
; 4390 : 			{	// look for _Ch
; 4391 : 			_Str0.assign(_Eq->_Data._Str() + _Ix, _Eq->_Sz);
; 4392 : 			_Str0 = _Traits.transform_primary(_Str0.begin(), _Str0.end());
; 4393 : 			if (_Str0 == _Str1)
; 4394 : 				return (true);
; 4395 : 			}
; 4396 : 		_Eq = _Eq->_Next;
; 4397 : 		}
; 4398 : 	return (false);
; 4399 : 	}
; 4400 : 
; 4401 : template<class _BidIt,
; 4402 : 	class _Elem> inline
; 4403 : 	_BidIt _Lookup_coll(_BidIt _First, _BidIt _Last,
; 4404 : 		const _Sequence<_Elem> *_Eq)
; 4405 : 	{	// look for collation element [_First, _Last) in _Eq
; 4406 : 	while (_Eq)
; 4407 : 		{	// look for sequence of elements that are the right size
; 4408 : 		for (unsigned int _Ix = 0; _Ix < _Eq->_Data._Size(); _Ix += _Eq->_Sz)
; 4409 : 			{	// look for character range
; 4410 : 			_BidIt _Res = _First;
; 4411 : 			for (size_t _Jx = 0; _Jx < _Eq->_Sz; ++_Jx)
; 4412 : 				{	// check current character
; 4413 : 				if (*_Res++ != *(_Eq->_Data._Str() + _Ix + _Jx))
; 4414 : 					break;
; 4415 : 				}
; 4416 : 			if (_Res == _Last)
; 4417 : 				return (_Last);
; 4418 : 			}
; 4419 : 		_Eq = _Eq->_Next;
; 4420 : 		}
; 4421 : 	return (_First);
; 4422 : 	}
; 4423 : 
; 4424 : template<class _BidIt,
; 4425 : 	class _Elem,
; 4426 : 	class _RxTraits,
; 4427 : 	class _It> inline
; 4428 : 	bool _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Do_class(
; 4429 : 		_Node_base *_Nx)
; 4430 : 	{	// apply bracket expression
; 4431 : 	bool _Found;
; 4432 : 	typename _RxTraits::_Uelem _Ch = *_Tgt_state._Cur;
; 4433 : 	if (_Sflags & regex_constants::icase)
; 4434 : 		_Ch = _Traits.translate_nocase(_Ch);
; 4435 : 	_It _Res0 = _Tgt_state._Cur;
; 4436 : 	++_Res0;
; 4437 : 	_It _Resx;
; 4438 : 	_Node_class<_Elem, _RxTraits> *_Node =
; 4439 : 		(_Node_class<_Elem, _RxTraits> *)_Nx;
; 4440 : 	if (_Node->_Coll
; 4441 : 		&& (_Resx = _Lookup_coll(_Tgt_state._Cur, _End, _Node->_Coll))
; 4442 : 			!= _Tgt_state._Cur)
; 4443 : 		{	// check for collation element
; 4444 : 		_Res0 = _Resx;
; 4445 : 		_Found = true;
; 4446 : 		}
; 4447 : 	else if (_Node->_Ranges
; 4448 : 		&& (_Lookup_range((typename _RxTraits::_Uelem)
; 4449 : 			(_Sflags & regex_constants::collate
; 4450 : 				? _Traits.translate(_Ch)
; 4451 : 				: _Ch), _Node->_Ranges)))
; 4452 : 		_Found = true;
; 4453 : 	else if (_Ch < _Bmp_max)
; 4454 : 		_Found = _Node->_Small && _Node->_Small->_Find(_Ch);
; 4455 : 	else if (_Node->_Large
; 4456 : 		&& _STD find(_Node->_Large->_Str(),
; 4457 : 			_Node->_Large->_Str() + _Node->_Large->_Size(), _Ch)
; 4458 : 				!= _Node->_Large->_Str() + _Node->_Large->_Size())
; 4459 : 		_Found = true;
; 4460 : 	else if (_Node->_Classes != 0 && _Traits.isctype(_Ch, _Node->_Classes))
; 4461 : 		_Found = true;
; 4462 : 	else if (_Node->_Equiv && _Lookup_equiv(_Ch, _Node->_Equiv, _Traits))
; 4463 : 		_Found = true;
; 4464 : 	else
; 4465 : 		_Found = false;
; 4466 : 	if (_Found == (_Node->_Flags & _Fl_negate))
; 4467 : 		return (false);
; 4468 : 	else
; 4469 : 		{	// record result
; 4470 : 		_Tgt_state._Cur = _Res0;
; 4471 : 		return (true);
; 4472 : 		}
; 4473 : 	}
; 4474 : 
; 4475 : template<class _BidIt,
; 4476 : 	class _Elem,
; 4477 : 	class _RxTraits,
; 4478 : 	class _It> inline
; 4479 : 	bool _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Better_match()
; 4480 : 	{	// check for better match under UNIX rules
; 4481 : 	for (unsigned int _Ix = 0; _Ix < _Get_ncap(); ++_Ix)
; 4482 : 		{	// check each capture group
; 4483 : 		if (!_Res._Grp_valid[_Ix] || !_Tgt_state._Grp_valid[_Ix])
; 4484 : 			;
; 4485 : 		else if (_Res._Grps[_Ix]._Begin
; 4486 : 			!= _Tgt_state._Grps[_Ix]._Begin)
; 4487 : 			return (_STD distance(_Begin, _Res._Grps[_Ix]._Begin)
; 4488 : 				< _STD distance(_Begin, _Tgt_state._Grps[_Ix]._Begin));
; 4489 : 		else if (_Res._Grps[_Ix]._End
; 4490 : 			!= _Tgt_state._Grps[_Ix]._End)
; 4491 : 			return (_STD distance(_Begin, _Res._Grps[_Ix]._End)
; 4492 : 				< _STD distance(_Begin, _Tgt_state._Grps[_Ix]._End));
; 4493 : 		}
; 4494 : 	return (false);
; 4495 : 	}
; 4496 : 
; 4497 : template<class _BidIt,
; 4498 : 	class _Elem,
; 4499 : 	class _RxTraits,
; 4500 : 	class _It> inline
; 4501 : 	bool _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Is_wbound() const
; 4502 : 	{	// test if _Tgt_state._Cur is a word boundary
; 4503 : 	if ((_Mflags & regex_constants::match_prev_avail)
; 4504 : 		|| _Tgt_state._Cur != _Begin)
; 4505 : 		{	// if --_Cur is valid, check for preceding word character
; 4506 : 		if (_Tgt_state._Cur == _End)
; 4507 : 			return ((_Mflags & regex_constants::match_not_eow) == 0 && _Is_word(*_STD prev(_Tgt_state._Cur)));
; 4508 : 		else
; 4509 : 			return (_Is_word(*_STD prev(_Tgt_state._Cur)) != _Is_word(*_Tgt_state._Cur));
; 4510 : 		}
; 4511 : 	else
; 4512 : 		{	// --_Cur is not valid
; 4513 : 		if (_Tgt_state._Cur == _End)
; 4514 : 			return ((_Mflags & (regex_constants::match_not_bow | regex_constants::match_not_eow)) == 0);
; 4515 : 		else
; 4516 : 			return ((_Mflags & regex_constants::match_not_bow) == 0 && _Is_word(*_Tgt_state._Cur));
; 4517 : 		}
; 4518 : 	}
; 4519 : 
; 4520 : template<class _BidIt,
; 4521 : 	class _Elem,
; 4522 : 	class _RxTraits,
; 4523 : 	class _It> inline
; 4524 : 	unsigned int _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Get_ncap() const
; 4525 : 	{
; 4526 : 	return (static_cast<unsigned int>(_Ncap));
; 4527 : 	}
; 4528 : 
; 4529 : template<class _BidIt,
; 4530 : 	class _Elem,
; 4531 : 	class _RxTraits,
; 4532 : 	class _It> inline
; 4533 : 	bool _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Match_pat(
; 4534 : 		_Node_base *_Nx)
; 4535 : 	{	// check for match
; 4536 : 	if (0 < _Max_stack_count && --_Max_stack_count <= 0)
; 4537 : 		_Xregex_error(regex_constants::error_stack);
; 4538 : 	if (0 < _Max_complexity_count && --_Max_complexity_count <= 0)
; 4539 : 		_Xregex_error(regex_constants::error_complexity);
; 4540 : 
; 4541 : 	bool _Failed = false;
; 4542 : 	while (_Nx != 0)
; 4543 : 		{	// match current node
; 4544 : 		switch (_Nx->_Kind)
; 4545 : 			{	// handle current node's type
; 4546 : 			case _N_nop:
; 4547 : 				break;
; 4548 : 
; 4549 : 			case _N_bol:
; 4550 : 				if ((_Mflags & regex_constants::match_prev_avail)
; 4551 : 					|| _Tgt_state._Cur != _Begin)
; 4552 : 					{	// if --_Cur is valid, check for preceding newline
; 4553 : 					_Failed = *_STD prev(_Tgt_state._Cur) != _Meta_nl;
; 4554 : 					}
; 4555 : 				else
; 4556 : 					_Failed = (_Mflags & regex_constants::match_not_bol) != 0;
; 4557 : 				break;
; 4558 : 
; 4559 : 			case _N_eol:
; 4560 : 				if (_Tgt_state._Cur == _End)
; 4561 : 					_Failed = (_Mflags & regex_constants::match_not_eol) != 0;
; 4562 : 				else
; 4563 : 					_Failed = *_Tgt_state._Cur != _Meta_nl;
; 4564 : 				break;
; 4565 : 
; 4566 : 			case _N_wbound:
; 4567 : 				_Failed = _Is_wbound() == ((_Nx->_Flags & _Fl_negate) != 0);
; 4568 : 				break;
; 4569 : 
; 4570 : 			case _N_dot:
; 4571 : 				if (_Tgt_state._Cur == _End
; 4572 : 					|| *_Tgt_state._Cur == _Meta_nl
; 4573 : 					|| *_Tgt_state._Cur == _Meta_cr)
; 4574 : 					_Failed = true;
; 4575 : 				else
; 4576 : 					++_Tgt_state._Cur;
; 4577 : 				break;
; 4578 : 
; 4579 : 			case _N_str:
; 4580 : 				{	// check for string match
; 4581 : 				_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Nx;
; 4582 : 				_It _Res0;
; 4583 : 				if ((_Res0 = _Compare(_Tgt_state._Cur, _End,
; 4584 : 					_Node->_Data._Str(),
; 4585 : 					_Node->_Data._Str() + _Node->_Data._Size(),
; 4586 : 					_Traits, _Sflags))
; 4587 : 						!= _Tgt_state._Cur)
; 4588 : 					_Tgt_state._Cur = _Res0;
; 4589 : 				else
; 4590 : 					_Failed = true;
; 4591 : 				break;
; 4592 : 				}
; 4593 : 
; 4594 : 			case _N_class:
; 4595 : 				{	// check for bracket expression match
; 4596 : 				_Failed = _Tgt_state._Cur == _End
; 4597 : 					|| !_Do_class(_Nx);
; 4598 : 				break;
; 4599 : 				}
; 4600 : 
; 4601 : 			case _N_group:
; 4602 : 				break;
; 4603 : 
; 4604 : 			case _N_end_group:
; 4605 : 				break;
; 4606 : 
; 4607 : 			case _N_neg_assert:
; 4608 : 			case _N_assert:
; 4609 : 				{	// check assert
; 4610 : 				_It _Ch = _Tgt_state._Cur;
; 4611 : 				bool _Neg = _Nx->_Kind == _N_neg_assert;
; 4612 : 				_Bt_state_t<_It> _St = _Tgt_state;
; 4613 : 				if (_Match_pat(((_Node_assert *)_Nx)->_Child) == _Neg)
; 4614 : 					{	// restore initial state and indicate failure
; 4615 : 					_Tgt_state = _St;
; 4616 : 					_Failed = true;
; 4617 : 					}
; 4618 : 				else
; 4619 : 					_Tgt_state._Cur = _Ch;
; 4620 : 				break;
; 4621 : 				}
; 4622 : 
; 4623 : 			case _N_end_assert:
; 4624 : 				_Nx = 0;
; 4625 : 				break;
; 4626 : 
; 4627 : 			case _N_capture:
; 4628 : 				{	// record current position
; 4629 : 				_Node_capture *_Node = (_Node_capture *)_Nx;
; 4630 : 				_Tgt_state._Grps[_Node->_Idx]._Begin = _Tgt_state._Cur;
; 4631 : 				for (size_t _Idx = _Tgt_state._Grp_valid.size();
; 4632 : 					_Node->_Idx < _Idx; )
; 4633 : 					_Tgt_state._Grp_valid[--_Idx] = false;
; 4634 : 				break;
; 4635 : 				}
; 4636 : 
; 4637 : 			case _N_end_capture:
; 4638 : 				{	// record successful capture
; 4639 : 				_Node_end_group *_Node = (_Node_end_group *)_Nx;
; 4640 : 				_Node_capture *_Node0 = (_Node_capture *)_Node->_Back;
; 4641 : 				if (_Cap || _Node0->_Idx != 0)
; 4642 : 					{	// update capture data
; 4643 : 					_Tgt_state._Grp_valid[_Node0->_Idx] = true;
; 4644 : 					_Tgt_state._Grps[_Node0->_Idx]._End = _Tgt_state._Cur;
; 4645 : 					}
; 4646 : 				break;
; 4647 : 				}
; 4648 : 
; 4649 : 			case _N_back:
; 4650 : 				{	// check back reference
; 4651 : 				_Node_back *_Node = (_Node_back *)_Nx;
; 4652 : 				if (_Tgt_state._Grp_valid[_Node->_Idx])
; 4653 : 					{	// check for match
; 4654 : 					_It _Res0 = _Tgt_state._Cur;
; 4655 : 					_It _Bx = _Tgt_state._Grps[_Node->_Idx]._Begin;
; 4656 : 					_It _Ex = _Tgt_state._Grps[_Node->_Idx]._End;
; 4657 : 					if (_Bx != _Ex	// _Bx == _Ex for zero-length match
; 4658 : 						&& (_Res0 = _Compare(_Tgt_state._Cur, _End,
; 4659 : 							_Bx, _Ex, _Traits, _Sflags))
; 4660 : 								== _Tgt_state._Cur)
; 4661 : 						_Failed = true;
; 4662 : 					else
; 4663 : 						_Tgt_state._Cur = _Res0;
; 4664 : 					}
; 4665 : 				break;
; 4666 : 				}
; 4667 : 
; 4668 : 			case _N_if:
; 4669 : 				if (!_Do_if((_Node_if *)_Nx))
; 4670 : 					_Failed = true;
; 4671 : 				_Nx = 0;
; 4672 : 				break;
; 4673 : 
; 4674 : 			case _N_endif:
; 4675 : 				break;
; 4676 : 
; 4677 : 			case _N_rep:
; 4678 : 				if (!_Do_rep((_Node_rep *)_Nx,
; 4679 : 					(_Nx->_Flags & _Fl_greedy) != 0, 0))
; 4680 : 					_Failed = true;
; 4681 : 				_Nx = 0;
; 4682 : 				break;
; 4683 : 
; 4684 : 			case _N_end_rep:
; 4685 : 				{	// return at end of loop
; 4686 : 				_Node_rep *_Nr = ((_Node_end_rep *)_Nx)->_Begin_rep;
; 4687 : 				_Loop_vals_t *_Psav = &_Loop_vals[_Nr->_Loop_number];
; 4688 : 
; 4689 : 				if (_Nr->_Simple_loop == 0 && !_Do_rep(_Nr,
; 4690 : 					(_Nr->_Flags & _Fl_greedy) != 0, _Psav->_Loop_idx))
; 4691 : 					_Failed = true;	// recurse only if loop contains if/do
; 4692 : 				_Nx = 0;
; 4693 : 				break;
; 4694 : 				}
; 4695 : 
; 4696 : 			case _N_begin:
; 4697 : 				break;
; 4698 : 
; 4699 : 			case _N_end:
; 4700 : 				if (((_Mflags & (regex_constants::match_not_null
; 4701 : 						| regex_constants::_Match_not_null))
; 4702 : 					&& _Begin == _Tgt_state._Cur)
; 4703 : 						|| (_Full && _Tgt_state._Cur != _End))
; 4704 : 					_Failed = true;
; 4705 : 				else if (!_Matched || _Better_match())
; 4706 : 					{	// record successful match
; 4707 : 					_Res = _Tgt_state;
; 4708 : 					_Matched = true;
; 4709 : 					}
; 4710 : 				_Nx = 0;
; 4711 : 				break;
; 4712 : 
; 4713 : 			default:
; 4714 : 				_Xregex_error(regex_constants::error_parse);
; 4715 : 			}
; 4716 : 
; 4717 : 		if (_Failed)
; 4718 : 			_Nx = 0;
; 4719 : 		else if (_Nx)
; 4720 : 			_Nx = _Nx->_Next;
; 4721 : 		}
; 4722 : 
; 4723 : 	if (0 < _Max_stack_count)
; 4724 : 		++_Max_stack_count;
; 4725 : 	return (!_Failed);
; 4726 : 	}
; 4727 : 
; 4728 : template<class _BidIt,
; 4729 : 	class _Elem,
; 4730 : 	class _RxTraits,
; 4731 : 	class _It> inline
; 4732 : 	_BidIt _Matcher<_BidIt, _Elem, _RxTraits, _It>::_Skip(
; 4733 : 		_BidIt _First_arg, _BidIt _Last, _Node_base *_Node_arg)
; 4734 : 	{	// skip until possible match
; 4735 : 		// assumes --_First_arg is valid
; 4736 : 	_Node_base *_Nx = _Node_arg != 0 ? _Node_arg : _Rep;
; 4737 : 
; 4738 : 	while (_First_arg != _Last && _Nx != 0)
; 4739 : 		{	// check current node
; 4740 : 		switch (_Nx->_Kind)
; 4741 : 			{	// handle current node's type
; 4742 : 			case _N_nop:
; 4743 : 				break;
; 4744 : 
; 4745 : 			case _N_bol:
; 4746 : 				{	// check for embedded newline
; 4747 : 					// return iterator to character just after the newline; for input like "\nabc"
; 4748 : 					// matching "^abc", _First_arg could be pointing at 'a', so we need to check
; 4749 : 					// --_First_arg for '\n'
; 4750 : 				if (*_STD prev(_First_arg) != _Meta_nl)
; 4751 : 					{
; 4752 : 					_First_arg = _STD find(_First_arg, _Last, _Meta_nl);
; 4753 : 					if (_First_arg != _Last)
; 4754 : 						++_First_arg;
; 4755 : 					}
; 4756 : 
; 4757 : 				return (_First_arg);
; 4758 : 				}
; 4759 : 
; 4760 : 			case _N_eol:
; 4761 : 				return (_STD find(_First_arg, _Last, _Meta_nl));
; 4762 : 
; 4763 : //			case _N_wbound:
; 4764 : //			case _N_dot:
; 4765 : 
; 4766 : 			case _N_str:
; 4767 : 				{	// check for string match
; 4768 : 				_Node_str<_Elem> *_Node = (_Node_str<_Elem> *)_Nx;
; 4769 : 				for (; _First_arg != _Last; ++_First_arg)
; 4770 : 					{	// look for starting match
; 4771 : 					_BidIt _Next = _First_arg;
; 4772 : 					if (_Compare(_First_arg, ++_Next,
; 4773 : 						_Node->_Data._Str(),
; 4774 : 						_Node->_Data._Str() + 1,
; 4775 : 						_Traits, _Sflags)
; 4776 : 							!= _First_arg)
; 4777 : 						break;
; 4778 : 					}
; 4779 : 				return (_First_arg);
; 4780 : 				}
; 4781 : 
; 4782 : 			case _N_class:
; 4783 : 				{	// check for string match
; 4784 : 				for (; _First_arg != _Last; ++_First_arg)
; 4785 : 					{	// look for starting match
; 4786 : 					bool _Found;
; 4787 : 					typename _RxTraits::_Uelem _Ch = *_First_arg;
; 4788 : 					_Node_class<_Elem, _RxTraits> *_Node =
; 4789 : 						(_Node_class<_Elem, _RxTraits> *)_Nx;
; 4790 : 					_It _Next = _First_arg;
; 4791 : 					++_Next;
; 4792 : 
; 4793 : 					if (_Node->_Coll
; 4794 : 						&& _Lookup_coll(_First_arg, _Next, _Node->_Coll)
; 4795 : 							!= _First_arg)
; 4796 : 						_Found = true;
; 4797 : 					else if (_Node->_Ranges
; 4798 : 						&& (_Lookup_range((typename _RxTraits::_Uelem)
; 4799 : 							(_Sflags & regex_constants::collate
; 4800 : 								? _Traits.translate(_Ch)
; 4801 : 								: _Ch), _Node->_Ranges)))
; 4802 : 						_Found = true;
; 4803 : 					else if (_Ch < _Bmp_max)
; 4804 : 						_Found = _Node->_Small && _Node->_Small->_Find(_Ch);
; 4805 : 					else if (_Node->_Large
; 4806 : 						&& _STD find(_Node->_Large->_Str(),
; 4807 : 							_Node->_Large->_Str() + _Node->_Large->_Size(),
; 4808 : 								_Ch)
; 4809 : 							!= _Node->_Large->_Str() + _Node->_Large->_Size())
; 4810 : 						_Found = true;
; 4811 : 					else if (_Node->_Classes
; 4812 : 						&& _Traits.isctype(_Ch, _Node->_Classes))
; 4813 : 						_Found = true;
; 4814 : 					else if (_Node->_Equiv
; 4815 : 						&& _Lookup_equiv(_Ch, _Node->_Equiv, _Traits))
; 4816 : 						_Found = true;
; 4817 : 					else
; 4818 : 						_Found = false;
; 4819 : 
; 4820 : 					if (_Found != (_Node->_Flags & _Fl_negate))
; 4821 : 						return (_First_arg);
; 4822 : 					}
; 4823 : 				}
; 4824 : 				return (_First_arg);
; 4825 : 
; 4826 : 			case _N_group:
; 4827 : 				break;
; 4828 : 
; 4829 : 			case _N_end_group:
; 4830 : 				break;
; 4831 : 
; 4832 : //			case _N_neg_assert:
; 4833 : //			case _N_assert:
; 4834 : 
; 4835 : 			case _N_end_assert:
; 4836 : 				_Nx = 0;
; 4837 : 				break;
; 4838 : 
; 4839 : 			case _N_capture:
; 4840 : 				break;
; 4841 : 
; 4842 : 			case _N_end_capture:
; 4843 : 				break;
; 4844 : 
; 4845 : //			case _N_back:
; 4846 : 
; 4847 : 			case _N_if:
; 4848 : 				{	// check for soonest string match
; 4849 : 				_Node_if *_Node = (_Node_if *)_Nx;
; 4850 : 
; 4851 : 				for (; _First_arg != _Last && _Node != 0;
; 4852 : 					_Node = _Node->_Child)
; 4853 : 					_Last = _Skip(_First_arg, _Last, _Node->_Next);
; 4854 : 				return (_Last);
; 4855 : 				}
; 4856 : 
; 4857 : //			case _N_endif:
; 4858 : //			case _N_rep:
; 4859 : //			case _N_end_rep:
; 4860 : 
; 4861 : 			case _N_begin:
; 4862 : 				break;
; 4863 : 
; 4864 : 			case _N_end:
; 4865 : 				_Nx = 0;
; 4866 : 				break;
; 4867 : 
; 4868 : 			default:
; 4869 : 				return (_First_arg);
; 4870 : 			}
; 4871 : 		if (_Nx)
; 4872 : 			_Nx = _Nx->_Next;
; 4873 : 		}
; 4874 : 	return (_First_arg);
; 4875 : 	}
; 4876 : 
; 4877 : 	// IMPLEMENTATION OF _Parser
; 4878 : template<class _FwdIt,
; 4879 : 	class _Elem,
; 4880 : 	class _RxTraits> inline
; 4881 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Error(
; 4882 : 		regex_constants::error_type _Code)
; 4883 : 	{	// handle error
; 4884 : 	_Xregex_error(_Code);
; 4885 : 	}
; 4886 : 
; 4887 : template<class _FwdIt,
; 4888 : 	class _Elem,
; 4889 : 	class _RxTraits> inline
; 4890 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_Is_esc() const
; 4891 : 	{	// assumes _Pat != _End
; 4892 : 	_FwdIt _Ch0 = _Pat;
; 4893 : 	return (++_Ch0 != _End
; 4894 : 		&& ((!(_L_flags & _L_nex_grp)
; 4895 : 			&& (*_Ch0 == _Meta_lpar || *_Ch0 == _Meta_rpar))
; 4896 : 		|| (!(_L_flags & _L_nex_rep)
; 4897 : 			&& (*_Ch0 == _Meta_lbr || *_Ch0 == _Meta_rbr))));
; 4898 : 	}
; 4899 : 
; 4900 : template<class _FwdIt,
; 4901 : 	class _Elem,
; 4902 : 	class _RxTraits> inline
; 4903 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Trans()
; 4904 : 	{	// map character to meta-character
; 4905 : 	static constexpr char _Meta_map[] = {
; 4906 : 		_Meta_lpar, _Meta_rpar, _Meta_dlr, _Meta_caret,
; 4907 : 		_Meta_dot, _Meta_star, _Meta_plus, _Meta_query,
; 4908 : 		_Meta_lsq, _Meta_rsq, _Meta_bar, _Meta_esc,
; 4909 : 		_Meta_dash, _Meta_lbr, _Meta_rbr, _Meta_comma,
; 4910 : 		_Meta_colon, _Meta_equal, _Meta_exc, _Meta_nl,
; 4911 : 		_Meta_cr, _Meta_bsp,
; 4912 : 		0};	// array of meta chars
; 4913 : 
; 4914 : 	if (_Pat == _End)
; 4915 : 		_Mchar = _Meta_eos, _Char = (_Elem)_Meta_eos;
; 4916 : 	else
; 4917 : 		{	// map current character
; 4918 : 		_Char = *_Pat;
; 4919 : 		_Mchar = _CSTD strchr(_Meta_map, _Char) != 0
; 4920 : 			? (_Meta_type)_Char : _Meta_chr;
; 4921 : 		}
; 4922 : 	switch (_Char)
; 4923 : 		{	// handle special cases
; 4924 : 		case _Meta_esc:
; 4925 : 			if (_Is_esc())
; 4926 : 				{	// replace escape sequence
; 4927 : 				_FwdIt _Ch0 = _Pat;
; 4928 : 				_Mchar = _Meta_type(_Char = *++_Ch0);
; 4929 : 				}
; 4930 : 			break;
; 4931 : 
; 4932 : 		case _Meta_nl:
; 4933 : 			if ((_L_flags & _L_alt_nl) && _Disj_count == 0)
; 4934 : 				_Mchar = _Meta_bar;
; 4935 : 			break;
; 4936 : 
; 4937 : 		case _Meta_lpar:
; 4938 : 		case _Meta_rpar:
; 4939 : 			if (!(_L_flags & _L_nex_grp))
; 4940 : 				_Mchar = _Meta_chr;
; 4941 : 			break;
; 4942 : 
; 4943 : 		case _Meta_lbr:
; 4944 : 		case _Meta_rbr:
; 4945 : 			if (!(_L_flags & _L_nex_rep))
; 4946 : 				_Mchar = _Meta_chr;
; 4947 : 			break;
; 4948 : 
; 4949 : 		case _Meta_star:
; 4950 : 			if ((_L_flags & _L_star_beg)
; 4951 : 				&& _Nfa._Beg_expr())
; 4952 : 				_Mchar = _Meta_chr;
; 4953 : 			break;
; 4954 : 
; 4955 : 		case _Meta_caret:
; 4956 : 			if ((_L_flags & _L_anch_rstr)
; 4957 : 				&& !_Nfa._Beg_expr())
; 4958 : 			_Mchar = _Meta_chr;
; 4959 : 			break;
; 4960 : 
; 4961 : 		case _Meta_dlr:
; 4962 : 			{	// check if $ is special
; 4963 : 			_FwdIt _Ch0 = _Pat;
; 4964 : 			if ((_L_flags & _L_anch_rstr)
; 4965 : 				&& ++_Ch0 != _End && *_Ch0 != _Meta_nl)
; 4966 : 				_Mchar = _Meta_chr;
; 4967 : 			break;
; 4968 : 			}
; 4969 : 
; 4970 : 		case _Meta_plus:
; 4971 : 		case _Meta_query:
; 4972 : 			if (!(_L_flags & _L_ext_rep))
; 4973 : 				_Mchar = _Meta_chr;
; 4974 : 			break;
; 4975 : 
; 4976 : 		case _Meta_bar:
; 4977 : 			if (!(_L_flags & _L_alt_pipe))
; 4978 : 				_Mchar = _Meta_chr;
; 4979 : 			break;
; 4980 : 		}
; 4981 : 	}
; 4982 : 
; 4983 : template<class _FwdIt,
; 4984 : 	class _Elem,
; 4985 : 	class _RxTraits> inline
; 4986 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Next()
; 4987 : 	{	// advance to next input character
; 4988 : 	if (_Pat != _End)
; 4989 : 		{	// advance
; 4990 : 		if (*_Pat == _Meta_esc && _Is_esc())
; 4991 : 			++_Pat;
; 4992 : 		++_Pat;
; 4993 : 		}
; 4994 : 	_Trans();
; 4995 : 	}
; 4996 : 
; 4997 : template<class _FwdIt,
; 4998 : 	class _Elem,
; 4999 : 	class _RxTraits> inline
; 5000 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Expect(
; 5001 : 		_Meta_type _St, regex_constants::error_type _Code)
; 5002 : 	{	// check whether current meta-character is _St
; 5003 : 	if (_Mchar != _St)
; 5004 : 		_Error(_Code);
; 5005 : 	_Next();
; 5006 : 	}
; 5007 : 
; 5008 : template<class _FwdIt,
; 5009 : 	class _Elem,
; 5010 : 	class _RxTraits> inline
; 5011 : 	int _Parser<_FwdIt, _Elem, _RxTraits>::_Do_digits(
; 5012 : 		int _Base, int _Count)
; 5013 : 	{	// translate digits to numeric value
; 5014 : 	int _Chv;
; 5015 : 	_Val = 0;
; 5016 : 	while (_Count != 0 && (_Chv = _Traits.value(_Char, _Base)) != -1)
; 5017 : 		{	// append next digit
; 5018 : 		--_Count;
; 5019 : 		_Val *= _Base;
; 5020 : 		_Val += _Chv;
; 5021 : 		_Next();
; 5022 : 		}
; 5023 : 	return (_Count);
; 5024 : 	}
; 5025 : 
; 5026 : template<class _FwdIt,
; 5027 : 	class _Elem,
; 5028 : 	class _RxTraits> inline
; 5029 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_DecimalDigits()
; 5030 : 	{	// check for decimal value
; 5031 : 	return (_Do_digits(10, INT_MAX) != INT_MAX);
; 5032 : 	}
; 5033 : 
; 5034 : template<class _FwdIt,
; 5035 : 	class _Elem,
; 5036 : 	class _RxTraits> inline
; 5037 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_HexDigits(int _Count)
; 5038 : 	{	// check for _Count hex digits
; 5039 : 	if (_Do_digits(16, _Count) != 0)
; 5040 : 		_Error(regex_constants::error_escape);
; 5041 : 	}
; 5042 : 
; 5043 : template<class _FwdIt,
; 5044 : 	class _Elem,
; 5045 : 	class _RxTraits> inline
; 5046 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_OctalDigits()
; 5047 : 	{	// check for up to 3 octal digits
; 5048 : 	return (_Do_digits(8, 3) != 3);
; 5049 : 	}
; 5050 : 
; 5051 : template<class _FwdIt,
; 5052 : 	class _Elem,
; 5053 : 	class _RxTraits> inline
; 5054 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Do_ex_class(_Meta_type _End_arg)
; 5055 : 	{	// handle delimited expressions within bracket expression
; 5056 : 	regex_constants::error_type _Errtype =
; 5057 : 		(_End_arg == _Meta_colon ? regex_constants::error_ctype
; 5058 : 			: _End_arg == _Meta_equal ? regex_constants::error_collate
; 5059 : 			: _End_arg == _Meta_dot ? regex_constants::error_collate
; 5060 : 			: regex_constants::error_syntax);
; 5061 : 	_FwdIt _Beg = _Pat;
; 5062 : 	_Iter_diff_t<_FwdIt> _Diff = 0;
; 5063 : 
; 5064 : 	while (_Mchar != _Meta_colon && _Mchar != _Meta_equal
; 5065 : 		&& _Mchar != _Meta_dot && _Mchar != _Meta_eos)
; 5066 : 		{	// advance to end delimiter
; 5067 : 		_Next();
; 5068 : 		++_Diff;
; 5069 : 		}
; 5070 : 	if (_Mchar != _End_arg)
; 5071 : 		_Error(_Errtype);
; 5072 : 	else if (_End_arg == _Meta_colon)
; 5073 : 		{	// handle named character class
; 5074 : 		typename _RxTraits::char_class_type _Cls =
; 5075 : 			_Traits.lookup_classname(_Beg, _Pat,
; 5076 : 				(_Flags & regex_constants::icase) != 0);
; 5077 : 		if (!_Cls)
; 5078 : 			_Error(regex_constants::error_ctype);
; 5079 : 		_Nfa._Add_named_class(_Cls);
; 5080 : 		}
; 5081 : 	else if (_End_arg == _Meta_equal)
; 5082 : 		{	// process =
; 5083 : 		if (_Beg == _Pat)
; 5084 : 			_Error(regex_constants::error_collate);
; 5085 : 		else
; 5086 : 			_Nfa._Add_equiv(_Beg, _Pat, _Diff);
; 5087 : 		}
; 5088 : 	else if (_End_arg == _Meta_dot)
; 5089 : 		{	// process .
; 5090 : 		if (_Beg == _Pat)
; 5091 : 			_Error(regex_constants::error_collate);
; 5092 : 		else
; 5093 : 			_Nfa._Add_coll(_Beg, _Pat, _Diff);
; 5094 : 		}
; 5095 : 	_Next();
; 5096 : 	_Expect(_Meta_rsq, _Errtype);
; 5097 : 	}
; 5098 : 
; 5099 : template<class _FwdIt,
; 5100 : 	class _Elem,
; 5101 : 	class _RxTraits> inline
; 5102 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_CharacterClassEscape(bool _Addit)
; 5103 : 	{	// check for character class escape
; 5104 : 	typename _RxTraits::char_class_type _Cls;
; 5105 : 	_FwdIt _Ch0 = _Pat;
; 5106 : 	if (_Ch0 == _End
; 5107 : 		|| (_Cls = _Traits.lookup_classname(_Pat, ++_Ch0,
; 5108 : 			(_Flags & regex_constants::icase) != 0)) == 0)
; 5109 : 		return (false);
; 5110 : 
; 5111 : 	if (_Addit)
; 5112 : 		_Nfa._Add_class();
; 5113 : 	_Nfa._Add_named_class(_Cls,
; 5114 : 		_Traits.isctype(_Char, _RxTraits::_Ch_upper));
; 5115 : 	_Next();
; 5116 : 	return (true);
; 5117 : 	}
; 5118 : 
; 5119 : template<class _FwdIt,
; 5120 : 	class _Elem,
; 5121 : 	class _RxTraits> inline
; 5122 : 	_Prs_ret _Parser<_FwdIt, _Elem, _RxTraits>::_ClassEscape(bool _Addit)
; 5123 : 	{	// check for class escape
; 5124 : 	if ((_L_flags & _L_esc_bsl)
; 5125 : 		&& _Char == _Esc_bsl)
; 5126 : 		{	// handle escape backslash if allowed
; 5127 : 		_Val = _Esc_bsl;
; 5128 : 		_Next();
; 5129 : 		return (_Prs_chr);
; 5130 : 		}
; 5131 : 	else if ((_L_flags & _L_esc_wsd) && _CharacterClassEscape(_Addit))
; 5132 : 		return (_Prs_set);
; 5133 : 	else if (_DecimalDigits())
; 5134 : 		{	// check for invalid value
; 5135 : 		if (_Val != 0)
; 5136 : 			_Error(regex_constants::error_escape);
; 5137 : 		return (_Prs_chr);
; 5138 : 		}
; 5139 : 	return (_CharacterEscape() ? _Prs_chr : _Prs_none);
; 5140 : 	}
; 5141 : 
; 5142 : template<class _FwdIt,
; 5143 : 	class _Elem,
; 5144 : 	class _RxTraits> inline
; 5145 : 	_Prs_ret _Parser<_FwdIt, _Elem, _RxTraits>::_ClassAtom()
; 5146 : 	{	// check for class atom
; 5147 : 	if (_Mchar == _Meta_esc)
; 5148 : 		{	// check for valid escape sequence
; 5149 : 		_Next();
; 5150 : 		if (_L_flags & _L_grp_esc)
; 5151 : 			return (_ClassEscape(false));
; 5152 : 		else if ((_L_flags & _L_esc_ffn && _Do_ffn(_Char))
; 5153 : 			|| (_L_flags & _L_esc_ffnx && _Do_ffnx(_Char)))
; 5154 : 			{	// advance to next character
; 5155 : 			_Next();
; 5156 : 			return (_Prs_chr);
; 5157 : 			}
; 5158 : 		_Val = _Meta_esc;
; 5159 : 		return (_Prs_chr);
; 5160 : 		}
; 5161 : 	else if (_Mchar == _Meta_lsq)
; 5162 : 		{	// check for valid delimited expression
; 5163 : 		_Next();
; 5164 : 		if (_Mchar == _Meta_colon
; 5165 : 			|| _Mchar == _Meta_equal
; 5166 : 			|| _Mchar == _Meta_dot)
; 5167 : 			{	// handle delimited expression
; 5168 : 			_Meta_type _St = _Mchar;
; 5169 : 			_Next();
; 5170 : 			_Do_ex_class(_St);
; 5171 : 			return (_Prs_set);
; 5172 : 			}
; 5173 : 		else
; 5174 : 			{	// handle ordinary [
; 5175 : 			_Val = _Meta_lsq;
; 5176 : 			return (_Prs_chr);
; 5177 : 			}
; 5178 : 		}
; 5179 : 	else if (_Mchar == _Meta_rsq || _Mchar == _Meta_eos)
; 5180 : 		return (_Prs_none);
; 5181 : 	else
; 5182 : 		{	// handle ordinary character
; 5183 : 		_Val = _Char;
; 5184 : 		_Next();
; 5185 : 		return (_Prs_chr);
; 5186 : 		}
; 5187 : 	}
; 5188 : 
; 5189 : template<class _FwdIt,
; 5190 : 	class _Elem,
; 5191 : 	class _RxTraits> inline
; 5192 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_ClassRanges()
; 5193 : 	{	// check for valid class ranges
; 5194 : 	_Prs_ret _Ret;
; 5195 : 
; 5196 : 	for (; ; )
; 5197 : 		{	// process characters through end of bracket expression
; 5198 : 		if ((_Ret = _ClassAtom()) == _Prs_none)
; 5199 : 			return;
; 5200 : 		else if (_Ret == _Prs_set)
; 5201 : 			;
; 5202 : 		else if (_Val == 0 && !(_L_flags & _L_bzr_chr))
; 5203 : 			_Error(regex_constants::error_escape);
; 5204 : 		else if (_Mchar == _Meta_dash)
; 5205 : 			{	// check for valid range
; 5206 : 			_Next();
; 5207 : 			_Elem _Chr1 = (_Elem)_Val;
; 5208 : 			if ((_Ret = _ClassAtom()) == _Prs_none)
; 5209 : 				{	// treat - as ordinary character
; 5210 : 				_Nfa._Add_char_to_class((_Elem)_Val);
; 5211 : 				_Nfa._Add_char_to_class(_Meta_dash);
; 5212 : 				return;
; 5213 : 				}
; 5214 : 			else if (_Ret == _Prs_set)
; 5215 : 				_Error(regex_constants::error_range);	// set follows dash
; 5216 : 			else if (_Flags & regex_constants::collate)
; 5217 : 				{	// translate ends of range
; 5218 : 				_Val = _Traits.translate((_Elem)_Val);
; 5219 : 				_Chr1 = _Traits.translate(_Chr1);
; 5220 : 				}
; 5221 : 			if ((typename _RxTraits::_Uelem)_Val
; 5222 : 				< (typename _RxTraits::_Uelem)_Chr1)
; 5223 : 				_Error(regex_constants::error_range);
; 5224 : 			_Nfa._Add_range(_Chr1, (_Elem)_Val);
; 5225 : 			}
; 5226 : 		else
; 5227 : 			_Nfa._Add_char_to_class((_Elem)_Val);
; 5228 : 		}
; 5229 : 	}
; 5230 : 
; 5231 : template<class _FwdIt,
; 5232 : 	class _Elem,
; 5233 : 	class _RxTraits> inline
; 5234 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_CharacterClass()
; 5235 : 	{	// add bracket expression
; 5236 : 	_Nfa._Add_class();
; 5237 : 	if (_Mchar == _Meta_caret)
; 5238 : 		{	// negate bracket expression
; 5239 : 		_Nfa._Negate();
; 5240 : 		_Next();
; 5241 : 		}
; 5242 : 	if ((_L_flags & _L_brk_rstr) && _Mchar == _Meta_rsq)
; 5243 : 		{	// insert initial ] when not special
; 5244 : 		_Nfa._Add_char_to_class(_Meta_rsq);
; 5245 : 		_Next();
; 5246 : 		}
; 5247 : 	_ClassRanges();
; 5248 : 	}
; 5249 : 
; 5250 : template<class _FwdIt,
; 5251 : 	class _Elem,
; 5252 : 	class _RxTraits> inline
; 5253 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Do_capture_group()
; 5254 : 	{	// add capture group
; 5255 : //	if (_MAX_GRP <= ++_Grp_idx)
; 5256 : //		_Error(regex_constants::error_complexity);
; 5257 : 	_Node_base *_Pos1 = _Nfa._Begin_capture_group(++_Grp_idx);
; 5258 : 	_Disjunction();
; 5259 : 	_Nfa._End_group(_Pos1);
; 5260 : 	_Finished_grps.resize(_Grp_idx + 1);
; 5261 : 	_Finished_grps[((_Node_capture *)_Pos1)->_Idx] = true;
; 5262 : 	}
; 5263 : 
; 5264 : template<class _FwdIt,
; 5265 : 	class _Elem,
; 5266 : 	class _RxTraits> inline
; 5267 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Do_noncapture_group()
; 5268 : 	{	// add non-capture group
; 5269 : 	_Node_base *_Pos1 = _Nfa._Begin_group();
; 5270 : 	_Disjunction();
; 5271 : 	_Nfa._End_group(_Pos1);
; 5272 : 	}
; 5273 : 
; 5274 : template<class _FwdIt,
; 5275 : 	class _Elem,
; 5276 : 	class _RxTraits> inline
; 5277 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Do_assert_group(bool _Neg)
; 5278 : 	{	// add assert group
; 5279 : 	_Node_base *_Pos1 = _Nfa._Begin_assert_group(_Neg);
; 5280 : 	_Disjunction();
; 5281 : 	_Nfa._End_assert_group(_Pos1);
; 5282 : 	}
; 5283 : 
; 5284 : template<class _FwdIt,
; 5285 : 	class _Elem,
; 5286 : 	class _RxTraits> inline
; 5287 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_Wrapped_disjunction()
; 5288 : 	{	// add disjunction inside group
; 5289 : 	++_Disj_count;
; 5290 : 	if (!(_L_flags & _L_empty_grp) && _Mchar == _Meta_rpar)
; 5291 : 		_Error(regex_constants::error_paren);
; 5292 : 	else if ((_L_flags & _L_nc_grp) && _Mchar == _Meta_query)
; 5293 : 		{	// check for valid ECMAScript (?x ... ) group
; 5294 : 		_Next();
; 5295 : 		_Meta_type _Ch =_Mchar;
; 5296 : 		_Next();
; 5297 : 		if (_Ch == _Meta_colon)
; 5298 : 			_Do_noncapture_group();
; 5299 : 		else if (_Ch == _Meta_exc)
; 5300 : 			{	// process assert group, negating
; 5301 : 			_Do_assert_group(true);
; 5302 : 			--_Disj_count;
; 5303 : 			return (false);
; 5304 : 			}
; 5305 : 		else if (_Ch == _Meta_equal)
; 5306 : 			{	// process assert group
; 5307 : 			_Do_assert_group(false);
; 5308 : 			--_Disj_count;
; 5309 : 			return (false);
; 5310 : 			}
; 5311 : 		else
; 5312 : 			_Error(regex_constants::error_syntax);
; 5313 : 		}
; 5314 : 	else if (_Flags & regex_constants::nosubs)
; 5315 : 		_Do_noncapture_group();
; 5316 : 	else
; 5317 : 		_Do_capture_group();
; 5318 : 		--_Disj_count;
; 5319 : 	return (true);
; 5320 : 	}
; 5321 : 
; 5322 : template<class _FwdIt,
; 5323 : 	class _Elem,
; 5324 : 	class _RxTraits> inline
; 5325 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_IsIdentityEscape() const
; 5326 : 	{	// check for valid identity escape
; 5327 : 	if (_L_flags & _L_ident_ECMA)
; 5328 : 		// ECMAScript identity escape characters
; 5329 : 		switch (_Char)
; 5330 : 			{
; 5331 : 			case 'c':	// ASCII control character
; 5332 : 			case 'd':	// digit
; 5333 : 			case 'D':
; 5334 : 			case 's':	// whitespace
; 5335 : 			case 'S':
; 5336 : 			case 'w':	// word character
; 5337 : 			case 'W':
; 5338 : 				return (false);
; 5339 : 			default:
; 5340 : 				return (true);
; 5341 : 			}
; 5342 : 
; 5343 : 	switch (_Char)
; 5344 : 		{
; 5345 : 		case _Meta_dot:
; 5346 : 		case _Meta_lsq:
; 5347 : 		case _Meta_esc:
; 5348 : 		case _Meta_star:
; 5349 : 		case _Meta_bar:
; 5350 : 		case _Meta_caret:
; 5351 : 		case _Meta_dlr:
; 5352 : 			// BRE, ERE, awk identity escape characters
; 5353 : 			return (true);
; 5354 : 		case _Meta_lpar:
; 5355 : 		case _Meta_rpar:
; 5356 : 		case _Meta_plus:
; 5357 : 		case _Meta_query:
; 5358 : 		case _Meta_lbr:
; 5359 : 		case _Meta_rbr:
; 5360 : 			// additional ERE identity escape characters
; 5361 : 			return ((_L_flags & _L_ident_ERE) != 0);
; 5362 : 		case '"':
; 5363 : 		case '/':
; 5364 : 			// additional awk identity escape characters
; 5365 : 			return ((_L_flags & _L_ident_awk) != 0);
; 5366 : 		default:
; 5367 : 			return (false);
; 5368 : 		}
; 5369 : 	}
; 5370 : 
; 5371 : template<class _FwdIt,
; 5372 : 	class _Elem,
; 5373 : 	class _RxTraits> inline
; 5374 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_IdentityEscape()
; 5375 : 	{	// check whether an escape is valid, and process it if so
; 5376 : 	if (_IsIdentityEscape())
; 5377 : 		{
; 5378 : 		_Val = _Char;
; 5379 : 		_Next();
; 5380 : 		return (true);
; 5381 : 		}
; 5382 : 	else
; 5383 : 		return (false);
; 5384 : 	}
; 5385 : 
; 5386 : template<class _FwdIt,
; 5387 : 	class _Elem,
; 5388 : 	class _RxTraits> inline
; 5389 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_Do_ffn(_Elem _Ch)
; 5390 : 	{	// check for limited file format escape characters
; 5391 : 	if (_Ch == _Esc_ctrl_f)
; 5392 : 		_Val = '\f';
; 5393 : 	else if (_Ch == _Esc_ctrl_n)
; 5394 : 		_Val = '\n';
; 5395 : 	else if (_Ch == _Esc_ctrl_r)
; 5396 : 		_Val = '\r';
; 5397 : 	else if (_Ch == _Esc_ctrl_t)
; 5398 : 		_Val = '\t';
; 5399 : 	else if (_Ch == _Esc_ctrl_v)
; 5400 : 		_Val = '\v';
; 5401 : 	else
; 5402 : 		return (false);
; 5403 : 	return (true);
; 5404 : 	}
; 5405 : 
; 5406 : template<class _FwdIt,
; 5407 : 	class _Elem,
; 5408 : 	class _RxTraits> inline
; 5409 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_Do_ffnx(_Elem _Ch)
; 5410 : 	{	// check for the remaining file format escape characters
; 5411 : 	if (_Ch == _Esc_ctrl_a)
; 5412 : 		_Val = '\a';
; 5413 : 	else if (_Ch == _Esc_ctrl_b)
; 5414 : 		_Val = '\b';
; 5415 : 	else
; 5416 : 		return (false);
; 5417 : 	return (true);
; 5418 : 	}
; 5419 : 
; 5420 : template<class _FwdIt,
; 5421 : 	class _Elem,
; 5422 : 	class _RxTraits> inline
; 5423 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_CharacterEscape()
; 5424 : 	{	// check for valid character escape
; 5425 : 	if (_Mchar == _Meta_eos)
; 5426 : 		_Error(regex_constants::error_escape);
; 5427 : 
; 5428 : 	if ((_L_flags & _L_esc_ffn && _Do_ffn(_Char))
; 5429 : 		|| (_L_flags & _L_esc_ffnx && _Do_ffnx(_Char)))
; 5430 : 		_Next();
; 5431 : 	else if (_Char == _Esc_ctrl && (_L_flags & _L_esc_ctrl))
; 5432 : 		{	// handle control escape sequence
; 5433 : 		_Next();
; 5434 : 		if (!_Traits.isctype(_Char, _RxTraits::_Ch_alpha))
; 5435 : 			_Error(regex_constants::error_escape);
; 5436 : 		_Val = (char)(_Char % 32);
; 5437 : 		_Next();
; 5438 : 		}
; 5439 : 	else if (_Char == _Esc_hex && (_L_flags & _L_esc_hex))
; 5440 : 		{	// handle hexadecimal escape sequence
; 5441 : 		_Next();
; 5442 : 		_HexDigits(2);
; 5443 : 		}
; 5444 : 	else if (_Char == _Esc_uni && (_L_flags & _L_esc_uni))
; 5445 : 		{	// handle unicode escape sequence
; 5446 : 		_Next();
; 5447 : 		_HexDigits(4);
; 5448 : 		}
; 5449 : 	else if ((_L_flags & _L_esc_oct) && _OctalDigits())
; 5450 : 		{	// handle octal escape sequence
; 5451 : 		if (_Val == 0)
; 5452 : 			_Error(regex_constants::error_escape);
; 5453 : 		}
; 5454 : 	else
; 5455 : 		return (_IdentityEscape());
; 5456 : 
; 5457 : 	if ((numeric_limits<typename _RxTraits::_Uelem>::max)()
; 5458 : 		< (unsigned int)_Val)
; 5459 : 		_Error(regex_constants::error_escape);
; 5460 : 	_Val = (_Elem)_Val;
; 5461 : 	return (true);
; 5462 : 	}
; 5463 : 
; 5464 : template<class _FwdIt,
; 5465 : 	class _Elem,
; 5466 : 	class _RxTraits> inline
; 5467 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_AtomEscape()
; 5468 : 	{	// check for valid atom escape
; 5469 : 	if ((_L_flags & _L_bckr) && _DecimalDigits())
; 5470 : 		{	// check for valid back reference
; 5471 : 		if (_Val == 0)
; 5472 : 			{	// handle \0
; 5473 : 			if (!(_L_flags & _L_bzr_chr))
; 5474 : 				_Error(regex_constants::error_escape);
; 5475 : 			else
; 5476 : 				_Nfa._Add_char((_Elem)_Val);
; 5477 : 			}
; 5478 : 		else if (((_L_flags & _L_lim_bckr) && _BRE_MAX_GRP < _Val)
; 5479 : 			|| _Grp_idx < _Val
; 5480 : 			|| _Finished_grps.size() <= static_cast<size_t>(_Val)
; 5481 : 			|| !_Finished_grps[_Val])
; 5482 : 			_Error(regex_constants::error_backref);
; 5483 : 		else
; 5484 : 			_Nfa._Add_backreference(_Val);
; 5485 : 		}
; 5486 : 	else if (_CharacterEscape())
; 5487 : 		_Nfa._Add_char((_Elem)_Val);
; 5488 : 	else if (!(_L_flags & _L_esc_wsd) || !_CharacterClassEscape(true))
; 5489 : 		_Error(regex_constants::error_escape);
; 5490 : 	}
; 5491 : 
; 5492 : template<class _FwdIt,
; 5493 : 	class _Elem,
; 5494 : 	class _RxTraits> inline
; 5495 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Quantifier()
; 5496 : 	{	// check for quantifier following atom
; 5497 : 	int _Min = 0;
; 5498 : 	int _Max = -1;
; 5499 : 	if (_Mchar == _Meta_star)
; 5500 : 		;
; 5501 : 	else if (_Mchar == _Meta_plus)
; 5502 : 		_Min = 1;
; 5503 : 	else if (_Mchar == _Meta_query)
; 5504 : 		_Max = 1;
; 5505 : 	else if (_Mchar == _Meta_lbr)
; 5506 : 		{	// check for valid bracketed value
; 5507 : 		_Next();
; 5508 : 		if (!_DecimalDigits())
; 5509 : 			_Error(regex_constants::error_badbrace);
; 5510 : 		_Min = _Val;
; 5511 : 		if (_Mchar != _Meta_comma)
; 5512 : 			_Max = _Min;
; 5513 : 		else
; 5514 : 			{	// check for decimal constant following comma
; 5515 : 			_Next();
; 5516 : 			if (_Mchar == _Meta_rbr)
; 5517 : 				;
; 5518 : 			else if (!_DecimalDigits())
; 5519 : 				_Error(regex_constants::error_badbrace);
; 5520 : 			else
; 5521 : 				_Max = _Val;
; 5522 : 			}
; 5523 : 		if (_Mchar != _Meta_rbr || (_Max != -1 && _Max < _Min))
; 5524 : 			_Error(regex_constants::error_badbrace);
; 5525 : 		}
; 5526 : 	else
; 5527 : 		return;
; 5528 : 	_Nfa._Mark_final();
; 5529 : 	_Next();
; 5530 : 	if ((_L_flags & _L_ngr_rep) && _Mchar == _Meta_query)
; 5531 : 		{	// add non-greedy repeat node
; 5532 : 		_Next();
; 5533 : 		_Nfa._Add_rep(_Min, _Max, false);
; 5534 : 		}
; 5535 : 	else
; 5536 : 		_Nfa._Add_rep(_Min, _Max, true);
; 5537 : 	}
; 5538 : 
; 5539 : template<class _FwdIt,
; 5540 : 	class _Elem,
; 5541 : 	class _RxTraits> inline
; 5542 : 	bool _Parser<_FwdIt, _Elem, _RxTraits>::_Alternative()
; 5543 : 	{	// check for valid alternative
; 5544 : 	bool _Found = false;
; 5545 : 	for (; ; )
; 5546 : 		{	// concatenate valid elements
; 5547 : 		bool _Quant = true;
; 5548 : 		if (_Mchar == _Meta_eos || _Mchar == _Meta_bar
; 5549 : 			|| (_Mchar == _Meta_rpar && _Disj_count != 0))
; 5550 : 			return (_Found);
; 5551 : 		else if (_Mchar == _Meta_rpar && !(_L_flags & _L_paren_bal))
; 5552 : 			_Error(regex_constants::error_paren);
; 5553 : 		else if (_Mchar == _Meta_dot)
; 5554 : 			{	// add dot node
; 5555 : 			_Nfa._Add_dot();
; 5556 : 			_Next();
; 5557 : 			}
; 5558 : 		else if (_Mchar == _Meta_esc)
; 5559 : 			{	// check for valid escape sequence
; 5560 : 			_Next();
; 5561 : 			if ((_L_flags & _L_asrt_wrd) && _Char == _Esc_word)
; 5562 : 				{	// add word assert
; 5563 : 				_Nfa._Add_wbound();
; 5564 : 				_Next();
; 5565 : 				_Quant = false;
; 5566 : 				}
; 5567 : 			else if ((_L_flags & _L_asrt_wrd) && _Char == _Esc_not_word)
; 5568 : 				{	// add not-word assert
; 5569 : 				_Nfa._Add_wbound();
; 5570 : 				_Nfa._Negate();
; 5571 : 				_Next();
; 5572 : 				_Quant = false;
; 5573 : 				}
; 5574 : 			else
; 5575 : 				_AtomEscape();
; 5576 : 			}
; 5577 : 		else if (_Mchar == _Meta_lsq)
; 5578 : 			{	// add bracket expression
; 5579 : 			_Next();
; 5580 : 			_CharacterClass();
; 5581 : 			_Expect(_Meta_rsq, regex_constants::error_brack);
; 5582 : 			}
; 5583 : 		else if (_Mchar == _Meta_lpar)
; 5584 : 			{	// check for valid group
; 5585 : 			_Next();
; 5586 : 			_Quant = _Wrapped_disjunction();
; 5587 : 			_Expect(_Meta_rpar, regex_constants::error_paren);
; 5588 : 			}
; 5589 : 		else if (_Mchar == _Meta_caret)
; 5590 : 			{	// add bol node
; 5591 : 			_Nfa._Add_bol();
; 5592 : 			_Next();
; 5593 : 			_Quant = false;
; 5594 : 			}
; 5595 : 		else if (_Mchar == _Meta_dlr)
; 5596 : 			{	// add eol node
; 5597 : 			_Nfa._Add_eol();
; 5598 : 			_Next();
; 5599 : 			_Quant = false;
; 5600 : 			}
; 5601 : 		else if (_Mchar == _Meta_star
; 5602 : 			|| _Mchar == _Meta_plus
; 5603 : 			|| _Mchar == _Meta_query
; 5604 : 			|| _Mchar == _Meta_lbr)
; 5605 : 			_Error(regex_constants::error_badrepeat);
; 5606 : 		else if (_Mchar == _Meta_rbr && !(_L_flags & _L_paren_bal))
; 5607 : 			_Error(regex_constants::error_brace);
; 5608 : 		else if (_Mchar == _Meta_rsq && !(_L_flags & _L_paren_bal))
; 5609 : 			_Error(regex_constants::error_brack);
; 5610 : 		else
; 5611 : 			{	// add character
; 5612 : 			_Nfa._Add_char(_Char);
; 5613 : 			_Next();
; 5614 : 			}
; 5615 : 		if (_Quant)
; 5616 : 			_Quantifier();
; 5617 : 		_Found = true;
; 5618 : 		}
; 5619 : 	}
; 5620 : 
; 5621 : template<class _FwdIt,
; 5622 : 	class _Elem,
; 5623 : 	class _RxTraits> inline
; 5624 : 	void _Parser<_FwdIt, _Elem, _RxTraits>::_Disjunction()
; 5625 : 	{	// check for valid disjunction
; 5626 : 	_Node_base *_Pos1 = _Nfa._Getmark();
; 5627 : 	if (_Alternative())
; 5628 : 		;
; 5629 : 	else if (_Mchar != _Meta_bar)
; 5630 : 		return;	// zero-length alternative not followed by '|'
; 5631 : 	else
; 5632 : 		{	// zero-length leading alternative
; 5633 : 		_Node_base *_Pos3 = _Nfa._Begin_group();
; 5634 : 		_Nfa._End_group(_Pos3);
; 5635 : 		}
; 5636 : 
; 5637 : 	_Node_base *_Pos2 = _Nfa._Begin_if(_Pos1);
; 5638 : 	while (_Mchar == _Meta_bar)
; 5639 : 		{	// append terms as long as we keep finding | characters
; 5640 : 		_Next();
; 5641 : 		if (!_Alternative())
; 5642 : 			{	// zero-length trailing alternative
; 5643 : 			_Node_base *_Pos3 = _Nfa._Begin_group();
; 5644 : 			_Nfa._End_group(_Pos3);
; 5645 : 			}
; 5646 : 		_Nfa._Else_if(_Pos1, _Pos2);
; 5647 : 		}
; 5648 : 	}
; 5649 : 
; 5650 : inline void _Calculate_loop_simplicity(_Node_base *_Nx, _Node_base *_Ne, _Node_rep *_Outer_rep)
; 5651 : 	{	// walks regex NFA, calculates values of _Node_rep::_Simple_loop
; 5652 : 	for (; _Nx != _Ne && _Nx != 0; _Nx = _Nx->_Next)
; 5653 : 		{
; 5654 : 		switch (_Nx->_Kind)
; 5655 : 			{
; 5656 : 			case _N_if:
; 5657 : 				// _Node_if inside a _Node_rep makes the rep not simple
; 5658 : 				if (_Outer_rep != 0)
; 5659 : 					_Outer_rep->_Simple_loop = 0;
; 5660 : 				// visit each branch of the if
; 5661 : 				for (_Node_if *_Branch = static_cast<_Node_if *>(_Nx)->_Child;
; 5662 : 					_Branch != 0;
; 5663 : 					_Branch = _Branch->_Child)
; 5664 : 					_Calculate_loop_simplicity(_Branch->_Next, _Branch->_Endif, _Outer_rep);
; 5665 : 				break;
; 5666 : 			case _N_assert:
; 5667 : 			case _N_neg_assert:
; 5668 : 				// visit the assertion body
; 5669 : 				// note _Outer_rep being reset: the assertion regex is completely independent
; 5670 : 				_Calculate_loop_simplicity(static_cast<_Node_assert *>(_Nx)->_Child, 0, 0);
; 5671 : 				break;
; 5672 : 			case _N_rep:
; 5673 : 				// _Node_rep inside another _Node_rep makes both not simple
; 5674 : 				if (_Outer_rep == 0)
; 5675 : 					_Outer_rep = static_cast<_Node_rep *>(_Nx);
; 5676 : 				else
; 5677 : 					{
; 5678 : 					_Outer_rep->_Simple_loop = 0;
; 5679 : 					static_cast<_Node_rep *>(_Nx)->_Simple_loop = 0;
; 5680 : 					}
; 5681 : 				break;
; 5682 : 			case _N_end_rep:
; 5683 : 				if (_Outer_rep == static_cast<_Node_end_rep *>(_Nx)->_Begin_rep)
; 5684 : 					{
; 5685 : 					// if the _Node_rep is still undetermined when we reach its end, it is simple
; 5686 : #pragma warning(push)
; 5687 : #pragma warning(disable: 6011)	// Dereferencing NULL pointer
; 5688 : 					if (_Outer_rep->_Simple_loop == -1)
; 5689 : 						_Outer_rep->_Simple_loop = 1;
; 5690 : #pragma warning(pop)
; 5691 : 					_Outer_rep = 0;
; 5692 : 					}
; 5693 : 				break;
; 5694 : 			default:
; 5695 : 				break;
; 5696 : 			}
; 5697 : 		}
; 5698 : 	}
; 5699 : 
; 5700 : template<class _FwdIt,
; 5701 : 	class _Elem,
; 5702 : 	class _RxTraits> inline
; 5703 : 	_Root_node *_Parser<_FwdIt, _Elem, _RxTraits>::_Compile()
; 5704 : 	{	// compile regular expression
; 5705 : 	_Root_node *_Res = 0;
; 5706 : 	_TRY_BEGIN
; 5707 : 	_Node_base *_Pos1 = _Nfa._Begin_capture_group(0);
; 5708 : 	_Disjunction();
; 5709 : 	if (_Pat != _End)
; 5710 : 		_Error(regex_constants::error_syntax);
; 5711 : 	_Nfa._End_group(_Pos1);
; 5712 : 	_Res = _Nfa._End_pattern();
; 5713 : 	_Res->_Fl = _Flags;
; 5714 : 	_Res->_Marks = _Mark_count();
; 5715 : 	_Calculate_loop_simplicity(_Res, 0, 0);
; 5716 : 	_CATCH_ALL
; 5717 : 	_Nfa._Discard_pattern();
; 5718 : 	_RERAISE;
; 5719 : 	_CATCH_END
; 5720 : 	return (_Res);
; 5721 : 	}
; 5722 : 
; 5723 : template<class _FwdIt,
; 5724 : 	class _Elem,
; 5725 : 	class _RxTraits> inline
; 5726 : 	_Parser<_FwdIt, _Elem, _RxTraits>::_Parser(
; 5727 : 		const _RxTraits& _Tr,
; 5728 : 		_FwdIt _Pfirst, _FwdIt _Plast,
; 5729 : 		regex_constants::syntax_option_type _Fx)
; 5730 : 	: _Pat(_Pfirst), _Begin(_Pfirst), _End(_Plast),

	mov	eax, DWORD PTR __Pfirst$[ebp]
	push	esi
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+4], eax
	mov	eax, DWORD PTR __Plast$[ebp]
	push	edi
	mov	DWORD PTR [ebx+8], eax

; 5731 : 		_Grp_idx(0), _Disj_count(0), _Finished_grps(0),

	lea	edi, DWORD PTR [ebx+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	lea	eax, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 5731 : 		_Grp_idx(0), _Disj_count(0), _Finished_grps(0),

	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 5731 : 		_Grp_idx(0), _Disj_count(0), _Finished_grps(0),

	mov	DWORD PTR [ebx+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	push	eax
	push	0
	mov	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 5731 : 		_Grp_idx(0), _Disj_count(0), _Finished_grps(0),

	mov	DWORD PTR [ebx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	mov	DWORD PTR $T3[ebp], 0
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2541 : 		{	// construct _Count * _Val elements with allocator _Al
; 2542 : 		_Alloc_proxy();
; 2543 : 		_Mysize = 0;

	mov	DWORD PTR [edi+12], 0

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edi]
	sub	eax, esi
	sar	eax, 2

; 3222 : 		if (_Words < this->_Myvec.size())

	test	eax, eax
	je	SHORT $LN140@Parser

; 3223 : 			this->_Myvec.erase(this->_Myvec.begin() + _Words,

	mov	eax, DWORD PTR [edi+4]

; 1602 : 		if (_First._Ptr != _Last._Ptr)

	cmp	esi, eax
	je	SHORT $LN140@Parser

; 1603 : 			{	// something to do, invalidate iterators
; 1604 : 			_Orphan_range(_First._Ptr, this->_Mylast());
; 1605 : 			const pointer _Newlast = _Move_unchecked(_Last._Ptr, this->_Mylast(), _First._Ptr);

	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1607 : 			this->_Mylast() = _Newlast;

	lea	edi, DWORD PTR [ebx+20]
	mov	DWORD PTR [edi+4], eax
$LN140@Parser:

; 3225 : 		this->_Mysize = _Size;

	mov	DWORD PTR [edi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 5732 : 		_Nfa(_Tr, _Fx), _Traits(_Tr), _Flags(_Fx)

	mov	edi, DWORD PTR __Fx$[ebp]
	lea	ecx, DWORD PTR [ebx+36]
	mov	esi, DWORD PTR __Tr$[ebp]
	push	edi
	push	esi
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	call	??0?$_Builder@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@W4syntax_option_type@regex_constants@1@@Z ; std::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Builder<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >
	mov	DWORD PTR [ebx+64], edi

; 113  : _BITMASK_OPS(syntax_option_type)

	and	edi, 63					; 0000003fH

; 5732 : 		_Nfa(_Tr, _Fx), _Traits(_Tr), _Flags(_Fx)

	mov	DWORD PTR [ebx+60], esi
	cmp	edi, 1

; 5734 : 
; 5735 : 		// PARSER LANGUAGE FLAGS
; 5736 : 	constexpr unsigned int _ECMA_flags =
; 5737 : 		_L_ext_rep | _L_alt_pipe | _L_nex_grp | _L_nex_rep | _L_nc_grp
; 5738 : 			| _L_asrt_gen | _L_asrt_wrd | _L_bckr | _L_ngr_rep
; 5739 : 			| _L_esc_uni | _L_esc_hex | _L_esc_bsl | _L_esc_ffn | _L_esc_wsd
; 5740 : 			| _L_esc_ctrl | _L_bzr_chr | _L_grp_esc | _L_ident_ECMA
; 5741 : 			| _L_empty_grp;
; 5742 : 
; 5743 : 	constexpr unsigned int _Basic_flags =
; 5744 : 		_L_bckr | _L_lim_bckr | _L_anch_rstr
; 5745 : 			| _L_star_beg | _L_empty_grp | _L_brk_rstr | _L_mtch_long;
; 5746 : 
; 5747 : 	constexpr unsigned int _Grep_flags =
; 5748 : 		_Basic_flags | _L_alt_nl | _L_no_nl;
; 5749 : 
; 5750 : 	constexpr unsigned int _Extended_flags =
; 5751 : 		_L_ext_rep | _L_alt_pipe | _L_nex_grp | _L_nex_rep | _L_ident_ERE
; 5752 : 		| _L_paren_bal | _L_brk_rstr | _L_mtch_long;
; 5753 : 
; 5754 : 	constexpr unsigned int _Awk_flags =
; 5755 : 		_Extended_flags | _L_esc_oct | _L_esc_ffn | _L_esc_ffnx | _L_ident_awk;
; 5756 : 
; 5757 : 	constexpr unsigned int _Egrep_flags =
; 5758 : 		_Extended_flags | _L_alt_nl | _L_no_nl;
; 5759 : 
; 5760 : 	using namespace regex_constants;
; 5761 : 	_L_flags = (_Flags & _Gmask) == ECMAScript

	je	SHORT $LN4@Parser
	test	edi, edi
	je	SHORT $LN4@Parser
	cmp	edi, 2
	jne	SHORT $LN11@Parser
	mov	eax, 1845494528				; 6e000300H
	jmp	SHORT $LN13@Parser
$LN11@Parser:
	cmp	edi, 4
	jne	SHORT $LN9@Parser
	mov	eax, 1887436827				; 7080001bH
	jmp	SHORT $LN13@Parser
$LN9@Parser:
	cmp	edi, 8
	jne	SHORT $LN7@Parser
	mov	eax, 1904320539				; 7181a01bH
	jmp	SHORT $LN13@Parser
$LN7@Parser:
	cmp	edi, 16					; 00000010H
	jne	SHORT $LN5@Parser
	mov	eax, 1846018820				; 6e080304H
	jmp	SHORT $LN13@Parser
$LN5@Parser:
	xor	eax, eax
	mov	ecx, 1887961119				; 7088001fH
	cmp	edi, 32					; 00000020H
	cmove	eax, ecx
	jmp	SHORT $LN13@Parser
$LN4@Parser:
	mov	eax, 142040571				; 08775dfbH
$LN13@Parser:
	mov	DWORD PTR [ebx+80], eax

; 5762 : 		|| (_Flags & _Gmask) == 0 ? _ECMA_flags
; 5763 : 		: (_Flags & _Gmask) == basic ? _Basic_flags
; 5764 : 		: (_Flags & _Gmask) == extended ? _Extended_flags
; 5765 : 		: (_Flags & _Gmask) == awk ? _Awk_flags
; 5766 : 		: (_Flags & _Gmask) == grep ? _Grep_flags
; 5767 : 		: (_Flags & _Gmask) == egrep ? _Egrep_flags
; 5768 : 		: 0;
; 5769 : 	if (_L_flags & _L_mtch_long)

	test	eax, 1073741824				; 40000000H
	je	SHORT $LN2@Parser

; 3623 : 	_Root->_Flags |= _Fl_longest;

	mov	eax, DWORD PTR [ebx+36]

; 1523 : 	return (_Left = _Node_flags((int)_Left | _Right));

	or	DWORD PTR [eax+8], 8
$LN2@Parser:

; 5770 : 		_Nfa._Setlong();
; 5771 : 	_Trans();

	mov	ecx, ebx
	call	?_Trans@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@AAEXXZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Trans

; 5772 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
__unwindfunclet$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z ENDP ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z
_TEXT	SEGMENT
__Mx$ = -140						; size = 128
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Matches$ = 16						; size = 4
__Re$ = 20						; size = 4
__Found$1$ = 23						; size = 1
__Flgs$ = 24						; size = 4
__Org$ = 28						; size = 4
??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z PROC ; std::_Regex_search1<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> >,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>, COMDAT

; 2860 : 	{	// search for regular expression match in target text

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 2537 : 		return (_Rep == 0);

	mov	ecx, DWORD PTR __Re$[ebp]

; 2860 : 	{	// search for regular expression match in target text

	push	-1
	push	__ehhandler$??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 128				; 00000080H

; 2537 : 		return (_Rep == 0);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax

; 2861 : 	if (_Re._Empty())

	jne	SHORT $LN4@Regex_sear

; 2862 : 		return (false);

	xor	al, al

; 2895 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@Regex_sear:
	push	ebx

; 2863 : 	bool _Found = false;
; 2864 : 	_It _Begin = _First;
; 2865 : 	_Matcher<_BidIt, _Elem, _RxTraits, _It> _Mx(_First, _Last,

	mov	ebx, DWORD PTR __Last$[ebp]
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	push	edi
	push	DWORD PTR __Flgs$[ebp]
	mov	BYTE PTR __Found$1$[ebp], 0
	push	DWORD PTR [eax+20]
	push	DWORD PTR [eax+28]
	push	eax

; 2542 : 		return (_Traits);

	lea	eax, DWORD PTR [ecx+4]

; 2863 : 	bool _Found = false;
; 2864 : 	_It _Begin = _First;
; 2865 : 	_Matcher<_BidIt, _Elem, _RxTraits, _It> _Mx(_First, _Last,

	push	eax
	push	ebx
	push	esi
	lea	ecx, DWORD PTR __Mx$[ebp]
	call	??0?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@PB_W0ABV?$regex_traits@_W@1@PAV_Root_node@1@IW4syntax_option_type@regex_constants@1@W4match_flag_type@51@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>

; 2866 : 		_Re._Get_traits(), _Re._Get(), _Re.mark_count() + 1, _Re.flags(),
; 2867 : 			_Flgs);
; 2868 : 
; 2869 : 	if (_Mx._Match(_Matches, false))

	mov	edi, DWORD PTR __Matches$[ebp]
	lea	ecx, DWORD PTR __Mx$[ebp]
	push	0
	push	edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >
	test	al, al
	jne	SHORT $LN160@Regex_sear

; 2870 : 		_Found = true;
; 2871 : 	else if (_First == _Last
; 2872 : 		|| _Flgs & regex_constants::match_continuous)

	cmp	esi, ebx
	je	$LN12@Regex_sear

; 133  : _BITMASK_OPS(match_flag_type)

	test	BYTE PTR __Flgs$[ebp], 64		; 00000040H

; 2870 : 		_Found = true;
; 2871 : 	else if (_First == _Last
; 2872 : 		|| _Flgs & regex_constants::match_continuous)

	jne	$LN12@Regex_sear

; 133  : _BITMASK_OPS(match_flag_type)

	mov	eax, DWORD PTR __Mx$[ebp+96]

; 2873 : 		;
; 2874 : 	else
; 2875 : 		{	// try more on suffixes
; 2876 : 		_Mx._Setf(regex_constants::match_prev_avail);
; 2877 : 		_Mx._Clearf(regex_constants::_Match_not_null);
; 2878 : 		while ((_First = _Mx._Skip(++_First, _Last)) != _Last)

	lea	ecx, DWORD PTR __Mx$[ebp]

; 133  : _BITMASK_OPS(match_flag_type)

	or	eax, 256				; 00000100H
	and	eax, -8193				; ffffdfffH

; 2873 : 		;
; 2874 : 	else
; 2875 : 		{	// try more on suffixes
; 2876 : 		_Mx._Setf(regex_constants::match_prev_avail);
; 2877 : 		_Mx._Clearf(regex_constants::_Match_not_null);
; 2878 : 		while ((_First = _Mx._Skip(++_First, _Last)) != _Last)

	push	0

; 133  : _BITMASK_OPS(match_flag_type)

	mov	DWORD PTR __Mx$[ebp+96], eax

; 2873 : 		;
; 2874 : 	else
; 2875 : 		{	// try more on suffixes
; 2876 : 		_Mx._Setf(regex_constants::match_prev_avail);
; 2877 : 		_Mx._Clearf(regex_constants::_Match_not_null);
; 2878 : 		while ((_First = _Mx._Skip(++_First, _Last)) != _Last)

	lea	eax, DWORD PTR [esi+2]
	push	ebx
	push	eax
	call	?_Skip@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEPB_WPB_W0PAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Skip
	mov	esi, eax
	cmp	esi, ebx
	je	SHORT $LN158@Regex_sear
$LL2@Regex_sear:

; 2054 : 		return (_Match(_Matches, _Full_match));

	push	0
	push	edi
	lea	ecx, DWORD PTR __Mx$[ebp]
	mov	DWORD PTR __Mx$[ebp+84], esi
	call	??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >

; 2879 : 			if (_Mx._Match(_First, _Matches, false))

	test	al, al
	jne	SHORT $LN154@Regex_sear

; 2873 : 		;
; 2874 : 	else
; 2875 : 		{	// try more on suffixes
; 2876 : 		_Mx._Setf(regex_constants::match_prev_avail);
; 2877 : 		_Mx._Clearf(regex_constants::_Match_not_null);
; 2878 : 		while ((_First = _Mx._Skip(++_First, _Last)) != _Last)

	push	0
	push	ebx
	lea	eax, DWORD PTR [esi+2]
	push	eax
	lea	ecx, DWORD PTR __Mx$[ebp]
	call	?_Skip@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAEPB_WPB_W0PAV_Node_base@2@@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Skip
	mov	esi, eax
	cmp	esi, ebx
	jne	SHORT $LL2@Regex_sear
$LN158@Regex_sear:

; 2054 : 		return (_Match(_Matches, _Full_match));

	push	0
	push	edi
	lea	ecx, DWORD PTR __Mx$[ebp]
	mov	DWORD PTR __Mx$[ebp+84], ebx
	call	??$_Match@V?$allocator@V?$sub_match@PB_W@std@@@std@@@?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE_NPAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@1@_N@Z ; std::_Matcher<wchar_t const *,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>::_Match<std::allocator<std::sub_match<wchar_t const *> > >

; 2880 : 				{	// found match starting at _First
; 2881 : 				_Found = true;
; 2882 : 				break;
; 2883 : 				}
; 2884 : 		if (!_Found && _Mx._Match(_Last, _Matches, false))

	test	al, al
	je	SHORT $LN12@Regex_sear
$LN154@Regex_sear:
	mov	esi, DWORD PTR __First$[ebp]
$LN160@Regex_sear:

; 2885 : 			_Found = true;

	mov	BYTE PTR __Found$1$[ebp], 1

; 2886 : 		}
; 2887 : 	if (_Found && _Matches)

	test	edi, edi
	je	SHORT $LN12@Regex_sear

; 2888 : 		{	// update _Matches
; 2889 : 		_Matches->_Org = _Org;

	mov	eax, DWORD PTR __Org$[ebp]

; 2890 : 		_Matches->_Pfx().first = _Begin;
; 2891 : 		_Matches->_Pfx().matched =

	cmp	esi, DWORD PTR [edi+24]
	mov	DWORD PTR [edi], eax
	setne	al
	mov	DWORD PTR [edi+20], esi
	mov	BYTE PTR [edi+28], al
$LN12@Regex_sear:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR __Mx$[ebp+64]
	pop	edi
	pop	esi
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN60@Regex_sear

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR __Mx$[ebp+72]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR __Mx$[ebp+64], 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR __Mx$[ebp+68], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR __Mx$[ebp+72], 0
$LN60@Regex_sear:
	lea	ecx, DWORD PTR __Mx$[ebp+32]
	call	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
	lea	ecx, DWORD PTR __Mx$[ebp]
	call	??1?$_Tgt_state_t@PB_W@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2895 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, BYTE PTR __Found$1$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z$0:
	lea	ecx, DWORD PTR __Mx$[ebp]
	jmp	??1?$_Matcher@PB_W_WV?$regex_traits@_W@std@@PB_W@std@@QAE@XZ
__ehhandler$??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z ENDP ; std::_Regex_search1<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> >,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0PB_WPB_WX@?$pair@PB_WPB_W@std@@QAE@XZ
_TEXT	SEGMENT
??$?0PB_WPB_WX@?$pair@PB_WPB_W@std@@QAE@XZ PROC		; std::pair<wchar_t const *,wchar_t const *>::pair<wchar_t const *,wchar_t const *><wchar_t const *,wchar_t const *,void>, COMDAT
; _this$ = ecx

; 103  : 		: first(), second()

	mov	DWORD PTR [ecx], 0

; 105  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??$?0PB_WPB_WX@?$pair@PB_WPB_W@std@@QAE@XZ ENDP		; std::pair<wchar_t const *,wchar_t const *>::pair<wchar_t const *,wchar_t const *><wchar_t const *,wchar_t const *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$sub_match@PB_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$sub_match@PB_W@std@@QAE@XZ PROC			; std::sub_match<wchar_t const *>::sub_match<wchar_t const *>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 103  : 		: first(), second()

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 662  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 103  : 		: first(), second()

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 660  : 		: _Mybase(), matched(false)

	mov	BYTE PTR [ecx+8], 0

; 662  : 		}

	ret	0
??0?$sub_match@PB_W@std@@QAE@XZ ENDP			; std::sub_match<wchar_t const *>::sub_match<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_At@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@I@Z
_TEXT	SEGMENT
__Sub$ = 8						; size = 4
?_At@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@I@Z PROC ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_At, COMDAT
; _this$ = ecx

; 1447 : 		{	// unchecked access to element at _Sub

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Sub$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 1449 : 		}

	pop	ebp
	ret	4
?_At@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@I@Z ENDP ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_At
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Null@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Null@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ PROC ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Null, COMDAT
; _this$ = ecx

; 1443 : 		return (_Null_elem);

	lea	eax, DWORD PTR [ecx+44]

; 1444 : 		}

	ret	0
?_Null@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ ENDP ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Null
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Sfx@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Sfx@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ PROC ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Sfx, COMDAT
; _this$ = ecx

; 1438 : 		return (_Suffix);

	lea	eax, DWORD PTR [ecx+32]

; 1439 : 		}

	ret	0
?_Sfx@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ ENDP ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Sfx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Pfx@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Pfx@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ PROC ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Pfx, COMDAT
; _this$ = ecx

; 1433 : 		return (_Prefix);

	lea	eax, DWORD PTR [ecx+20]

; 1434 : 		}

	ret	0
?_Pfx@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEAAV?$sub_match@PB_W@2@XZ ENDP ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Pfx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Resize@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Nx$ = 8						; size = 4
?_Resize@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXI@Z PROC ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Resize, COMDAT
; _this$ = ecx

; 1427 : 		{	// allocate space for _Nx submatches

	npad	2
	push	ebp
	mov	ebp, esp

; 1428 : 		_Matches.resize(_Nx);

	add	ecx, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	ecx
	push	DWORD PTR __Nx$[ebp]
	call	??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Resize<<lambda_cfdb45d3a034db37f9e74d96913a06ba> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 1429 : 		}

	pop	ebp
	ret	4
?_Resize@?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXI@Z ENDP ; std::match_results<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> > >::_Resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@ABEXPAV?$sub_match@PB_W@2@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@ABEXPAV?$sub_match@PB_W@2@0@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Orphan_range, COMDAT
; _this$ = ecx

; 1996 : 		}

	ret	8
?_Orphan_range@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@ABEXPAV?$sub_match@PB_W@2@0@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@CAXXZ PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXQAV?$sub_match@PB_W@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXQAV?$sub_match@PB_W@2@II@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXQAV?$sub_match@PB_W@2@II@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 357913941				; 15555555H

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, ecx
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@0@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@0@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@00@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 893  : 	return {};

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@00@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 893  : 	return {};

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$sub_match@PB_W@std@@PAV12@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::sub_match<wchar_t const *> *,std::sub_match<wchar_t const *> *,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXPAV?$sub_match@PB_W@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Udefault@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEPAV?$sub_match@PB_W@2@PAV32@I@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
$T1 = 12						; size = 1
__Count$ = 12						; size = 4
?_Udefault@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEPAV?$sub_match@PB_W@2@PAV32@I@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Udefault, COMDAT
; _this$ = ecx

; 1847 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAV?$sub_match@PB_W@std@@IV?$allocator@V?$sub_match@PB_W@std@@@2@@std@@YAPAV?$sub_match@PB_W@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::sub_match<wchar_t const *> *,unsigned int,std::allocator<std::sub_match<wchar_t const *> > >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1849 : 		}

	pop	ebp
	ret	8
?_Udefault@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEPAV?$sub_match@PB_W@2@PAV32@I@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QAEAAV?$sub_match@PB_W@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QAEAAV?$sub_match@PB_W@1@I@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::operator[], COMDAT
; _this$ = ecx

; 1736 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1737 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1738 : 		if (size() <= _Pos)
; 1739 : 			{	// report error
; 1740 : 			_DEBUG_ERROR("vector subscript out of range");
; 1741 : 			}
; 1742 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1743 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1744 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1745 : 
; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Pos$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 1747 : 		}

	pop	ebp
	ret	4
??A?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QAEAAV?$sub_match@PB_W@1@I@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1721 : 		}

	ret	0
?capacity@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 357913941				; 15555555H

; 1716 : 		}

	ret	0
?max_size@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1711 : 		}

	ret	0
?size@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?resize@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::resize, COMDAT
; _this$ = ecx

; 1490 : 		{	// trim or append value-initialized elements, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 1491 : 		auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1492 : 			{
; 1493 : 			return (_Udefault(_Dest, _Count));
; 1494 : 			};
; 1495 : 
; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	ecx
	push	DWORD PTR __Newsize$[ebp]
	call	??$_Resize@V<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@AAEXIV<lambda_cfdb45d3a034db37f9e74d96913a06ba>@@@Z ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::_Resize<<lambda_cfdb45d3a034db37f9e74d96913a06ba> >

; 1497 : 		}

	pop	ebp
	ret	4
?resize@?$vector@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >,std::_Vector_val<std::_Simple_types<std::sub_match<wchar_t const *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABQAV?$sub_match@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAPAV?$sub_match@PB_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$sub_match@PB_W@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$sub_match@PB_W@std@@V?$allocator@V?$sub_match@PB_W@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::sub_match<wchar_t const *>,std::allocator<std::sub_match<wchar_t const *> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 357913941				; 15555555H

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z ; std::allocator<std::sub_match<wchar_t const *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::sub_match<wchar_t const *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAIABV?$allocator@V?$sub_match@PB_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAIABV?$allocator@V?$sub_match@PB_W@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 357913941				; 15555555H

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$sub_match@PB_W@std@@@std@@@std@@SAIABV?$allocator@V?$sub_match@PB_W@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::sub_match<wchar_t const *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$sub_match@PB_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$sub_match@PB_W@std@@@std@@QBEIXZ PROC ; std::allocator<std::sub_match<wchar_t const *> >::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 357913941				; 15555555H

; 852  : 		}

	ret	0
?max_size@?$allocator@V?$sub_match@PB_W@std@@@std@@QBEIXZ ENDP ; std::allocator<std::sub_match<wchar_t const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z PROC ; std::allocator<std::sub_match<wchar_t const *> >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEPAV?$sub_match@PB_W@2@I@Z ENDP ; std::allocator<std::sub_match<wchar_t const *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z PROC ; std::allocator<std::sub_match<wchar_t const *> >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@V?$sub_match@PB_W@std@@@std@@QAEXPAV?$sub_match@PB_W@2@I@Z ENDP ; std::allocator<std::sub_match<wchar_t const *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 2
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z PROC ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 75   : 	{	// get characters into string, discard delimiter

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream

; 92   : 			: _Myistr(_Istr)

	mov	esi, DWORD PTR __Istr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 79   : 	bool _Changed = false;

	xor	bl, bl
	push	edi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __State$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 79   : 	bool _Changed = false;

	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream

; 92   : 			: _Myistr(_Istr)

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN24@getline

; 95   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN24@getline:

; 117  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	1
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
	mov	BYTE PTR __Ok$[ebp+4], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 80   : 	const typename _Myis::sentry _Ok(_Istr, true);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 81   : 
; 82   : 	if (_Ok)

	test	al, al
	je	$LN136@getline
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 84   : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+16], 0

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN57@getline
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN57@getline:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 88   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
$LN139@getline:
	mov	ecx, 65535				; 0000ffffH
	movzx	eax, ax
	cmp	cx, ax

; 91   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	SHORT $LN7@getline

; 92   : 				{	// end of file, quit
; 93   : 				_State |= ios_base::eofbit;

	mov	edi, 1

; 94   : 				break;

	jmp	SHORT $LN3@getline
$LN7@getline:
	movzx	ecx, WORD PTR __Delim$[ebp]
	cmp	ax, cx

; 95   : 				}
; 96   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

	jne	SHORT $LN9@getline
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 98   : 				_Changed = true;

	mov	bl, 1
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 99   : 				_Istr.rdbuf()->sbumpc();

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ

; 100  : 				break;

	jmp	SHORT $LN3@getline
$LN9@getline:

; 101  : 				}
; 102  : 			else if (_Str.max_size() <= _Str.size())

	mov	ecx, DWORD PTR __Str$[ebp]
	cmp	DWORD PTR [ecx+16], 2147483646		; 7ffffffeH
	jb	SHORT $LN11@getline

; 103  : 				{	// string too large, quit
; 104  : 				_State |= ios_base::failbit;

	mov	edi, 2
	jmp	SHORT $LN3@getline
$LN11@getline:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2278 : 		push_back(_Ch);

	push	eax
	call	?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 110  : 				_Changed = true;

	mov	bl, 1
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 90   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
	jmp	SHORT $LN139@getline
__catch$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z$0:

; 111  : 				}
; 112  : 		_CATCH_IO_(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
	mov	eax, $LN19@getline
	ret	0
$LN19@getline:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\ios
	mov	esi, DWORD PTR __Istr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	mov	bl, BYTE PTR __Changed$[ebp]
$LN3@getline:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 113  : 		}
; 114  : 
; 115  : 	if (!_Changed)

	test	bl, bl
	jne	SHORT $LN13@getline
$LN136@getline:

; 116  : 		_State |= ios_base::failbit;

	or	edi, 2
$LN13@getline:

; 117  : 	_Istr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	push	0
	push	edi
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+eax+56]
	test	ecx, ecx
	je	SHORT $LN137@getline

; 101  : 				_Myistr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN137@getline:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 119  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z:
	mov	eax, OFFSET __ehfuncinfo$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@std@@YA$$QAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@std@@YA$$QAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<wchar_t,std::char_traits<wchar_t> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@std@@YA$$QAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<wchar_t,std::char_traits<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1163 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1164 : 	_Pocma(_Left, _Right, _Tag);
; 1165 : 	}

	ret	0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 22   : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 24   : 	}

	pop	ebp
	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT

; 289  : 		{	// convert raw reference to pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 290  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 291  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 12
__Lock$3 = -20						; size = 4
__Psave$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::collate<wchar_t> >, COMDAT

; 505  : 	{	// get facet reference from locale

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$collate@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::collate<wchar_t> >::_Psave

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

	mov	ecx, DWORD PTR __imp_?id@?$collate@_W@std@@2V0locale@2@A
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __Psave$4[ebp], ebx
	call	DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
	mov	edi, eax

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	eax, DWORD PTR __Loc$[ebp]
	mov	eax, DWORD PTR [eax+4]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	SHORT $LN7@use_facet
	jmp	SHORT $LN24@use_facet
$LN20@use_facet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	esi, esi
$LN24@use_facet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN18@use_facet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN25@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN18@use_facet:

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 512  : 
; 513  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN7@use_facet
$LN25@use_facet:

; 514  : 			;	// got facet from locale
; 515  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 516  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN7@use_facet
$LN4@use_facet:

; 517  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	push	DWORD PTR __Loc$[ebp]
	lea	eax, DWORD PTR __Psave$4[ebp]
	push	eax
	call	?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::collate<wchar_t>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN6@use_facet

; 518  : 
; 519  :  #if _HAS_EXCEPTIONS
; 520  : 
; 521  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN29@use_facet:
$LN6@use_facet:

; 522  : 
; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 			abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 
; 527  : 		else
; 528  : 			{	// queue up lazy facet for destruction
; 529  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$4[ebp]

; 530  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 531  : 
; 532  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 533  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$collate@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::collate<wchar_t> >::_Psave
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+4]

; 534  : 
; 535  :  #if defined(_M_CEE)
; 536  : 			_Facet_Register_m(_Pfmod);
; 537  : 
; 538  :  #else /* defined(_M_CEE) */
; 539  : 			_Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4
$LN7@use_facet:

; 540  :  #endif /* defined(_M_CEE) */
; 541  : 			}
; 542  : 
; 543  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ

; 544  : 	_END_LOCK()
; 545  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$3[ebp]
	jmp	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::collate<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@_W@std@@YAPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@_W@std@@YAPA_WAA_W@Z PROC			; std::addressof<wchar_t>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@_W@std@@YAPA_WAA_W@Z ENDP			; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1705 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1705 : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z PROC ; std::pointer_traits<wchar_t *>::pointer_to, COMDAT

; 289  : 		{	// convert raw reference to pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 290  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 291  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z ENDP ; std::pointer_traits<wchar_t *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 66   : 		return (_Myoff + _Fpos);

	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+12]
	adc	edx, DWORD PTR [ecx+4]

; 67   : 		}

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::seekpos, COMDAT
; _this$ = ecx

; 61   : 		return (_Fpos);

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]

; 62   : 		}

	ret	0
?seekpos@?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT
; _this$ = ecx

; 50   : 		{	// return conversion state

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 		return (_Mystate);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 52   : 		}

	pop	ebp
	ret	4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 8
__Fileposition$ = 16					; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 46   : 		{	// construct with conversion state and C file position

	npad	2
	push	ebp
	mov	ebp, esp

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

	mov	eax, DWORD PTR __Fileposition$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Fileposition$[ebp+4]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __State$[ebp+4]
	mov	DWORD PTR [ecx+20], eax

; 47   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	pop	ebp
	ret	16					; 00000010H
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct with stream offset

	npad	2
	push	ebp
	mov	ebp, esp

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	eax, DWORD PTR __Off$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Off$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 42   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	movq	QWORD PTR [ecx+16], xmm0
	pop	ebp
	ret	8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 12
__Lock$3 = -20						; size = 4
__Psave$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >, COMDAT

; 505  : 	{	// get facet reference from locale

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<wchar_t,char,_Mbstatet> >::_Psave

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

	mov	ecx, DWORD PTR __imp_?id@?$codecvt@_WDU_Mbstatet@@@std@@2V0locale@2@A
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __Psave$4[ebp], eax
	call	DWORD PTR __imp_??Bid@locale@std@@QAEIXZ

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ebx, DWORD PTR __Loc$[ebp]

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

	mov	edi, eax

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	eax, DWORD PTR [ebx+4]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	SHORT $LN7@use_facet
	jmp	SHORT $LN24@use_facet
$LN20@use_facet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	esi, esi
$LN24@use_facet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN18@use_facet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN25@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN18@use_facet:

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 512  : 
; 513  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN7@use_facet
$LN25@use_facet:

; 514  : 			;	// got facet from locale
; 515  : 		else if (_Psave != 0)

	mov	esi, DWORD PTR __Psave$4[ebp]
	test	esi, esi
	jne	SHORT $LN7@use_facet

; 516  : 			_Pf = _Psave;	// lazy facet already allocated
; 517  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$4[ebp]
	push	ebx
	push	eax
	call	DWORD PTR __imp_?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN6@use_facet

; 518  : 
; 519  :  #if _HAS_EXCEPTIONS
; 520  : 
; 521  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN29@use_facet:
$LN6@use_facet:

; 522  : 
; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 			abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 
; 527  : 		else
; 528  : 			{	// queue up lazy facet for destruction
; 529  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$4[ebp]

; 530  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 531  : 
; 532  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 533  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<wchar_t,char,_Mbstatet> >::_Psave
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+4]

; 534  : 
; 535  :  #if defined(_M_CEE)
; 536  : 			_Facet_Register_m(_Pfmod);
; 537  : 
; 538  :  #else /* defined(_M_CEE) */
; 539  : 			_Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4
$LN7@use_facet:

; 540  :  #endif /* defined(_M_CEE) */
; 541  : 			}
; 542  : 
; 543  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ

; 544  : 	_END_LOCK()
; 545  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$3[ebp]
	jmp	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1705 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1705 : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 12
__Lock$3 = -20						; size = 4
__Psave$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 505  : 	{	// get facet reference from locale

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

	mov	ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __Psave$4[ebp], eax
	call	DWORD PTR __imp_??Bid@locale@std@@QAEIXZ

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ebx, DWORD PTR __Loc$[ebp]

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

	mov	edi, eax

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	eax, DWORD PTR [ebx+4]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	SHORT $LN7@use_facet
	jmp	SHORT $LN24@use_facet
$LN20@use_facet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	esi, esi
$LN24@use_facet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN18@use_facet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN25@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN18@use_facet:

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 512  : 
; 513  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN7@use_facet
$LN25@use_facet:

; 514  : 			;	// got facet from locale
; 515  : 		else if (_Psave != 0)

	mov	esi, DWORD PTR __Psave$4[ebp]
	test	esi, esi
	jne	SHORT $LN7@use_facet

; 516  : 			_Pf = _Psave;	// lazy facet already allocated
; 517  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$4[ebp]
	push	ebx
	push	eax
	call	DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN6@use_facet

; 518  : 
; 519  :  #if _HAS_EXCEPTIONS
; 520  : 
; 521  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN29@use_facet:
$LN6@use_facet:

; 522  : 
; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 			abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 
; 527  : 		else
; 528  : 			{	// queue up lazy facet for destruction
; 529  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$4[ebp]

; 530  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 531  : 
; 532  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 533  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+4]

; 534  : 
; 535  :  #if defined(_M_CEE)
; 536  : 			_Facet_Register_m(_Pfmod);
; 537  : 
; 538  :  #else /* defined(_M_CEE) */
; 539  : 			_Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4
$LN7@use_facet:

; 540  :  #endif /* defined(_M_CEE) */
; 541  : 			}
; 542  : 
; 543  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ

; 544  : 	_END_LOCK()
; 545  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$3[ebp]
	jmp	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1439 : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 1440 : 		}

	ret	0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1421 : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 1195 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 1422 : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__Prs$ = -96						; size = 84
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Flags$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Reset<wchar_t const *>, COMDAT
; _this$ = ecx

; 2574 : 		{	// build regular expression from forward iterators

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi

; 2575 :  #if _ENHANCED_REGEX_VISUALIZER
; 2576 : 		_Visualization.assign(_First, _Last);
; 2577 :  #endif /* _ENHANCED_REGEX_VISUALIZER */
; 2578 : 
; 2579 : 		_Parser<_FwdIt, _Elem, _RxTraits>
; 2580 : 			_Prs(_Traits, _First, _Last, _Flags);

	push	DWORD PTR __Flags$[ebp]
	mov	esi, ecx
	lea	ecx, DWORD PTR __Prs$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >

; 2581 : 		_Root_node *_Rx = _Prs._Compile();

	lea	ecx, DWORD PTR __Prs$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Compile
	mov	edi, eax

; 2587 : 		if (_Rx != 0)

	test	edi, edi
	je	SHORT $LN5@Reset

; 2588 : 			_MT_INCR(reinterpret_cast<_Atomic_counter_t&>(_Rx->_Refs));

	lock	 inc	 DWORD PTR [edi+32]
$LN5@Reset:

; 2555 : 		if (_Rep != 0 && _MT_DECR(

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN8@Reset
	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx+32], eax
	jne	SHORT $LN8@Reset

; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);

	push	0
	push	DWORD PTR [esi]
	call	?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ; std::_Destroy_node
	add	esp, 8
$LN8@Reset:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR __Prs$[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2590 : 		_Rep = _Rx;

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN25@Reset

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR __Prs$[ebp+28]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN25@Reset:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2583 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z$0:
	lea	ecx, DWORD PTR __Prs$[ebp]
	jmp	??1?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Reset<wchar_t const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$regex_search@_WV?$regex_traits@_W@std@@@std@@YA_NPB_WABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Re$ = 12						; size = 4
__Flgs$ = 16						; size = 4
??$regex_search@_WV?$regex_traits@_W@std@@@std@@YA_NPB_WABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@@Z PROC ; std::regex_search<wchar_t,std::regex_traits<wchar_t> >, COMDAT

; 2932 : 	{	// search for regular expression match in target text

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Str$[ebp]
	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+2]
	npad	2
$LL8@regex_sear:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL8@regex_sear
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 133  : _BITMASK_OPS(match_flag_type)

	mov	ecx, DWORD PTR __Flgs$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sub	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2934 : 	return (_Regex_search1(_Str, _Last,

	push	edx

; 133  : _BITMASK_OPS(match_flag_type)

	or	ecx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2934 : 	return (_Regex_search1(_Str, _Last,

	push	ecx
	push	DWORD PTR __Re$[ebp]
	push	0
	lea	eax, DWORD PTR [edx+eax*2]
	push	eax
	push	edx
	call	??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z ; std::_Regex_search1<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> >,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>
	add	esp, 24					; 00000018H
	pop	esi

; 2935 : 		static_cast<match_results<const _Elem *> *>(0), _Re,
; 2936 : 			_Flgs | regex_constants::match_any, _Str));
; 2937 : 	}

	pop	ebp
	ret	0
??$regex_search@_WV?$regex_traits@_W@std@@@std@@YA_NPB_WABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@@Z ENDP ; std::regex_search<wchar_t,std::regex_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Reset@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPAV_Root_node@2@@Z
_TEXT	SEGMENT
__Rx$ = 8						; size = 4
?_Reset@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPAV_Root_node@2@@Z PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Reset, COMDAT
; _this$ = ecx

; 2586 : 		{	// build regular expression holding root node _Rx

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 2587 : 		if (_Rx != 0)

	mov	esi, DWORD PTR __Rx$[ebp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN2@Reset

; 2588 : 			_MT_INCR(reinterpret_cast<_Atomic_counter_t&>(_Rx->_Refs));

	lock	 inc	 DWORD PTR [esi+32]
$LN2@Reset:

; 2555 : 		if (_Rep != 0 && _MT_DECR(

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN7@Reset
	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx+32], eax
	jne	SHORT $LN7@Reset

; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);

	push	0
	push	DWORD PTR [edi]
	call	?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ; std::_Destroy_node
	add	esp, 8
$LN7@Reset:

; 2589 : 		_Tidy();
; 2590 : 		_Rep = _Rx;

	mov	DWORD PTR [edi], esi
	pop	edi
	pop	esi

; 2591 : 		}

	pop	ebp
	ret	4
?_Reset@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPAV_Root_node@2@@Z ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Tidy@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXXZ PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2554 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 2555 : 		if (_Rep != 0 && _MT_DECR(

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@Tidy
	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx+32], eax
	jne	SHORT $LN4@Tidy

; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);

	push	0
	push	DWORD PTR [esi]
	call	?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ; std::_Destroy_node
	add	esp, 8
$LN4@Tidy:

; 2558 : 		_Rep = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 2559 : 		}

	ret	0
?_Tidy@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXXZ ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Get_traits@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEABV?$regex_traits@_W@2@XZ
_TEXT	SEGMENT
?_Get_traits@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEABV?$regex_traits@_W@2@XZ PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Get_traits, COMDAT
; _this$ = ecx

; 2542 : 		return (_Traits);

	lea	eax, DWORD PTR [ecx+4]

; 2543 : 		}

	ret	0
?_Get_traits@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEABV?$regex_traits@_W@2@XZ ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Get_traits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Empty@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Empty@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Empty, COMDAT
; _this$ = ecx

; 2536 : 		{	// test if empty

	cmp	DWORD PTR [ecx], 0
	sete	al

; 2537 : 		return (_Rep == 0);
; 2538 : 		}

	ret	0
?_Empty@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Get@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEPAV_Root_node@2@XZ
_TEXT	SEGMENT
?_Get@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEPAV_Root_node@2@XZ PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Get, COMDAT
; _this$ = ecx

; 2532 : 		return (_Rep);

	mov	eax, DWORD PTR [ecx]

; 2533 : 		}

	ret	0
?_Get@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEPAV_Root_node@2@XZ ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?flags@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBE?AW4syntax_option_type@regex_constants@2@XZ
_TEXT	SEGMENT
?flags@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBE?AW4syntax_option_type@regex_constants@2@XZ PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::flags, COMDAT
; _this$ = ecx

; 2507 : 		return (_Rep ? _Rep->_Fl : (flag_type)0);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@flags
	mov	eax, DWORD PTR [eax+20]

; 2508 : 		}

	ret	0
$LN3@flags:

; 2507 : 		return (_Rep ? _Rep->_Fl : (flag_type)0);

	xor	eax, eax

; 2508 : 		}

	ret	0
?flags@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBE?AW4syntax_option_type@regex_constants@2@XZ ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::flags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?mark_count@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?mark_count@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEIXZ PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::mark_count, COMDAT
; _this$ = ecx

; 2458 : 		return (_Rep != 0 ? _Rep->_Marks - 1 : 0);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@mark_count
	mov	eax, DWORD PTR [eax+28]
	dec	eax

; 2459 : 		}

	ret	0
$LN3@mark_count:

; 2458 : 		return (_Rep != 0 ? _Rep->_Marks - 1 : 0);

	xor	eax, eax

; 2459 : 		}

	ret	0
?mark_count@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QBEIXZ ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::mark_count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::~basic_regex<wchar_t,std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 2425 : 		{	// destroy the object

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 2555 : 		if (_Rep != 0 && _MT_DECR(

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@basic_rege
	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx+32], eax
	jne	SHORT $LN4@basic_rege

; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);

	push	0
	push	DWORD PTR [esi]
	call	?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ; std::_Destroy_node
	add	esp, 8
$LN4@basic_rege:

; 2558 : 		_Rep = 0;

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 404  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN15@basic_rege

; 405  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN15@basic_rege
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN15@basic_rege:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2427 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::~basic_regex<wchar_t,std::regex_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Flags$ = 12						; size = 4
??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z PROC ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::basic_regex<wchar_t,std::regex_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 2315 : 		{	// construct from null terminated character sequence

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ebx
	lea	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR _this$[ebp], edi

; 276  : 		{	// default construct

	lea	esi, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 304  : 		{	// construct from current locale

	push	1
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR __imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z
	mov	DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	push	esi

; 276  : 		{	// default construct

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	call	??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z ; std::use_facet<std::collate<wchar_t> >

; 413  : 		_Pctype = &_USE(_Loc, ctype<_Elem>);

	push	esi
	mov	DWORD PTR [edi], eax
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2315 : 		{	// construct from null terminated character sequence

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2316 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	esi, DWORD PTR [eax+2]
$LL20@basic_rege:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL20@basic_rege
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2316 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sub	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2316 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),

	mov	ecx, ebx
	push	DWORD PTR __Flags$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2316 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),

	lea	eax, DWORD PTR [edx+eax*2]
	push	eax
	push	edx
	call	??$_Reset@PB_W@?$basic_regex@_WV?$regex_traits@_W@std@@@std@@AAEXPB_W0W4syntax_option_type@regex_constants@1@Uforward_iterator_tag@1@@Z ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::_Reset<wchar_t const *>

; 2317 : 			_Flags, random_access_iterator_tag());
; 2318 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$regex_traits@_W@std@@QAE@XZ
__ehhandler$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@PB_WW4syntax_option_type@regex_constants@1@@Z ENDP ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::basic_regex<wchar_t,std::regex_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??E?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator++, COMDAT
; _this$ = ecx

; 1246 : 		++_Ptr;

	add	DWORD PTR [ecx], 2

; 1449 : 		++*(_Mybase *)this;
; 1450 : 		return (*this);

	mov	eax, ecx

; 1451 : 		}

	ret	0
??E?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*, COMDAT
; _this$ = ecx

; 1439 : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 1440 : 		}

	ret	0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ
_TEXT	SEGMENT
?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unchecked, COMDAT
; _this$ = ecx

; 1434 : 		return (_Const_cast(this->_Ptr));

	mov	eax, DWORD PTR [ecx]

; 1435 : 		}

	ret	0
?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEPA_WXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
; _this$ = ecx

; 1421 : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 1195 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 1422 : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 158  : 	{	// get characters into string, discard newline

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

	mov	esi, DWORD PTR __Istr$[ebp]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
	movzx	eax, ax
	push	eax
	push	DWORD PTR __Str$[ebp]
	push	esi
	call	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 12					; 0000000cH
	pop	esi

; 160  : 	}

	pop	ebp
	ret	0
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
	npad	2
	push	esi
	lea	esi, DWORD PTR [ecx+112]
	mov	ecx, esi
	call	??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	lea	edi, DWORD PTR [esi-112]
	call	??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	184					; 000000b8H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	push	edi
	mov	esi, ecx

; 152  : 		if (_Myfile != 0)

	cmp	DWORD PTR [esi+76], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@
	je	SHORT $LN10@scalar
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 221  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 700  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN10@scalar

; 701  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [edi], ecx
	mov	eax, DWORD PTR [esi+28]
	sar	edx, 1
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN10@scalar:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 154  : 		if (_Closef)

	cmp	BYTE PTR [esi+72], 0
	je	SHORT $LN6@scalar

; 155  : 			close();

	mov	ecx, esi
	call	?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close
$LN6@scalar:

; 156  : 		}

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN16@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN16@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Set_back, COMDAT
; _this$ = ecx

; 705  : 		{	// set up putback area

	mov	edx, ecx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 221  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [edx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 706  : 		if (_Mysb::eback() != &_Mychar)

	lea	esi, DWORD PTR [edx+60]
	mov	eax, DWORD PTR [edi]
	cmp	eax, esi
	je	SHORT $LN2@Set_back

; 707  : 			{	// save current get buffer
; 708  : 			_Set_eback = _Mysb::eback();

	mov	DWORD PTR [edx+80], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+28]
	mov	eax, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+ecx*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 709  : 			_Set_egptr = _Mysb::egptr();

	mov	DWORD PTR [edx+84], eax
$LN2@Set_back:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 252  : 		*_IGfirst = _First;

	mov	DWORD PTR [edi], esi

; 254  : 		*_IGcount = (int)(_Last - _Next);

	mov	ecx, edx
	mov	eax, DWORD PTR [edx+28]
	sub	ecx, esi
	add	ecx, 62					; 0000003eH
	sar	ecx, 1
	pop	edi

; 253  : 		*_IGnext = _Next;

	mov	DWORD PTR [eax], esi

; 254  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [edx+44]
	pop	esi
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 712  : 		}

	ret	0
?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back, COMDAT
; _this$ = ecx

; 699  : 		{	// restore buffer after putback

	npad	2
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 221  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 700  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [ecx+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN2@Reset_back

; 701  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [ecx+80]
	push	esi
	mov	esi, DWORD PTR [ecx+84]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 252  : 		*_IGfirst = _First;

	mov	DWORD PTR [edi], edx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

	sub	esi, edx
	mov	eax, DWORD PTR [ecx+28]
	sar	esi, 1
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax], esi
	pop	esi
$LN2@Reset_back:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 702  : 		}

	ret	0
?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPBV?$codecvt@_WDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
__Newpcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPBV?$codecvt@_WDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Initcvt, COMDAT
; _this$ = ecx

; 680  : 		{	// initialize codecvt pointer

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 681  : 		if (_Newpcvt->always_noconv())

	mov	edi, DWORD PTR __Newpcvt$[ebp]
	mov	esi, ecx
	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN2@Initcvt

; 682  : 			_Pcvt = 0;	// nothing to do

	pop	edi
	mov	DWORD PTR [esi+56], 0
	pop	esi

; 687  : 			}
; 688  : 		}

	pop	ebp
	ret	4
$LN2@Initcvt:

; 683  : 		else
; 684  : 			{	// set up for nontrivial codecvt facet
; 685  : 			_Pcvt = _Newpcvt;
; 686  : 			_Mysb::_Init();	// reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ
	pop	edi
	pop	esi

; 687  : 			}
; 688  : 		}

	pop	ebp
	ret	4
?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPBV?$codecvt@_WDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Str$2 = -40						; size = 24
__Dest$3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite, COMDAT
; _this$ = ecx

; 639  : 		{	// put shift to initial conversion state, as needed

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, ecx

; 640  : 		if (_Pcvt == 0 || !_Wrotesome)

	cmp	DWORD PTR [ebx+56], 0
	je	$LN9@Endwrite
	cmp	BYTE PTR [ebx+62], 0
	je	$LN9@Endwrite

; 646  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

	mov	eax, DWORD PTR [ebx]
	push	65535					; 0000ffffH
	call	DWORD PTR [eax+12]
	movzx	eax, ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 351  : 		return (_Left == _Right);

	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	sete	al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 646  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

	test	al, al
	je	SHORT $LN10@Endwrite

; 647  : 				return (false);

	xor	al, al
	pop	ebx

; 676  : 			}
; 677  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@Endwrite:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	ecx, 15					; 0000000fH

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$2[ebp+16], 8
	xorps	xmm0, xmm0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$2[ebp+20], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H
	movq	QWORD PTR __Str$2[ebp], xmm0

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]
	cmovae	eax, DWORD PTR __Str$2[ebp]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 649  : 			string _Str(_STRING_INC, '\0');

	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN371@Endwrite:
	mov	esi, DWORD PTR __Str$2[ebp+20]
	lea	edi, DWORD PTR [ebx+64]
$LL2@Endwrite:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 651  : 				switch (_Pcvt->unshift(_State,

	lea	eax, DWORD PTR __Dest$3[ebp]
	push	eax
	mov	eax, DWORD PTR __Str$2[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	lea	edx, DWORD PTR __Str$2[ebp]
	cmovae	edx, DWORD PTR __Str$2[ebp]
	lea	ecx, DWORD PTR __Str$2[ebp]
	cmovae	ecx, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 651  : 				switch (_Pcvt->unshift(_State,

	add	eax, edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx+56]
	push	edi
	call	DWORD PTR __imp_?unshift@?$codecvt@_WDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z
	sub	eax, 0
	je	SHORT $LN11@Endwrite
	sub	eax, 1
	je	SHORT $LN12@Endwrite

; 674  : 					return (false);	// conversion failed

	mov	esi, DWORD PTR __Str$2[ebp+20]
	sub	eax, 2
	je	SHORT $LN366@Endwrite
$LN365@Endwrite:
	xor	bl, bl
	jmp	SHORT $LN20@Endwrite
$LN11@Endwrite:

; 652  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 653  : 				{	// test result of homing conversion
; 654  : 				case codecvt_base::ok:
; 655  : 					_Wrotesome = false;	// homed successfully

	mov	BYTE PTR [ebx+62], 0
$LN12@Endwrite:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	esi, DWORD PTR __Str$2[ebp+20]

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]
	mov	ecx, DWORD PTR __Str$2[ebp]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 659  : 					size_t _Count = _Dest - &*_Str.begin();

	mov	edi, DWORD PTR __Dest$3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 659  : 					size_t _Count = _Dest - &*_Str.begin();

	sub	edi, eax

; 660  : 					if (0 < _Count && _Count !=

	je	SHORT $LN13@Endwrite
	push	DWORD PTR [ebx+76]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 660  : 					if (0 < _Count && _Count !=

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 660  : 					if (0 < _Count && _Count !=

	push	1
	push	eax
	call	DWORD PTR __imp__fwrite
	mov	esi, DWORD PTR __Str$2[ebp+20]
	add	esp, 16					; 00000010H
	cmp	edi, eax
	jne	SHORT $LN365@Endwrite
$LN13@Endwrite:

; 661  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 662  : 						return (false);	// write failed
; 663  : 					if (!_Wrotesome)

	cmp	BYTE PTR [ebx+62], 0
	je	SHORT $LN366@Endwrite

; 665  : 					if (_Count == 0)

	test	edi, edi
	lea	edi, DWORD PTR [ebx+64]
	jne	$LL2@Endwrite

; 666  : 						_Str.append(_STRING_INC, '\0');	// try with more space

	push	0
	push	8
	lea	ecx, DWORD PTR __Str$2[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 675  : 				}

	jmp	$LN371@Endwrite
$LN366@Endwrite:

; 664  : 						return (true);

	mov	bl, 1
$LN20@Endwrite:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN338@Endwrite
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR __Str$2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN338@Endwrite:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 674  : 					return (false);	// conversion failed

	mov	al, bl
	pop	ebx

; 676  : 			}
; 677  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@Endwrite:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ$0:
	lea	ecx, DWORD PTR __Str$2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 604  : 		{	// initialize to C stream _File after {new, open, close}

	npad	2
	push	ebp
	mov	ebp, esp

; 605  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 606  : 
; 607  : 		_Closef = _Which == _Openfl;

	cmp	DWORD PTR __Which$[ebp], 1
	push	esi
	mov	esi, ecx
	sete	al
	mov	BYTE PTR [esi+72], al

; 608  : 		_Wrotesome = false;

	mov	BYTE PTR [esi+62], 0

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 618  : 			{	// point inside C stream with [first, first + count) buffer
; 619  : 			_Elem **_Pb = 0;
; 620  : 			_Elem **_Pn = 0;
; 621  : 			int *_Nr = 0;
; 622  : 
; 623  : 			::_get_stream_buffer_pointers(
; 624  : 				_File,
; 625  : 				reinterpret_cast<char***>(&_Pb),
; 626  : 				reinterpret_cast<char***>(&_Pn),
; 627  : 				&_Nr);
; 628  : 			int *_Nw = _Nr;
; 629  : 
; 630  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 631  : 			}
; 632  : 
; 633  : 		_Myfile = _File;

	mov	eax, DWORD PTR __File$[ebp]
	mov	DWORD PTR [esi+76], eax

; 634  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+68], eax

; 635  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0
	pop	esi

; 636  : 		}

	pop	ebp
	ret	8
?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::imbue, COMDAT
; _this$ = ecx

; 599  : 		{	// set locale to argument (capture nontrivial codecvt facet)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 600  : 		_Initcvt(&_USE(_Loc, _Cvt));

	push	DWORD PTR __Loc$[ebp]
	mov	esi, ecx
	call	??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >
	add	esp, 4
	mov	edi, eax

; 681  : 		if (_Newpcvt->always_noconv())

	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN4@imbue
	pop	edi

; 682  : 			_Pcvt = 0;	// nothing to do

	mov	DWORD PTR [esi+56], 0
	pop	esi

; 601  : 		}

	pop	ebp
	ret	4
$LN4@imbue:

; 686  : 			_Mysb::_Init();	// reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ
	pop	edi
	pop	esi

; 601  : 		}

	pop	ebp
	ret	4
?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::sync, COMDAT
; _this$ = ecx

; 592  : 		{	// synchronize C stream with external file

	npad	2
	push	esi
	mov	esi, ecx

; 593  : 		return (_Myfile == 0

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN3@sync
	mov	eax, DWORD PTR [esi]
	push	65535					; 0000ffffH
	call	DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 351  : 		return (_Left == _Right);

	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 593  : 		return (_Myfile == 0

	je	SHORT $LN3@sync
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fflush
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN3@sync
	or	eax, -1
	pop	esi

; 594  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 595  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 596  : 		}

	ret	0
$LN3@sync:

; 593  : 		return (_Myfile == 0

	xor	eax, eax
	pop	esi

; 594  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 595  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 596  : 		}

	ret	0
?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::setbuf, COMDAT
; _this$ = ecx

; 579  : 		{	// offer _Buffer to C stream

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 580  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,

	mov	ecx, DWORD PTR [edi+76]
	test	ecx, ecx
	je	SHORT $LN4@setbuf
	mov	esi, DWORD PTR __Buffer$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Count$[ebp]
	test	esi, esi
	jne	SHORT $LN6@setbuf
	mov	eax, ebx
	or	eax, DWORD PTR __Count$[ebp+4]
	jne	SHORT $LN6@setbuf
	lea	edx, DWORD PTR [eax+4]
	jmp	SHORT $LN7@setbuf
$LN6@setbuf:
	xor	edx, edx
$LN7@setbuf:
	lea	eax, DWORD PTR [ebx+ebx]
	push	eax
	push	edx
	push	esi
	push	ecx
	call	DWORD PTR __imp__setvbuf
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN4@setbuf

; 584  : 		else
; 585  : 			{	// new buffer, reinitialize pointers
; 586  : 			_Init(_Myfile, _Openfl);

	mov	esi, DWORD PTR [edi+76]

; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, edi
	mov	BYTE PTR [edi+72], 1
	mov	BYTE PTR [edi+62], al
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 618  : 			{	// point inside C stream with [first, first + count) buffer
; 619  : 			_Elem **_Pb = 0;
; 620  : 			_Elem **_Pn = 0;
; 621  : 			int *_Nr = 0;
; 622  : 
; 623  : 			::_get_stream_buffer_pointers(
; 624  : 				_File,
; 625  : 				reinterpret_cast<char***>(&_Pb),
; 626  : 				reinterpret_cast<char***>(&_Pn),
; 627  : 				&_Nr);
; 628  : 			int *_Nw = _Nr;
; 629  : 
; 630  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 631  : 			}
; 632  : 
; 633  : 		_Myfile = _File;

	mov	DWORD PTR [edi+76], esi

; 634  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [edi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [edi+68], eax

; 587  : 			return (this);

	mov	eax, edi

; 635  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	DWORD PTR [edi+56], 0
	pop	edi
	pop	esi

; 588  : 			}
; 589  : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN4@setbuf:
	pop	edi

; 581  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 582  : 			(size_t)_Count * sizeof (_Elem)) != 0)
; 583  : 			return (0);	// failed

	xor	eax, eax
	pop	esi

; 588  : 			}
; 589  : 		}

	pop	ebp
	ret	12					; 0000000cH
?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Fileposition$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 561  : 		{	// change position to _Pos

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 562  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);

	mov	eax, DWORD PTR __Pos$[ebp+8]
	push	ebx

; 563  : 		off_type _Off = static_cast<off_type>(_Pos) - static_cast<off_type>(_Fileposition);

	mov	ebx, DWORD PTR __Pos$[ebp+4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __Fileposition$[ebp], eax
	mov	eax, DWORD PTR __Pos$[ebp+12]
	push	edi
	mov	edi, DWORD PTR __Pos$[ebp]

; 564  : 
; 565  : 		if (_Myfile == 0 || !_Endwrite()
; 566  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 567  : 			|| (_Off != 0 && _fseeki64(_Myfile, _Off, SEEK_CUR) != 0)
; 568  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

	cmp	DWORD PTR [esi+76], 0
	mov	DWORD PTR __Fileposition$[ebp+4], eax
	je	SHORT $LN3@seekpos
	call	?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
	test	al, al
	je	SHORT $LN3@seekpos
	lea	eax, DWORD PTR __Fileposition$[ebp]
	push	eax
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fsetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@seekpos
	mov	eax, edi
	or	eax, ebx
	je	SHORT $LN4@seekpos
	push	1
	push	ebx
	push	edi
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp___fseeki64
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN3@seekpos
$LN4@seekpos:
	lea	eax, DWORD PTR __Fileposition$[ebp]
	push	eax
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fgetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@seekpos

; 570  : 
; 571  : 		_State = _POS_TYPE_TO_STATE(_Pos);

	mov	eax, DWORD PTR __Pos$[ebp+16]

; 572  : 
; 573  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

	mov	ecx, esi
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR __Pos$[ebp+20]
	mov	DWORD PTR [esi+68], eax
	call	?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back

; 574  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

	push	DWORD PTR __Fileposition$[ebp+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	DWORD PTR __Fileposition$[ebp]
	push	DWORD PTR [esi+68]
	push	DWORD PTR [esi+64]
	call	??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 576  : 		}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN3@seekpos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	ecx, DWORD PTR __imp_?_BADOFF@std@@3_JB
	xorps	xmm0, xmm0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 569  : 			return (pos_type(_BADOFF));	// report failure

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	movq	QWORD PTR [edx+16], xmm0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 576  : 		}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Fileposition$ = 12					; size = 8
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 539  : 		{	// change position by _Off

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 226  : 		return (*_IGnext);

	mov	edx, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 544  : 			&& _Pcvt == 0)	// not converting

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [edx], eax
	jne	SHORT $LN14@seekoff
	cmp	DWORD PTR __Way$[ebp], 1
	jne	SHORT $LN14@seekoff
	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN14@seekoff

; 545  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

	mov	edi, DWORD PTR __Off$[ebp]
	mov	ebx, DWORD PTR __Off$[ebp+4]
	add	edi, -2					; fffffffeH
	adc	ebx, -1
	jmp	SHORT $LN2@seekoff
$LN14@seekoff:
	mov	ebx, DWORD PTR __Off$[ebp+4]
	mov	edi, DWORD PTR __Off$[ebp]
$LN2@seekoff:

; 546  : 
; 547  : 		if (_Myfile == 0 || !_Endwrite()
; 548  : 			|| ((_Off != 0 || _Way != ios_base::cur)
; 549  : 				&& _fseeki64(_Myfile, _Off, _Way) != 0)
; 550  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN4@seekoff
	call	?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
	test	al, al
	je	SHORT $LN4@seekoff
	mov	eax, edi
	or	eax, ebx
	mov	eax, DWORD PTR __Way$[ebp]
	jne	SHORT $LN6@seekoff
	cmp	eax, 1
	je	SHORT $LN5@seekoff
$LN6@seekoff:
	push	eax
	push	ebx
	push	edi
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp___fseeki64
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN4@seekoff
$LN5@seekoff:
	lea	eax, DWORD PTR __Fileposition$[ebp]
	push	eax
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fgetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@seekoff

; 552  : 
; 553  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

	mov	ecx, esi
	call	?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 554  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

	mov	edx, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+68]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

	mov	ecx, DWORD PTR __Fileposition$[ebp]
	pop	edi
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Fileposition$[ebp+4]
	pop	esi
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 556  : 		}

	pop	ebp
	ret	20					; 00000014H
$LN4@seekoff:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	ecx, DWORD PTR __imp_?_BADOFF@std@@3_JB
	xorps	xmm0, xmm0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 551  : 			return (pos_type(_BADOFF));	// report failure

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	movq	QWORD PTR [edx+16], xmm0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 556  : 		}

	pop	ebp
	ret	20					; 00000014H
?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
__Str$2 = -48						; size = 24
__Dest$3 = -24						; size = 4
__Src$4 = -20						; size = 4
__Ch$5 = -16						; size = 2
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::uflow, COMDAT
; _this$ = ecx

; 472  : 		{	// get an element from stream, point past it

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 226  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 474  : 			&& _Mysb::gptr() < _Mysb::egptr())

	test	ecx, ecx
	je	SHORT $LN10@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

	mov	edx, DWORD PTR [edi+44]
	mov	esi, DWORD PTR [edx]
	lea	eax, DWORD PTR [ecx+esi*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 474  : 			&& _Mysb::gptr() < _Mysb::egptr())

	cmp	ecx, eax
	jae	SHORT $LN10@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 270  : 		--*_IGcount;

	lea	eax, DWORD PTR [esi-1]
	mov	DWORD PTR [edx], eax

; 271  : 		return ((*_IGnext)++);

	mov	edx, DWORD PTR [edi+28]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 475  : 			return (_Traits::to_int_type(

	mov	ax, WORD PTR [eax]

; 533  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@uflow:

; 476  : 				*_Mysb::_Gninc()));	// return buffered
; 477  : 		else if (_Myfile == 0)

	cmp	DWORD PTR [edi+76], 0
	jne	SHORT $LN12@uflow

; 478  : 			return (_Traits::eof());	// no open C stream, fail

	pop	edi
	mov	eax, 65535				; 0000ffffH
	pop	esi

; 533  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 221  : 		return (*_IGfirst);

	mov	esi, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 700  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [edi+60]
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN44@uflow

; 701  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR [edi+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [edi+28]
	sar	edx, 1
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax], edx
$LN44@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 480  : 		if (_Pcvt == 0)

	cmp	DWORD PTR [edi+56], 0
	jne	SHORT $LN13@uflow

; 51   : 	if ((_Meta = _CSTD fgetwc(_File)) == WEOF)

	push	DWORD PTR [edi+76]
	call	DWORD PTR __imp__fgetwc
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	add	esp, 4
	cmp	ax, cx
	jne	$LN14@uflow
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 361  : 		return (WEOF);

	mov	eax, ecx
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 533  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@uflow:
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Str$2[ebp+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$2[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR __Str$2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 495  : 				int _Meta = fgetc(_Myfile);

	push	DWORD PTR [edi+76]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR __imp__fgetc
	mov	ebx, eax
	add	esp, 4

; 496  : 
; 497  : 				if (_Meta == EOF)

	cmp	ebx, -1
	je	$LN500@uflow
	npad	7
$LL2@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2349 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR __Str$2[ebp+16]
	or	ecx, -1
	sub	ecx, edx
	cmp	ecx, 1
	jbe	$LN501@uflow

; 2352 : 			}
; 2353 : 
; 2354 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	esi, DWORD PTR [edx+1]

; 3573 : 		if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $LN106@uflow

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$2[ebp+20], 16		; 00000010H

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$2[ebp+16], esi

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	jmp	SHORT $LN205@uflow
$LN106@uflow:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	mov	ecx, DWORD PTR __Str$2[ebp+20]
	cmp	ecx, esi
	jae	SHORT $LN107@uflow

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	esi
	lea	ecx, DWORD PTR __Str$2[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Str$2[ebp+20]
	mov	edx, DWORD PTR __Str$2[ebp+16]
$LN107@uflow:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]
	cmovae	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], bl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$2[ebp+20], 16		; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$2[ebp+16], esi

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+esi], 0
$LN205@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$2[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 501  : 				switch (_Pcvt->in(_State,

	lea	eax, DWORD PTR __Dest$3[ebp]
	mov	ecx, DWORD PTR [edi+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	lea	esi, DWORD PTR __Str$2[ebp]
	cmovae	esi, DWORD PTR __Str$2[ebp]
	lea	edx, DWORD PTR __Str$2[ebp]
	cmovae	edx, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 501  : 				switch (_Pcvt->in(_State,

	push	eax
	lea	eax, DWORD PTR __Ch$5[ebp+2]
	push	eax
	lea	eax, DWORD PTR __Ch$5[ebp]
	push	eax
	lea	eax, DWORD PTR __Src$4[ebp]
	push	eax
	mov	eax, DWORD PTR __Str$2[ebp+16]
	add	eax, esi
	push	eax
	push	edx
	lea	eax, DWORD PTR [edi+64]
	push	eax
	call	DWORD PTR __imp_?in@?$codecvt@_WDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPA_W3AAPA_W@Z
	test	eax, eax
	js	$LN21@uflow
	cmp	eax, 1
	jle	SHORT $LN16@uflow
	cmp	eax, 3
	jne	$LN21@uflow

; 516  : 							(size_t)(_Src - &*_Str.begin()));
; 517  : 					break;
; 518  : 
; 519  : 				case codecvt_base::noconv:
; 520  : 					if (_Str.size() < sizeof (_Elem))

	cmp	DWORD PTR __Str$2[ebp+16], 2
	jb	SHORT $LN18@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$2[ebp+20], 16		; 00000010H

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 523  : 					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 523  : 					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),

	push	eax
	lea	eax, DWORD PTR __Ch$5[ebp]
	push	2
	push	eax
	call	_memcpy_s
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 346  : 		return (_Ch);

	movzx	eax, WORD PTR __Ch$5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 523  : 					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 346  : 		return (_Ch);

	jmp	SHORT $LN463@uflow
$LN16@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 507  : 					if (_Dest != &_Ch)

	lea	eax, DWORD PTR __Ch$5[ebp]
	cmp	DWORD PTR __Dest$3[ebp], eax
	jne	SHORT $LN503@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$2[ebp+20], 16		; 00000010H

; 1614 : 		return (_Large_string_engaged()

	lea	ecx, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 515  : 						_Str.erase((size_t)0,	// partial, discard used input

	mov	eax, DWORD PTR __Src$4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	cmovae	ecx, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 515  : 						_Str.erase((size_t)0,	// partial, discard used input

	sub	eax, ecx
	lea	ecx, DWORD PTR __Str$2[ebp]
	push	eax
	push	0
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
$LN18@uflow:

; 495  : 				int _Meta = fgetc(_Myfile);

	push	DWORD PTR [edi+76]
	call	DWORD PTR __imp__fgetc
	mov	ebx, eax
	add	esp, 4

; 496  : 
; 497  : 				if (_Meta == EOF)

	cmp	ebx, -1
	jne	$LL2@uflow
$LN500@uflow:
	mov	eax, 65535				; 0000ffffH
$LN362@uflow:
	movzx	eax, ax
$LN463@uflow:
	movzx	esi, ax
$LN466@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR __Str$2[ebp+20]
	pop	ebx
	cmp	ecx, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN472@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR __Str$2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN472@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 529  : 					return (_Traits::eof());	// conversion failed

	mov	ax, si
$LN14@uflow:

; 533  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN503@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$2[ebp+20], 16		; 00000010H

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 509  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

	mov	esi, DWORD PTR __Str$2[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 509  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

	mov	ecx, DWORD PTR __Src$4[ebp]
	sub	esi, ecx
	add	esi, eax

; 510  : 						for (; 0 < _Nleft; )

	test	esi, esi
	jle	SHORT $LN515@uflow
	mov	ebx, DWORD PTR __imp__ungetc
$LL7@uflow:

; 511  : 							ungetc(_Src[--_Nleft], _Myfile);

	push	DWORD PTR [edi+76]
	movsx	eax, BYTE PTR [esi+ecx-1]
	dec	esi
	push	eax
	call	ebx
	add	esp, 8
	test	esi, esi
	jle	SHORT $LN515@uflow

; 510  : 						for (; 0 < _Nleft; )

	mov	ecx, DWORD PTR __Src$4[ebp]
	jmp	SHORT $LL7@uflow
$LN515@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 346  : 		return (_Ch);

	movzx	eax, WORD PTR __Ch$5[ebp]
	jmp	SHORT $LN362@uflow
$LN21@uflow:

; 361  : 		return (WEOF);

	mov	esi, 65535				; 0000ffffH
	jmp	SHORT $LN466@uflow
$LN501@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2351 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN518@uflow:
$LN517@uflow:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ$0:
	lea	ecx, DWORD PTR __Str$2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ:
	mov	eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::uflow
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 457  : 		{	// get an element from stream, but don't point past it

	npad	2
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 226  : 		return (*_IGnext);

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 460  : 			&& _Mysb::gptr() < _Mysb::egptr())

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN2@underflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

	mov	edx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [edx]
	lea	edx, DWORD PTR [eax+edx*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 460  : 			&& _Mysb::gptr() < _Mysb::egptr())

	cmp	eax, edx
	jae	SHORT $LN2@underflow

; 461  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

	mov	ax, WORD PTR [eax]
	pop	esi

; 468  : 			}
; 469  : 		}

	ret	0
$LN2@underflow:

; 462  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	mov	eax, DWORD PTR [esi]
	push	edi
	call	DWORD PTR [eax+28]
	movzx	edi, ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 351  : 		return (_Left == _Right);

	mov	eax, 65535				; 0000ffffH
	cmp	ax, di
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 462  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	je	SHORT $LN24@underflow

; 463  : 			return (_Meta);	// uflow failed, return EOF
; 464  : 		else
; 465  : 			{	// get a char, don't point past it
; 466  : 			pbackfail(_Meta);

	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [edx+16]

; 467  : 			return (_Meta);

	mov	ax, di
$LN24@underflow:

; 468  : 			}
; 469  : 		}

	pop	edi
	pop	esi
	ret	0
?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 2
?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 432  : 		{	// put an element back to stream

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	esi, DWORD PTR __Meta$[ebp]
	mov	ebx, 65535				; 0000ffffH
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 226  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 221  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	DWORD PTR [eax], ecx
	jae	SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 351  : 		return (_Left == _Right);

	cmp	bx, si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 351  : 		return (_Left == _Right);

	cmp	WORD PTR [ecx-2], si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	jne	SHORT $LN2@pbackfail
$LN4@pbackfail:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 264  : 		++*_IGcount;

	mov	eax, DWORD PTR [edi+44]
	xor	ecx, ecx
	inc	DWORD PTR [eax]

; 265  : 		return (--*_IGnext);

	mov	eax, DWORD PTR [edi+28]
	pop	edi
	add	DWORD PTR [eax], -2			; fffffffeH
	cmp	si, bx
	movzx	eax, si
	pop	esi
	cmove	eax, ecx
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 454  : 	}

	pop	ebp
	ret	4
$LN2@pbackfail:

; 442  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

	mov	eax, DWORD PTR [edi+76]
	test	eax, eax
	je	SHORT $LN7@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 351  : 		return (_Left == _Right);

	cmp	bx, si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 442  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

	je	SHORT $LN7@pbackfail

; 444  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

	cmp	DWORD PTR [edi+56], 0
	jne	SHORT $LN8@pbackfail

; 122  : 	return (_CSTD ungetwc(_Wchar, _File) != WEOF);

	push	eax
	push	esi
	call	DWORD PTR __imp__ungetwc
	add	esp, 8
	cmp	ax, bx

; 444  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

	jne	SHORT $LN68@pbackfail
$LN8@pbackfail:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 226  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 446  : 		else if (_Mysb::gptr() != &_Mychar)

	lea	ecx, DWORD PTR [edi+60]
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN7@pbackfail

; 447  : 			{	// putback to _Mychar
; 448  : 			_Mychar = _Traits::to_char_type(_Meta);

	mov	WORD PTR [ecx], si

; 449  : 			_Set_back();	// switch to _Mychar buffer

	mov	ecx, edi
	call	?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Set_back
$LN68@pbackfail:

; 450  : 			return (_Meta);

	pop	edi
	mov	ax, si
	pop	esi
	pop	ebx

; 454  : 	}

	pop	ebp
	ret	4
$LN7@pbackfail:
	pop	edi
	pop	esi

; 443  : 			return (_Traits::eof());	// no open C stream or EOF, fail

	mov	ax, bx
	pop	ebx

; 454  : 	}

	pop	ebp
	ret	4
?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
__Str$2 = -48						; size = 24
__Src$3 = -24						; size = 4
__Dest$4 = -20						; size = 4
__Ch$5 = -16						; size = 2
__$EHRec$ = -12						; size = 12
__Meta$ = 8						; size = 2
?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 371  : 		{	// put an element to stream

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	mov	edx, 65535				; 0000ffffH
	push	-1
	push	__ehhandler$?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	mov	ebx, DWORD PTR __Meta$[ebp]
	push	edi
	mov	edi, ecx
	cmp	dx, bx

; 372  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	SHORT $LN7@overflow

; 373  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	pop	edi
	xor	eax, eax
	pop	ebx

; 428  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN7@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 236  : 		return (*_IPnext);

	mov	eax, DWORD PTR [edi+32]
	push	esi
	mov	ecx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 375  : 			&& _Mysb::pptr() < _Mysb::epptr())

	test	ecx, ecx
	je	SHORT $LN9@overflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

	mov	edx, DWORD PTR [edi+48]
	mov	esi, DWORD PTR [edx]
	lea	eax, DWORD PTR [ecx+esi*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 375  : 			&& _Mysb::pptr() < _Mysb::epptr())

	cmp	ecx, eax
	jae	SHORT $LN446@overflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 307  : 		--*_IPcount;

	lea	ecx, DWORD PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 378  : 			return (_Meta);

	mov	ax, bx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 307  : 		--*_IPcount;

	mov	DWORD PTR [edx], ecx

; 308  : 		return ((*_IPnext)++);

	mov	edx, DWORD PTR [edi+32]
	mov	esi, DWORD PTR [edx]
	lea	ecx, DWORD PTR [esi+2]
	mov	DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 377  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	WORD PTR [esi], bx
	pop	esi
	pop	edi
	pop	ebx

; 428  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN446@overflow:
	mov	edx, 65535				; 0000ffffH
$LN9@overflow:

; 379  : 			}
; 380  : 		else if (_Myfile == 0)

	cmp	DWORD PTR [edi+76], 0
	jne	SHORT $LN11@overflow

; 381  : 			return (_Traits::eof());	// no open C stream, fail

	pop	esi
	pop	edi
	mov	ax, dx
	pop	ebx

; 428  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN11@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 221  : 		return (*_IGfirst);

	mov	esi, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 700  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [edi+60]
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN65@overflow

; 701  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR [edi+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [edi+28]
	sar	edx, 1
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax], edx
$LN65@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 383  : 		if (_Pcvt == 0)

	cmp	DWORD PTR [edi+56], 0
	jne	SHORT $LN12@overflow

; 88   : 	return (_CSTD fputwc(_Wchar, _File) != WEOF);

	push	DWORD PTR [edi+76]
	push	ebx
	call	DWORD PTR __imp__fputwc
	mov	ecx, 65535				; 0000ffffH
	add	esp, 8
	cmp	ax, cx

; 384  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

	movzx	eax, bx
	jne	$LN448@overflow
	pop	esi
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 361  : 		return (WEOF);

	mov	eax, ecx
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 428  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 341  : 		return (_Meta);

	movzx	eax, bx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	ecx, 15					; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 341  : 		return (_Meta);

	mov	DWORD PTR __Ch$5[ebp], eax
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H
	movq	QWORD PTR __Str$2[ebp], xmm0

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$2[ebp+20], ecx

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR __Str$2[ebp]

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$2[ebp+16], 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 393  : 			string _Str(_STRING_INC, '\0');

	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN449@overflow:
	mov	esi, DWORD PTR __Str$2[ebp+20]
	lea	ebx, DWORD PTR [edi+64]
$LL2@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 395  : 				switch (_Pcvt->out(_State,

	lea	eax, DWORD PTR __Dest$4[ebp]
	push	eax
	mov	eax, DWORD PTR __Str$2[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	lea	edx, DWORD PTR __Str$2[ebp]
	cmovae	edx, DWORD PTR __Str$2[ebp]
	lea	ecx, DWORD PTR __Str$2[ebp]
	cmovae	ecx, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 395  : 				switch (_Pcvt->out(_State,

	add	eax, edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [edi+56]
	lea	eax, DWORD PTR __Src$3[ebp]
	push	eax
	lea	eax, DWORD PTR __Ch$5[ebp+2]
	push	eax
	lea	eax, DWORD PTR __Ch$5[ebp]
	push	eax
	push	ebx
	call	DWORD PTR __imp_?out@?$codecvt@_WDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PB_W1AAPB_WPAD3AAPAD@Z
	test	eax, eax
	js	$LN22@overflow
	cmp	eax, 1
	jg	$LN441@overflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	esi, DWORD PTR __Str$2[ebp+20]

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]
	mov	ecx, DWORD PTR __Str$2[ebp]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 402  : 					size_t _Count = _Dest - &*_Str.begin();

	mov	ebx, DWORD PTR __Dest$4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 402  : 					size_t _Count = _Dest - &*_Str.begin();

	sub	ebx, eax

; 403  : 					if (0 < _Count && _Count !=

	je	SHORT $LN15@overflow
	push	DWORD PTR [edi+76]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Str$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 403  : 					if (0 < _Count && _Count !=

	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 403  : 					if (0 < _Count && _Count !=

	push	1
	push	eax
	call	DWORD PTR __imp__fwrite
	mov	esi, DWORD PTR __Str$2[ebp+20]
	add	esp, 16					; 00000010H
	cmp	ebx, eax
	jne	SHORT $LN442@overflow
$LN15@overflow:

; 404  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 405  : 						return (_Traits::eof());	// write failed
; 406  : 
; 407  : 					_Wrotesome = true;	// write succeeded
; 408  : 					if (_Src != &_Ch)

	lea	eax, DWORD PTR __Ch$5[ebp]
	mov	BYTE PTR [edi+62], 1
	cmp	DWORD PTR __Src$3[ebp], eax
	jne	SHORT $LN443@overflow

; 410  : 
; 411  : 					if (0 < _Count)

	test	ebx, ebx
	lea	ebx, DWORD PTR [edi+64]
	jne	$LL2@overflow

; 412  : 						;
; 413  : 					else if (_Str.size() < 4 * _STRING_INC)

	cmp	DWORD PTR __Str$2[ebp+16], 32		; 00000020H
	jae	SHORT $LN19@overflow

; 414  : 						_Str.append(_STRING_INC, '\0');	// try with more space

	push	0
	push	8
	lea	ecx, DWORD PTR __Str$2[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 426  : 				}

	jmp	$LN449@overflow
$LN442@overflow:
	mov	eax, 65535				; 0000ffffH
	movzx	eax, ax

; 421  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

	movzx	eax, ax
	movzx	edi, ax
	jmp	SHORT $LN408@overflow
$LN19@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 361  : 		return (WEOF);

	mov	eax, 65535				; 0000ffffH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 421  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

	movzx	eax, ax
	movzx	edi, ax
	jmp	SHORT $LN408@overflow
$LN443@overflow:

; 409  : 						return (_Meta);	// converted whole element

	mov	eax, DWORD PTR __Meta$[ebp]
	movzx	eax, ax
	movzx	eax, ax

; 421  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

	movzx	eax, ax
	movzx	edi, ax
	jmp	SHORT $LN408@overflow
$LN441@overflow:

; 395  : 				switch (_Pcvt->out(_State,

	cmp	eax, 3
	jne	SHORT $LN22@overflow

; 88   : 	return (_CSTD fputwc(_Wchar, _File) != WEOF);

	push	DWORD PTR [edi+76]
	push	DWORD PTR __Ch$5[ebp]
	call	DWORD PTR __imp__fputwc
	mov	ecx, 65535				; 0000ffffH
	add	esp, 8
	cmp	ax, cx

; 421  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

	je	SHORT $LN26@overflow
	mov	eax, DWORD PTR __Meta$[ebp]
	mov	esi, DWORD PTR __Str$2[ebp+20]
	movzx	eax, ax
	movzx	eax, ax
	movzx	edi, ax
	jmp	SHORT $LN408@overflow
$LN26@overflow:
	mov	esi, DWORD PTR __Str$2[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 361  : 		return (WEOF);

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 421  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

	movzx	eax, ax
	movzx	edi, ax
	jmp	SHORT $LN408@overflow
$LN22@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 361  : 		return (WEOF);

	mov	esi, DWORD PTR __Str$2[ebp+20]
	mov	edi, 65535				; 0000ffffH
$LN408@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN414@overflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR __Str$2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN414@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 425  : 					return (_Traits::eof());	// conversion failed

	mov	ax, di
$LN448@overflow:

; 428  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z$0:
	lea	ecx, DWORD PTR __Str$2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z:
	mov	eax, OFFSET __ehfuncinfo$?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::overflow
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Unlock, COMDAT
; _this$ = ecx

; 364  : 		if (_Myfile)

	mov	eax, DWORD PTR [ecx+76]
	test	eax, eax
	je	SHORT $LN2@Unlock

; 365  : 			_CSTD _unlock_file(_Myfile);

	push	eax
	call	DWORD PTR __imp___unlock_file
	pop	ecx
$LN2@Unlock:

; 366  : 		}

	ret	0
?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Lock, COMDAT
; _this$ = ecx

; 358  : 		if (_Myfile)

	mov	eax, DWORD PTR [ecx+76]
	test	eax, eax
	je	SHORT $LN2@Lock

; 359  : 			_CSTD _lock_file(_Myfile);

	push	eax
	call	DWORD PTR __imp___lock_file
	pop	ecx
$LN2@Lock:

; 360  : 		}

	ret	0
?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close, COMDAT
; _this$ = ecx

; 341  : 		{	// close the C stream

	npad	2
	push	esi
	mov	esi, ecx
	push	edi

; 342  : 		_Myt *_Ans = this;
; 343  : 		if (_Myfile == 0)

	cmp	DWORD PTR [esi+76], 0
	jne	SHORT $LN2@close

; 344  : 			_Ans = 0;

	xor	edi, edi

; 345  : 		else

	jmp	SHORT $LN5@close
$LN2@close:

; 346  : 			{	// put any homing sequence and close file
; 347  : 			if (!_Endwrite())

	call	?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite

; 348  : 				_Ans = 0;
; 349  : 			if (fclose(_Myfile) != 0)

	push	DWORD PTR [esi+76]
	xor	ecx, ecx
	mov	edi, esi
	test	al, al
	cmove	edi, ecx
	call	DWORD PTR __imp__fclose
	xor	ecx, ecx
	add	esp, 4
	test	eax, eax
	cmovne	edi, ecx
$LN5@close:

; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 0
	mov	BYTE PTR [esi+62], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 618  : 			{	// point inside C stream with [first, first + count) buffer
; 619  : 			_Elem **_Pb = 0;
; 620  : 			_Elem **_Pn = 0;
; 621  : 			int *_Nr = 0;
; 622  : 
; 623  : 			::_get_stream_buffer_pointers(
; 624  : 				_File,
; 625  : 				reinterpret_cast<char***>(&_Pb),
; 626  : 				reinterpret_cast<char***>(&_Pn),
; 627  : 				&_Nr);
; 628  : 			int *_Nw = _Nr;
; 629  : 
; 630  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 631  : 			}
; 632  : 
; 633  : 		_Myfile = _File;

	mov	DWORD PTR [esi+76], 0

; 350  : 				_Ans = 0;
; 351  : 			}
; 352  : 		_Init(0, _Closefl);
; 353  : 		return (_Ans);

	mov	eax, edi

; 634  : 		_State = _Stinit;

	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], ecx
	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	pop	edi
	mov	DWORD PTR [esi+68], ecx

; 635  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0
	pop	esi

; 354  : 		}

	ret	0
?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::open, COMDAT
; _this$ = ecx

; 292  : 		{	// open a wide-named C stream -- EXTENSION

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 293  : 		_Filet *_File;
; 294  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

	cmp	DWORD PTR [esi+76], 0
	jne	$LN3@open
	push	DWORD PTR __Prot$[ebp]
	push	DWORD PTR __Mode$[ebp]
	push	DWORD PTR __Filename$[ebp]
	call	DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PB_WHH@Z
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	$LN3@open

; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 1
	mov	BYTE PTR [esi+62], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 618  : 			{	// point inside C stream with [first, first + count) buffer
; 619  : 			_Elem **_Pb = 0;
; 620  : 			_Elem **_Pn = 0;
; 621  : 			int *_Nr = 0;
; 622  : 
; 623  : 			::_get_stream_buffer_pointers(
; 624  : 				_File,
; 625  : 				reinterpret_cast<char***>(&_Pb),
; 626  : 				reinterpret_cast<char***>(&_Pn),
; 627  : 				&_Nr);
; 628  : 			int *_Nw = _Nr;
; 629  : 
; 630  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 631  : 			}
; 632  : 
; 633  : 		_Myfile = _File;

	mov	DWORD PTR [esi+76], edi

; 295  : 			return (0);	// open failed
; 296  : 
; 297  : 		_Init(_File, _Openfl);
; 298  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

	mov	ecx, esi

; 634  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+68], eax

; 295  : 			return (0);	// open failed
; 296  : 
; 297  : 		_Init(_File, _Openfl);
; 298  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

	lea	eax, DWORD PTR $T2[ebp]
	push	eax

; 635  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 295  : 			return (0);	// open failed
; 296  : 
; 297  : 		_Init(_File, _Openfl);
; 298  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

	call	DWORD PTR __imp_?getloc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QBE?AVlocale@2@XZ
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >
	add	esp, 4
	mov	edi, eax

; 681  : 		if (_Newpcvt->always_noconv())

	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN18@open

; 682  : 			_Pcvt = 0;	// nothing to do

	mov	DWORD PTR [esi+56], 0

; 683  : 		else

	jmp	SHORT $LN19@open
$LN18@open:

; 684  : 			{	// set up for nontrivial codecvt facet
; 685  : 			_Pcvt = _Newpcvt;
; 686  : 			_Mysb::_Init();	// reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ
$LN19@open:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 404  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	ecx, ecx
	je	SHORT $LN30@open

; 405  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN30@open
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN30@open:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 299  : 		return (this);	// open succeeded

	mov	eax, esi
	pop	esi

; 300  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@open:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?is_open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::is_open, COMDAT
; _this$ = ecx

; 258  : 		{	// test if C stream has been opened

	cmp	DWORD PTR [ecx+76], 0
	setne	al

; 259  : 		return (_Myfile != 0);
; 260  : 		}

	ret	0
?is_open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy the object

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx
	push	edi

; 152  : 		if (_Myfile != 0)

	cmp	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@
	je	SHORT $LN6@basic_file
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 221  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 700  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN6@basic_file

; 701  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [edi], ecx
	mov	eax, DWORD PTR [esi+28]
	sar	edx, 1
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN6@basic_file:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 154  : 		if (_Closef)

	cmp	BYTE PTR [esi+72], 0
	je	SHORT $LN3@basic_file

; 155  : 			close();

	mov	ecx, esi
	call	?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close
$LN3@basic_file:

; 156  : 		}

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__File$ = 8						; size = 4
??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::basic_filebuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 146  : 		{	// construct from pointer to C stream

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	call	DWORD PTR __imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ

; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi

; 145  : 		: _Mysb()

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 146  : 		{	// construct from pointer to C stream

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@

; 607  : 		_Closef = _Which == _Openfl;

	mov	BYTE PTR [esi+72], 0

; 608  : 		_Wrotesome = false;

	mov	BYTE PTR [esi+62], 0

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 618  : 			{	// point inside C stream with [first, first + count) buffer
; 619  : 			_Elem **_Pb = 0;
; 620  : 			_Elem **_Pn = 0;
; 621  : 			int *_Nr = 0;
; 622  : 
; 623  : 			::_get_stream_buffer_pointers(
; 624  : 				_File,
; 625  : 				reinterpret_cast<char***>(&_Pb),
; 626  : 				reinterpret_cast<char***>(&_Pn),
; 627  : 				&_Nr);
; 628  : 			int *_Nw = _Nr;
; 629  : 
; 630  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 631  : 			}
; 632  : 
; 633  : 		_Myfile = _File;

	mov	eax, DWORD PTR __File$[ebp]

; 147  : 		_Init(_File, _Newfl);
; 148  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]

; 633  : 		_Myfile = _File;

	mov	DWORD PTR [esi+76], eax

; 634  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+68], eax

; 147  : 		_Init(_File, _Newfl);
; 148  : 		}

	mov	eax, esi

; 635  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0
	pop	esi

; 147  : 		_Init(_File, _Newfl);
; 148  : 		}

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::basic_filebuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ?is_open@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::is_open, COMDAT
; _this$ = ecx

; 884  : 		{	// test if C stream has been opened

	cmp	DWORD PTR [ecx+92], 0
	setne	al

; 885  : 		return (_Filebuffer.is_open());
; 886  : 		}

	ret	0
?is_open@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 875  : 		{	// destroy the object

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi-112]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+edi-112], OFFSET ??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@
	mov	eax, DWORD PTR [edi-112]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-112]
	mov	DWORD PTR [edx+edi-116], eax

; 152  : 		if (_Myfile != 0)

	cmp	DWORD PTR [edi-20], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [edi-96], OFFSET ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@
	je	SHORT $LN9@basic_ifst
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 221  : 		return (*_IGfirst);

	mov	ebx, DWORD PTR [edi-84]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 700  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [edi-36]
	cmp	DWORD PTR [ebx], eax
	jne	SHORT $LN9@basic_ifst

; 701  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [edi-12]
	mov	ecx, DWORD PTR [edi-16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [ebx], ecx
	mov	eax, DWORD PTR [edi-68]
	sar	edx, 1
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [edi-52]
	mov	DWORD PTR [eax], edx
$LN9@basic_ifst:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 154  : 		if (_Closef)

	cmp	BYTE PTR [edi-24], 0
	je	SHORT $LN5@basic_ifst

; 155  : 			close();

	lea	ecx, DWORD PTR [edi-96]
	call	?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close
$LN5@basic_ifst:

; 156  : 		}

	lea	ecx, DWORD PTR [edi-96]
	call	DWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ

; 876  : 		}

	lea	ecx, DWORD PTR [edi-88]
	call	DWORD PTR __imp_??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Str$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
_this$ = 20						; size = 4
_$initVBases$ = 20					; size = 4
??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::basic_ifstream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 775  : 		{	// construct with wide-named file -- EXTENSION

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR $T2[ebp], 0
	cmp	DWORD PTR _$initVBases$[ebp], 0
	je	SHORT $LN2@basic_ifst
	lea	ecx, DWORD PTR [esi+112]
	mov	DWORD PTR [esi], OFFSET ??_8?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 1
$LN2@basic_ifst:

; 636  : 		}
; 637  : 
; 638  : 	bool _Endwrite()
; 639  : 		{	// put shift to initial conversion state, as needed
; 640  : 		if (_Pcvt == 0 || !_Wrotesome)
; 641  : 			return (true);
; 642  : 		else
; 643  : 			{	// may have to put
; 644  : 			const int _STRING_INC = 8;
; 645  : 			char *_Dest;
; 646  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 647  : 				return (false);
; 648  : 
; 649  : 			string _Str(_STRING_INC, '\0');
; 650  : 			for (; ; )
; 651  : 				switch (_Pcvt->unshift(_State,
; 652  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 653  : 				{	// test result of homing conversion
; 654  : 				case codecvt_base::ok:
; 655  : 					_Wrotesome = false;	// homed successfully
; 656  : 
; 657  : 				case codecvt_base::partial:	// fall through
; 658  : 					{	// put any generated bytes
; 659  : 					size_t _Count = _Dest - &*_Str.begin();
; 660  : 					if (0 < _Count && _Count !=
; 661  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 662  : 						return (false);	// write failed
; 663  : 					if (!_Wrotesome)
; 664  : 						return (true);
; 665  : 					if (_Count == 0)
; 666  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 667  : 					break;
; 668  : 					}
; 669  : 
; 670  : 				case codecvt_base::noconv:
; 671  : 					return (true);	// nothing to do
; 672  : 
; 673  : 				default:
; 674  : 					return (false);	// conversion failed
; 675  : 				}
; 676  : 			}
; 677  : 		}
; 678  : 
; 679  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 680  : 		{	// initialize codecvt pointer
; 681  : 		if (_Newpcvt->always_noconv())
; 682  : 			_Pcvt = 0;	// nothing to do
; 683  : 		else
; 684  : 			{	// set up for nontrivial codecvt facet
; 685  : 			_Pcvt = _Newpcvt;
; 686  : 			_Mysb::_Init();	// reset any buffering
; 687  : 			}
; 688  : 		}
; 689  : 
; 690  : private:
; 691  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 692  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 693  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 694  : 	typename _Traits::state_type _State;	// current conversion state
; 695  : 	bool _Closef;	// true if C stream must be closed
; 696  : 	_Filet *_Myfile;	// pointer to C stream
; 697  : 
; 698  : 	void _Reset_back()
; 699  : 		{	// restore buffer after putback
; 700  : 		if (_Mysb::eback() == &_Mychar)
; 701  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 702  : 		}
; 703  : 
; 704  : 	void _Set_back()
; 705  : 		{	// set up putback area
; 706  : 		if (_Mysb::eback() != &_Mychar)
; 707  : 			{	// save current get buffer
; 708  : 			_Set_eback = _Mysb::eback();
; 709  : 			_Set_egptr = _Mysb::egptr();
; 710  : 			}
; 711  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 712  : 		}
; 713  : 
; 714  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 715  : 	_Elem *_Set_egptr;	// saves egptr()
; 716  : 	};
; 717  : 
; 718  : 	// basic_filebuf TEMPLATE OPERATORS
; 719  : template<class _Elem,
; 720  : 	class _Traits> inline
; 721  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 722  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 723  : 	{	// swap _Left and _Right basic_filebufs
; 724  : 	_Left.swap(_Right);
; 725  : 	}
; 726  : 
; 727  : 		// TEMPLATE CLASS basic_ifstream
; 728  : template<class _Elem,
; 729  : 	class _Traits>
; 730  : 	class basic_ifstream
; 731  : 		: public basic_istream<_Elem, _Traits>
; 732  : 	{	// input stream associated with a C stream
; 733  : public:
; 734  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 735  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 736  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 737  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 738  : 
; 739  : 	basic_ifstream()
; 740  : 		: _Mybase(&_Filebuffer)
; 741  : 		{	// construct unopened
; 742  : 		}
; 743  : 
; 744  : 	explicit basic_ifstream(const char *_Filename,
; 745  : 		ios_base::openmode _Mode = ios_base::in,
; 746  : 		int _Prot = (int)ios_base::_Openprot)
; 747  : 		: _Mybase(&_Filebuffer)
; 748  : 		{	// construct with named file and specified mode
; 749  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 750  : 			_Myios::setstate(ios_base::failbit);
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_ifstream(const string& _Str,
; 754  : 		ios_base::openmode _Mode = ios_base::in,
; 755  : 		int _Prot = (int)ios_base::_Openprot)
; 756  : 		: _Mybase(&_Filebuffer)
; 757  : 		{	// construct with named file and specified mode
; 758  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
; 759  : 			_Myios::setstate(ios_base::failbit);
; 760  : 		}
; 761  : 
; 762  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 763  : 		ios_base::openmode _Mode = ios_base::in,
; 764  : 		int _Prot = (int)ios_base::_Openprot)
; 765  : 		: _Mybase(&_Filebuffer)
; 766  : 		{	// construct with wide-named file -- EXTENSION
; 767  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 768  : 			_Myios::setstate(ios_base::failbit);
; 769  : 		}
; 770  : 
; 771  : 	explicit basic_ifstream(const wstring& _Str,
; 772  : 		ios_base::openmode _Mode = ios_base::in,
; 773  : 		int _Prot = (int)ios_base::_Openprot)
; 774  : 		: _Mybase(&_Filebuffer)

	push	edi
	push	0
	push	0
	lea	edi, DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	DWORD PTR __imp_??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z

; 775  : 		{	// construct with wide-named file -- EXTENSION

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+eax], OFFSET ??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _this$[ebp], edi
	lea	eax, DWORD PTR [ecx-112]
	mov	DWORD PTR [ecx+esi-4], eax

; 145  : 		: _Mysb()

	mov	ecx, edi
	call	DWORD PTR __imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ

; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, edi

; 145  : 		: _Mysb()

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 146  : 		{	// construct from pointer to C stream

	mov	DWORD PTR [edi], OFFSET ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@

; 607  : 		_Closef = _Which == _Openfl;

	mov	BYTE PTR [edi+72], 0

; 608  : 		_Wrotesome = false;

	mov	BYTE PTR [edi+62], 0

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 618  : 			{	// point inside C stream with [first, first + count) buffer
; 619  : 			_Elem **_Pb = 0;
; 620  : 			_Elem **_Pn = 0;
; 621  : 			int *_Nr = 0;
; 622  : 
; 623  : 			::_get_stream_buffer_pointers(
; 624  : 				_File,
; 625  : 				reinterpret_cast<char***>(&_Pb),
; 626  : 				reinterpret_cast<char***>(&_Pn),
; 627  : 				&_Nr);
; 628  : 			int *_Nw = _Nr;
; 629  : 
; 630  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 631  : 			}
; 632  : 
; 633  : 		_Myfile = _File;

	mov	DWORD PTR [edi+76], 0

; 634  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [edi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [edi+68], eax

; 635  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	DWORD PTR [edi+56], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 775  : 		{	// construct with wide-named file -- EXTENSION

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN34@basic_ifst
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN34@basic_ifst:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 776  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)

	push	DWORD PTR __Prot$[ebp]
	mov	eax, DWORD PTR __Mode$[ebp]
	or	eax, 1
	push	eax
	push	ecx
	mov	ecx, edi
	call	?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PB_WHH@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::open
	pop	edi
	test	eax, eax
	jne	SHORT $LN40@basic_ifst

; 777  : 			_Myios::setstate(ios_base::failbit);

	push	eax
	mov	eax, DWORD PTR [esi]
	push	2
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
$LN40@basic_ifst:

; 778  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN6@basic_ifst
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	DWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
$LN6@basic_ifst:
	ret	0
__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	DWORD PTR __imp_??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::basic_ifstream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3802 : 	{	// return string + NTCTS

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, edx
	push	esi
	mov	DWORD PTR $T1[ebp], 0
	lea	esi, DWORD PTR [eax+2]
$LL71@operator:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL71@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR __Left$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sub	eax, esi
	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1595 : 		_Mysize(0),

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [eax], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3803 : 	return (_STD move(_Left.append(_Right)));

	mov	eax, ecx

; 3804 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xiosbase
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xiosbase
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xiosbase
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_whitelist_file$2 = -360				; size = 184
__Prs$3 = -176						; size = 84
$T4 = -92						; size = 24
$T5 = -68						; size = 24
_this$ = -44						; size = 4
_i$1$ = -40						; size = 4
_line$6 = -36						; size = 24
_regexp$7 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_wszExecutable$ = 8					; size = 4
?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z PROC		; SK_Inject_TestUserWhitelist

; 1276 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 348				; 0000015cH

; 1277 :   if (whitelist_count == 0)

	mov	eax, DWORD PTR ?whitelist_count@@3HA	; whitelist_count
	push	ebx
	push	esi
	or	esi, -1
	push	edi
	test	eax, eax
	jne	$LN257@SK_Inject_

; 1278 :   {
; 1279 :     std::wifstream whitelist_file (std::wstring (SK_GetDocumentsDir () + L"\\My Mods\\SpecialK\\Global\\whitelist.ini"));

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?SK_GetDocumentsDir@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; SK_GetDocumentsDir
	push	OFFSET $SG157374
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	esp, 16					; 00000010H
	push	1
	push	64					; 00000040H
	push	1
	push	eax
	lea	ecx, DWORD PTR _whitelist_file$2[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@HH@Z ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::basic_ifstream<wchar_t,std::char_traits<wchar_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T5[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN26@SK_Inject_

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN26@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T5[ebp+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T5[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR $T5[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN56@SK_Inject_

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN56@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream

; 259  : 		return (_Myfile != 0);

	cmp	DWORD PTR _whitelist_file$2[ebp+92], 0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1281 :     if (whitelist_file.is_open ())

	je	$LN11@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	edx, 7
	mov	DWORD PTR _line$6[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _line$6[ebp+20], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR _line$6[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xiosbase

; 314  : 		return (_Mystate);

	mov	eax, DWORD PTR _whitelist_file$2[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1283 :       std::wstring line;

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xiosbase

; 314  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR _whitelist_file$2[ebp+eax+12], 0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1285 :       while (whitelist_file.good ())

	jne	$LN504@SK_Inject_
	mov	ebx, DWORD PTR __imp__iswalpha
$LL2@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

	lea	ecx, DWORD PTR _whitelist_file$2[ebp]
	push	10					; 0000000aH
	add	ecx, eax
	call	DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
	movzx	eax, ax
	push	eax
	lea	eax, DWORD PTR _line$6[ebp]
	push	eax
	lea	eax, DWORD PTR _whitelist_file$2[ebp]
	push	eax
	call	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR _line$6[ebp+20]

; 1614 : 		return (_Large_string_engaged()

	lea	ecx, DWORD PTR _line$6[ebp]

; 2872 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));

	mov	eax, DWORD PTR _line$6[ebp+16]

; 1614 : 		return (_Large_string_engaged()

	lea	esi, DWORD PTR _line$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 1614 : 		return (_Large_string_engaged()

	cmovae	ecx, DWORD PTR _line$6[ebp]
	cmovae	esi, DWORD PTR _line$6[ebp]

; 2872 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));

	lea	edi, DWORD PTR [ecx+eax*2]

; 1330 : 		return (_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1290 :         for (const auto& it : line)

	je	SHORT $LN5@SK_Inject_
$LL6@SK_Inject_:

; 1291 :         {
; 1292 :           if (iswalpha (it))

	movzx	eax, WORD PTR [esi]
	push	eax
	call	ebx
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN480@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1246 : 		++_Ptr;

	add	esi, 2

; 1330 : 		return (_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1290 :         for (const auto& it : line)

	jne	SHORT $LL6@SK_Inject_

; 1312 :     if (std::regex_search (wszExecutable, regexp))

	jmp	SHORT $LN510@SK_Inject_
$LN480@SK_Inject_:

; 1294 :             wcsncpy ((wchar_t *)&whitelist_patterns [MAX_PATH * whitelist_count++], line.c_str (), MAX_PATH-1);

	mov	eax, DWORD PTR ?whitelist_count@@3HA	; whitelist_count
	imul	ecx, eax, 520
	inc	eax
	mov	DWORD PTR ?whitelist_count@@3HA, eax	; whitelist_count
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _line$6[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1294 :             wcsncpy ((wchar_t *)&whitelist_patterns [MAX_PATH * whitelist_count++], line.c_str (), MAX_PATH-1);

	push	259					; 00000103H
	add	ecx, OFFSET ?whitelist_patterns@@3PA_WA	; whitelist_patterns
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _line$6[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _line$6[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1294 :             wcsncpy ((wchar_t *)&whitelist_patterns [MAX_PATH * whitelist_count++], line.c_str (), MAX_PATH-1);

	push	eax
	push	ecx
	call	DWORD PTR __imp__wcsncpy
	add	esp, 12					; 0000000cH
$LN510@SK_Inject_:
	mov	edx, DWORD PTR _line$6[ebp+20]
$LN5@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xiosbase

; 314  : 		return (_Mystate);

	mov	eax, DWORD PTR _whitelist_file$2[ebp]
	mov	eax, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR _whitelist_file$2[ebp+eax+12], 0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1285 :       while (whitelist_file.good ())

	je	$LL2@SK_Inject_
	or	esi, -1
$LN504@SK_Inject_:

; 1295 :             break;
; 1296 :           }
; 1297 :         }
; 1298 :       }
; 1299 : 
; 1300 :       if (whitelist_count == 0)

	mov	eax, DWORD PTR ?whitelist_count@@3HA	; whitelist_count
	test	eax, eax
	cmove	eax, esi
	mov	DWORD PTR ?whitelist_count@@3HA, eax	; whitelist_count
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN12@SK_Inject_

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	eax, DWORD PTR [edx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR _line$6[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1304 :     else

	jmp	SHORT $LN12@SK_Inject_
$LN11@SK_Inject_:

; 1305 :       whitelist_count = -1;

	mov	DWORD PTR ?whitelist_count@@3HA, -1	; whitelist_count
$LN12@SK_Inject_:
	lea	ecx, DWORD PTR _whitelist_file$2[ebp+112]

; 1306 :   }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >
	lea	ecx, DWORD PTR _whitelist_file$2[ebp+112]
	call	DWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	mov	eax, DWORD PTR ?whitelist_count@@3HA	; whitelist_count
$LN257@SK_Inject_:

; 1308 :   for ( int i = 0; i < whitelist_count; i++ )

	mov	DWORD PTR _i$1$[ebp], 0
	test	eax, eax
	jle	$LN8@SK_Inject_
	mov	ebx, OFFSET ?whitelist_patterns@@3PA_WA	; whitelist_patterns
$LL9@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2315 : 		{	// construct from null terminated character sequence

	lea	eax, DWORD PTR _regexp$7[ebp+4]
	mov	DWORD PTR _regexp$7[ebp], 0
	mov	DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 304  : 		{	// construct from current locale

	push	1
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	call	DWORD PTR __imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z
	mov	DWORD PTR _regexp$7[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	lea	eax, DWORD PTR _regexp$7[ebp+12]

; 276  : 		{	// default construct

	mov	DWORD PTR __$EHRec$[ebp+8], 7

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	push	eax
	call	??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z ; std::use_facet<std::collate<wchar_t> >
	mov	DWORD PTR _regexp$7[ebp+4], eax

; 413  : 		_Pctype = &_USE(_Loc, ctype<_Elem>);

	lea	eax, DWORD PTR _regexp$7[ebp+12]
	push	eax
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _regexp$7[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2315 : 		{	// construct from null terminated character sequence

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edx, DWORD PTR [ecx+2]
	npad	1
$LL502@SK_Inject_:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL502@SK_Inject_
	sub	ecx, edx
	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2580 : 			_Prs(_Traits, _First, _Last, _Flags);

	push	256					; 00000100H

; 2316 : 		_Reset(_Ptr, _Ptr + _RxTraits::length(_Ptr),

	lea	eax, DWORD PTR [ebx+ecx*2]

; 2580 : 			_Prs(_Traits, _First, _Last, _Flags);

	push	eax
	push	ebx
	lea	eax, DWORD PTR _regexp$7[ebp+4]
	push	eax
	lea	ecx, DWORD PTR __Prs$3[ebp]
	call	??0?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@ABV?$regex_traits@_W@1@PB_W1W4syntax_option_type@regex_constants@1@@Z ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >

; 2581 : 		_Root_node *_Rx = _Prs._Compile();

	lea	ecx, DWORD PTR __Prs$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	call	?_Compile@?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAEPAV_Root_node@2@XZ ; std::_Parser<wchar_t const *,wchar_t,std::regex_traits<wchar_t> >::_Compile
	mov	edi, eax

; 2587 : 		if (_Rx != 0)

	test	edi, edi
	je	SHORT $LN282@SK_Inject_

; 2588 : 			_MT_INCR(reinterpret_cast<_Atomic_counter_t&>(_Rx->_Refs));

	lock	 inc	 DWORD PTR [edi+32]
$LN282@SK_Inject_:

; 2555 : 		if (_Rep != 0 && _MT_DECR(

	mov	ecx, DWORD PTR _regexp$7[ebp]
	test	ecx, ecx
	je	SHORT $LN505@SK_Inject_
	mov	eax, esi
	lock	 xadd	 DWORD PTR [ecx+32], eax
	jne	SHORT $LN505@SK_Inject_

; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);

	mov	esi, DWORD PTR _regexp$7[ebp]

; 1694 : 	while (_Nx != _Ne && _Nx != 0)

	test	esi, esi
	je	SHORT $LN505@SK_Inject_
$LN512@SK_Inject_:

; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;

	mov	ecx, esi

; 1697 : 		_Nx = _Nx->_Next;

	lea	eax, DWORD PTR [esi+12]
	mov	esi, DWORD PTR [eax]

; 1698 : 		_Tmp->_Next = 0;

	mov	DWORD PTR [eax], 0

; 1699 : 		delete _Tmp;

	push	1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	test	esi, esi
	jne	SHORT $LN512@SK_Inject_
$LN505@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR __Prs$3[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2590 : 		_Rep = _Rx;

	mov	DWORD PTR _regexp$7[ebp], edi

; 2583 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN308@SK_Inject_

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR __Prs$3[ebp+28]
	sub	eax, ecx
	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	ja	$LN485@SK_Inject_

; 99   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN376@SK_Inject_

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN485@SK_Inject_

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN485@SK_Inject_

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN485@SK_Inject_

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN485@SK_Inject_

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN376@SK_Inject_:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR __Prs$3[ebp+20], 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR __Prs$3[ebp+24], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR __Prs$3[ebp+28], 0
$LN308@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	esi, DWORD PTR _wszExecutable$[ebp]
	mov	ecx, esi
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1310 :     std::wregex regexp ((wchar_t *)&whitelist_patterns [MAX_PATH * i], std::regex_constants::icase);

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edx, DWORD PTR [ecx+2]
$LL503@SK_Inject_:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL503@SK_Inject_
	sub	ecx, edx
	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2934 : 	return (_Regex_search1(_Str, _Last,

	push	esi
	push	16					; 00000010H
	lea	eax, DWORD PTR [esi+ecx*2]
	lea	ecx, DWORD PTR _regexp$7[ebp]
	push	ecx
	push	0
	push	eax
	push	esi
	call	??$_Regex_search1@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@_WV?$regex_traits@_W@2@PB_W@std@@YA_NPB_W0PAV?$match_results@PB_WV?$allocator@V?$sub_match@PB_W@std@@@std@@@0@ABV?$basic_regex@_WV?$regex_traits@_W@std@@@0@W4match_flag_type@regex_constants@0@0@Z ; std::_Regex_search1<wchar_t const *,std::allocator<std::sub_match<wchar_t const *> >,wchar_t,std::regex_traits<wchar_t>,wchar_t const *>
	add	esp, 24					; 00000018H
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1312 :     if (std::regex_search (wszExecutable, regexp))

	test	al, al
	jne	$LN486@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2555 : 		if (_Rep != 0 && _MT_DECR(

	mov	ecx, DWORD PTR _regexp$7[ebp]
	test	ecx, ecx
	je	SHORT $LN506@SK_Inject_
	or	edx, -1
	mov	eax, edx
	lock	 xadd	 DWORD PTR [ecx+32], eax
	jne	SHORT $LN506@SK_Inject_

; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);

	mov	esi, DWORD PTR _regexp$7[ebp]

; 1694 : 	while (_Nx != _Ne && _Nx != 0)

	test	esi, esi
	je	SHORT $LN506@SK_Inject_
$LN514@SK_Inject_:

; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;

	mov	ecx, esi

; 1697 : 		_Nx = _Nx->_Next;

	lea	eax, DWORD PTR [esi+12]
	mov	esi, DWORD PTR [eax]

; 1698 : 		_Tmp->_Next = 0;

	mov	DWORD PTR [eax], 0

; 1699 : 		delete _Tmp;

	push	1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	test	esi, esi
	jne	SHORT $LN514@SK_Inject_
$LN506@SK_Inject_:

; 2558 : 		_Rep = 0;

	mov	DWORD PTR _regexp$7[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 404  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR _regexp$7[ebp+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	ecx, ecx
	je	SHORT $LN471@SK_Inject_

; 405  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN471@SK_Inject_
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN471@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1308 :   for ( int i = 0; i < whitelist_count; i++ )

	mov	esi, DWORD PTR _i$1$[ebp]
	add	ebx, 520				; 00000208H
	inc	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 406  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1308 :   for ( int i = 0; i < whitelist_count; i++ )

	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR ?whitelist_count@@3HA	; whitelist_count
	jge	$LN8@SK_Inject_
	or	esi, -1
	jmp	$LL9@SK_Inject_
$LN485@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN517@SK_Inject_:
$LN486@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 2555 : 		if (_Rep != 0 && _MT_DECR(

	mov	eax, DWORD PTR _regexp$7[ebp]
	test	eax, eax
	je	SHORT $LN507@SK_Inject_
	or	edx, -1
	lock	 xadd	 DWORD PTR [eax+32], edx
	dec	edx
	jne	SHORT $LN507@SK_Inject_

; 2556 : 			reinterpret_cast<_Atomic_counter_t&>(_Rep->_Refs)) == 0)
; 2557 : 			_Destroy_node(_Rep);

	mov	esi, DWORD PTR _regexp$7[ebp]

; 1694 : 	while (_Nx != _Ne && _Nx != 0)

	test	esi, esi
	je	SHORT $LN507@SK_Inject_
$LN516@SK_Inject_:

; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;

	mov	ecx, esi

; 1697 : 		_Nx = _Nx->_Next;

	lea	eax, DWORD PTR [esi+12]
	mov	esi, DWORD PTR [eax]

; 1698 : 		_Tmp->_Next = 0;

	mov	DWORD PTR [eax], 0

; 1699 : 		delete _Tmp;

	push	1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	test	esi, esi
	jne	SHORT $LN516@SK_Inject_
$LN507@SK_Inject_:

; 2558 : 		_Rep = 0;

	mov	DWORD PTR _regexp$7[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 404  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR _regexp$7[ebp+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	ecx, ecx
	je	SHORT $LN447@SK_Inject_

; 405  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN447@SK_Inject_
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN447@SK_Inject_:
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1314 :       return true;

	mov	al, 1
	pop	ebx

; 1315 :     }
; 1316 :   }
; 1317 : 
; 1318 :   return false;
; 1319 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SK_Inject_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	al, al
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN509@SK_Inject_:
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$1:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$2:
	lea	ecx, DWORD PTR _whitelist_file$2[ebp]
	jmp	??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$3:
	lea	ecx, DWORD PTR _line$6[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$51:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$49:
	lea	ecx, DWORD PTR _regexp$7[ebp+4]
	jmp	??1?$regex_traits@_W@std@@QAE@XZ
__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$54:
	lea	ecx, DWORD PTR __Prs$3[ebp]
	jmp	??1?$_Parser@PB_W_WV?$regex_traits@_W@std@@@std@@QAE@XZ
__unwindfunclet$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z$4:
	lea	ecx, DWORD PTR _regexp$7[ebp]
	jmp	??1?$basic_regex@_WV?$regex_traits@_W@std@@@std@@QAE@XZ ; std::basic_regex<wchar_t,std::regex_traits<wchar_t> >::~basic_regex<wchar_t,std::regex_traits<wchar_t> >
__ehhandler$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_Inject_TestUserWhitelist@@YA_NPB_W@Z ENDP		; SK_Inject_TestUserWhitelist
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z
_TEXT	SEGMENT
__Nx$ = 8						; size = 4
__Ne$ = 12						; size = 4
__Outer_rep$ = 16					; size = 4
?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z PROC ; std::_Calculate_loop_simplicity, COMDAT

; 5651 : 	{	// walks regex NFA, calculates values of _Node_rep::_Simple_loop

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 5652 : 	for (; _Nx != _Ne && _Nx != 0; _Nx = _Nx->_Next)

	mov	edi, DWORD PTR __Nx$[ebp]
	cmp	edi, DWORD PTR __Ne$[ebp]
	je	$LN30@Calculate_
	push	ebx
	mov	ebx, DWORD PTR __Outer_rep$[ebp]
	push	esi
$LL4@Calculate_:
	test	edi, edi
	je	$LN32@Calculate_

; 5653 : 		{
; 5654 : 		switch (_Nx->_Kind)

	mov	eax, DWORD PTR [edi+4]
	add	eax, -10				; fffffff6H
	cmp	eax, 9
	ja	SHORT $LN2@Calculate_
	movzx	eax, BYTE PTR $LN29@Calculate_[eax]
	jmp	DWORD PTR $LN34@Calculate_[eax*4]
$LN10@Calculate_:

; 5655 : 			{
; 5656 : 			case _N_if:
; 5657 : 				// _Node_if inside a _Node_rep makes the rep not simple
; 5658 : 				if (_Outer_rep != 0)

	test	ebx, ebx
	je	SHORT $LN11@Calculate_

; 5659 : 					_Outer_rep->_Simple_loop = 0;

	mov	DWORD PTR [ebx+36], 0
$LN11@Calculate_:

; 5660 : 				// visit each branch of the if
; 5661 : 				for (_Node_if *_Branch = static_cast<_Node_if *>(_Nx)->_Child;

	mov	esi, DWORD PTR [edi+24]

; 5662 : 					_Branch != 0;

	test	esi, esi
	je	SHORT $LN2@Calculate_
	npad	6
$LL9@Calculate_:

; 5663 : 					_Branch = _Branch->_Child)
; 5664 : 					_Calculate_loop_simplicity(_Branch->_Next, _Branch->_Endif, _Outer_rep);

	push	ebx
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+12]
	call	?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ; std::_Calculate_loop_simplicity
	mov	esi, DWORD PTR [esi+24]
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL9@Calculate_

; 5665 : 				break;

	jmp	SHORT $LN2@Calculate_
$LN12@Calculate_:

; 5666 : 			case _N_assert:
; 5667 : 			case _N_neg_assert:
; 5668 : 				// visit the assertion body
; 5669 : 				// note _Outer_rep being reset: the assertion regex is completely independent
; 5670 : 				_Calculate_loop_simplicity(static_cast<_Node_assert *>(_Nx)->_Child, 0, 0);

	push	0
	push	0
	push	DWORD PTR [edi+20]
	call	?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ; std::_Calculate_loop_simplicity
	add	esp, 12					; 0000000cH

; 5671 : 				break;

	jmp	SHORT $LN2@Calculate_
$LN13@Calculate_:

; 5672 : 			case _N_rep:
; 5673 : 				// _Node_rep inside another _Node_rep makes both not simple
; 5674 : 				if (_Outer_rep == 0)

	test	ebx, ebx
	jne	SHORT $LN14@Calculate_

; 5675 : 					_Outer_rep = static_cast<_Node_rep *>(_Nx);

	mov	ebx, edi

; 5676 : 				else

	jmp	SHORT $LN2@Calculate_
$LN14@Calculate_:

; 5677 : 					{
; 5678 : 					_Outer_rep->_Simple_loop = 0;

	mov	DWORD PTR [ebx+36], 0

; 5679 : 					static_cast<_Node_rep *>(_Nx)->_Simple_loop = 0;

	mov	DWORD PTR [edi+36], 0

; 5680 : 					}
; 5681 : 				break;

	jmp	SHORT $LN2@Calculate_
$LN16@Calculate_:

; 5682 : 			case _N_end_rep:
; 5683 : 				if (_Outer_rep == static_cast<_Node_end_rep *>(_Nx)->_Begin_rep)

	cmp	ebx, DWORD PTR [edi+20]
	jne	SHORT $LN2@Calculate_

; 5684 : 					{
; 5685 : 					// if the _Node_rep is still undetermined when we reach its end, it is simple
; 5686 : #pragma warning(push)
; 5687 : #pragma warning(disable: 6011)	// Dereferencing NULL pointer
; 5688 : 					if (_Outer_rep->_Simple_loop == -1)

	cmp	DWORD PTR [ebx+36], -1
	jne	SHORT $LN18@Calculate_

; 5689 : 						_Outer_rep->_Simple_loop = 1;

	mov	DWORD PTR [ebx+36], 1
$LN18@Calculate_:

; 5690 : #pragma warning(pop)
; 5691 : 					_Outer_rep = 0;

	xor	ebx, ebx
$LN2@Calculate_:

; 5652 : 	for (; _Nx != _Ne && _Nx != 0; _Nx = _Nx->_Next)

	mov	edi, DWORD PTR [edi+12]
	cmp	edi, DWORD PTR __Ne$[ebp]
	jne	$LL4@Calculate_
$LN32@Calculate_:
	pop	esi
	pop	ebx
$LN30@Calculate_:
	pop	edi

; 5692 : 					}
; 5693 : 				break;
; 5694 : 			default:
; 5695 : 				break;
; 5696 : 			}
; 5697 : 		}
; 5698 : 	}

	pop	ebp
	ret	0
	npad	2
$LN34@Calculate_:
	DD	$LN12@Calculate_
	DD	$LN10@Calculate_
	DD	$LN13@Calculate_
	DD	$LN16@Calculate_
	DD	$LN2@Calculate_
$LN29@Calculate_:
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	2
	DB	3
?_Calculate_loop_simplicity@std@@YAXPAV_Node_base@1@0PAV_Node_rep@1@@Z ENDP ; std::_Calculate_loop_simplicity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Compat, COMDAT
; _this$ = ecx

; 1369 : 		}

	ret	4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator!=, COMDAT
; _this$ = ecx

; 1334 : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 1335 : 		return (!(*this == _Right));
; 1336 : 		}

	pop	ebp
	ret	4
??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator==, COMDAT
; _this$ = ecx

; 1328 : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 1329 : 		_Compat(_Right);
; 1330 : 		return (_Ptr == _Right._Ptr);
; 1331 : 		}

	pop	ebp
	ret	4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator++, COMDAT
; _this$ = ecx

; 1237 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1238 : 		_IDL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");
; 1239 : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 1240 : 		_IDL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was"
; 1241 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1242 : 		_IDL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize,
; 1243 : 			"cannot increment string iterator past end");
; 1244 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1245 : 
; 1246 : 		++_Ptr;

	add	DWORD PTR [ecx], 2

; 1247 : 		return (*this);

	mov	eax, ecx

; 1248 : 		}

	ret	0
??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*, COMDAT
; _this$ = ecx

; 1215 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1216 : 		_IDL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1217 : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 1218 : 		_IDL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1219 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1220 : 		const auto _Contptr = _Mycont->_Myptr();
; 1221 : 		const auto _Rawptr = _Unfancy(_Ptr);
; 1222 : 		_IDL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1223 : 			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1224 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1225 : 
; 1226 : 		_Analysis_assume_(_Ptr);
; 1227 : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 1228 : 		}

	ret	0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
; _this$ = ecx

; 1196 : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 1195 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 1197 : 		this->_Adopt(_Pstring);
; 1198 : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1215 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1216 : 		_IDL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1217 : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 1218 : 		_IDL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1219 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1220 : 		const auto _Contptr = _Mycont->_Myptr();
; 1221 : 		const auto _Rawptr = _Unfancy(_Ptr);
; 1222 : 		_IDL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1223 : 			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1224 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1225 : 
; 1226 : 		_Analysis_assume_(_Ptr);
; 1227 : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 1228 : 		}

	ret	0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1196 : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 1195 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 1197 : 		this->_Adopt(_Pstring);
; 1198 : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@ABEXPAU_Loop_vals_t@2@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@ABEXPAU_Loop_vals_t@2@0@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1996 : 		}

	ret	8
?_Orphan_range@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@ABEXPAU_Loop_vals_t@2@0@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@CAXXZ PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXQAU_Loop_vals_t@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXQAU_Loop_vals_t@2@II@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXQAU_Loop_vals_t@2@II@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 536870911				; 1fffffffH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 3

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@0@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@0@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@00@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@00@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXPAU_Loop_vals_t@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Udefault@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEPAU_Loop_vals_t@2@PAU32@I@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
$T1 = 12						; size = 1
__Count$ = 12						; size = 4
?_Udefault@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEPAU_Loop_vals_t@2@PAU32@I@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Udefault, COMDAT
; _this$ = ecx

; 1847 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAU_Loop_vals_t@std@@IV?$allocator@U_Loop_vals_t@std@@@2@@std@@YAPAU_Loop_vals_t@0@PAU10@IAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Loop_vals_t *,unsigned int,std::allocator<std::_Loop_vals_t> >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1849 : 		}

	pop	ebp
	ret	8
?_Udefault@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEPAU_Loop_vals_t@2@PAU32@I@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAEAAU_Loop_vals_t@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAEAAU_Loop_vals_t@1@I@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::operator[], COMDAT
; _this$ = ecx

; 1736 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1737 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1738 : 		if (size() <= _Pos)
; 1739 : 			{	// report error
; 1740 : 			_DEBUG_ERROR("vector subscript out of range");
; 1741 : 			}
; 1742 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1743 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1744 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1745 : 
; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]

; 1747 : 		}

	pop	ebp
	ret	4
??A?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAEAAU_Loop_vals_t@1@I@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1721 : 		}

	ret	0
?capacity@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 536870911				; 1fffffffH

; 1716 : 		}

	ret	0
?max_size@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1711 : 		}

	ret	0
?size@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?resize@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::resize, COMDAT
; _this$ = ecx

; 1490 : 		{	// trim or append value-initialized elements, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 1491 : 		auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1492 : 			{
; 1493 : 			return (_Udefault(_Dest, _Count));
; 1494 : 			};
; 1495 : 
; 1496 : 		_Resize(_Newsize, _Lambda_default);

	push	ecx
	push	DWORD PTR __Newsize$[ebp]
	call	??$_Resize@V<lambda_73aa1e031ed5205b52738960793434b5>@@@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@AAEXIV<lambda_73aa1e031ed5205b52738960793434b5>@@@Z ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::_Resize<<lambda_73aa1e031ed5205b52738960793434b5> >

; 1497 : 		}

	pop	ebp
	ret	4
?resize@?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::~vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::~vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 723  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 723  : 		}

	ret	0
??0?$vector@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >::vector<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >,std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >::_Vector_val<std::_Simple_types<std::_Loop_vals_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABQAU_Loop_vals_t@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAPAU_Loop_vals_t@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_Loop_vals_t@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 509  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 509  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@U_Loop_vals_t@std@@V?$allocator@U_Loop_vals_t@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >::_Vector_alloc<std::_Vec_base_types<std::_Loop_vals_t,std::allocator<std::_Loop_vals_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 536870911				; 1fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z ; std::allocator<std::_Loop_vals_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >::_Wrap_alloc<std::allocator<std::_Loop_vals_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@SAIABV?$allocator@U_Loop_vals_t@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@SAIABV?$allocator@U_Loop_vals_t@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Loop_vals_t> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 536870911				; 1fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U_Loop_vals_t@std@@@std@@@std@@SAIABV?$allocator@U_Loop_vals_t@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Loop_vals_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@U_Loop_vals_t@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U_Loop_vals_t@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Loop_vals_t>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 536870911				; 1fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@U_Loop_vals_t@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Loop_vals_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z PROC ; std::allocator<std::_Loop_vals_t>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 536870911				; 1fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 3

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEPAU_Loop_vals_t@2@I@Z ENDP ; std::allocator<std::_Loop_vals_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z PROC ; std::allocator<std::_Loop_vals_t>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U_Loop_vals_t@std@@@std@@QAEXPAU_Loop_vals_t@2@I@Z ENDP ; std::allocator<std::_Loop_vals_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U_Loop_vals_t@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U_Loop_vals_t@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Loop_vals_t>::allocator<std::_Loop_vals_t>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U_Loop_vals_t@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Loop_vals_t>::allocator<std::_Loop_vals_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 3233 : 		_Xlength_error("vector<bool> too long");

	push	OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Words$1$ = 8						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 3217 : 		{	// trim base vector to exact length in bits

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 3218 : 		if (max_size() < _Size)

	mov	ebx, DWORD PTR __Size$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi
	cmp	ebx, -1
	ja	SHORT $LN189@Trim

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+4]

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	lea	esi, DWORD PTR [ebx+31]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi]
	mov	edx, eax
	sub	edx, ecx

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	shr	esi, 5

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	DWORD PTR __Words$1$[ebp], esi

; 3220 : 		size_type _Words = this->_Nw(_Size);
; 3221 : 
; 3222 : 		if (_Words < this->_Myvec.size())

	cmp	esi, edx
	jae	SHORT $LN113@Trim

; 171  : 		_Ptr += _Off;

	lea	esi, DWORD PTR [ecx+esi*4]

; 1602 : 		if (_First._Ptr != _Last._Ptr)

	cmp	esi, eax
	je	SHORT $LN187@Trim
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, eax
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1607 : 			this->_Mylast() = _Newlast;

	mov	edi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [edi+4], eax
$LN187@Trim:
	mov	esi, DWORD PTR __Words$1$[ebp]
$LN113@Trim:

; 3223 : 			this->_Myvec.erase(this->_Myvec.begin() + _Words,
; 3224 : 				this->_Myvec.end());
; 3225 : 		this->_Mysize = _Size;

	mov	DWORD PTR [edi+12], ebx

; 3226 : 		_Size %= _VBITS;

	and	ebx, 31					; 0000001fH

; 3227 : 		if (0 < _Size)

	jbe	SHORT $LN4@Trim

; 3228 : 			this->_Myvec[_Words - 1] &= ((_Vbase)(1) << _Size) - 1;

	mov	eax, DWORD PTR [edi]
	mov	ecx, ebx
	lea	edx, DWORD PTR [eax+esi*4]
	mov	eax, 1
	shl	eax, cl
	dec	eax
	and	DWORD PTR [edx-4], eax
$LN4@Trim:
	pop	edi
	pop	esi
	pop	ebx

; 3229 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN189@Trim:

; 3219 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN191@Trim:
$LN188@Trim:
	int	3
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z
_TEXT	SEGMENT
$T2 = -32						; size = 8
$T3 = -24						; size = 8
$T4 = -16						; size = 8
__Oldend$5 = -16					; size = 8
$T6 = -8						; size = 8
__Where$ = 8						; size = 8
$T7 = 16						; size = 1
$T8 = 16						; size = 4
__Count$ = 16						; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 3151 : 		{	// make room to insert _Count elements at _Where

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	mov	ebx, DWORD PTR __Where$[ebp]
	push	esi

; 3151 : 		{	// make room to insert _Count elements at _Where

	mov	esi, ecx
	push	edi

; 3153 : 
; 3154 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3155 : 		if (end() < _Where)
; 3156 : 			{
; 3157 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 3158 : 			}
; 3159 : 
; 3160 : 		bool _Realloc = capacity() - size() < _Count;
; 3161 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 3162 : 
; 3163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	sub	ebx, DWORD PTR [esi]
	sar	ebx, 2
	shl	ebx, 5

; 3152 : 		size_type _Off = _Where - begin();

	add	ebx, DWORD PTR __Where$[ebp+4]

; 3153 : 
; 3154 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3155 : 		if (end() < _Where)
; 3156 : 			{
; 3157 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 3158 : 			}
; 3159 : 
; 3160 : 		bool _Realloc = capacity() - size() < _Count;
; 3161 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 3162 : 
; 3163 : 		if (_Count == 0)

	test	edi, edi
	je	$LN7@Insert_x

; 3164 : 			;
; 3165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR [esi+12]
	or	eax, -1
	sub	eax, ecx
	cmp	eax, edi
	jb	$LN125@Insert_x

; 1504 : 			};

	lea	eax, DWORD PTR $T8[ebp]

; 3167 : 		else
; 3168 : 			{	// worth doing
; 3169 : 			this->_Myvec.resize(this->_Nw(size() + _Count), 0);

	mov	DWORD PTR $T8[ebp], 0

; 1506 : 		_Resize(_Newsize, _Lambda_fill);

	push	eax

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	lea	eax, DWORD PTR [edi+31]
	add	eax, ecx

; 1506 : 		_Resize(_Newsize, _Lambda_fill);

	mov	ecx, esi
	push	esi

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	shr	eax, 5

; 1506 : 		_Resize(_Newsize, _Lambda_fill);

	push	eax
	call	??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Resize<<lambda_b34abe9eb6f8b770c54a1bf984cd7e79> >

; 2930 : 		return (size() == 0);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax

; 3170 : 			if (empty())

	jne	SHORT $LN6@Insert_x

; 3171 : 				this->_Mysize += _Count;

	mov	DWORD PTR [esi+12], edi

; 3183 : 		return (_Off);

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 3184 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN6@Insert_x:

; 3172 : 			else
; 3173 : 				{	// make room and copy down suffix
; 3174 : 				iterator _Oldend = end();

	lea	eax, DWORD PTR __Oldend$5[ebp]
	mov	ecx, esi
	push	eax
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end

; 3175 : 				this->_Mysize += _Count;

	add	DWORD PTR [esi+12], edi

; 3176 : 				_STD copy_backward(begin() + _Off, _Oldend, end());

	mov	ecx, esi

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T6[ebp], eax

; 3176 : 				_STD copy_backward(begin() + _Off, _Oldend, end());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	DWORD PTR $T6[ebp+4], 0

; 3176 : 				_STD copy_backward(begin() + _Off, _Oldend, end());

	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	push	ebx
	lea	ecx, DWORD PTR $T6[ebp]
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 866  : 	return {};

	mov	BYTE PTR $T7[ebp], 0

; 2523 : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T7[ebp]
	push	esi
	push	edi
	push	DWORD PTR __Oldend$5[ebp+4]
	push	DWORD PTR __Oldend$5[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$_Copy_backward_unchecked@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_backward_unchecked<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
	add	esp, 32					; 00000020H
$LN7@Insert_x:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 3183 : 		return (_Off);

	mov	eax, ebx
	pop	ebx

; 3184 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN125@Insert_x:

; 3166 : 			_Xlen();	// result too long

	mov	ecx, esi
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN127@Insert_x:
$LN124@Insert_x:
	int	3
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z
_TEXT	SEGMENT
__Tmp$1 = -16						; size = 8
__Tmp$2 = -16						; size = 8
_this$1$ = -8						; size = 4
__Tmp$1$ = -4						; size = 4
$T3 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Tmp$4 = 12						; size = 8
__Where$ = 12						; size = 8
__Tmp$1$ = 20						; size = 4
__Count$ = 20						; size = 4
__Val$ = 24						; size = 4
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 3144 : 		{	// insert _Count * _Val at _Where

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 3145 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	esi, DWORD PTR __Count$[ebp]
	mov	ebx, ecx
	push	edi
	push	esi
	push	DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR _this$1$[ebp], ebx
	push	DWORD PTR __Where$[ebp]
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@QAEIV?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [ebx]

; 3145 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	edi, eax

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	or	ebx, -1

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	DWORD PTR __Tmp$1$[ebp], ecx

; 2483 : 		_Mytype _Tmp = *this;

	mov	DWORD PTR __Tmp$1$[ebp], ecx
	mov	DWORD PTR __Tmp$2[ebp+4], 0

; 3146 : 		_STD fill(begin() + _Off, begin() + (_Off + _Count), _Val);

	lea	edx, DWORD PTR [edi+esi]

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	lea	esi, DWORD PTR [ebx-3]
	test	edx, edx
	jns	SHORT $LN33@Insert_n
	mov	eax, edx
	neg	eax
	je	SHORT $LN33@Insert_n

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	ecx, ebx
	mov	eax, esi
	sub	ecx, edx
	shr	ecx, 5
	shl	ecx, 2
	sub	eax, ecx
	add	DWORD PTR __Tmp$1$[ebp], eax

; 2259 : 			this->_Myoff %= _VBITS;
; 2260 : 			}
; 2261 : 		else

	jmp	SHORT $LN112@Insert_n
$LN33@Insert_n:

; 2262 : 			{	/* add non-negative increment */
; 2263 : 			this->_Myoff += _Off;
; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	ecx, DWORD PTR __Tmp$1$[ebp]
	mov	eax, edx
	shr	eax, 5
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$1$[ebp], ecx
$LN112@Insert_n:
	mov	ecx, DWORD PTR __Tmp$1$[ebp]

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH

; 2483 : 		_Mytype _Tmp = *this;

	mov	DWORD PTR __Tmp$1[ebp+4], 0

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	test	edi, edi
	jns	SHORT $LN66@Insert_n
	mov	eax, edi
	neg	eax
	je	SHORT $LN66@Insert_n

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	ecx, ebx
	sub	ecx, edi
	shr	ecx, 5
	shl	ecx, 2
	sub	esi, ecx
	mov	ecx, DWORD PTR __Tmp$1$[ebp]
	add	ecx, esi

; 2259 : 			this->_Myoff %= _VBITS;
; 2260 : 			}
; 2261 : 		else

	jmp	SHORT $LN113@Insert_n
$LN66@Insert_n:

; 2262 : 			{	/* add non-negative increment */
; 2263 : 			this->_Myoff += _Off;
; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, edi
	shr	eax, 5
	lea	ecx, DWORD PTR [ecx+eax*4]
$LN113@Insert_n:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2682 : 	return {};

	mov	BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2265 : 			this->_Myoff %= _VBITS;

	mov	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2265 : 			this->_Myoff %= _VBITS;

	and	esi, 31					; 0000001fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2265 : 			this->_Myoff %= _VBITS;

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	edx
	push	DWORD PTR __Tmp$1$[ebp]
	push	eax
	push	ecx
	call	??$_Fill_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@0AB_NU?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,bool>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2483 : 		_Mytype _Tmp = *this;

	mov	DWORD PTR __Tmp$4[ebp+4], 0

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [ecx]

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	test	edi, edi
	jns	SHORT $LN109@Insert_n
	mov	eax, edi
	neg	eax
	je	SHORT $LN109@Insert_n

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	sub	ebx, edi
	mov	eax, -4					; fffffffcH
	shr	ebx, 5
	shl	ebx, 2
	sub	eax, ebx
	add	ecx, eax

; 2484 : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3147 : 		return (begin() + _Off);
; 3148 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN109@Insert_n:

; 2484 : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	shr	edi, 5

; 2484 : 		return (_Tmp += _Off);

	mov	DWORD PTR [eax+4], esi

; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	lea	ecx, DWORD PTR [ecx+edi*4]
	pop	edi
	pop	esi

; 2484 : 		return (_Tmp += _Off);

	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3147 : 		return (begin() + _Off);
; 3148 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
$T5 = -16						; size = 8
$T6 = -12						; size = 4
$T7 = -12						; size = 1
__First$1$ = -8						; size = 4
__Last$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Tmp$8 = 12						; size = 8
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 3079 : 		{	// erase [_First, _Last)

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	xor	edx, edx

; 2883 : 		if (0 < this->_Mysize)

	or	ebx, -1

; 3079 : 		{	// erase [_First, _Last)

	mov	DWORD PTR _this$1$[ebp], edi

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [edi]
	mov	esi, ecx
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __First$1$[ebp], esi

; 2883 : 		if (0 < this->_Mysize)

	cmp	DWORD PTR [edi+12], edx
	jbe	SHORT $LN65@erase

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	mov	edx, DWORD PTR __First_arg$[ebp]
	sub	edx, ecx
	sar	edx, 2
	shl	edx, 5

; 2884 : 			_Tmp += _Where - begin();

	add	edx, DWORD PTR __First_arg$[ebp+4]

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jns	SHORT $LN64@erase
	mov	eax, edx
	neg	eax
	je	SHORT $LN64@erase

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	ecx, ebx
	mov	eax, -4					; fffffffcH
	sub	ecx, edx
	shr	ecx, 5
	shl	ecx, 2
	sub	eax, ecx

; 2259 : 			this->_Myoff %= _VBITS;
; 2260 : 			}
; 2261 : 		else

	mov	ecx, DWORD PTR $T6[ebp]
	add	esi, eax
	jmp	SHORT $LN293@erase
$LN64@erase:

; 2262 : 			{	/* add non-negative increment */
; 2263 : 			this->_Myoff += _Off;
; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, edx
	shr	eax, 5
	lea	esi, DWORD PTR [esi+eax*4]
$LN293@erase:

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	mov	DWORD PTR __First$1$[ebp], esi
$LN65@erase:

; 2883 : 		if (0 < this->_Mysize)

	mov	eax, DWORD PTR _this$1$[ebp]

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	xor	edi, edi
	mov	DWORD PTR __Last$1$[ebp], ecx

; 2883 : 		if (0 < this->_Mysize)

	cmp	DWORD PTR [eax+12], edi
	jbe	SHORT $LN128@erase

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	mov	edi, DWORD PTR __Last_arg$[ebp]
	sub	edi, ecx
	sar	edi, 2
	shl	edi, 5

; 2884 : 			_Tmp += _Where - begin();

	add	edi, DWORD PTR __Last_arg$[ebp+4]

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jns	SHORT $LN127@erase
	mov	eax, edi
	neg	eax
	je	SHORT $LN127@erase

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	ecx, ebx
	mov	eax, -4					; fffffffcH
	sub	ecx, edi
	shr	ecx, 5
	shl	ecx, 2
	sub	eax, ecx

; 2259 : 			this->_Myoff %= _VBITS;
; 2260 : 			}
; 2261 : 		else

	mov	ecx, DWORD PTR $T6[ebp]
	add	DWORD PTR __Last$1$[ebp], eax
	jmp	SHORT $LN294@erase
$LN127@erase:

; 2262 : 			{	/* add non-negative increment */
; 2263 : 			this->_Myoff += _Off;
; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	esi, DWORD PTR __Last$1$[ebp]
	mov	eax, edi
	shr	eax, 5
	lea	esi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR __Last$1$[ebp], esi
	mov	esi, DWORD PTR __First$1$[ebp]
$LN294@erase:

; 2265 : 			this->_Myoff %= _VBITS;

	and	edi, 31					; 0000001fH
$LN128@erase:

; 2304 : 		return (this->_Myptr == _Right._Myptr

	mov	eax, DWORD PTR __Last$1$[ebp]

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	sub	esi, ecx
	sar	esi, 2
	shl	esi, 5

; 3080 : 		iterator _First = _Make_iter(_First_arg);
; 3081 : 		iterator _Last = _Make_iter(_Last_arg);
; 3082 : 		size_type _Off = _First - begin();

	add	esi, edx

; 2304 : 		return (this->_Myptr == _Right._Myptr

	cmp	DWORD PTR __First$1$[ebp], eax
	jne	SHORT $LN165@erase
	cmp	edx, edi
	je	SHORT $LN2@erase
$LN165@erase:

; 2838 : 		if (0 < this->_Mysize)

	mov	ecx, DWORD PTR _this$1$[ebp]

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	xor	ebx, ebx

; 2838 : 		if (0 < this->_Mysize)

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR $T6[ebp]
	test	eax, eax
	je	SHORT $LN202@erase

; 2839 : 			_Tmp += this->_Mysize;

	mov	ebx, eax

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	test	ebx, ebx
	jns	SHORT $LN201@erase
	neg	eax
	je	SHORT $LN201@erase

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	or	ecx, -1
	mov	eax, -4					; fffffffcH
	sub	ecx, ebx
	shr	ecx, 5
	shl	ecx, 2
	sub	eax, ecx
	mov	ecx, DWORD PTR $T6[ebp]
	add	ecx, eax

; 2259 : 			this->_Myoff %= _VBITS;
; 2260 : 			}
; 2261 : 		else

	jmp	SHORT $LN295@erase
$LN201@erase:

; 2262 : 			{	/* add non-negative increment */
; 2263 : 			this->_Myoff += _Off;
; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, ebx
	shr	eax, 5
	lea	ecx, DWORD PTR [ecx+eax*4]
$LN295@erase:

; 2265 : 			this->_Myoff %= _VBITS;

	and	ebx, 31					; 0000001fH
$LN202@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 866  : 	return {};

	mov	BYTE PTR $T7[ebp], 0

; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	lea	eax, DWORD PTR $T5[ebp]
	push	DWORD PTR $T7[ebp]
	push	edx
	push	DWORD PTR __First$1$[ebp]
	push	ebx
	push	ecx
	push	edi
	push	DWORD PTR __Last$1$[ebp]
	push	eax
	call	??$_Copy_unchecked1@V?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >,std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	add	esp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	mov	eax, DWORD PTR $T5[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	shl	eax, 5

; 3083 : 
; 3084 : 		if (_First != _Last)
; 3085 : 			{	// worth doing, copy down over hole
; 3086 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 3087 : 			if (_Last < _First || end() < _Last)
; 3088 : 				{
; 3089 : 				_DEBUG_ERROR("vector<bool> erase iterator outside range");
; 3090 : 				}
; 3091 : 
; 3092 : 			iterator _Next = _STD copy(_Last, end(), _First);
; 3093 : 			size_type _Newsize = _Next - begin();
; 3094 : 			_Orphan_range(_Newsize, this->_Mysize);
; 3095 : 			_Trim(_Newsize);
; 3096 : 
; 3097 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 3098 : 			iterator _Next = _STD copy(_Last, end(), _First);
; 3099 : 			_Trim(_Next - begin());

	add	eax, DWORD PTR $T5[ebp+4]
	push	eax
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
	or	ebx, -1
$LN2@erase:

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR _this$1$[ebp]

; 2483 : 		_Mytype _Tmp = *this;

	mov	DWORD PTR __Tmp$8[ebp+4], 0

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [eax]

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	test	esi, esi
	jns	SHORT $LN289@erase
	mov	eax, esi
	neg	eax
	je	SHORT $LN289@erase

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	sub	ebx, esi
	mov	eax, -4					; fffffffcH
	shr	ebx, 5
	shl	ebx, 2
	sub	eax, ebx
	add	ecx, eax

; 2265 : 			this->_Myoff %= _VBITS;

	and	esi, 31					; 0000001fH

; 2484 : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3100 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 3101 : 			}
; 3102 : 		return (begin() + _Off);
; 3103 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN289@erase:

; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, esi
	shr	eax, 5

; 2265 : 			this->_Myoff %= _VBITS;

	and	esi, 31					; 0000001fH
	pop	edi

; 2262 : 			{	/* add non-negative increment */
; 2263 : 			this->_Myoff += _Off;
; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	lea	ecx, DWORD PTR [ecx+eax*4]

; 2484 : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+4], esi
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3100 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 3101 : 			}
; 3102 : 		return (begin() + _Off);
; 3103 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2961 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 2094 : 		_Myptr += _Myoff / _VBITS;

	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, edx

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	ecx, DWORD PTR [ecx]

; 2094 : 		_Myptr += _Myoff / _VBITS;

	shr	eax, 5

; 2095 : 		_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	lea	ecx, DWORD PTR [ecx+eax*4]

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 2962 : 		iterator _It = begin();
; 2963 : 		_It._Advance(_Off);
; 2964 : 		return (*_It);
; 2965 : 		}

	pop	ebp
	ret	8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ PROC ; std::vector<bool,std::allocator<bool> >::empty, COMDAT
; _this$ = ecx

; 2929 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+12], 0
	sete	al

; 2930 : 		return (size() == 0);
; 2931 : 		}

	ret	0
?empty@?$vector@_NV?$allocator@_N@std@@@std@@QBE_NXZ ENDP ; std::vector<bool,std::allocator<bool> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 2923 : 		const size_type _Maxsize = this->_Myvec.max_size();
; 2924 : 		return (_Maxsize < (size_type)(-1) / _VBITS

	or	eax, -1

; 2925 : 			? _Maxsize * _VBITS : (size_type)(-1));
; 2926 : 		}

	ret	0
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2918 : 		return (this->_Mysize);

	mov	eax, DWORD PTR [ecx+12]

; 2919 : 		}

	ret	0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<bool,std::allocator<bool> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 8
$T3 = -12						; size = 8
$T4 = -12						; size = 8
$T5 = -12						; size = 8
_this$1$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 1
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z PROC ; std::vector<bool,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 2909 : 		{	// determine new length, padding with _Val elements as needed

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx

; 2910 : 		if (size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[ebp]
	push	esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR _this$1$[ebp], ecx
	push	edi
	cmp	ebx, esi
	jbe	SHORT $LN75@resize

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	edi, DWORD PTR [ecx]
	xor	edx, edx

; 2838 : 		if (0 < this->_Mysize)

	test	esi, esi
	je	SHORT $LN42@resize

; 2839 : 			_Tmp += this->_Mysize;

	mov	edx, esi

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	test	edx, edx
	jns	SHORT $LN41@resize
	mov	eax, edx
	neg	eax
	je	SHORT $LN41@resize

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	or	ecx, -1
	mov	eax, -4					; fffffffcH
	sub	ecx, edx
	shr	ecx, 5
	shl	ecx, 2
	sub	eax, ecx

; 2259 : 			this->_Myoff %= _VBITS;
; 2260 : 			}
; 2261 : 		else

	mov	ecx, DWORD PTR _this$1$[ebp]
	add	edi, eax
	jmp	SHORT $LN76@resize
$LN41@resize:

; 2262 : 			{	/* add non-negative increment */
; 2263 : 			this->_Myoff += _Off;
; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, edx
	shr	eax, 5
	lea	edi, DWORD PTR [edi+eax*4]
$LN76@resize:

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
$LN42@resize:

; 2911 : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR __Val$[ebp]
	sub	ebx, esi
	push	eax
	push	ebx
	push	edx
	push	edi
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@IAB_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
	pop	edi
	pop	esi
	pop	ebx

; 2914 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN75@resize:

; 2912 : 		else if (_Newsize < size())

	jae	SHORT $LN4@resize

; 2913 : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	push	ebx
	lea	ecx, DWORD PTR $T4[ebp]

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	DWORD PTR $T4[ebp+4], 0

; 2913 : 			erase(begin() + _Newsize, end());

	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T4[ebp], eax

; 2913 : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??H?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator+
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	push	edi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
$LN4@resize:
	pop	edi
	pop	esi
	pop	ebx

; 2914 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2881 : 		{	// make iterator from const_iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 2882 : 		iterator _Tmp = begin();
; 2883 : 		if (0 < this->_Mysize)

	cmp	DWORD PTR [ecx+12], 0
	push	esi

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], 0

; 2882 : 		iterator _Tmp = begin();
; 2883 : 		if (0 < this->_Mysize)

	jbe	SHORT $LN64@Make_iter

; 2291 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, edi
	sar	edx, 2
	shl	edx, 5

; 2884 : 			_Tmp += _Where - begin();

	add	edx, DWORD PTR __Where$[ebp+4]

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jns	SHORT $LN61@Make_iter
	mov	eax, edx
	neg	eax
	je	SHORT $LN61@Make_iter

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	ecx, edx

; 2885 : 		return (_Tmp);

	mov	eax, esi

; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	not	ecx
	shr	ecx, 5
	lea	ecx, DWORD PTR [ecx*4+4]
	sub	edi, ecx

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	mov	DWORD PTR [esi], edi
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 2886 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN61@Make_iter:

; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, edx
	shr	eax, 5

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	mov	DWORD PTR [esi+4], edx
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi], eax
$LN64@Make_iter:
	pop	edi

; 2885 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2886 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@V?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 2836 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 2837 : 		iterator _Tmp = begin();
; 2838 : 		if (0 < this->_Mysize)

	mov	edx, DWORD PTR [ecx+12]
	push	esi

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], 0

; 2837 : 		iterator _Tmp = begin();
; 2838 : 		if (0 < this->_Mysize)

	test	edx, edx
	je	SHORT $LN35@end

; 2255 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jns	SHORT $LN32@end
	mov	eax, edx
	neg	eax
	je	SHORT $LN32@end

; 2256 : 			{	/* add negative increment */
; 2257 : 			this->_Myoff += _Off;
; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	ecx, edx

; 2839 : 			_Tmp += this->_Mysize;
; 2840 : 		return (_Tmp);

	mov	eax, esi

; 2258 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	not	ecx
	shr	ecx, 5
	lea	ecx, DWORD PTR [ecx*4+4]
	sub	edi, ecx

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	mov	DWORD PTR [esi], edi
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 2841 : 		}

	pop	ebp
	ret	4
$LN32@end:

; 2264 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	eax, edx
	shr	eax, 5

; 2265 : 			this->_Myoff %= _VBITS;

	and	edx, 31					; 0000001fH
	mov	DWORD PTR [esi+4], edx
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi], eax
$LN35@end:
	pop	edi

; 2839 : 			_Tmp += this->_Mysize;
; 2840 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2841 : 		}

	pop	ebp
	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 2826 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 2086 : 		: _Myptr(_Ptr), _Myoff(_Off)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 2827 : 		return (iterator(this->_Myvec.data(), this));
; 2828 : 		}

	pop	ebp
	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Right$ = 8						; size = 4
??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<bool,std::allocator<bool> >::operator=, COMDAT
; _this$ = ecx

; 2789 : 		{	// assign from _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2790 : 		if (this != _STD addressof(_Right))

	mov	edi, DWORD PTR __Right$[ebp]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN147@operator

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>

; 2791 : 			{	// different, assign it
; 2792 : 			this->_Orphan_all();
; 2793 : 
; 2794 : 			const bool _Reload = _Alty::propagate_on_container_copy_assignment::value
; 2795 : 				&& this->_Myvec._Getal() != _Right._Myvec._Getal();
; 2796 : 
; 2797 : 			if (_Reload)
; 2798 : 				{
; 2799 : 				this->_Free_proxy();
; 2800 : 				}
; 2801 : 
; 2802 : 			this->_Myvec = _Right._Myvec;
; 2803 : 
; 2804 : 			if (_Reload)
; 2805 : 				{
; 2806 : 				this->_Alloc_proxy();
; 2807 : 				}
; 2808 : 
; 2809 : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
$LN147@operator:

; 2810 : 			}
; 2811 : 
; 2812 : 		return (*this);

	pop	edi
	mov	eax, esi
	pop	esi

; 2813 : 		}

	pop	ebp
	ret	4
??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2785 : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN12@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN12@vector:
	pop	esi

; 2786 : 		}

	ret	0
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2677 : 		{	// construct by copying _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2547 : 		: _Myvec(_Right._Myvec),

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 2677 : 		{	// construct by copying _Right

	mov	edi, ecx

; 2547 : 		: _Myvec(_Right._Myvec),

	push	esi

; 2677 : 		{	// construct by copying _Right

	mov	DWORD PTR _this$[ebp], edi

; 2547 : 		: _Myvec(_Right._Myvec),

	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2548 : 			_Mysize(_Right._Mysize)

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax

; 2678 : 		}

	mov	eax, edi
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z PROC ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2665 : 		{	// construct from _Count * false, optional allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	esi, DWORD PTR __Count$[ebp]

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	lea	eax, DWORD PTR $T2[ebp]
	push	edi
	push	DWORD PTR __Al$[ebp]

; 2665 : 		{	// construct from _Count * false, optional allocator

	mov	edi, ecx

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	push	eax

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	lea	eax, DWORD PTR [esi+31]

; 2665 : 		{	// construct from _Count * false, optional allocator

	mov	DWORD PTR _this$[ebp], edi

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	shr	eax, 5

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	push	eax
	mov	DWORD PTR $T2[ebp], 0
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2541 : 		{	// construct _Count * _Val elements with allocator _Al
; 2542 : 		_Alloc_proxy();
; 2543 : 		_Mysize = 0;

	mov	DWORD PTR [edi+12], 0

; 2666 : 		_Trim(_Count);

	push	esi
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2667 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ENDP ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2655 : 		{	// construct empty vector

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp], 0
	push	eax
	lea	eax, DWORD PTR $T2[ebp]

; 2655 : 		{	// construct empty vector

	mov	esi, ecx

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	push	eax
	push	0
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2656 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi

; 2536 : 		_Mysize = 0;

	mov	DWORD PTR [esi+12], 0
	pop	esi

; 2656 : 		}

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_range@?$vector@IV?$allocator@_N@std@@@std@@ABEXPAI0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@IV?$allocator@_N@std@@@std@@ABEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1996 : 		}

	ret	8
?_Orphan_range@?$vector@IV?$allocator@_N@std@@@std@@ABEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@AAEXXZ PROC	; std::vector<unsigned int,std::allocator<bool> >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned int,std::allocator<bool> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@IV?$allocator@_N@std@@@std@@AAEXQAIII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@IV?$allocator@_N@std@@@std@@AAEXQAIII@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@IV?$allocator@_N@std@@@std@@AAEXQAIII@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Buy@?$vector@IV?$allocator@_N@std@@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@IV?$allocator@_N@std@@@std@@AAE_NI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Buy, COMDAT
; _this$ = ecx

; 1908 : 		{	// allocate array with _Newcapacity elements

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1909 : 		this->_Myfirst() = pointer();
; 1910 : 		this->_Mylast() = pointer();
; 1911 : 		this->_Myend() = pointer();
; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	mov	edi, DWORD PTR __Newcapacity$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1914 : 			{
; 1915 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN2@Buy:

; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	edi, 1073741823				; 3fffffffH
	ja	SHORT $LN104@Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1926 : 
; 1927 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN104@Buy:

; 1919 : 			{
; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlength
$LN106@Buy:
$LN103@Buy:
	int	3
?_Buy@?$vector@IV?$allocator@_N@std@@@std@@AAE_NI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@IV?$allocator@_N@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@IV?$allocator@_N@std@@@std@@ABEII@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 1073741823				; 3fffffffH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 2

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@IV?$allocator@_N@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI00@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@AAEPAIPAIIABI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
$T1 = 16						; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@AAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::_Ufill, COMDAT
; _this$ = ecx

; 1852 : 		{	// fill raw _Dest with _Count copies of _Val, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1854 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@_N@std@@@std@@AAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 1736 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1737 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1738 : 		if (size() <= _Pos)
; 1739 : 			{	// report error
; 1740 : 			_DEBUG_ERROR("vector subscript out of range");
; 1741 : 			}
; 1742 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1743 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1744 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1745 : 
; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1747 : 		}

	pop	ebp
	ret	4
??A?$vector@IV?$allocator@_N@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<bool> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1721 : 		}

	ret	0
?capacity@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1716 : 		}

	ret	0
?max_size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1711 : 		}

	ret	0
?size@?$vector@IV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<bool> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1654 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1655 : 		return (iterator(this->_Mylast(), _STD addressof(this->_Get_data())));
; 1656 : 		}

	pop	ebp
	ret	4
?end@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1644 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1645 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
; 1646 : 		}

	pop	ebp
	ret	4
?begin@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?data@?$vector@IV?$allocator@_N@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT
?data@?$vector@IV?$allocator@_N@std@@@std@@QAEPAIXZ PROC ; std::vector<unsigned int,std::allocator<bool> >::data, COMDAT
; _this$ = ecx

; 1635 : 		return (_Unfancy_maybe_null(this->_Myfirst()));

	mov	eax, DWORD PTR [ecx]

; 1636 : 		}

	ret	0
?data@?$vector@IV?$allocator@_N@std@@@std@@QAEPAIXZ ENDP ; std::vector<unsigned int,std::allocator<bool> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 1590 : 		{	// erase [_First, _Last)

	npad	2
	push	ebp
	mov	ebp, esp

; 1591 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1592 : 		if (_First._Getcont() != _STD addressof(this->_Get_data())
; 1593 : 			|| _Last._Getcont() != _STD addressof(this->_Get_data())
; 1594 : 			|| _First._Ptr < this->_Myfirst()
; 1595 : 			|| _Last._Ptr < _First._Ptr
; 1596 : 			|| this->_Mylast() < _Last._Ptr)
; 1597 : 			{
; 1598 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1599 : 			}
; 1600 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1601 : 
; 1602 : 		if (_First._Ptr != _Last._Ptr)

	mov	eax, DWORD PTR __Last$[ebp]
	push	ebx
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
	mov	ebx, ecx
	cmp	edi, eax
	je	SHORT $LN65@erase
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 42   : 		: _Ptr(_Parg)

	mov	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [esi+edi]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1607 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [ebx+4], eax

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1608 : 			}
; 1609 : 
; 1610 : 		return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));
; 1611 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN65@erase:

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	ebx

; 1608 : 			}
; 1609 : 
; 1610 : 		return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));
; 1611 : 		}

	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@IV?$allocator@_N@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 1500 : 		{	// trim or append copies of _Val, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 1501 : 		auto _Lambda_fill = [this, &_Val](pointer _Dest, const size_type _Count)
; 1502 : 			{
; 1503 : 			return (_Ufill(_Dest, _Count, _Val));
; 1504 : 			};
; 1505 : 
; 1506 : 		_Resize(_Newsize, _Lambda_fill);

	push	DWORD PTR __Val$[ebp]
	push	ecx
	push	DWORD PTR __Newsize$[ebp]
	call	??$_Resize@V<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@?$vector@IV?$allocator@_N@std@@@std@@AAEXIV<lambda_b34abe9eb6f8b770c54a1bf984cd7e79>@@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Resize<<lambda_b34abe9eb6f8b770c54a1bf984cd7e79> >

; 1507 : 		}

	pop	ebp
	ret	8
?resize@?$vector@IV?$allocator@_N@std@@@std@@QAEXIABI@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$vector@IV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Right$ = 8						; size = 4
??4?$vector@IV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::operator=, COMDAT
; _this$ = ecx

; 1414 : 		{	// assign _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 1415 : 		if (this != _STD addressof(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN132@operator

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$_Assign_range@PAI@?$vector@IV?$allocator@_N@std@@@std@@AAEXPAI0Uforward_iterator_tag@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::_Assign_range<unsigned int *>
$LN132@operator:

; 1416 : 			{	// different, assign it
; 1417 : #pragma warning(push)
; 1418 : #pragma warning(disable: 4127)	// conditional expression is constant
; 1419 : 			if (_Alty::propagate_on_container_copy_assignment::value && this->_Getal() != _Right._Getal())
; 1420 : 				{	// reload array
; 1421 : 				_Tidy();
; 1422 : 				}
; 1423 : #pragma warning(pop)
; 1424 : 
; 1425 : 			this->_Copy_alloc(_Right._Getal());
; 1426 : 
; 1427 : 			assign(_Right._Myfirst(), _Right._Mylast());
; 1428 : 			}
; 1429 : 
; 1430 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1431 : 		}

	pop	ebp
	ret	4
??4?$vector@IV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<bool> >::~vector<unsigned int,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@IV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<bool> >::~vector<unsigned int,std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 805  : 		{	// construct by copying _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR __Right$[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ebx], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [ebx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ebx+8], 0

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [edi+4]
	sub	esi, DWORD PTR [edi]
	sar	esi, 2

; 1909 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [ebx], 0

; 1910 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [ebx+4], 0

; 1911 : 		this->_Myend() = pointer();

	mov	DWORD PTR [ebx+8], 0

; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	test	esi, esi
	je	SHORT $LN5@vector

; 1914 : 			{
; 1915 : 			return (false);
; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	esi, 1073741823				; 3fffffffH
	ja	SHORT $LN220@vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	esi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [ebx], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [ebx+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [ebx]
	lea	eax, DWORD PTR [eax+esi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	DWORD PTR [ebx+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	eax, DWORD PTR [edi]

; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	edi, DWORD PTR [ebx]

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR [esi+4]
	sub	esi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [esi+edi]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 809  : 			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());

	mov	DWORD PTR [ebx+4], eax
$LN5@vector:

; 810  : 			_CATCH_ALL
; 811  : 			_Tidy();
; 812  : 			_RERAISE;
; 813  : 			_CATCH_END
; 814  : 			}
; 815  : 		}

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
$LN220@vector:

; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlength
$LN222@vector:
$LN219@vector:
	int	3
??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
__Al$ = 16						; size = 4
??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z PROC ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 746  : 		{	// construct from _Count * _Val, optional allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 1913 : 		if (_Newcapacity == 0)

	mov	edi, DWORD PTR __Count$[ebp]

; 746  : 		{	// construct from _Count * _Val, optional allocator

	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 1909 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1910 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1911 : 		this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0

; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	test	edi, edi
	je	SHORT $LN7@vector

; 1914 : 			{
; 1915 : 			return (false);
; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN23@vector

; 1919 : 			{
; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@IV?$allocator@_N@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Xlength
$LN155@vector:
$LN23@vector:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	esi
	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 749  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	edi
	push	DWORD PTR [esi]
	call	??$_Uninit_alloc_fill_n1@PAIIV?$allocator@I@std@@@std@@YAPAIPAIIABIAAU?$_Wrap_alloc@V?$allocator@I@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<unsigned int *,unsigned int,std::allocator<unsigned int> >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 750  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Val);

	mov	DWORD PTR [esi+4], eax
$LN7@vector:

; 754  : 			_CATCH_END
; 755  : 			}
; 756  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z$0:

; 751  : 			_CATCH_ALL
; 752  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@IV?$allocator@_N@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<bool> >::_Tidy

; 753  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN156@vector:
$LN154@vector:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ENDP ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z PROC	; std::_Vb_val<std::allocator<bool> >::_Nw, COMDAT

; 2612 : 		{	// return number of base words from number of bits

	npad	2
	push	ebp
	mov	ebp, esp

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 31					; 0000001fH
	shr	eax, 5

; 2614 : 		}

	pop	ebp
	ret	0
?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ENDP	; std::_Vb_val<std::allocator<bool> >::_Nw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::_Vb_val<std::allocator<bool> >::_Free_proxy, COMDAT
; _this$ = ecx

; 2588 : 		}

	ret	0
?_Free_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::_Vb_val<std::allocator<bool> >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::_Vb_val<std::allocator<bool> >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 2584 : 		}

	ret	0
?_Alloc_proxy@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::_Vb_val<std::allocator<bool> >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2577 : 		{	// destroy proxy

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN9@Vb_val

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN9@Vb_val:
	pop	esi

; 2578 : 		_Free_proxy();
; 2579 : 		}

	ret	0
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2549 : 		{	// copy construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2547 : 		: _Myvec(_Right._Myvec),

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 2549 : 		{	// copy construct

	mov	edi, ecx
	push	esi
	mov	DWORD PTR _this$[ebp], edi
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax

; 2550 : 		_Alloc_proxy();
; 2551 : 		}

	mov	eax, edi
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
$T1 = 12						; size = 4
__Val$ = 12						; size = 4
__Al$ = 16						; size = 4
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z PROC ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2541 : 		{	// construct _Count * _Val elements with allocator _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	mov	eax, DWORD PTR __Val$[ebp]
	push	esi
	push	DWORD PTR __Al$[ebp]

; 2541 : 		{	// construct _Count * _Val elements with allocator _Al

	mov	esi, ecx
	movzx	eax, BYTE PTR [eax]
	neg	eax
	mov	DWORD PTR _this$[ebp], esi
	sbb	eax, eax
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 31					; 0000001fH
	shr	eax, 5

; 2540 : 		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)

	push	eax
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2542 : 		_Alloc_proxy();
; 2543 : 		_Mysize = 0;

	mov	DWORD PTR [esi+12], 0

; 2544 : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ENDP ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_N@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
$T2 = 15						; size = 1
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_N@Z PROC ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2534 : 		{	// construct _Count * _Val elements

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	eax, DWORD PTR __Val$[ebp]
	movzx	eax, BYTE PTR [eax]
	neg	eax
	sbb	eax, eax
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax

; 2613 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 31					; 0000001fH
	shr	eax, 5

; 2533 : 		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))

	push	eax
	call	??0?$vector@IV?$allocator@_N@std@@@std@@QAE@IABIABV?$allocator@_N@1@@Z ; std::vector<unsigned int,std::allocator<bool> >::vector<unsigned int,std::allocator<bool> >

; 2535 : 		_Alloc_proxy();
; 2536 : 		_Mysize = 0;

	mov	DWORD PTR [esi+12], 0

; 2537 : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_N@Z ENDP ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned int> >,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABQAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAPAIXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@I@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@I@std@@@2@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 521  : 		_Pocca(_Getal(), _Al);
; 522  : 		}

	ret	4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@IV?$allocator@_N@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@I@std@@@2@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned int,std::allocator<bool> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::_Wrap_alloc<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned int> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 1013 : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 1014 : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1015 : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction, COMDAT

; 975  : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 976  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 977  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z PROC ; std::allocator_traits<std::allocator<unsigned int> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ENDP ; std::allocator_traits<std::allocator<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXPAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@I@std@@QAEXPAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@_N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_N@std@@QAE@XZ PROC			; std::allocator<bool>::allocator<bool>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@_N@std@@QAE@XZ ENDP			; std::allocator<bool>::allocator<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Node_rep@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_rep@std@@UAEPAXI@Z PROC			; std::_Node_rep::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN10@scalar
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_rep@std@@UAEPAXI@Z ENDP			; std::_Node_rep::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_rep@std@@UAE@XZ
_TEXT	SEGMENT
??1_Node_rep@std@@UAE@XZ PROC				; std::_Node_rep::~_Node_rep, COMDAT
; _this$ = ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	ret	0
??1_Node_rep@std@@UAE@XZ ENDP				; std::_Node_rep::~_Node_rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Greedy$ = 8						; size = 1
__Mn$ = 12						; size = 4
__Mx$ = 16						; size = 4
__End$ = 20						; size = 4
__Number$ = 24						; size = 4
??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z PROC	; std::_Node_rep::_Node_rep, COMDAT
; _this$ = ecx

; 1908 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1677 : 		{	// construct
; 1678 : 		}
; 1679 : 
; 1680 : 	_Node_type _Kind;
; 1681 : 	_Node_flags _Flags;
; 1682 : 	_Node_base *_Next;
; 1683 : 	_Node_base *_Prev;
; 1684 : 
; 1685 : 	virtual ~_Node_base() _NOEXCEPT
; 1686 : 		{	// destroy
; 1687 : 		}
; 1688 : 	};
; 1689 : 
; 1690 : 	// FUNCTION _Destroy_node
; 1691 : inline void _Destroy_node(_Node_base *_Nx,
; 1692 : 	_Node_base *_Ne = 0)
; 1693 : 	{	// destroy sublist of nodes
; 1694 : 	while (_Nx != _Ne && _Nx != 0)
; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;
; 1697 : 		_Nx = _Nx->_Next;
; 1698 : 		_Tmp->_Next = 0;
; 1699 : 		delete _Tmp;
; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	// CLASS _Root_node
; 1704 : class _Root_node
; 1705 : 	: public _Node_base
; 1706 : 	{	// root of parse tree
; 1707 : public:
; 1708 : 	_Root_node()
; 1709 : 		: _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)
; 1710 : 		{	// construct
; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)
; 1728 : 		{	// construct
; 1729 : 		}
; 1730 : 
; 1731 : 	_Node_base *_Back;
; 1732 : 	};
; 1733 : 
; 1734 : 	// CLASS _Node_assert
; 1735 : class _Node_assert
; 1736 : 	: public _Node_base
; 1737 : 	{	// node that holds an ECMAScript assertion
; 1738 : public:
; 1739 : 	_Node_assert(_Node_type _Ty, _Node_flags _Fl = _Fl_none)
; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)
; 1741 : 		{	// construct
; 1742 : 		}
; 1743 : 
; 1744 : 	~_Node_assert() _NOEXCEPT
; 1745 : 		{	// destroy branch
; 1746 : 		_Destroy_node(_Child);
; 1747 : 		}
; 1748 : 
; 1749 : 	_Node_base *_Child;
; 1750 : 	};
; 1751 : 
; 1752 : 	// TEMPLATE CLASS _Node_capture
; 1753 : class _Node_capture
; 1754 : 	: public _Node_base
; 1755 : 	{	// node that marks beginning of a capture group
; 1756 : public:
; 1757 : 	_Node_capture(unsigned int _Ix)
; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)
; 1759 : 		{	// construct
; 1760 : 		}
; 1761 : 
; 1762 : 	unsigned int _Idx;
; 1763 : 	};
; 1764 : 
; 1765 : 	// CLASS _Node_back
; 1766 : class _Node_back
; 1767 : 	: public _Node_base
; 1768 : 	{	// node that holds a back reference
; 1769 : public:
; 1770 : 	_Node_back(unsigned int _Ix)
; 1771 : 		: _Node_base(_N_back, _Fl_none), _Idx(_Ix)
; 1772 : 		{	// construct
; 1773 : 		}
; 1774 : 
; 1775 : 	unsigned int _Idx;
; 1776 : 	};
; 1777 : 
; 1778 : 	// TEMPLATE CLASS _Node_str
; 1779 : template<class _Elem>
; 1780 : 	class _Node_str
; 1781 : 		: public _Node_base
; 1782 : 	{	// node that holds text
; 1783 : public:
; 1784 : 	_Node_str(_Node_flags _Fl = _Fl_none)
; 1785 : 		: _Node_base(_N_str, _Fl)
; 1786 : 		{	// construct
; 1787 : 		}
; 1788 : 
; 1789 : 	_Buf<_Elem> _Data;
; 1790 : 	};
; 1791 : 
; 1792 : 	// TEMPLATE CLASS _Node_class
; 1793 : template<class _Elem,
; 1794 : 	class _RxTraits>
; 1795 : 	class _Node_class
; 1796 : 		: public _Node_base
; 1797 : 	{	// node that holds a character class (POSIX bracket expression)
; 1798 : public:
; 1799 : 	_Node_class(_Node_type _Ty = _N_class, _Node_flags _Fl = _Fl_none)
; 1800 : 		: _Node_base(_Ty, _Fl), _Coll(0), _Small(0), _Large(0), _Ranges(0),
; 1801 : 		_Classes((typename _RxTraits::char_class_type)0), _Equiv(0)
; 1802 : 		{	// construct
; 1803 : 		}
; 1804 : 
; 1805 : 	~_Node_class() _NOEXCEPT
; 1806 : 		{	// destroy
; 1807 : 		_Tidy(_Coll);
; 1808 : 		delete _Small;
; 1809 : 		delete _Large;
; 1810 : 		delete _Ranges;
; 1811 : 		_Tidy(_Equiv);
; 1812 : 		}
; 1813 : 
; 1814 : 	void _Tidy(_Sequence<_Elem> *_Head)
; 1815 : 		{	// clean up a list of sequences
; 1816 : 		while (_Head)
; 1817 : 			{	// delete the head of the list
; 1818 : 			_Sequence<_Elem> *_Temp = _Head;
; 1819 : 			_Head = _Head->_Next;
; 1820 : 			delete _Temp;
; 1821 : 			}
; 1822 : 		}
; 1823 : 
; 1824 : 	_Sequence<_Elem> *_Coll;
; 1825 : 	_Bitmap *_Small;
; 1826 : 	_Buf<_Elem> *_Large;
; 1827 : 	_Buf<_Elem> *_Ranges;
; 1828 : 	typename _RxTraits::char_class_type _Classes;
; 1829 : 	_Sequence<_Elem> *_Equiv;
; 1830 : 	};
; 1831 : 
; 1832 : 	// CLASS _Node_endif
; 1833 : class _Node_endif
; 1834 : 	: public _Node_base
; 1835 : 	{	// node that marks the end of an alternative
; 1836 : public:
; 1837 : 	_Node_endif()
; 1838 : 		: _Node_base(_N_endif, _Fl_none)
; 1839 : 		{	// construct
; 1840 : 		}
; 1841 : 	};
; 1842 : 
; 1843 : 	// CLASS _Node_if
; 1844 : class _Node_if
; 1845 : 	: public _Node_base
; 1846 : 	{	// node that marks the beginning of an alternative
; 1847 : public:
; 1848 : 	_Node_if(_Node_base *_End)
; 1849 : 		: _Node_base(_N_if, _Fl_none), _Endif((_Node_endif *)_End), _Child(0)
; 1850 : 		{	// construct
; 1851 : 		}
; 1852 : 
; 1853 : 	~_Node_if() _NOEXCEPT
; 1854 : 		{	// destroy branches of if node
; 1855 : 		_Node_if *_Cur = _Child;
; 1856 : 		while (_Cur)
; 1857 : 			{	// destroy branch
; 1858 : 			_Node_if *_Tmp = _Cur;
; 1859 : 			_Cur = _Cur->_Child;
; 1860 : 			_Tmp->_Child = 0;
; 1861 : 			_Destroy_node(_Tmp, _Endif);
; 1862 : 			}
; 1863 : 		}
; 1864 : 
; 1865 : 	_Node_endif *_Endif;
; 1866 : 	_Node_if *_Child;
; 1867 : 	};
; 1868 : 
; 1869 : 	// CLASS _Node_end_rep
; 1870 : class _Node_rep;
; 1871 : 
; 1872 : class _Node_end_rep
; 1873 : 	: public _Node_base
; 1874 : 	{	// node that marks the end of a repetition
; 1875 : public:
; 1876 : 	_Node_end_rep()
; 1877 : 		: _Node_base(_N_end_rep),
; 1878 : 			_Begin_rep(0)
; 1879 : 		{	// construct
; 1880 : 		}
; 1881 : 
; 1882 : 	_Node_rep *_Begin_rep;
; 1883 : 
; 1884 : private:
; 1885 : 	_Node_end_rep& operator=(const _Node_end_rep&);
; 1886 : 	};
; 1887 : 
; 1888 : 	// CLASS _Loop_vals_t
; 1889 : struct _Loop_vals_t
; 1890 : 	{	// storage for loop administration
; 1891 : 	int _Loop_idx;
; 1892 : 	void *_Loop_iter;
; 1893 : 	};
; 1894 : 
; 1895 : 	// CLASS _Node_rep
; 1896 : class _Node_rep
; 1897 : 	: public _Node_base
; 1898 : 	{	// node that marks the beginning of a repetition
; 1899 : public:
; 1900 : 	_Node_rep(bool _Greedy, int _Mn, int _Mx, _Node_end_rep *_End,
; 1901 : 		unsigned int _Number)
; 1902 : 		: _Node_base(_N_rep, _Greedy ? _Fl_greedy : _Fl_none),

	xor	eax, eax

; 1908 : 		{	// construct

	mov	DWORD PTR _this$[ebp], ecx
	cmp	BYTE PTR __Greedy$[ebp], al
	mov	edx, 2

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 18			; 00000012H

; 1677 : 		{	// construct
; 1678 : 		}
; 1679 : 
; 1680 : 	_Node_type _Kind;
; 1681 : 	_Node_flags _Flags;
; 1682 : 	_Node_base *_Next;
; 1683 : 	_Node_base *_Prev;
; 1684 : 
; 1685 : 	virtual ~_Node_base() _NOEXCEPT
; 1686 : 		{	// destroy
; 1687 : 		}
; 1688 : 	};
; 1689 : 
; 1690 : 	// FUNCTION _Destroy_node
; 1691 : inline void _Destroy_node(_Node_base *_Nx,
; 1692 : 	_Node_base *_Ne = 0)
; 1693 : 	{	// destroy sublist of nodes
; 1694 : 	while (_Nx != _Ne && _Nx != 0)
; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;
; 1697 : 		_Nx = _Nx->_Next;
; 1698 : 		_Tmp->_Next = 0;
; 1699 : 		delete _Tmp;
; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	// CLASS _Root_node
; 1704 : class _Root_node
; 1705 : 	: public _Node_base
; 1706 : 	{	// root of parse tree
; 1707 : public:
; 1708 : 	_Root_node()
; 1709 : 		: _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)
; 1710 : 		{	// construct
; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)
; 1728 : 		{	// construct
; 1729 : 		}
; 1730 : 
; 1731 : 	_Node_base *_Back;
; 1732 : 	};
; 1733 : 
; 1734 : 	// CLASS _Node_assert
; 1735 : class _Node_assert
; 1736 : 	: public _Node_base
; 1737 : 	{	// node that holds an ECMAScript assertion
; 1738 : public:
; 1739 : 	_Node_assert(_Node_type _Ty, _Node_flags _Fl = _Fl_none)
; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)
; 1741 : 		{	// construct
; 1742 : 		}
; 1743 : 
; 1744 : 	~_Node_assert() _NOEXCEPT
; 1745 : 		{	// destroy branch
; 1746 : 		_Destroy_node(_Child);
; 1747 : 		}
; 1748 : 
; 1749 : 	_Node_base *_Child;
; 1750 : 	};
; 1751 : 
; 1752 : 	// TEMPLATE CLASS _Node_capture
; 1753 : class _Node_capture
; 1754 : 	: public _Node_base
; 1755 : 	{	// node that marks beginning of a capture group
; 1756 : public:
; 1757 : 	_Node_capture(unsigned int _Ix)
; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)
; 1759 : 		{	// construct
; 1760 : 		}
; 1761 : 
; 1762 : 	unsigned int _Idx;
; 1763 : 	};
; 1764 : 
; 1765 : 	// CLASS _Node_back
; 1766 : class _Node_back
; 1767 : 	: public _Node_base
; 1768 : 	{	// node that holds a back reference
; 1769 : public:
; 1770 : 	_Node_back(unsigned int _Ix)
; 1771 : 		: _Node_base(_N_back, _Fl_none), _Idx(_Ix)
; 1772 : 		{	// construct
; 1773 : 		}
; 1774 : 
; 1775 : 	unsigned int _Idx;
; 1776 : 	};
; 1777 : 
; 1778 : 	// TEMPLATE CLASS _Node_str
; 1779 : template<class _Elem>
; 1780 : 	class _Node_str
; 1781 : 		: public _Node_base
; 1782 : 	{	// node that holds text
; 1783 : public:
; 1784 : 	_Node_str(_Node_flags _Fl = _Fl_none)
; 1785 : 		: _Node_base(_N_str, _Fl)
; 1786 : 		{	// construct
; 1787 : 		}
; 1788 : 
; 1789 : 	_Buf<_Elem> _Data;
; 1790 : 	};
; 1791 : 
; 1792 : 	// TEMPLATE CLASS _Node_class
; 1793 : template<class _Elem,
; 1794 : 	class _RxTraits>
; 1795 : 	class _Node_class
; 1796 : 		: public _Node_base
; 1797 : 	{	// node that holds a character class (POSIX bracket expression)
; 1798 : public:
; 1799 : 	_Node_class(_Node_type _Ty = _N_class, _Node_flags _Fl = _Fl_none)
; 1800 : 		: _Node_base(_Ty, _Fl), _Coll(0), _Small(0), _Large(0), _Ranges(0),
; 1801 : 		_Classes((typename _RxTraits::char_class_type)0), _Equiv(0)
; 1802 : 		{	// construct
; 1803 : 		}
; 1804 : 
; 1805 : 	~_Node_class() _NOEXCEPT
; 1806 : 		{	// destroy
; 1807 : 		_Tidy(_Coll);
; 1808 : 		delete _Small;
; 1809 : 		delete _Large;
; 1810 : 		delete _Ranges;
; 1811 : 		_Tidy(_Equiv);
; 1812 : 		}
; 1813 : 
; 1814 : 	void _Tidy(_Sequence<_Elem> *_Head)
; 1815 : 		{	// clean up a list of sequences
; 1816 : 		while (_Head)
; 1817 : 			{	// delete the head of the list
; 1818 : 			_Sequence<_Elem> *_Temp = _Head;
; 1819 : 			_Head = _Head->_Next;
; 1820 : 			delete _Temp;
; 1821 : 			}
; 1822 : 		}
; 1823 : 
; 1824 : 	_Sequence<_Elem> *_Coll;
; 1825 : 	_Bitmap *_Small;
; 1826 : 	_Buf<_Elem> *_Large;
; 1827 : 	_Buf<_Elem> *_Ranges;
; 1828 : 	typename _RxTraits::char_class_type _Classes;
; 1829 : 	_Sequence<_Elem> *_Equiv;
; 1830 : 	};
; 1831 : 
; 1832 : 	// CLASS _Node_endif
; 1833 : class _Node_endif
; 1834 : 	: public _Node_base
; 1835 : 	{	// node that marks the end of an alternative
; 1836 : public:
; 1837 : 	_Node_endif()
; 1838 : 		: _Node_base(_N_endif, _Fl_none)
; 1839 : 		{	// construct
; 1840 : 		}
; 1841 : 	};
; 1842 : 
; 1843 : 	// CLASS _Node_if
; 1844 : class _Node_if
; 1845 : 	: public _Node_base
; 1846 : 	{	// node that marks the beginning of an alternative
; 1847 : public:
; 1848 : 	_Node_if(_Node_base *_End)
; 1849 : 		: _Node_base(_N_if, _Fl_none), _Endif((_Node_endif *)_End), _Child(0)
; 1850 : 		{	// construct
; 1851 : 		}
; 1852 : 
; 1853 : 	~_Node_if() _NOEXCEPT
; 1854 : 		{	// destroy branches of if node
; 1855 : 		_Node_if *_Cur = _Child;
; 1856 : 		while (_Cur)
; 1857 : 			{	// destroy branch
; 1858 : 			_Node_if *_Tmp = _Cur;
; 1859 : 			_Cur = _Cur->_Child;
; 1860 : 			_Tmp->_Child = 0;
; 1861 : 			_Destroy_node(_Tmp, _Endif);
; 1862 : 			}
; 1863 : 		}
; 1864 : 
; 1865 : 	_Node_endif *_Endif;
; 1866 : 	_Node_if *_Child;
; 1867 : 	};
; 1868 : 
; 1869 : 	// CLASS _Node_end_rep
; 1870 : class _Node_rep;
; 1871 : 
; 1872 : class _Node_end_rep
; 1873 : 	: public _Node_base
; 1874 : 	{	// node that marks the end of a repetition
; 1875 : public:
; 1876 : 	_Node_end_rep()
; 1877 : 		: _Node_base(_N_end_rep),
; 1878 : 			_Begin_rep(0)
; 1879 : 		{	// construct
; 1880 : 		}
; 1881 : 
; 1882 : 	_Node_rep *_Begin_rep;
; 1883 : 
; 1884 : private:
; 1885 : 	_Node_end_rep& operator=(const _Node_end_rep&);
; 1886 : 	};
; 1887 : 
; 1888 : 	// CLASS _Loop_vals_t
; 1889 : struct _Loop_vals_t
; 1890 : 	{	// storage for loop administration
; 1891 : 	int _Loop_idx;
; 1892 : 	void *_Loop_iter;
; 1893 : 	};
; 1894 : 
; 1895 : 	// CLASS _Node_rep
; 1896 : class _Node_rep
; 1897 : 	: public _Node_base
; 1898 : 	{	// node that marks the beginning of a repetition
; 1899 : public:
; 1900 : 	_Node_rep(bool _Greedy, int _Mn, int _Mx, _Node_end_rep *_End,
; 1901 : 		unsigned int _Number)
; 1902 : 		: _Node_base(_N_rep, _Greedy ? _Fl_greedy : _Fl_none),

	cmovne	eax, edx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], eax

; 1903 : 			_Min(_Mn),

	mov	eax, DWORD PTR __Mn$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1904 : 			_Max(_Mx),

	mov	eax, DWORD PTR __Mx$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1905 : 			_End_rep(_End),

	mov	eax, DWORD PTR __End$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1906 : 			_Loop_number(_Number),

	mov	eax, DWORD PTR __Number$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1909 : 		}

	mov	eax, ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+16], 0

; 1908 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_rep@std@@6B@
	mov	DWORD PTR [ecx+36], -1

; 1909 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node_rep@std@@QAE@_NHHPAV_Node_end_rep@1@I@Z ENDP	; std::_Node_rep::_Node_rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Node_end_rep@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_end_rep@std@@UAEPAXI@Z PROC			; std::_Node_end_rep::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN10@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_end_rep@std@@UAEPAXI@Z ENDP			; std::_Node_end_rep::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_end_rep@std@@UAE@XZ
_TEXT	SEGMENT
??1_Node_end_rep@std@@UAE@XZ PROC			; std::_Node_end_rep::~_Node_end_rep, COMDAT
; _this$ = ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	ret	0
??1_Node_end_rep@std@@UAE@XZ ENDP			; std::_Node_end_rep::~_Node_end_rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_end_rep@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Node_end_rep@std@@QAE@XZ PROC			; std::_Node_end_rep::_Node_end_rep, COMDAT
; _this$ = ecx

; 1879 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1880 : 		}

	mov	eax, ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 19			; 00000013H
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1879 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_end_rep@std@@6B@
	mov	DWORD PTR [ecx+20], 0

; 1880 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??0_Node_end_rep@std@@QAE@XZ ENDP			; std::_Node_end_rep::_Node_end_rep
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Node_if@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_if@std@@UAEPAXI@Z PROC			; std::_Node_if::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1_Node_if@std@@UAE@XZ			; std::_Node_if::~_Node_if
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	28					; 0000001cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_if@std@@UAEPAXI@Z ENDP			; std::_Node_if::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_if@std@@UAE@XZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
??1_Node_if@std@@UAE@XZ PROC				; std::_Node_if::~_Node_if, COMDAT
; _this$ = ecx

; 1854 : 		{	// destroy branches of if node

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi

; 1855 : 		_Node_if *_Cur = _Child;

	mov	edi, DWORD PTR [ecx+24]
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	DWORD PTR [ecx], OFFSET ??_7_Node_if@std@@6B@

; 1856 : 		while (_Cur)

	test	edi, edi
	je	SHORT $LN20@Node_if
	push	ebx
	push	esi
	npad	7
$LL2@Node_if:

; 1857 : 			{	// destroy branch
; 1858 : 			_Node_if *_Tmp = _Cur;
; 1859 : 			_Cur = _Cur->_Child;

	lea	eax, DWORD PTR [edi+24]
	mov	esi, edi
	mov	edi, DWORD PTR [eax]

; 1860 : 			_Tmp->_Child = 0;

	mov	DWORD PTR [eax], 0

; 1861 : 			_Destroy_node(_Tmp, _Endif);

	mov	ebx, DWORD PTR [ecx+20]

; 1694 : 	while (_Nx != _Ne && _Nx != 0)

	cmp	esi, ebx
	je	SHORT $LN7@Node_if
$LL6@Node_if:
	test	esi, esi
	je	SHORT $LN21@Node_if

; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;

	mov	ecx, esi

; 1697 : 		_Nx = _Nx->_Next;

	lea	eax, DWORD PTR [esi+12]
	mov	esi, DWORD PTR [eax]

; 1698 : 		_Tmp->_Next = 0;

	mov	DWORD PTR [eax], 0

; 1699 : 		delete _Tmp;

	push	1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	cmp	esi, ebx
	jne	SHORT $LL6@Node_if
$LN21@Node_if:
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN7@Node_if:

; 1856 : 		while (_Cur)

	test	edi, edi
	jne	SHORT $LL2@Node_if
	pop	esi
	pop	ebx
$LN20@Node_if:

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	pop	edi

; 1862 : 			}
; 1863 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Node_if@std@@UAE@XZ ENDP				; std::_Node_if::~_Node_if
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_if@std@@QAE@PAV_Node_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__End$ = 8						; size = 4
??0_Node_if@std@@QAE@PAV_Node_base@1@@Z PROC		; std::_Node_if::_Node_if, COMDAT
; _this$ = ecx

; 1850 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1677 : 		{	// construct
; 1678 : 		}
; 1679 : 
; 1680 : 	_Node_type _Kind;
; 1681 : 	_Node_flags _Flags;
; 1682 : 	_Node_base *_Next;
; 1683 : 	_Node_base *_Prev;
; 1684 : 
; 1685 : 	virtual ~_Node_base() _NOEXCEPT
; 1686 : 		{	// destroy
; 1687 : 		}
; 1688 : 	};
; 1689 : 
; 1690 : 	// FUNCTION _Destroy_node
; 1691 : inline void _Destroy_node(_Node_base *_Nx,
; 1692 : 	_Node_base *_Ne = 0)
; 1693 : 	{	// destroy sublist of nodes
; 1694 : 	while (_Nx != _Ne && _Nx != 0)
; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;
; 1697 : 		_Nx = _Nx->_Next;
; 1698 : 		_Tmp->_Next = 0;
; 1699 : 		delete _Tmp;
; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	// CLASS _Root_node
; 1704 : class _Root_node
; 1705 : 	: public _Node_base
; 1706 : 	{	// root of parse tree
; 1707 : public:
; 1708 : 	_Root_node()
; 1709 : 		: _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)
; 1710 : 		{	// construct
; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)
; 1728 : 		{	// construct
; 1729 : 		}
; 1730 : 
; 1731 : 	_Node_base *_Back;
; 1732 : 	};
; 1733 : 
; 1734 : 	// CLASS _Node_assert
; 1735 : class _Node_assert
; 1736 : 	: public _Node_base
; 1737 : 	{	// node that holds an ECMAScript assertion
; 1738 : public:
; 1739 : 	_Node_assert(_Node_type _Ty, _Node_flags _Fl = _Fl_none)
; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)
; 1741 : 		{	// construct
; 1742 : 		}
; 1743 : 
; 1744 : 	~_Node_assert() _NOEXCEPT
; 1745 : 		{	// destroy branch
; 1746 : 		_Destroy_node(_Child);
; 1747 : 		}
; 1748 : 
; 1749 : 	_Node_base *_Child;
; 1750 : 	};
; 1751 : 
; 1752 : 	// TEMPLATE CLASS _Node_capture
; 1753 : class _Node_capture
; 1754 : 	: public _Node_base
; 1755 : 	{	// node that marks beginning of a capture group
; 1756 : public:
; 1757 : 	_Node_capture(unsigned int _Ix)
; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)
; 1759 : 		{	// construct
; 1760 : 		}
; 1761 : 
; 1762 : 	unsigned int _Idx;
; 1763 : 	};
; 1764 : 
; 1765 : 	// CLASS _Node_back
; 1766 : class _Node_back
; 1767 : 	: public _Node_base
; 1768 : 	{	// node that holds a back reference
; 1769 : public:
; 1770 : 	_Node_back(unsigned int _Ix)
; 1771 : 		: _Node_base(_N_back, _Fl_none), _Idx(_Ix)
; 1772 : 		{	// construct
; 1773 : 		}
; 1774 : 
; 1775 : 	unsigned int _Idx;
; 1776 : 	};
; 1777 : 
; 1778 : 	// TEMPLATE CLASS _Node_str
; 1779 : template<class _Elem>
; 1780 : 	class _Node_str
; 1781 : 		: public _Node_base
; 1782 : 	{	// node that holds text
; 1783 : public:
; 1784 : 	_Node_str(_Node_flags _Fl = _Fl_none)
; 1785 : 		: _Node_base(_N_str, _Fl)
; 1786 : 		{	// construct
; 1787 : 		}
; 1788 : 
; 1789 : 	_Buf<_Elem> _Data;
; 1790 : 	};
; 1791 : 
; 1792 : 	// TEMPLATE CLASS _Node_class
; 1793 : template<class _Elem,
; 1794 : 	class _RxTraits>
; 1795 : 	class _Node_class
; 1796 : 		: public _Node_base
; 1797 : 	{	// node that holds a character class (POSIX bracket expression)
; 1798 : public:
; 1799 : 	_Node_class(_Node_type _Ty = _N_class, _Node_flags _Fl = _Fl_none)
; 1800 : 		: _Node_base(_Ty, _Fl), _Coll(0), _Small(0), _Large(0), _Ranges(0),
; 1801 : 		_Classes((typename _RxTraits::char_class_type)0), _Equiv(0)
; 1802 : 		{	// construct
; 1803 : 		}
; 1804 : 
; 1805 : 	~_Node_class() _NOEXCEPT
; 1806 : 		{	// destroy
; 1807 : 		_Tidy(_Coll);
; 1808 : 		delete _Small;
; 1809 : 		delete _Large;
; 1810 : 		delete _Ranges;
; 1811 : 		_Tidy(_Equiv);
; 1812 : 		}
; 1813 : 
; 1814 : 	void _Tidy(_Sequence<_Elem> *_Head)
; 1815 : 		{	// clean up a list of sequences
; 1816 : 		while (_Head)
; 1817 : 			{	// delete the head of the list
; 1818 : 			_Sequence<_Elem> *_Temp = _Head;
; 1819 : 			_Head = _Head->_Next;
; 1820 : 			delete _Temp;
; 1821 : 			}
; 1822 : 		}
; 1823 : 
; 1824 : 	_Sequence<_Elem> *_Coll;
; 1825 : 	_Bitmap *_Small;
; 1826 : 	_Buf<_Elem> *_Large;
; 1827 : 	_Buf<_Elem> *_Ranges;
; 1828 : 	typename _RxTraits::char_class_type _Classes;
; 1829 : 	_Sequence<_Elem> *_Equiv;
; 1830 : 	};
; 1831 : 
; 1832 : 	// CLASS _Node_endif
; 1833 : class _Node_endif
; 1834 : 	: public _Node_base
; 1835 : 	{	// node that marks the end of an alternative
; 1836 : public:
; 1837 : 	_Node_endif()
; 1838 : 		: _Node_base(_N_endif, _Fl_none)
; 1839 : 		{	// construct
; 1840 : 		}
; 1841 : 	};
; 1842 : 
; 1843 : 	// CLASS _Node_if
; 1844 : class _Node_if
; 1845 : 	: public _Node_base
; 1846 : 	{	// node that marks the beginning of an alternative
; 1847 : public:
; 1848 : 	_Node_if(_Node_base *_End)
; 1849 : 		: _Node_base(_N_if, _Fl_none), _Endif((_Node_endif *)_End), _Child(0)

	mov	eax, DWORD PTR __End$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1851 : 		}

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 16			; 00000010H
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1850 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_if@std@@6B@
	mov	DWORD PTR [ecx+24], 0

; 1851 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??0_Node_if@std@@QAE@PAV_Node_base@1@@Z ENDP		; std::_Node_if::_Node_if
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Node_endif@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_endif@std@@UAEPAXI@Z PROC			; std::_Node_endif::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN10@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_endif@std@@UAEPAXI@Z ENDP			; std::_Node_endif::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_endif@std@@UAE@XZ
_TEXT	SEGMENT
??1_Node_endif@std@@UAE@XZ PROC				; std::_Node_endif::~_Node_endif, COMDAT
; _this$ = ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	ret	0
??1_Node_endif@std@@UAE@XZ ENDP				; std::_Node_endif::~_Node_endif
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_endif@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Node_endif@std@@QAE@XZ PROC				; std::_Node_endif::_Node_endif, COMDAT
; _this$ = ecx

; 1839 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1840 : 		}

	mov	eax, ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 17			; 00000011H
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1839 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_endif@std@@6B@

; 1840 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??0_Node_endif@std@@QAE@XZ ENDP				; std::_Node_endif::_Node_endif
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Node_back@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_back@std@@UAEPAXI@Z PROC			; std::_Node_back::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN10@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_back@std@@UAEPAXI@Z ENDP			; std::_Node_back::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_back@std@@UAE@XZ
_TEXT	SEGMENT
??1_Node_back@std@@UAE@XZ PROC				; std::_Node_back::~_Node_back, COMDAT
; _this$ = ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	ret	0
??1_Node_back@std@@UAE@XZ ENDP				; std::_Node_back::~_Node_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_back@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ix$ = 8						; size = 4
??0_Node_back@std@@QAE@I@Z PROC				; std::_Node_back::_Node_back, COMDAT
; _this$ = ecx

; 1772 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1677 : 		{	// construct
; 1678 : 		}
; 1679 : 
; 1680 : 	_Node_type _Kind;
; 1681 : 	_Node_flags _Flags;
; 1682 : 	_Node_base *_Next;
; 1683 : 	_Node_base *_Prev;
; 1684 : 
; 1685 : 	virtual ~_Node_base() _NOEXCEPT
; 1686 : 		{	// destroy
; 1687 : 		}
; 1688 : 	};
; 1689 : 
; 1690 : 	// FUNCTION _Destroy_node
; 1691 : inline void _Destroy_node(_Node_base *_Nx,
; 1692 : 	_Node_base *_Ne = 0)
; 1693 : 	{	// destroy sublist of nodes
; 1694 : 	while (_Nx != _Ne && _Nx != 0)
; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;
; 1697 : 		_Nx = _Nx->_Next;
; 1698 : 		_Tmp->_Next = 0;
; 1699 : 		delete _Tmp;
; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	// CLASS _Root_node
; 1704 : class _Root_node
; 1705 : 	: public _Node_base
; 1706 : 	{	// root of parse tree
; 1707 : public:
; 1708 : 	_Root_node()
; 1709 : 		: _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)
; 1710 : 		{	// construct
; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)
; 1728 : 		{	// construct
; 1729 : 		}
; 1730 : 
; 1731 : 	_Node_base *_Back;
; 1732 : 	};
; 1733 : 
; 1734 : 	// CLASS _Node_assert
; 1735 : class _Node_assert
; 1736 : 	: public _Node_base
; 1737 : 	{	// node that holds an ECMAScript assertion
; 1738 : public:
; 1739 : 	_Node_assert(_Node_type _Ty, _Node_flags _Fl = _Fl_none)
; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)
; 1741 : 		{	// construct
; 1742 : 		}
; 1743 : 
; 1744 : 	~_Node_assert() _NOEXCEPT
; 1745 : 		{	// destroy branch
; 1746 : 		_Destroy_node(_Child);
; 1747 : 		}
; 1748 : 
; 1749 : 	_Node_base *_Child;
; 1750 : 	};
; 1751 : 
; 1752 : 	// TEMPLATE CLASS _Node_capture
; 1753 : class _Node_capture
; 1754 : 	: public _Node_base
; 1755 : 	{	// node that marks beginning of a capture group
; 1756 : public:
; 1757 : 	_Node_capture(unsigned int _Ix)
; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)
; 1759 : 		{	// construct
; 1760 : 		}
; 1761 : 
; 1762 : 	unsigned int _Idx;
; 1763 : 	};
; 1764 : 
; 1765 : 	// CLASS _Node_back
; 1766 : class _Node_back
; 1767 : 	: public _Node_base
; 1768 : 	{	// node that holds a back reference
; 1769 : public:
; 1770 : 	_Node_back(unsigned int _Ix)
; 1771 : 		: _Node_base(_N_back, _Fl_none), _Idx(_Ix)

	mov	eax, DWORD PTR __Ix$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1773 : 		}

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 15			; 0000000fH
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1772 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_back@std@@6B@

; 1773 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??0_Node_back@std@@QAE@I@Z ENDP				; std::_Node_back::_Node_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Node_capture@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_capture@std@@UAEPAXI@Z PROC			; std::_Node_capture::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN10@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_capture@std@@UAEPAXI@Z ENDP			; std::_Node_capture::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_capture@std@@UAE@XZ
_TEXT	SEGMENT
??1_Node_capture@std@@UAE@XZ PROC			; std::_Node_capture::~_Node_capture, COMDAT
; _this$ = ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	ret	0
??1_Node_capture@std@@UAE@XZ ENDP			; std::_Node_capture::~_Node_capture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_capture@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ix$ = 8						; size = 4
??0_Node_capture@std@@QAE@I@Z PROC			; std::_Node_capture::_Node_capture, COMDAT
; _this$ = ecx

; 1759 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1677 : 		{	// construct
; 1678 : 		}
; 1679 : 
; 1680 : 	_Node_type _Kind;
; 1681 : 	_Node_flags _Flags;
; 1682 : 	_Node_base *_Next;
; 1683 : 	_Node_base *_Prev;
; 1684 : 
; 1685 : 	virtual ~_Node_base() _NOEXCEPT
; 1686 : 		{	// destroy
; 1687 : 		}
; 1688 : 	};
; 1689 : 
; 1690 : 	// FUNCTION _Destroy_node
; 1691 : inline void _Destroy_node(_Node_base *_Nx,
; 1692 : 	_Node_base *_Ne = 0)
; 1693 : 	{	// destroy sublist of nodes
; 1694 : 	while (_Nx != _Ne && _Nx != 0)
; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;
; 1697 : 		_Nx = _Nx->_Next;
; 1698 : 		_Tmp->_Next = 0;
; 1699 : 		delete _Tmp;
; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	// CLASS _Root_node
; 1704 : class _Root_node
; 1705 : 	: public _Node_base
; 1706 : 	{	// root of parse tree
; 1707 : public:
; 1708 : 	_Root_node()
; 1709 : 		: _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)
; 1710 : 		{	// construct
; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)
; 1728 : 		{	// construct
; 1729 : 		}
; 1730 : 
; 1731 : 	_Node_base *_Back;
; 1732 : 	};
; 1733 : 
; 1734 : 	// CLASS _Node_assert
; 1735 : class _Node_assert
; 1736 : 	: public _Node_base
; 1737 : 	{	// node that holds an ECMAScript assertion
; 1738 : public:
; 1739 : 	_Node_assert(_Node_type _Ty, _Node_flags _Fl = _Fl_none)
; 1740 : 		: _Node_base(_Ty, _Fl), _Child(0)
; 1741 : 		{	// construct
; 1742 : 		}
; 1743 : 
; 1744 : 	~_Node_assert() _NOEXCEPT
; 1745 : 		{	// destroy branch
; 1746 : 		_Destroy_node(_Child);
; 1747 : 		}
; 1748 : 
; 1749 : 	_Node_base *_Child;
; 1750 : 	};
; 1751 : 
; 1752 : 	// TEMPLATE CLASS _Node_capture
; 1753 : class _Node_capture
; 1754 : 	: public _Node_base
; 1755 : 	{	// node that marks beginning of a capture group
; 1756 : public:
; 1757 : 	_Node_capture(unsigned int _Ix)
; 1758 : 		: _Node_base(_N_capture, _Fl_none), _Idx(_Ix)

	mov	eax, DWORD PTR __Ix$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1760 : 		}

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 13			; 0000000dH
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1759 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_capture@std@@6B@

; 1760 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??0_Node_capture@std@@QAE@I@Z ENDP			; std::_Node_capture::_Node_capture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Node_assert@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_assert@std@@UAEPAXI@Z PROC			; std::_Node_assert::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 1746 : 		_Destroy_node(_Child);

	mov	esi, DWORD PTR [edi+20]
	mov	DWORD PTR [edi], OFFSET ??_7_Node_assert@std@@6B@

; 1694 : 	while (_Nx != _Ne && _Nx != 0)

	test	esi, esi
	je	SHORT $LN20@scalar
$LN22@scalar:

; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;

	mov	ecx, esi

; 1697 : 		_Nx = _Nx->_Next;

	lea	eax, DWORD PTR [esi+12]
	mov	esi, DWORD PTR [eax]

; 1698 : 		_Tmp->_Next = 0;

	mov	DWORD PTR [eax], 0

; 1699 : 		delete _Tmp;

	push	1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	test	esi, esi
	jne	SHORT $LN22@scalar
$LN20@scalar:
	test	BYTE PTR ___flags$[ebp], 1

; 1686 : 		{	// destroy

	mov	DWORD PTR [edi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN19@scalar
	push	24					; 00000018H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN19@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_assert@std@@UAEPAXI@Z ENDP			; std::_Node_assert::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_assert@std@@UAE@XZ
_TEXT	SEGMENT
??1_Node_assert@std@@UAE@XZ PROC			; std::_Node_assert::~_Node_assert, COMDAT
; _this$ = ecx

; 1745 : 		{	// destroy branch

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 1746 : 		_Destroy_node(_Child);

	mov	esi, DWORD PTR [edi+20]
	mov	DWORD PTR [edi], OFFSET ??_7_Node_assert@std@@6B@

; 1694 : 	while (_Nx != _Ne && _Nx != 0)

	test	esi, esi
	je	SHORT $LN15@Node_asser
$LN18@Node_asser:

; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;

	mov	ecx, esi

; 1697 : 		_Nx = _Nx->_Next;

	lea	eax, DWORD PTR [esi+12]
	mov	esi, DWORD PTR [eax]

; 1698 : 		_Tmp->_Next = 0;

	mov	DWORD PTR [eax], 0

; 1699 : 		delete _Tmp;

	push	1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	test	esi, esi
	jne	SHORT $LN18@Node_asser
$LN15@Node_asser:

; 1686 : 		{	// destroy

	mov	DWORD PTR [edi], OFFSET ??_7_Node_base@std@@6B@
	pop	edi
	pop	esi

; 1747 : 		}

	ret	0
??1_Node_assert@std@@UAE@XZ ENDP			; std::_Node_assert::~_Node_assert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ty$ = 8						; size = 4
__Fl$ = 12						; size = 4
??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z PROC ; std::_Node_assert::_Node_assert, COMDAT
; _this$ = ecx

; 1741 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	eax, DWORD PTR __Ty$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Fl$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1742 : 		}

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1741 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_assert@std@@6B@
	mov	DWORD PTR [ecx+20], 0

; 1742 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??0_Node_assert@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ENDP ; std::_Node_assert::_Node_assert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Node_end_group@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_end_group@std@@UAEPAXI@Z PROC			; std::_Node_end_group::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN10@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_end_group@std@@UAEPAXI@Z ENDP			; std::_Node_end_group::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_end_group@std@@UAE@XZ
_TEXT	SEGMENT
??1_Node_end_group@std@@UAE@XZ PROC			; std::_Node_end_group::~_Node_end_group, COMDAT
; _this$ = ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	ret	0
??1_Node_end_group@std@@UAE@XZ ENDP			; std::_Node_end_group::~_Node_end_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ty$ = 8						; size = 4
__Fl$ = 12						; size = 4
__Bx$ = 16						; size = 4
??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z PROC ; std::_Node_end_group::_Node_end_group, COMDAT
; _this$ = ecx

; 1728 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	eax, DWORD PTR __Ty$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Fl$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1677 : 		{	// construct
; 1678 : 		}
; 1679 : 
; 1680 : 	_Node_type _Kind;
; 1681 : 	_Node_flags _Flags;
; 1682 : 	_Node_base *_Next;
; 1683 : 	_Node_base *_Prev;
; 1684 : 
; 1685 : 	virtual ~_Node_base() _NOEXCEPT
; 1686 : 		{	// destroy
; 1687 : 		}
; 1688 : 	};
; 1689 : 
; 1690 : 	// FUNCTION _Destroy_node
; 1691 : inline void _Destroy_node(_Node_base *_Nx,
; 1692 : 	_Node_base *_Ne = 0)
; 1693 : 	{	// destroy sublist of nodes
; 1694 : 	while (_Nx != _Ne && _Nx != 0)
; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;
; 1697 : 		_Nx = _Nx->_Next;
; 1698 : 		_Tmp->_Next = 0;
; 1699 : 		delete _Tmp;
; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	// CLASS _Root_node
; 1704 : class _Root_node
; 1705 : 	: public _Node_base
; 1706 : 	{	// root of parse tree
; 1707 : public:
; 1708 : 	_Root_node()
; 1709 : 		: _Node_base(_N_begin), _Loops(0), _Marks(0), _Refs(0)
; 1710 : 		{	// construct
; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}
; 1714 : 
; 1715 : 	regex_constants::syntax_option_type _Fl;
; 1716 : 	unsigned int _Loops;
; 1717 : 	unsigned int _Marks;
; 1718 : 	unsigned int _Refs;
; 1719 : 	};
; 1720 : 
; 1721 : 	// CLASS _Node_end_group
; 1722 : class _Node_end_group
; 1723 : 	: public _Node_base
; 1724 : 	{	// node that marks end of a group
; 1725 : public:
; 1726 : 	_Node_end_group(_Node_type _Ty, _Node_flags _Fl, _Node_base *_Bx)
; 1727 : 		: _Node_base(_Ty, _Fl), _Back(_Bx)

	mov	eax, DWORD PTR __Bx$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1729 : 		}

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1728 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_end_group@std@@6B@

; 1729 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0_Node_end_group@std@@QAE@W4_Node_type@1@W4_Node_flags@1@PAV_Node_base@1@@Z ENDP ; std::_Node_end_group::_Node_end_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Root_node@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Root_node@std@@UAEPAXI@Z PROC			; std::_Root_node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN10@scalar
	push	36					; 00000024H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Root_node@std@@UAEPAXI@Z ENDP			; std::_Root_node::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Root_node@std@@UAE@XZ
_TEXT	SEGMENT
??1_Root_node@std@@UAE@XZ PROC				; std::_Root_node::~_Root_node, COMDAT
; _this$ = ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	ret	0
??1_Root_node@std@@UAE@XZ ENDP				; std::_Root_node::~_Root_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Root_node@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Root_node@std@@QAE@XZ PROC				; std::_Root_node::_Root_node, COMDAT
; _this$ = ecx

; 1710 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}

	mov	eax, ecx

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	DWORD PTR [ecx+4], 20			; 00000014H
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0

; 1710 : 		{	// construct

	mov	DWORD PTR [ecx], OFFSET ??_7_Root_node@std@@6B@
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0

; 1711 : 		static_assert(sizeof (_Refs) == sizeof (_Atomic_counter_t),
; 1712 : 			"invalid _Refs size");
; 1713 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??0_Root_node@std@@QAE@XZ ENDP				; std::_Root_node::_Root_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z
_TEXT	SEGMENT
__Nx$ = 8						; size = 4
__Ne$ = 12						; size = 4
?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z PROC		; std::_Destroy_node, COMDAT

; 1693 : 	{	// destroy sublist of nodes

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1694 : 	while (_Nx != _Ne && _Nx != 0)

	mov	esi, DWORD PTR __Nx$[ebp]
	push	edi
	mov	edi, DWORD PTR __Ne$[ebp]
	cmp	esi, edi
	je	SHORT $LN10@Destroy_no
$LL2@Destroy_no:
	test	esi, esi
	je	SHORT $LN10@Destroy_no

; 1695 : 		{	// destroy node
; 1696 : 		_Node_base *_Tmp = _Nx;

	mov	ecx, esi

; 1697 : 		_Nx = _Nx->_Next;

	lea	eax, DWORD PTR [esi+12]
	mov	esi, DWORD PTR [eax]

; 1698 : 		_Tmp->_Next = 0;

	mov	DWORD PTR [eax], 0

; 1699 : 		delete _Tmp;

	push	1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	cmp	esi, edi
	jne	SHORT $LL2@Destroy_no
$LN10@Destroy_no:
	pop	edi
	pop	esi

; 1700 : 		}
; 1701 : 	}

	pop	ebp
	ret	0
?_Destroy_node@std@@YAXPAV_Node_base@1@0@Z ENDP		; std::_Destroy_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_G_Node_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node_base@std@@UAEPAXI@Z PROC			; std::_Node_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [esi], OFFSET ??_7_Node_base@std@@6B@
	je	SHORT $LN7@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Node_base@std@@UAEPAXI@Z ENDP			; std::_Node_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??1_Node_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Node_base@std@@UAE@XZ PROC				; std::_Node_base::~_Node_base, COMDAT
; _this$ = ecx

; 1686 : 		{	// destroy

	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@

; 1687 : 		}

	ret	0
??1_Node_base@std@@UAE@XZ ENDP				; std::_Node_base::~_Node_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z
_TEXT	SEGMENT
__Ty$ = 8						; size = 4
__Fl$ = 12						; size = 4
??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z PROC ; std::_Node_base::_Node_base, COMDAT
; _this$ = ecx

; 1677 : 		{	// construct

	npad	2
	push	ebp
	mov	ebp, esp

; 1676 : 		: _Kind(_Ty), _Flags(_Fl), _Next(0), _Prev(0)

	mov	eax, DWORD PTR __Ty$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Fl$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1678 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7_Node_base@std@@6B@
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	pop	ebp
	ret	8
??0_Node_base@std@@QAE@W4_Node_type@1@W4_Node_flags@1@@Z ENDP ; std::_Node_base::_Node_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0_Bitmap@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bitmap@std@@QAE@XZ PROC				; std::_Bitmap::_Bitmap, COMDAT
; _this$ = ecx

; 1632 : 	_Bitmap()

	xorps	xmm0, xmm0

; 1633 : 		{	// construct
; 1634 : 		_CSTD memset(_Chrs, '\0', _Bmp_size);
; 1635 : 		}

	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	movups	XMMWORD PTR [ecx+16], xmm0
	ret	0
??0_Bitmap@std@@QAE@XZ ENDP				; std::_Bitmap::_Bitmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z PROC	; std::operator^=, COMDAT

; 1527 : 	{	// bitwise xor

	npad	2
	push	ebp
	mov	ebp, esp

; 1528 : 	return (_Left = _Node_flags((int)_Left ^ _Right));

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	xor	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [ecx]

; 1529 : 	}

	pop	ebp
	ret	0
??_6std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ENDP	; std::operator^=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z PROC	; std::operator|=, COMDAT

; 1522 : 	{	// bitwise or

	npad	2
	push	ebp
	mov	ebp, esp

; 1523 : 	return (_Left = _Node_flags((int)_Left | _Right));

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	or	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [ecx]

; 1524 : 	}

	pop	ebp
	ret	0
??_5std@@YA?AW4_Node_flags@0@AAW410@W410@@Z ENDP	; std::operator|=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Is_word@std@@YA_NE@Z
_TEXT	SEGMENT
__UCh$ = 8						; size = 1
?_Is_word@std@@YA_NE@Z PROC				; std::_Is_word, COMDAT

; 611  : 	{	// test if _UCh is a word character

	npad	2
	push	ebp
	mov	ebp, esp

; 612  : 		// special casing char to avoid branches for std::regex in this path
; 613  : 	static constexpr bool _Is_word_table[(numeric_limits<unsigned char>::max)() + 1] =
; 614  : 		{
; 615  : 		/*        X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 XA XB XC XD XE XF */
; 616  : 		/* 0X */   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
; 617  : 		/* 1X */   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
; 618  : 		/* 2X */   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
; 619  : 		/* 3X */   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, /* 0-9 */
; 620  : 		/* 4X */   0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* A-Z */
; 621  : 		/* 5X */   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, /* 5F == _ */
; 622  : 		/* 6X */   0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* a-z */
; 623  : 		/* 7X */   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
; 624  : 		/* non-ASCII values initialized to 0 */
; 625  : 		};
; 626  : 	return (_Is_word_table[_UCh]);

	movzx	eax, BYTE PTR __UCh$[ebp]
	mov	al, BYTE PTR ?_Is_word_table@?1??_Is_word@std@@YA_NE@Z@4QB_NB[eax]

; 627  : 	}

	pop	ebp
	ret	0
?_Is_word@std@@YA_NE@Z ENDP				; std::_Is_word
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ??1?$regex_traits@_W@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$regex_traits@_W@std@@QAE@XZ PROC			; std::regex_traits<wchar_t>::~regex_traits<wchar_t>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$regex_traits@_W@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 404  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN9@regex_trai

; 405  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN9@regex_trai
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN9@regex_trai:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$regex_traits@_W@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$regex_traits@_W@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$regex_traits@_W@std@@QAE@XZ ENDP			; std::regex_traits<wchar_t>::~regex_traits<wchar_t>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$regex_traits@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$regex_traits@_W@std@@QAE@XZ PROC			; std::regex_traits<wchar_t>::regex_traits<wchar_t>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$regex_traits@_W@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 276  : 		{	// default construct

	lea	esi, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 304  : 		{	// construct from current locale

	push	1
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR __imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z
	mov	DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	push	esi

; 276  : 		{	// default construct

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	call	??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z ; std::use_facet<std::collate<wchar_t> >

; 413  : 		_Pctype = &_USE(_Loc, ctype<_Elem>);

	push	esi
	mov	DWORD PTR [edi], eax
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+4], eax
	mov	eax, edi
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$regex_traits@_W@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??0?$regex_traits@_W@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$regex_traits@_W@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$regex_traits@_W@std@@QAE@XZ ENDP			; std::regex_traits<wchar_t>::regex_traits<wchar_t>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?value@?$regex_traits@_W@std@@QBEH_WH@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
__Base$ = 12						; size = 4
?value@?$regex_traits@_W@std@@QBEH_WH@Z PROC		; std::regex_traits<wchar_t>::value, COMDAT
; _this$ = ecx

; 449  : 		{	// map character value to numeric value

	npad	2
	push	ebp
	mov	ebp, esp

; 450  : 		if ((_Base != 8 && L'0' <= _Ch && _Ch <= L'9')
; 451  : 			|| (_Base == 8 && L'0' <= _Ch && _Ch <= L'7'))

	mov	eax, DWORD PTR __Base$[ebp]
	mov	ecx, DWORD PTR __Ch$[ebp]
	cmp	eax, 8
	je	SHORT $LN12@value
	mov	edx, 48					; 00000030H
	cmp	dx, cx
	ja	SHORT $LN2@value
	cmp	cx, 57					; 00000039H
	jbe	SHORT $LN4@value
$LN2@value:

; 453  : 		else if (_Base != 16)

	cmp	eax, 16					; 00000010H
	jne	SHORT $LN10@value

; 454  : 			;
; 455  : 		else if (L'a' <= _Ch && _Ch <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN8@value

; 456  : 			return (_Ch - L'a' + 10);

	movzx	eax, cx
	sub	eax, 87					; 00000057H

; 460  : 		}

	pop	ebp
	ret	8
$LN8@value:

; 457  : 		else if (L'A' <= _Ch && _Ch <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN10@value

; 458  : 			return (_Ch - L'A' + 10);

	movzx	eax, cx
	sub	eax, 55					; 00000037H

; 460  : 		}

	pop	ebp
	ret	8
$LN12@value:

; 450  : 		if ((_Base != 8 && L'0' <= _Ch && _Ch <= L'9')
; 451  : 			|| (_Base == 8 && L'0' <= _Ch && _Ch <= L'7'))

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 7
	ja	SHORT $LN10@value
$LN4@value:

; 452  : 			return (_Ch - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H

; 460  : 		}

	pop	ebp
	ret	8
$LN10@value:

; 459  : 		return (-1);

	or	eax, -1

; 460  : 		}

	pop	ebp
	ret	8
?value@?$regex_traits@_W@std@@QBEH_WH@Z ENDP		; std::regex_traits<wchar_t>::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ??1?$_Regex_traits@_W@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$_Regex_traits@_W@std@@QAE@XZ PROC			; std::_Regex_traits<wchar_t>::~_Regex_traits<wchar_t>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$_Regex_traits@_W@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 404  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN6@Regex_trai

; 405  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN6@Regex_trai
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN6@Regex_trai:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Regex_traits@_W@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Regex_traits@_W@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Regex_traits@_W@std@@QAE@XZ ENDP			; std::_Regex_traits<wchar_t>::~_Regex_traits<wchar_t>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Cache_locale@?$_Regex_traits@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Cache_locale@?$_Regex_traits@_W@std@@AAEXXZ PROC	; std::_Regex_traits<wchar_t>::_Cache_locale, COMDAT
; _this$ = ecx

; 411  : 		{	// populate _Pcoll and _Pctype with _Loc locale

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	lea	esi, DWORD PTR [edi+8]
	push	esi
	call	??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z ; std::use_facet<std::collate<wchar_t> >

; 413  : 		_Pctype = &_USE(_Loc, ctype<_Elem>);

	push	esi
	mov	DWORD PTR [edi], eax
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi

; 414  : 		}

	ret	0
?_Cache_locale@?$_Regex_traits@_W@std@@AAEXXZ ENDP	; std::_Regex_traits<wchar_t>::_Cache_locale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Getctype@?$_Regex_traits@_W@std@@QBEPBV?$ctype@_W@2@XZ
_TEXT	SEGMENT
?_Getctype@?$_Regex_traits@_W@std@@QBEPBV?$ctype@_W@2@XZ PROC ; std::_Regex_traits<wchar_t>::_Getctype, COMDAT
; _this$ = ecx

; 406  : 		return (_Pctype);

	mov	eax, DWORD PTR [ecx+4]

; 407  : 		}

	ret	0
?_Getctype@?$_Regex_traits@_W@std@@QBEPBV?$ctype@_W@2@XZ ENDP ; std::_Regex_traits<wchar_t>::_Getctype
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?_Getcoll@?$_Regex_traits@_W@std@@QBEPBV?$collate@_W@2@XZ
_TEXT	SEGMENT
?_Getcoll@?$_Regex_traits@_W@std@@QBEPBV?$collate@_W@2@XZ PROC ; std::_Regex_traits<wchar_t>::_Getcoll, COMDAT
; _this$ = ecx

; 401  : 		return (_Pcoll);

	mov	eax, DWORD PTR [ecx]

; 402  : 		}

	ret	0
?_Getcoll@?$_Regex_traits@_W@std@@QBEPBV?$collate@_W@2@XZ ENDP ; std::_Regex_traits<wchar_t>::_Getcoll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?isctype@?$_Regex_traits@_W@std@@QBE_N_WF@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
__Fx$ = 12						; size = 2
?isctype@?$_Regex_traits@_W@std@@QBE_N_WF@Z PROC	; std::_Regex_traits<wchar_t>::isctype, COMDAT
; _this$ = ecx

; 328  : 		{	// return true if _Ch is in character class _Fx

	npad	2
	push	ebp
	mov	ebp, esp

; 329  : 		if (_Fx != (char_class_type)(-1))

	mov	eax, DWORD PTR __Fx$[ebp]
	cmp	ax, -1
	je	SHORT $LN2@isctype

; 330  : 			return (_Getctype()->is(_Fx, _Ch));

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z

; 333  : 				|| _Getctype()->is(_Ch_alnum, _Ch));
; 334  : 		}

	pop	ebp
	ret	8
$LN2@isctype:

; 331  : 		else
; 332  : 			return (_Ch == '_'	// assumes L'_' == '_'

	mov	eax, DWORD PTR __Ch$[ebp]
	cmp	ax, 95					; 0000005fH
	je	SHORT $LN5@isctype
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	push	263					; 00000107H
	call	DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
	test	al, al
	jne	SHORT $LN5@isctype
	xor	eax, eax

; 333  : 				|| _Getctype()->is(_Ch_alnum, _Ch));
; 334  : 		}

	pop	ebp
	ret	8
$LN5@isctype:

; 331  : 		else
; 332  : 			return (_Ch == '_'	// assumes L'_' == '_'

	mov	eax, 1

; 333  : 				|| _Getctype()->is(_Ch_alnum, _Ch));
; 334  : 		}

	pop	ebp
	ret	8
?isctype@?$_Regex_traits@_W@std@@QBE_N_WF@Z ENDP	; std::_Regex_traits<wchar_t>::isctype
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?translate_nocase@?$_Regex_traits@_W@std@@QBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?translate_nocase@?$_Regex_traits@_W@std@@QBE_W_W@Z PROC ; std::_Regex_traits<wchar_t>::translate_nocase, COMDAT
; _this$ = ecx

; 300  : 		{	// provide case-insensitive mapping

	npad	2
	push	ebp
	mov	ebp, esp

; 301  : 		return (_Getctype()->tolower(_Ch));

	mov	ecx, DWORD PTR [ecx+4]

; 302  : 		}

	pop	ebp

; 301  : 		return (_Getctype()->tolower(_Ch));

	jmp	DWORD PTR __imp_?tolower@?$ctype@_W@std@@QBE_W_W@Z
?translate_nocase@?$_Regex_traits@_W@std@@QBE_W_W@Z ENDP ; std::_Regex_traits<wchar_t>::translate_nocase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z
_TEXT	SEGMENT
__Res$ = -24						; size = 24
__Ch$ = 8						; size = 2
?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z PROC	; std::_Regex_traits<wchar_t>::translate, COMDAT
; _this$ = ecx

; 294  : 		{	// provide locale-sensitive mapping

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 295  : 		string_type _Res = _Getcoll()->transform(&_Ch, &_Ch + 1);

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR __Ch$[ebp+2]
	push	esi
	push	eax
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	lea	eax, DWORD PTR __Res$[ebp]
	push	eax
	call	?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ; std::collate<wchar_t>::transform

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	cmp	DWORD PTR __Res$[ebp+16], 1
	mov	ecx, DWORD PTR __Res$[ebp+20]
	mov	edx, DWORD PTR __Res$[ebp]
	jne	SHORT $LN3@translate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR __Res$[ebp]
	cmovae	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	movzx	esi, WORD PTR [eax]
	jmp	SHORT $LN4@translate
$LN3@translate:
	movzx	esi, WORD PTR __Ch$[ebp]
$LN4@translate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN68@translate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	edx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN68@translate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 296  : 		return (_Res.length() == 1 ? _Res[0] : _Ch);

	mov	ax, si
	pop	esi

; 297  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?translate@?$_Regex_traits@_W@std@@QBE_W_W@Z ENDP	; std::_Regex_traits<wchar_t>::translate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??0?$_Regex_traits@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_Regex_traits@_W@std@@QAE@XZ PROC			; std::_Regex_traits<wchar_t>::_Regex_traits<wchar_t>, COMDAT
; _this$ = ecx

; 275  : 	_Regex_traits()

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Regex_traits@_W@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 276  : 		{	// default construct

	lea	esi, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 304  : 		{	// construct from current locale

	push	1
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR __imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z
	mov	DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	push	esi

; 276  : 		{	// default construct

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 412  : 		_Pcoll = &_USE(_Loc, collate<_Elem>);

	call	??$use_facet@V?$collate@_W@std@@@std@@YAABV?$collate@_W@0@ABVlocale@0@@Z ; std::use_facet<std::collate<wchar_t> >

; 413  : 		_Pctype = &_USE(_Loc, ctype<_Elem>);

	push	esi
	mov	DWORD PTR [edi], eax
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >

; 277  : 		_Cache_locale();
; 278  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]

; 413  : 		_Pctype = &_USE(_Loc, ctype<_Elem>);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+4], eax

; 277  : 		_Cache_locale();
; 278  : 		}

	mov	eax, edi
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Regex_traits@_W@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??0?$_Regex_traits@_W@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Regex_traits@_W@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Regex_traits@_W@std@@QAE@XZ ENDP			; std::_Regex_traits<wchar_t>::_Regex_traits<wchar_t>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ?length@?$_Regex_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
?length@?$_Regex_traits@_W@std@@SAIPB_W@Z PROC		; std::_Regex_traits<wchar_t>::length, COMDAT

; 271  : 		{	// return length of _Str

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	eax, DWORD PTR __Str$[ebp]
	lea	edx, DWORD PTR [eax+2]
	npad	5
$LL6@length:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL6@length
	sub	eax, edx
	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex

; 273  : 		}

	pop	ebp
	ret	0
?length@?$_Regex_traits@_W@std@@SAIPB_W@Z ENDP		; std::_Regex_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??$_Get@_W@_Cl_names@std@@QBEPB_WXZ
_TEXT	SEGMENT
??$_Get@_W@_Cl_names@std@@QBEPB_WXZ PROC		; std::_Cl_names::_Get<wchar_t>, COMDAT
; _this$ = ecx

; 182  : 	return (_Wide);

	mov	eax, DWORD PTR [ecx+4]

; 183  : 	}

	ret	0
??$_Get@_W@_Cl_names@std@@QBEPB_WXZ ENDP		; std::_Cl_names::_Get<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??Sregex_constants@std@@YA?AW4match_flag_type@01@W4201@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
??Sregex_constants@std@@YA?AW4match_flag_type@01@W4201@@Z PROC ; std::regex_constants::operator~, COMDAT

; 133  : _BITMASK_OPS(match_flag_type)

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	not	eax
	pop	ebp
	ret	0
??Sregex_constants@std@@YA?AW4match_flag_type@01@W4201@@Z ENDP ; std::regex_constants::operator~
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??Uregex_constants@std@@YA?AW4match_flag_type@01@W4201@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??Uregex_constants@std@@YA?AW4match_flag_type@01@W4201@0@Z PROC ; std::regex_constants::operator|, COMDAT

; 133  : _BITMASK_OPS(match_flag_type)

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	or	eax, DWORD PTR __Right$[ebp]
	pop	ebp
	ret	0
??Uregex_constants@std@@YA?AW4match_flag_type@01@W4201@0@Z ENDP ; std::regex_constants::operator|
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??Iregex_constants@std@@YA?AW4match_flag_type@01@W4201@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??Iregex_constants@std@@YA?AW4match_flag_type@01@W4201@0@Z PROC ; std::regex_constants::operator&, COMDAT

; 133  : _BITMASK_OPS(match_flag_type)

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	and	eax, DWORD PTR __Right$[ebp]
	pop	ebp
	ret	0
??Iregex_constants@std@@YA?AW4match_flag_type@01@W4201@0@Z ENDP ; std::regex_constants::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_5regex_constants@std@@YAAAW4match_flag_type@01@AAW4201@W4201@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??_5regex_constants@std@@YAAAW4match_flag_type@01@AAW4201@W4201@@Z PROC ; std::regex_constants::operator|=, COMDAT

; 133  : _BITMASK_OPS(match_flag_type)

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	or	DWORD PTR [eax], ecx
	pop	ebp
	ret	0
??_5regex_constants@std@@YAAAW4match_flag_type@01@AAW4201@W4201@@Z ENDP ; std::regex_constants::operator|=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??_4regex_constants@std@@YAAAW4match_flag_type@01@AAW4201@W4201@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??_4regex_constants@std@@YAAAW4match_flag_type@01@AAW4201@W4201@@Z PROC ; std::regex_constants::operator&=, COMDAT

; 133  : _BITMASK_OPS(match_flag_type)

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	and	DWORD PTR [eax], ecx
	pop	ebp
	ret	0
??_4regex_constants@std@@YAAAW4match_flag_type@01@AAW4201@W4201@@Z ENDP ; std::regex_constants::operator&=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\regex
;	COMDAT ??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z PROC ; std::regex_constants::operator&, COMDAT

; 113  : _BITMASK_OPS(syntax_option_type)

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	and	eax, DWORD PTR __Right$[ebp]
	pop	ebp
	ret	0
??Iregex_constants@std@@YA?AW4syntax_option_type@01@W4201@0@Z ENDP ; std::regex_constants::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ??_G?$collate@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$collate@_W@std@@MAEPAXI@Z PROC			; std::collate<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 76   : 		_CSTD free(_Coll._LocaleName);

	push	DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7?$collate@_W@std@@6B@
	call	DWORD PTR __imp__free
	add	esp, 4

; 77   : 		}

	mov	ecx, esi
	call	DWORD PTR __imp_??1facet@locale@std@@MAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$collate@_W@std@@MAEPAXI@Z ENDP			; std::collate<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ?do_hash@?$collate@_W@std@@MBEJPB_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_hash@?$collate@_W@std@@MBEJPB_W0@Z PROC		; std::collate<wchar_t>::do_hash, COMDAT
; _this$ = ecx

; 123  : 		{	// compute hash code for [_First, _Last)

	npad	2
	push	ebp
	mov	ebp, esp

; 125  : 		return ((long)_Hash_seq((const unsigned char *)_First,

	mov	edx, DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 344  : 	for (size_t _Next = 0; _Next < _Count; ++_Next)

	mov	ecx, 0
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 125  : 		return ((long)_Hash_seq((const unsigned char *)_First,

	mov	edi, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 343  : 	size_t _Val = _FNV_offset_basis;

	mov	esi, -2128831035			; 811c9dc5H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 125  : 		return ((long)_Hash_seq((const unsigned char *)_First,

	sub	edx, edi
	sar	edx, 1
	add	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 344  : 	for (size_t _Next = 0; _Next < _Count; ++_Next)

	je	SHORT $LN14@do_hash
	npad	1
$LL10@do_hash:

; 345  : 		{	// fold in another byte
; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ecx+edi]
	inc	ecx
	xor	eax, esi

; 347  : 		_Val *= _FNV_prime;

	imul	esi, eax, 16777619
	cmp	ecx, edx
	jb	SHORT $LL10@do_hash
$LN14@do_hash:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 125  : 		return ((long)_Hash_seq((const unsigned char *)_First,

	mov	eax, esi
	pop	esi

; 126  : 			(_Last - _First) * sizeof (_Elem)));
; 127  : 		}

	pop	ebp
	ret	8
?do_hash@?$collate@_W@std@@MBEJPB_W0@Z ENDP		; std::collate<wchar_t>::do_hash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
tv644 = 16						; size = 4
__Last$ = 16						; size = 4
?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z PROC ; std::collate<wchar_t>::do_transform, COMDAT
; _this$ = ecx

; 104  : 		{	// transform [_First, _Last) to key string

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 118  : 		return (_Str);

	mov	ebx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	mov	eax, ebx
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 1
	mov	DWORD PTR $T2[ebp], 1
	je	SHORT $LN231@do_transfo
	add	ecx, 8
	mov	DWORD PTR tv644[ebp], ecx
	push	edi
$LL2@do_transfo:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3041 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	eax, ecx
	ja	SHORT $LN32@do_transfo

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN54@do_transfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
	mov	WORD PTR [ecx+eax*2], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3045 : 		else

	jmp	SHORT $LN33@do_transfo
$LN54@do_transfo:

; 1614 : 		return (_Large_string_engaged()

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
	mov	WORD PTR [ecx+eax*2], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3045 : 		else

	jmp	SHORT $LN33@do_transfo
$LN32@do_transfo:

; 3047 : 			append(_Newsize - this->_Mysize(), _Ch);

	sub	eax, ecx
	mov	ecx, esi
	push	0
	push	eax
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN33@do_transfo:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN86@do_transfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN87@do_transfo
$LN86@do_transfo:
	mov	edx, esi
$LN87@do_transfo:

; 3025 : 		return (this->_Mysize());

	mov	edi, DWORD PTR [esi+16]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN141@do_transfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN142@do_transfo
$LN141@do_transfo:
	mov	ecx, esi
$LN142@do_transfo:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo

; 293  : 	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));

	push	DWORD PTR tv644[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 114  : 					_First, _Last, &_Coll)) <= _Str.size())

	lea	eax, DWORD PTR [edx+edi*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo

; 293  : 	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));

	push	ebx
	push	DWORD PTR __First$[ebp]
	push	eax
	push	ecx
	call	DWORD PTR __imp___Wcsxfrm
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 114  : 					_First, _Last, &_Coll)) <= _Str.size())

	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN233@do_transfo

; 105  : 		_DEBUG_RANGE(_First, _Last);
; 106  : 		size_t _Count;
; 107  : 		string_type _Str;
; 108  : 
; 109  : 		for (_Count = _Last - _First; 0 < _Count; )

	test	eax, eax
	jne	SHORT $LL2@do_transfo
$LN233@do_transfo:
	pop	edi
$LN231@do_transfo:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3041 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	eax, ecx
	ja	SHORT $LN187@do_transfo

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN209@do_transfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
	mov	WORD PTR [ecx+eax*2], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 118  : 		return (_Str);

	mov	eax, esi
	pop	esi
	pop	ebx

; 119  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN209@do_transfo:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
	mov	WORD PTR [ecx+eax*2], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 118  : 		return (_Str);

	mov	eax, esi
	pop	esi
	pop	ebx

; 119  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN187@do_transfo:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3047 : 			append(_Newsize - this->_Mysize(), _Ch);

	sub	eax, ecx
	mov	ecx, esi
	push	0
	push	eax
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 119  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN8@do_transfo
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN8@do_transfo:
	ret	0
__ehhandler$?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_transform@?$collate@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ENDP ; std::collate<wchar_t>::do_transform
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ?do_compare@?$collate@_W@std@@MBEHPB_W000@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?do_compare@?$collate@_W@std@@MBEHPB_W000@Z PROC	; std::collate<wchar_t>::do_compare, COMDAT
; _this$ = ecx

; 95   : 		{	// compare [_First1, _Last1) to [_First2, _Last2)

	npad	2
	push	ebp
	mov	ebp, esp

; 98   : 		int _Ans = _LStrcoll(_First1, _Last1, _First2, _Last2, &_Coll);

	lea	eax, DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo

; 262  : 	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));

	push	eax
	push	DWORD PTR __Last2$[ebp]
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __Last1$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	DWORD PTR __imp___Wcscoll
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 98   : 		int _Ans = _LStrcoll(_First1, _Last1, _First2, _Last2, &_Coll);

	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo

; 262  : 	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));

	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 99   : 		return (_Ans < 0 ? -1 : _Ans == 0 ? 0 : +1);

	test	ecx, ecx
	jns	SHORT $LN3@do_compare
	or	eax, -1

; 100  : 		}

	pop	ebp
	ret	16					; 00000010H
$LN3@do_compare:

; 99   : 		return (_Ans < 0 ? -1 : _Ans == 0 ? 0 : +1);

	xor	eax, eax
	test	ecx, ecx
	setne	al

; 100  : 		}

	pop	ebp
	ret	16					; 00000010H
?do_compare@?$collate@_W@std@@MBEHPB_W000@Z ENDP	; std::collate<wchar_t>::do_compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ?_Init@?$collate@_W@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
?_Init@?$collate@_W@std@@IAEXABV_Locinfo@2@@Z PROC	; std::collate<wchar_t>::_Init, COMDAT
; _this$ = ecx

; 89   : 		{	// initialize from _Lobj

	npad	2
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo

; 111  : 		return (::_Getcoll());

	call	DWORD PTR __imp___Getcoll
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 90   : 		_Coll = _Lobj._Getcoll();

	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	pop	esi

; 91   : 		}

	ret	4
?_Init@?$collate@_W@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::collate<wchar_t>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ??1?$collate@_W@std@@MAE@XZ
_TEXT	SEGMENT
??1?$collate@_W@std@@MAE@XZ PROC			; std::collate<wchar_t>::~collate<wchar_t>, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 76   : 		_CSTD free(_Coll._LocaleName);

	push	DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7?$collate@_W@std@@6B@
	call	DWORD PTR __imp__free
	add	esp, 4

; 77   : 		}

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1facet@locale@std@@MAE@XZ
??1?$collate@_W@std@@MAE@XZ ENDP			; std::collate<wchar_t>::~collate<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -92						; size = 52
$T3 = -40						; size = 24
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T5 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::collate<wchar_t>::_Getcat, COMDAT

; 66   : 		{	// return locale category mask and construct standard facet

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T4[ebp], ebx

; 67   : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	edi, DWORD PTR __Ppf$[ebp]
	test	edi, edi
	je	$LN71@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	$LN71@Getcat

; 68   : 			*_Ppf = new collate<_Elem>(

	push	esi
	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T5[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	test	esi, esi
	je	SHORT $LN4@Getcat
	mov	ecx, DWORD PTR __Ploc$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 68   : 			*_Ppf = new collate<_Elem>(

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T4[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@Getcat
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN26@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 68   : 			*_Ppf = new collate<_Elem>(

	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??0_Locinfo@std@@QAE@PBD@Z
	mov	ebx, 3
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 59   : 		: locale::facet(_Refs)

	push	0
	mov	ecx, esi
	mov	DWORD PTR $T4[ebp], ebx
	call	DWORD PTR __imp_??0facet@locale@std@@IAE@I@Z

; 60   : 		{	// construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$collate@_W@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo

; 111  : 		return (::_Getcoll());

	call	DWORD PTR __imp___Getcoll
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 90   : 		_Coll = _Lobj._Getcoll();

	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx

; 68   : 			*_Ppf = new collate<_Elem>(

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	pop	esi
	test	bl, 2
	je	SHORT $LN11@Getcat
	lea	ecx, DWORD PTR $T2[ebp]
	and	ebx, -3					; fffffffdH
	call	DWORD PTR __imp_??1_Locinfo@std@@QAE@XZ
$LN11@Getcat:
	test	bl, 1
	je	SHORT $LN71@Getcat
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN71@Getcat
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN71@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 71   : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, 1
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	push	16					; 00000010H
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@Getcat:
	ret	0
__unwindfunclet$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 2
	je	$LN10@Getcat
	and	DWORD PTR $T4[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	DWORD PTR __imp_??1_Locinfo@std@@QAE@XZ
$LN10@Getcat:
	ret	0
__ehhandler$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$collate@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::collate<wchar_t>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ??0?$collate@_W@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$collate@_W@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::collate<wchar_t>::collate<wchar_t>, COMDAT
; _this$ = ecx

; 60   : 		{	// construct from specified locale

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 59   : 		: locale::facet(_Refs)

	push	DWORD PTR __Refs$[ebp]

; 60   : 		{	// construct from specified locale

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	call	DWORD PTR __imp_??0facet@locale@std@@IAE@I@Z
	mov	DWORD PTR [esi], OFFSET ??_7?$collate@_W@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo

; 111  : 		return (::_Getcoll());

	call	DWORD PTR __imp___Getcoll
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale

; 90   : 		_Coll = _Lobj._Getcoll();

	mov	DWORD PTR [esi+8], eax

; 61   : 		_Init(_Lobj);
; 62   : 		}

	mov	eax, esi

; 90   : 		_Coll = _Lobj._Getcoll();

	mov	DWORD PTR [esi+12], edx
	pop	esi

; 61   : 		_Init(_Lobj);
; 62   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??0?$collate@_W@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::collate<wchar_t>::collate<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\locale
;	COMDAT ?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z PROC ; std::collate<wchar_t>::transform, COMDAT
; _this$ = ecx

; 39   : 		{	// transform [_First, _Last) to key string

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 40   : 		return (do_transform(_First, _Last));

	push	DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __First$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 41   : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?transform@?$collate@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PB_W0@Z ENDP ; std::collate<wchar_t>::transform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ??$_Ungetc@_W@std@@YA_NAB_WPAU_iobuf@@@Z
_TEXT	SEGMENT
__Wchar$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Ungetc@_W@std@@YA_NAB_WPAU_iobuf@@@Z PROC		; std::_Ungetc<wchar_t>, COMDAT

; 121  : 	{	// put back a wchar_t element to a C stream

	npad	2
	push	ebp
	mov	ebp, esp

; 122  : 	return (_CSTD ungetwc(_Wchar, _File) != WEOF);

	mov	eax, DWORD PTR __Wchar$[ebp]
	push	DWORD PTR __File$[ebp]
	movzx	eax, WORD PTR [eax]
	push	eax
	call	DWORD PTR __imp__ungetwc
	mov	edx, 65535				; 0000ffffH
	xor	ecx, ecx
	add	esp, 8
	cmp	ax, dx
	setne	al

; 123  : 	}

	pop	ebp
	ret	0
??$_Ungetc@_W@std@@YA_NAB_WPAU_iobuf@@@Z ENDP		; std::_Ungetc<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ??$_Fputc@_W@std@@YA_N_WPAU_iobuf@@@Z
_TEXT	SEGMENT
__Wchar$ = 8						; size = 2
__File$ = 12						; size = 4
??$_Fputc@_W@std@@YA_N_WPAU_iobuf@@@Z PROC		; std::_Fputc<wchar_t>, COMDAT

; 87   : 	{	// put a wchar_t element to a C stream

	npad	2
	push	ebp
	mov	ebp, esp

; 88   : 	return (_CSTD fputwc(_Wchar, _File) != WEOF);

	push	DWORD PTR __File$[ebp]
	push	DWORD PTR __Wchar$[ebp]
	call	DWORD PTR __imp__fputwc
	mov	edx, 65535				; 0000ffffH
	xor	ecx, ecx
	add	esp, 8
	cmp	ax, dx
	setne	al

; 89   : 	}

	pop	ebp
	ret	0
??$_Fputc@_W@std@@YA_N_WPAU_iobuf@@@Z ENDP		; std::_Fputc<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\fstream
;	COMDAT ??$_Fgetc@_W@std@@YA_NAA_WPAU_iobuf@@@Z
_TEXT	SEGMENT
__Wchar$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Fgetc@_W@std@@YA_NAA_WPAU_iobuf@@@Z PROC		; std::_Fgetc<wchar_t>, COMDAT

; 49   : 	{	// get a wchar_t element from a C stream

	npad	2
	push	ebp
	mov	ebp, esp

; 50   : 	wint_t _Meta;
; 51   : 	if ((_Meta = _CSTD fgetwc(_File)) == WEOF)

	push	DWORD PTR __File$[ebp]
	call	DWORD PTR __imp__fgetwc
	movzx	ecx, ax
	add	esp, 4
	mov	eax, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN2@Fgetc

; 52   : 		return (false);

	xor	al, al

; 57   : 		}
; 58   : 	}

	pop	ebp
	ret	0
$LN2@Fgetc:

; 53   : 	else
; 54   : 		{	// got one, convert to wchar_t
; 55   : 		_Wchar = (wchar_t)_Meta;

	mov	eax, DWORD PTR __Wchar$[ebp]
	mov	WORD PTR [eax], cx

; 56   : 		return (true);

	mov	al, 1

; 57   : 		}
; 58   : 	}

	pop	ebp
	ret	0
??$_Fgetc@_W@std@@YA_NAA_WPAU_iobuf@@@Z ENDP		; std::_Fgetc<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_wszCurrentDir$ = -2116					; size = 1040
_wszWOW64$ = -1076					; size = 524
_wszSys32$ = -552					; size = 524
$T1 = -28						; size = 24
$T2 = -28						; size = 24
$T3 = -28						; size = 24
$T4 = -28						; size = 24
?SK_Inject_Start@@YAXXZ PROC				; SK_Inject_Start

; 1177 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 2116				; 00000844H

; 1178 :   wchar_t wszCurrentDir [MAX_PATH * 2] = { };

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	esi
	push	edi
	push	1040					; 00000410H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1179 :   GetCurrentDirectoryW  (MAX_PATH * 2 - 1, wszCurrentDir);

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	eax
	push	519					; 00000207H
	call	DWORD PTR __imp__GetCurrentDirectoryW@8

; 1181 :   SetCurrentDirectory (SK_SYS_GetInstallPath ().c_str ());

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?SK_SYS_GetInstallPath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; SK_SYS_GetInstallPath
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN30@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN30@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1181 :   SetCurrentDirectory (SK_SYS_GetInstallPath ().c_str ());

	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryW@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN39@SK_Inject_

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN39@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1187 :   wchar_t wszWOW64 [MAX_PATH + 2] = { };

	push	524					; 0000020cH
	lea	eax, DWORD PTR _wszWOW64$[ebp]
	push	0
	push	eax
	call	_memset

; 1188 :   GetSystemDirectoryW      (wszWOW64, MAX_PATH);

	mov	esi, DWORD PTR __imp__GetSystemDirectoryW@8
	lea	eax, DWORD PTR _wszWOW64$[ebp]
	add	esp, 12					; 0000000cH
	push	260					; 00000104H
	push	eax
	call	esi

; 1189 : #endif
; 1190 : 
; 1191 :   wchar_t wszSys32 [MAX_PATH + 2] = { };

	push	524					; 0000020cH
	lea	eax, DWORD PTR _wszSys32$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1192 :   GetSystemDirectoryW      (wszSys32, MAX_PATH);

	lea	eax, DWORD PTR _wszSys32$[ebp]
	push	260					; 00000104H
	push	eax
	call	esi

; 1193 : 
; 1194 :   if (GetFileAttributes (L"SKIM64.exe") == INVALID_FILE_ATTRIBUTES)

	push	OFFSET $SG148230
	call	DWORD PTR __imp__GetFileAttributesW@4
	cmp	eax, -1
	jne	$LN2@SK_Inject_

; 1195 :   {
; 1196 :     if (SKX_IsHookingCBT ())

	call	?SKX_IsHookingCBT@@YG_NXZ		; SKX_IsHookingCBT
	test	al, al
	je	SHORT $LN4@SK_Inject_

; 1197 :     {
; 1198 :       RunDLL_InjectionManager ( nullptr, nullptr,

	push	-128					; ffffff80H
	push	OFFSET $SG148232
	push	0
	push	0
	call	?RunDLL_InjectionManager@@YGXPAUHWND__@@PAUHINSTANCE__@@PADH@Z ; RunDLL_InjectionManager
$LN4@SK_Inject_:

; 1199 :                                 "Remove", -128 );
; 1200 :     }
; 1201 : 
; 1202 :     PathAppendW   (wszSys32, L"rundll32.exe");

	mov	edi, DWORD PTR __imp__PathAppendW@8
	lea	eax, DWORD PTR _wszSys32$[ebp]
	push	OFFSET $SG148233
	push	eax
	call	edi

; 1203 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_InjectionManager Install", nullptr, SW_HIDE);

	push	0
	push	0
	push	OFFSET $SG148234
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	ecx, DWORD PTR _wszSys32$[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1203 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_InjectionManager Install", nullptr, SW_HIDE);

	mov	edx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	esi, DWORD PTR [ecx+2]

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edx], ax
$LL260@SK_Inject_:

; 289  : 		return (_CSTD wcslen(_First));

	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL260@SK_Inject_
	sub	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	eax, DWORD PTR _wszSys32$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	eax
	mov	ecx, edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1203 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_InjectionManager Install", nullptr, SW_HIDE);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN103@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN103@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1203 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_InjectionManager Install", nullptr, SW_HIDE);

	mov	esi, DWORD PTR __imp__ShellExecuteA@24
	push	eax
	push	OFFSET $SG148235
	push	0
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN112@SK_Inject_

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN112@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1205 :     PathAppendW   (wszWOW64, L"rundll32.exe");

	push	OFFSET $SG148236
	lea	eax, DWORD PTR _wszWOW64$[ebp]
	push	eax
	call	edi

; 1206 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_InjectionManager Install", nullptr, SW_HIDE);

	push	0
	push	0
	push	OFFSET $SG148237
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	ecx, DWORD PTR _wszWOW64$[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1206 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_InjectionManager Install", nullptr, SW_HIDE);

	mov	edx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [ecx+2]

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edx], ax
$LL261@SK_Inject_:

; 289  : 		return (_CSTD wcslen(_First));

	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL261@SK_Inject_
	sub	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	eax, DWORD PTR _wszWOW64$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	eax
	mov	ecx, edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1206 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_InjectionManager Install", nullptr, SW_HIDE);

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN176@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN176@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1206 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_InjectionManager Install", nullptr, SW_HIDE);

	push	eax
	push	OFFSET $SG148238
	push	0
	call	esi

; 1207 :   }
; 1208 : 
; 1209 :   else

	jmp	$LN263@SK_Inject_
$LN2@SK_Inject_:

; 1210 :   {
; 1211 :     if (SKX_IsHookingCBT ())

	call	?SKX_IsHookingCBT@@YG_NXZ		; SKX_IsHookingCBT
	test	al, al
	je	SHORT $LN5@SK_Inject_

; 1212 :     {
; 1213 :       RunDLL_InjectionManager ( nullptr, nullptr,

	push	-128					; ffffff80H
	push	OFFSET $SG148240
	push	0
	push	0
	call	?RunDLL_InjectionManager@@YGXPAUHWND__@@PAUHINSTANCE__@@PADH@Z ; RunDLL_InjectionManager
$LN5@SK_Inject_:

; 1214 :                                 "Remove", -128 );
; 1215 :     }
; 1216 : 
; 1217 :     HWND hWndExisting =
; 1218 :       FindWindow (L"SKIM_Frontend", nullptr);

	push	0
	push	OFFSET $SG148241
	call	DWORD PTR __imp__FindWindowW@8
	mov	edi, eax

; 1219 : 
; 1220 :     // Best-case, SKIM restarts itself
; 1221 :     if (hWndExisting)

	test	edi, edi
	je	SHORT $LN6@SK_Inject_

; 1222 :     {
; 1223 :       SendMessage (hWndExisting, WM_USER + 0x125, 0, 0);

	mov	esi, DWORD PTR __imp__SendMessageW@16
	push	0
	push	0
	push	1317					; 00000525H
	push	edi
	call	esi

; 1224 :       SleepEx     (100, FALSE);

	push	0
	push	100					; 00000064H
	call	DWORD PTR __imp__SleepEx@8

; 1225 :       SendMessage (hWndExisting, WM_USER + 0x124, 0, 0);

	push	0
	push	0
	push	1316					; 00000524H
	push	edi
	call	esi

; 1233 :   SetCurrentDirectoryW (wszCurrentDir);

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryW@4

; 1234 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SK_Inject_:

; 1230 :       ShellExecuteA (nullptr, "open", "SKIM64.exe", "+Inject", SK_WideCharToUTF8 (SK_SYS_GetInstallPath ()).c_str (), SW_FORCEMINIMIZE);

	push	11					; 0000000bH
	sub	esp, 24					; 00000018H
	push	esp
	call	?SK_SYS_GetInstallPath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; SK_SYS_GetInstallPath
	add	esp, 4
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN225@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN225@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1230 :       ShellExecuteA (nullptr, "open", "SKIM64.exe", "+Inject", SK_WideCharToUTF8 (SK_SYS_GetInstallPath ()).c_str (), SW_FORCEMINIMIZE);

	push	eax
	push	OFFSET $SG148244
	push	OFFSET $SG148245
	push	OFFSET $SG148246
	push	0
	call	DWORD PTR __imp__ShellExecuteA@24
$LN263@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T1[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN234@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T1[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN234@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1233 :   SetCurrentDirectoryW (wszCurrentDir);

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryW@4

; 1234 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SK_Inject_Start@@YAXXZ ENDP				; SK_Inject_Start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_wszCurrentDir$ = -2116					; size = 1040
_wszSys32$ = -1076					; size = 524
_wszWOW64$ = -552					; size = 524
$T1 = -28						; size = 24
$T2 = -28						; size = 24
$T3 = -28						; size = 24
$T4 = -28						; size = 24
?SK_Inject_Stop@@YAXXZ PROC				; SK_Inject_Stop

; 1117 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 2116				; 00000844H

; 1118 :   wchar_t wszCurrentDir [MAX_PATH * 2] = { };

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	ebx
	push	esi
	push	1040					; 00000410H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1119 :   GetCurrentDirectoryW  (MAX_PATH * 2 - 1, wszCurrentDir);

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	eax
	push	519					; 00000207H
	call	DWORD PTR __imp__GetCurrentDirectoryW@8

; 1121 :   SetCurrentDirectory (SK_SYS_GetInstallPath ().c_str ());

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?SK_SYS_GetInstallPath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; SK_SYS_GetInstallPath
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN28@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN28@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1121 :   SetCurrentDirectory (SK_SYS_GetInstallPath ().c_str ());

	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryW@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN37@SK_Inject_

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN37@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1124 :   LoadLibrary (L"SpecialK32.dll");

	push	OFFSET $SG148195
	call	DWORD PTR __imp__LoadLibraryW@4

; 1125 : #else
; 1126 :   LoadLibrary (L"SpecialK64.dll");
; 1127 : #endif
; 1128 : 
; 1129 : #ifdef _WIN64
; 1130 :   wchar_t wszWOW64 [MAX_PATH + 2] = { };
; 1131 :   GetSystemWow64DirectoryW (wszWOW64, MAX_PATH);
; 1132 : #else
; 1133 :   wchar_t wszWOW64 [MAX_PATH + 2] = { };

	push	524					; 0000020cH
	lea	eax, DWORD PTR _wszWOW64$[ebp]
	push	0
	push	eax
	call	_memset

; 1134 :   GetSystemDirectoryW      (wszWOW64, MAX_PATH);

	mov	esi, DWORD PTR __imp__GetSystemDirectoryW@8
	lea	eax, DWORD PTR _wszWOW64$[ebp]
	add	esp, 12					; 0000000cH
	push	260					; 00000104H
	push	eax
	call	esi

; 1135 : #endif
; 1136 : 
; 1137 :   wchar_t wszSys32 [MAX_PATH + 2] = { };

	push	524					; 0000020cH
	lea	eax, DWORD PTR _wszSys32$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1138 :   GetSystemDirectoryW      (wszSys32, MAX_PATH);

	lea	eax, DWORD PTR _wszSys32$[ebp]
	push	260					; 00000104H
	push	eax
	call	esi

; 1139 : 
; 1140 :   //SK_ExitRemoteProcess (L"SKIM64.exe", 0x00);
; 1141 : 
; 1142 :   if (GetFileAttributes (L"SKIM64.exe") == INVALID_FILE_ATTRIBUTES)

	push	OFFSET $SG148198
	call	DWORD PTR __imp__GetFileAttributesW@4
	cmp	eax, -1
	jne	$LN2@SK_Inject_

; 1143 :   {
; 1144 :     PathAppendW   (wszWOW64, L"rundll32.exe");

	mov	ebx, DWORD PTR __imp__PathAppendW@8
	lea	eax, DWORD PTR _wszWOW64$[ebp]
	push	OFFSET $SG148199
	push	eax
	call	ebx

; 1145 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_InjectionManager Remove", nullptr, SW_HIDE);

	push	0
	push	0
	push	OFFSET $SG148200
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	ecx, DWORD PTR _wszWOW64$[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1145 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_InjectionManager Remove", nullptr, SW_HIDE);

	mov	edx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	esi, DWORD PTR [ecx+2]

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edx], ax
$LL258@SK_Inject_:

; 289  : 		return (_CSTD wcslen(_First));

	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL258@SK_Inject_
	sub	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	eax, DWORD PTR _wszWOW64$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	eax
	mov	ecx, edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1145 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_InjectionManager Remove", nullptr, SW_HIDE);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN101@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN101@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1145 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_InjectionManager Remove", nullptr, SW_HIDE);

	mov	esi, DWORD PTR __imp__ShellExecuteA@24
	push	eax
	push	OFFSET $SG148201
	push	0
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN110@SK_Inject_

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN110@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1147 :     PathAppendW   (wszSys32, L"rundll32.exe");

	push	OFFSET $SG148202
	lea	eax, DWORD PTR _wszSys32$[ebp]
	push	eax
	call	ebx

; 1148 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_InjectionManager Remove", nullptr, SW_HIDE);

	push	0
	push	0
	push	OFFSET $SG148203
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	ecx, DWORD PTR _wszSys32$[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1148 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_InjectionManager Remove", nullptr, SW_HIDE);

	mov	edx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	ebx, DWORD PTR [ecx+2]

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edx], ax
$LL259@SK_Inject_:

; 289  : 		return (_CSTD wcslen(_First));

	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL259@SK_Inject_
	sub	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	eax, DWORD PTR _wszSys32$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	eax
	mov	ecx, edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1148 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_InjectionManager Remove", nullptr, SW_HIDE);

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN174@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN174@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1148 :     ShellExecuteA (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_InjectionManager Remove", nullptr, SW_HIDE);

	push	eax
	push	OFFSET $SG148204
	push	0
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	$LN5@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1172 :   SetCurrentDirectoryW (wszCurrentDir);

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryW@4

; 1173 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SK_Inject_:

; 1149 :   }
; 1150 : 
; 1151 :   else
; 1152 :   {
; 1153 :     HWND hWndExisting =
; 1154 :       FindWindow (L"SKIM_Frontend", nullptr);

	push	0
	push	OFFSET $SG148205
	call	DWORD PTR __imp__FindWindowW@8

; 1155 : 
; 1156 :     // Best-case, SKIM restarts itself
; 1157 :     if (hWndExisting)

	test	eax, eax
	je	SHORT $LN4@SK_Inject_

; 1158 :     {
; 1159 :       SendMessage (hWndExisting, WM_USER + 0x122, 0, 0);

	push	0
	push	0
	push	1314					; 00000522H
	push	eax
	call	DWORD PTR __imp__SendMessageW@16

; 1160 :       SleepEx     (100UL, FALSE);

	push	0
	push	100					; 00000064H
	call	DWORD PTR __imp__SleepEx@8

; 1172 :   SetCurrentDirectoryW (wszCurrentDir);

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryW@4

; 1173 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@SK_Inject_:

; 1166 :       ShellExecuteA        (nullptr, "open", "SKIM64.exe", "-Inject", SK_WideCharToUTF8 (SK_SYS_GetInstallPath ()).c_str (), SW_FORCEMINIMIZE);

	push	11					; 0000000bH
	sub	esp, 24					; 00000018H
	push	esp
	call	?SK_SYS_GetInstallPath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; SK_SYS_GetInstallPath
	add	esp, 4
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN223@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN223@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1166 :       ShellExecuteA        (nullptr, "open", "SKIM64.exe", "-Inject", SK_WideCharToUTF8 (SK_SYS_GetInstallPath ()).c_str (), SW_FORCEMINIMIZE);

	push	eax
	push	OFFSET $SG148208
	push	OFFSET $SG148209
	push	OFFSET $SG148210
	push	0
	call	DWORD PTR __imp__ShellExecuteA@24
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T1[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN232@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T1[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN232@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1167 :       SleepEx              (100UL, FALSE);

	push	0
	push	100					; 00000064H
	call	DWORD PTR __imp__SleepEx@8

; 1168 :       SK_ExitRemoteProcess (L"SKIM64.exe", 0x00);

	push	0
	push	OFFSET $SG148211
	call	?SK_ExitRemoteProcess@@YA_NPB_WI@Z	; SK_ExitRemoteProcess
	add	esp, 8
$LN5@SK_Inject_:

; 1172 :   SetCurrentDirectoryW (wszCurrentDir);

	lea	eax, DWORD PTR _wszCurrentDir$[ebp]
	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryW@4

; 1173 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SK_Inject_Stop@@YAXXZ ENDP				; SK_Inject_Stop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_pe32$ = -564						; size = 556
_wszProcName$ = 8					; size = 4
_uExitCode$ = 12					; size = 4
?SK_ExitRemoteProcess@@YA_NPB_WI@Z PROC			; SK_ExitRemoteProcess

; 1077 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 564				; 00000234H

; 1078 :   UNREFERENCED_PARAMETER (uExitCode);
; 1079 : 
; 1080 : 
; 1081 :   PROCESSENTRY32 pe32      = { };

	lea	eax, DWORD PTR _pe32$[ebp]
	push	esi
	push	556					; 0000022cH
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1082 :   HANDLE         hProcSnap =
; 1083 :     CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);

	push	0
	push	2
	call	_CreateToolhelp32Snapshot@8
	mov	esi, eax

; 1084 : 
; 1085 :   if (hProcSnap == INVALID_HANDLE_VALUE)

	cmp	esi, -1
	je	SHORT $LN21@SK_ExitRem

; 1086 :     return false;
; 1087 : 
; 1088 :   pe32.dwSize = sizeof PROCESSENTRY32;
; 1089 : 
; 1090 :   if (! Process32First (hProcSnap, &pe32))

	lea	eax, DWORD PTR _pe32$[ebp]
	mov	DWORD PTR _pe32$[ebp], 556		; 0000022cH
	push	eax
	push	esi
	call	_Process32FirstW@8
	test	eax, eax
	jne	SHORT $LN18@SK_ExitRem

; 1091 :   {
; 1092 :     CloseHandle (hProcSnap);

	push	esi
	call	DWORD PTR __imp__CloseHandle@4
$LN21@SK_ExitRem:

; 1093 :     return false;

	xor	al, al
	pop	esi

; 1112 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@SK_ExitRem:
	push	ebx

; 1093 :     return false;

	mov	ebx, DWORD PTR __imp__StrStrIW@8
	push	edi
	mov	edi, DWORD PTR _wszProcName$[ebp]
$LL4@SK_ExitRem:

; 1094 :   }
; 1095 : 
; 1096 :   do
; 1097 :   {
; 1098 :     if (StrStrIW (wszProcName, pe32.szExeFile))

	lea	eax, DWORD PTR _pe32$[ebp+36]
	push	eax
	push	edi
	call	ebx
	test	eax, eax
	jne	SHORT $LN10@SK_ExitRem

; 1106 :     }
; 1107 :   } while (Process32Next (hProcSnap, &pe32));

	lea	eax, DWORD PTR _pe32$[ebp]
	push	eax
	push	esi
	call	_Process32NextW@8
	test	eax, eax
	jne	SHORT $LL4@SK_ExitRem

; 1108 : 
; 1109 :   CloseHandle (hProcSnap);

	push	esi
	call	DWORD PTR __imp__CloseHandle@4
	pop	edi
	pop	ebx

; 1110 : 
; 1111 :   return false;

	xor	al, al
	pop	esi

; 1112 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@SK_ExitRem:

; 1099 :     {
; 1100 :       window_t win = SK_FindRootWindow (pe32.th32ProcessID);

	push	DWORD PTR _pe32$[ebp+8]
	call	?SK_FindRootWindow@@YA?AUwindow_t@@K@Z	; SK_FindRootWindow
	add	esp, 4

; 1101 : 
; 1102 :       SendMessage (win.root, WM_USER + 0x123, 0x00, 0x00);

	push	0
	push	0
	push	1315					; 00000523H
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 1103 : 
; 1104 :       CloseHandle (hProcSnap);

	push	esi
	call	DWORD PTR __imp__CloseHandle@4
	pop	edi
	pop	ebx

; 1105 :       return true;

	mov	al, 1
	pop	esi

; 1112 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_ExitRemoteProcess@@YA_NPB_WI@Z ENDP			; SK_ExitRemoteProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_wszOut$ = -1044					; size = 1040
?SK_Inject_EnableCentralizedConfig@@YAXXZ PROC		; SK_Inject_EnableCentralizedConfig

; 615  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 1044				; 00000414H

; 616  :   wchar_t wszOut [MAX_PATH * 2] = { };

	lea	eax, DWORD PTR _wszOut$[ebp]
	push	esi
	push	1040					; 00000410H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 617  : 
; 618  :   lstrcatW (wszOut, SK_GetHostPath ());

	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	mov	esi, DWORD PTR __imp__lstrcatW@8
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 619  :   lstrcatW (wszOut, L"\\SpecialK.central");

	push	OFFSET $SG147818
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 620  : 
; 621  :   FILE* fOut = _wfopen (wszOut, L"w");

	lea	eax, DWORD PTR _wszOut$[ebp]
	push	OFFSET $SG147819
	push	eax
	call	DWORD PTR __imp___wfopen
	mov	esi, eax

; 622  :                fputws (L" ", fOut);

	push	esi
	push	OFFSET $SG147820
	call	DWORD PTR __imp__fputws

; 623  :                      fclose (fOut);

	push	esi
	call	DWORD PTR __imp__fclose
	add	esp, 20					; 00000014H

; 624  : 
; 625  :   config.system.central_repository = true;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+820, 1

; 626  : 
; 627  :   SK_EstablishRootPath ();

	call	?SK_EstablishRootPath@@YGXXZ		; SK_EstablishRootPath

; 628  : 
; 629  :   switch (SK_GetCurrentRenderBackend ().api)

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	eax, DWORD PTR [eax]
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN10@SK_Inject_
	je	$LN7@SK_Inject_
	sub	eax, 2
	je	SHORT $LN8@SK_Inject_
	sub	eax, 6
	je	SHORT $LN4@SK_Inject_
	sub	eax, 16					; 00000010H
	jne	$LN2@SK_Inject_
$LN4@SK_Inject_:

; 630  :   {
; 631  :     case SK_RenderAPI::D3D9:
; 632  :     case SK_RenderAPI::D3D9Ex:
; 633  :       SK_SaveConfig (L"d3d9");

	push	0
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET $SG147822
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 652  :       SK_SaveConfig (L"dxgi");

	call	?SK_SaveConfig@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z ; SK_SaveConfig
	add	esp, 28					; 0000001cH

; 657  :       break;
; 658  : 
; 659  :     //case SK_RenderAPI::Vulkan:
; 660  :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 661  :       //break;
; 662  :   }
; 663  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SK_Inject_:

; 653  :     } break;
; 654  : 
; 655  :     case SK_RenderAPI::OpenGL:
; 656  :       SK_SaveConfig (L"OpenGL32");

	push	0
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET $SG147830
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	call	?SK_SaveConfig@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z ; SK_SaveConfig
	add	esp, 28					; 0000001cH

; 657  :       break;
; 658  : 
; 659  :     //case SK_RenderAPI::Vulkan:
; 660  :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 661  :       //break;
; 662  :   }
; 663  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@SK_Inject_:

; 628  : 
; 629  :   switch (SK_GetCurrentRenderBackend ().api)

	cmp	eax, 64					; 00000040H
	je	SHORT $LN7@SK_Inject_
	cmp	eax, 8256				; 00002040H
	je	SHORT $LN5@SK_Inject_
	cmp	eax, 16448				; 00004040H
	jne	SHORT $LN2@SK_Inject_

; 639  :     break;
; 640  : 
; 641  :   case SK_RenderAPI::DDrawOn11:
; 642  :     SK_SaveConfig (L"ddraw");

	push	0
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET $SG147826
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 652  :       SK_SaveConfig (L"dxgi");

	call	?SK_SaveConfig@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z ; SK_SaveConfig
	add	esp, 28					; 0000001cH

; 657  :       break;
; 658  : 
; 659  :     //case SK_RenderAPI::Vulkan:
; 660  :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 661  :       //break;
; 662  :   }
; 663  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SK_Inject_:

; 634  :       break;
; 635  : 
; 636  : #ifndef _WIN64
; 637  :   case SK_RenderAPI::D3D8On11:
; 638  :     SK_SaveConfig (L"d3d8");

	push	0
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	OFFSET $SG147824
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 652  :       SK_SaveConfig (L"dxgi");

	call	?SK_SaveConfig@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z ; SK_SaveConfig
	add	esp, 28					; 0000001cH

; 657  :       break;
; 658  : 
; 659  :     //case SK_RenderAPI::Vulkan:
; 660  :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 661  :       //break;
; 662  :   }
; 663  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@SK_Inject_:

; 652  :       SK_SaveConfig (L"dxgi");

	push	0
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 652  :       SK_SaveConfig (L"dxgi");

	mov	ecx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	4

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET $SG147828
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 652  :       SK_SaveConfig (L"dxgi");

	call	?SK_SaveConfig@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z ; SK_SaveConfig
	add	esp, 28					; 0000001cH
$LN2@SK_Inject_:

; 657  :       break;
; 658  : 
; 659  :     //case SK_RenderAPI::Vulkan:
; 660  :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 661  :       //break;
; 662  :   }
; 663  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SK_Inject_EnableCentralizedConfig@@YAXXZ ENDP		; SK_Inject_EnableCentralizedConfig
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ??B<lambda_f14ec5e87491314fd4de237527dc1a25>@@QBEP6GKPAX@ZXZ
_TEXT	SEGMENT
??B<lambda_f14ec5e87491314fd4de237527dc1a25>@@QBEP6GKPAX@ZXZ PROC ; <lambda_f14ec5e87491314fd4de237527dc1a25>::operator unsigned long (__stdcall*)(void *), COMDAT
; _this$ = ecx

; 562  :              },

	mov	eax, OFFSET ?<lambda_invoker_stdcall>@<lambda_f14ec5e87491314fd4de237527dc1a25>@@CGKPAX@Z ; <lambda_f14ec5e87491314fd4de237527dc1a25>::<lambda_invoker_stdcall>
	ret	0
??B<lambda_f14ec5e87491314fd4de237527dc1a25>@@QBEP6GKPAX@ZXZ ENDP ; <lambda_f14ec5e87491314fd4de237527dc1a25>::operator unsigned long (__stdcall*)(void *)
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ?<lambda_invoker_stdcall>@<lambda_f14ec5e87491314fd4de237527dc1a25>@@CGKPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
?<lambda_invoker_stdcall>@<lambda_f14ec5e87491314fd4de237527dc1a25>@@CGKPAX@Z PROC ; <lambda_f14ec5e87491314fd4de237527dc1a25>::<lambda_invoker_stdcall>, COMDAT

; 562  :              },

	npad	2
	push	ebp
	mov	ebp, esp
	xor	ecx, ecx
	pop	ebp
	jmp	??R<lambda_f14ec5e87491314fd4de237527dc1a25>@@QBEKPAX@Z ; <lambda_f14ec5e87491314fd4de237527dc1a25>::operator()
?<lambda_invoker_stdcall>@<lambda_f14ec5e87491314fd4de237527dc1a25>@@CGKPAX@Z ENDP ; <lambda_f14ec5e87491314fd4de237527dc1a25>::<lambda_invoker_stdcall>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ??R<lambda_f14ec5e87491314fd4de237527dc1a25>@@QBEKPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
??R<lambda_f14ec5e87491314fd4de237527dc1a25>@@QBEKPAX@Z PROC ; <lambda_f14ec5e87491314fd4de237527dc1a25>::operator(), COMDAT
; _this$ = ecx

; 548  :              {

	npad	2
	push	ebp
	mov	ebp, esp

; 549  :                if (g_hShutdown != nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	je	SHORT $LN21@operator

; 550  :                  WaitForSingleObject (g_hShutdown, INFINITE);

	mov	eax, DWORD PTR ?g_hShutdown@@3RAXA	; g_hShutdown
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN21@operator:
	push	esi
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@operator:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__SK_DLL_Attached@@3JC	; __SK_DLL_Attached
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 552  :                while ( ReadAcquire (&__SK_DLL_Attached) || (! SK_IsHostAppSKIM ()))

	test	eax, eax
	jne	SHORT $LN5@operator
	call	?SK_IsHostAppSKIM@@YA_NXZ		; SK_IsHostAppSKIM
	test	al, al
	jne	SHORT $LN3@operator
$LN5@operator:

; 553  :                  SleepEx (250UL, FALSE);

	push	0
	push	250					; 000000faH
	call	esi
	jmp	SHORT $LL2@operator
$LN3@operator:

; 554  : 
; 555  : 
; 556  :                if (PtrToInt (user) != -128)

	cmp	DWORD PTR _user$[ebp], -128		; ffffff80H
	pop	esi
	je	SHORT $LN6@operator

; 557  :                  ExitProcess (0x00);

	push	0
	call	DWORD PTR __imp__ExitProcess@4
$LN24@operator:
$LN6@operator:

; 558  :                else
; 559  :                  CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 560  : 
; 561  :                return 0;

	xor	eax, eax

; 562  :              },

	pop	ebp
	ret	4
$LN23@operator:
??R<lambda_f14ec5e87491314fd4de237527dc1a25>@@QBEKPAX@Z ENDP ; <lambda_f14ec5e87491314fd4de237527dc1a25>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_hwnd$ = 8						; size = 4
_hInst$ = 12						; size = 4
_dwPID$1 = 16						; size = 4
_lpszCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
?RunDLL_InjectionManager@@YGXPAUHWND__@@PAUHINSTANCE__@@PADH@Z PROC ; RunDLL_InjectionManager

; 524  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 525  :   UNREFERENCED_PARAMETER (hInst);
; 526  :   UNREFERENCED_PARAMETER (hwnd);
; 527  : 
; 528  :   if (StrStrA (lpszCmdLine, "Install") && (! SKX_IsHookingCBT ()))

	mov	esi, DWORD PTR _lpszCmdLine$[ebp]
	push	OFFSET $SG147788
	push	esi
	call	DWORD PTR __imp__StrStrA@8
	test	eax, eax
	je	SHORT $LN2@RunDLL_Inj
	call	?SKX_IsHookingCBT@@YG_NXZ		; SKX_IsHookingCBT
	test	al, al
	jne	SHORT $LN2@RunDLL_Inj

; 529  :   {
; 530  :     SKX_InstallCBTHook ();

	call	?SKX_InstallCBTHook@@YGXXZ		; SKX_InstallCBTHook

; 531  : 
; 532  :     if (SKX_IsHookingCBT ())

	call	?SKX_IsHookingCBT@@YG_NXZ		; SKX_IsHookingCBT
	test	al, al
	je	$LN8@RunDLL_Inj

; 533  :     {
; 534  : #ifndef _WIN64
; 535  :       FILE* fPID = fopen ("SpecialK32.pid", "w");

	push	OFFSET $SG147790
	push	OFFSET $SG147791
	call	DWORD PTR __imp__fopen
	mov	esi, eax
	add	esp, 8

; 536  : #else
; 537  :       FILE* fPID = fopen ("SpecialK64.pid", "w");
; 538  : #endif
; 539  : 
; 540  :       if (fPID)

	test	esi, esi
	je	$LN8@RunDLL_Inj

; 541  :       {
; 542  :         fprintf (fPID, "%lu\n", GetCurrentProcessId ());

	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	push	OFFSET $SG147793
	push	esi
	call	_fprintf

; 543  :         fclose  (fPID);

	push	esi
	call	DWORD PTR __imp__fclose
	add	esp, 16					; 00000010H

; 544  : 
; 545  :         CreateThread ( nullptr, 0,

	push	0
	push	0
	push	DWORD PTR _nCmdShow$[ebp]
	push	OFFSET ?<lambda_invoker_stdcall>@<lambda_f14ec5e87491314fd4de237527dc1a25>@@CGKPAX@Z ; <lambda_f14ec5e87491314fd4de237527dc1a25>::<lambda_invoker_stdcall>
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24

; 546  :          [](LPVOID user) ->
; 547  :            DWORD
; 548  :              {
; 549  :                if (g_hShutdown != nullptr)
; 550  :                  WaitForSingleObject (g_hShutdown, INFINITE);
; 551  : 
; 552  :                while ( ReadAcquire (&__SK_DLL_Attached) || (! SK_IsHostAppSKIM ()))
; 553  :                  SleepEx (250UL, FALSE);
; 554  : 
; 555  : 
; 556  :                if (PtrToInt (user) != -128)
; 557  :                  ExitProcess (0x00);
; 558  :                else
; 559  :                  CloseHandle (GetCurrentThread ());
; 560  : 
; 561  :                return 0;
; 562  :              },
; 563  :              UIntToPtr (nCmdShow),
; 564  :            0x00,
; 565  :          nullptr );
; 566  : 
; 567  :         SleepEx (INFINITE, FALSE);

	push	0
	push	-1
	call	DWORD PTR __imp__SleepEx@8

; 568  :       }
; 569  :     }
; 570  :   }

	jmp	SHORT $LN8@RunDLL_Inj
$LN2@RunDLL_Inj:

; 571  : 
; 572  :   else if (StrStrA (lpszCmdLine, "Remove"))

	push	OFFSET $SG147795
	push	esi
	call	DWORD PTR __imp__StrStrA@8
	test	eax, eax
	je	SHORT $LN8@RunDLL_Inj

; 573  :   {
; 574  :     SKX_RemoveCBTHook ();

	call	?SKX_RemoveCBTHook@@YGXXZ		; SKX_RemoveCBTHook

; 575  : 
; 576  : #ifndef _WIN64
; 577  :     FILE* fPID = fopen ("SpecialK32.pid", "r");

	push	OFFSET $SG147796
	push	OFFSET $SG147797
	call	DWORD PTR __imp__fopen
	mov	esi, eax
	add	esp, 8

; 578  : #else
; 579  :     FILE* fPID = fopen ("SpecialK64.pid", "r");
; 580  : #endif
; 581  : 
; 582  :     if (fPID != nullptr)

	test	esi, esi
	je	SHORT $LN8@RunDLL_Inj

; 583  :     {
; 584  :                       DWORD dwPID = 0;
; 585  :       fscanf (fPID, "%lu", &dwPID);

	lea	eax, DWORD PTR _dwPID$1[ebp]
	mov	DWORD PTR _dwPID$1[ebp], 0
	push	eax
	push	OFFSET $SG147799
	push	esi
	call	_fscanf

; 586  :       fclose (fPID);

	push	esi
	call	DWORD PTR __imp__fclose
	add	esp, 16					; 00000010H

; 587  : 
; 588  :       if (dwPID == GetCurrentProcessId () || SK_TerminatePID (dwPID, 0x00))

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	ecx, DWORD PTR _dwPID$1[ebp]
	cmp	ecx, eax
	je	SHORT $LN9@RunDLL_Inj
	push	0
	push	ecx
	call	?SK_TerminatePID@@YAHKI@Z		; SK_TerminatePID
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@RunDLL_Inj
$LN9@RunDLL_Inj:

; 589  :       {
; 590  : #ifndef _WIN64
; 591  :         DeleteFileA ("SpecialK32.pid");

	push	OFFSET $SG147802
	call	DWORD PTR __imp__DeleteFileA@4
$LN8@RunDLL_Inj:

; 592  : #else
; 593  :         DeleteFileA ("SpecialK64.pid");
; 594  : #endif
; 595  :       }
; 596  :     }
; 597  :   }
; 598  : 
; 599  :   if (nCmdShow != -128)

	cmp	DWORD PTR _nCmdShow$[ebp], -128		; ffffff80H
	pop	esi
	je	SHORT $LN10@RunDLL_Inj

; 600  :    ExitProcess (0x00);

	push	0
	call	DWORD PTR __imp__ExitProcess@4
$LN17@RunDLL_Inj:
$LN10@RunDLL_Inj:

; 601  : }

	pop	ebp
	ret	16					; 00000010H
$LN16@RunDLL_Inj:
?RunDLL_InjectionManager@@YGXPAUHWND__@@PAUHINSTANCE__@@PADH@Z ENDP ; RunDLL_InjectionManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
?SKX_IsHookingShell@@YG_NXZ PROC			; SKX_IsHookingShell

; 512  :   return (g_hHookShell != nullptr);

	mov	eax, DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A ; g_hHookShell
	neg	eax
	sbb	eax, eax
	neg	eax

; 513  : }

	ret	0
?SKX_IsHookingShell@@YG_NXZ ENDP			; SKX_IsHookingShell
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
?SKX_RemoveShellHook@@YGXXZ PROC			; SKX_RemoveShellHook

; 495  :   if (g_hShutdown != nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	je	SHORT $LN2@SKX_Remove

; 496  :     SetEvent (g_hShutdown);

	mov	eax, DWORD PTR ?g_hShutdown@@3RAXA	; g_hShutdown
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN2@SKX_Remove:

; 497  : 
; 498  :   if (g_hHookShell)

	cmp	DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A, 0 ; g_hHookShell
	je	SHORT $LN4@SKX_Remove

; 499  :   {
; 500  :     if (UnhookWindowsHookEx (g_hHookShell))

	mov	eax, DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A ; g_hHookShell
	push	eax
	call	DWORD PTR __imp__UnhookWindowsHookEx@4
	test	eax, eax
	je	SHORT $LN4@SKX_Remove

; 501  :     {
; 502  :       __SK_HookContextOwner = false;

	mov	DWORD PTR ?__SK_HookContextOwner@@3JC, 0 ; __SK_HookContextOwner

; 503  :       g_hHookShell = nullptr;

	mov	DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A, 0 ; g_hHookShell
$LN4@SKX_Remove:

; 504  :     }
; 505  :   }
; 506  : }

	ret	0
?SKX_RemoveShellHook@@YGXXZ ENDP			; SKX_RemoveShellHook
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_hMod$ = -4						; size = 4
?SKX_InstallShellHook@@YGXXZ PROC			; SKX_InstallShellHook

; 451  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 452  :   // Nothing to do here, move along.
; 453  :   if (g_hHookShell != nullptr)

	cmp	DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A, 0 ; g_hHookShell
	jne	SHORT $LN5@SKX_Instal

; 454  :     return;
; 455  : 
; 456  :   HMODULE hMod = nullptr;
; 457  : 
; 458  :   GetModuleHandleEx ( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,

	lea	eax, DWORD PTR _hMod$[ebp]
	mov	DWORD PTR _hMod$[ebp], 0
	push	eax
	push	OFFSET $SG147692
	push	2
	call	DWORD PTR __imp__GetModuleHandleExW@12

; 459  : #ifdef _WIN64
; 460  :                           L"SpecialK64.dll",
; 461  : #else
; 462  :                           L"SpecialK32.dll",
; 463  : #endif
; 464  :                           (HMODULE *) &hMod );
; 465  : 
; 466  :   extern HMODULE
; 467  :   __stdcall
; 468  :   SK_GetDLL (void);
; 469  : 
; 470  :   if (hMod == SK_GetDLL ())

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	cmp	DWORD PTR _hMod$[ebp], eax
	jne	SHORT $LN5@SKX_Instal

; 471  :   {
; 472  :     if (g_hShutdown == nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	jne	SHORT $LN4@SKX_Instal

; 473  :     {
; 474  : #ifdef _WIN64
; 475  :       g_hShutdown = CreateEvent (nullptr, TRUE, FALSE, L"SpecialK64_Reset");
; 476  : #else
; 477  :       g_hShutdown = CreateEvent (nullptr, TRUE, FALSE, L"SpecialK32_Reset");

	push	OFFSET $SG147695
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	DWORD PTR ?g_hShutdown@@3RAXA, eax	; g_hShutdown
$LN4@SKX_Instal:

; 478  : #endif
; 479  :     }
; 480  : 
; 481  :     g_hHookShell =

	push	0
	push	DWORD PTR _hMod$[ebp]
	push	OFFSET ?ShellProc@@YGJHIJ@Z		; ShellProc
	push	10					; 0000000aH
	call	DWORD PTR __imp__SetWindowsHookExW@16
	mov	DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A, eax ; g_hHookShell

; 482  :       SetWindowsHookEx (WH_SHELL, ShellProc, hMod, 0);
; 483  : 
; 484  :     if (g_hHookShell != nullptr)

	cmp	DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A, 0 ; g_hHookShell
	je	SHORT $LN5@SKX_Instal

; 485  :     {
; 486  :       __SK_HookContextOwner = true;

	mov	DWORD PTR ?__SK_HookContextOwner@@3JC, 1 ; __SK_HookContextOwner
$LN5@SKX_Instal:

; 487  :     }
; 488  :   }
; 489  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SKX_InstallShellHook@@YGXXZ ENDP			; SKX_InstallShellHook
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_dwProcessId$ = 8					; size = 4
_uExitCode$ = 12					; size = 4
?SK_TerminatePID@@YAHKI@Z PROC				; SK_TerminatePID

; 299  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 300  :   DWORD dwDesiredAccess = PROCESS_TERMINATE;
; 301  :   BOOL  bInheritHandle  = FALSE;
; 302  : 
; 303  :   HANDLE hProcess =
; 304  :     OpenProcess ( dwDesiredAccess, bInheritHandle, dwProcessId );

	push	DWORD PTR _dwProcessId$[ebp]
	push	0
	push	1
	call	DWORD PTR __imp__OpenProcess@12
	mov	edi, eax

; 305  : 
; 306  :   if (hProcess == nullptr)

	test	edi, edi
	jne	SHORT $LN2@SK_Termina
	pop	edi

; 315  : }

	pop	ebp
	ret	0
$LN2@SK_Termina:
	push	esi

; 307  :     return FALSE;
; 308  :   
; 309  :   BOOL result =
; 310  :     TerminateProcess (hProcess, uExitCode);

	push	DWORD PTR _uExitCode$[ebp]
	push	edi
	call	DWORD PTR __imp__TerminateProcess@8

; 311  :   
; 312  :   CloseHandle (hProcess);

	push	edi
	mov	esi, eax
	call	DWORD PTR __imp__CloseHandle@4

; 313  :   
; 314  :   return result;

	mov	eax, esi
	pop	esi
	pop	edi

; 315  : }

	pop	ebp
	ret	0
?SK_TerminatePID@@YAHKI@Z ENDP				; SK_TerminatePID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ??B<lambda_90c74cd29502a5a993a6ec8518c919e5>@@QBEP6GKPAX@ZXZ
_TEXT	SEGMENT
??B<lambda_90c74cd29502a5a993a6ec8518c919e5>@@QBEP6GKPAX@ZXZ PROC ; <lambda_90c74cd29502a5a993a6ec8518c919e5>::operator unsigned long (__stdcall*)(void *), COMDAT
; _this$ = ecx

; 285  :              },

	mov	eax, OFFSET ?<lambda_invoker_stdcall>@<lambda_90c74cd29502a5a993a6ec8518c919e5>@@CGKPAX@Z ; <lambda_90c74cd29502a5a993a6ec8518c919e5>::<lambda_invoker_stdcall>
	ret	0
??B<lambda_90c74cd29502a5a993a6ec8518c919e5>@@QBEP6GKPAX@ZXZ ENDP ; <lambda_90c74cd29502a5a993a6ec8518c919e5>::operator unsigned long (__stdcall*)(void *)
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ?<lambda_invoker_stdcall>@<lambda_90c74cd29502a5a993a6ec8518c919e5>@@CGKPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
?<lambda_invoker_stdcall>@<lambda_90c74cd29502a5a993a6ec8518c919e5>@@CGKPAX@Z PROC ; <lambda_90c74cd29502a5a993a6ec8518c919e5>::<lambda_invoker_stdcall>, COMDAT

; 277  :                if (g_hShutdown != nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	je	SHORT $LN4@

; 278  :                  WaitForSingleObject (g_hShutdown, INFINITE);

	mov	eax, DWORD PTR ?g_hShutdown@@3RAXA	; g_hShutdown
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN4@:

; 279  : 
; 280  :                hModHookInstance = nullptr;

	mov	DWORD PTR ?hModHookInstance@@3PAUHINSTANCE__@@A, 0 ; hModHookInstance

; 281  : 
; 282  :                CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 285  :              },

	xor	eax, eax
	ret	4
?<lambda_invoker_stdcall>@<lambda_90c74cd29502a5a993a6ec8518c919e5>@@CGKPAX@Z ENDP ; <lambda_90c74cd29502a5a993a6ec8518c919e5>::<lambda_invoker_stdcall>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ??R<lambda_90c74cd29502a5a993a6ec8518c919e5>@@QBEKPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
??R<lambda_90c74cd29502a5a993a6ec8518c919e5>@@QBEKPAX@Z PROC ; <lambda_90c74cd29502a5a993a6ec8518c919e5>::operator(), COMDAT
; _this$ = ecx

; 275  :                UNREFERENCED_PARAMETER (user);
; 276  : 
; 277  :                if (g_hShutdown != nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	je	SHORT $LN2@operator

; 278  :                  WaitForSingleObject (g_hShutdown, INFINITE);

	mov	eax, DWORD PTR ?g_hShutdown@@3RAXA	; g_hShutdown
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN2@operator:

; 279  : 
; 280  :                hModHookInstance = nullptr;

	mov	DWORD PTR ?hModHookInstance@@3PAUHINSTANCE__@@A, 0 ; hModHookInstance

; 281  : 
; 282  :                CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 283  : 
; 284  :                return 0;

	xor	eax, eax

; 285  :              },

	ret	4
??R<lambda_90c74cd29502a5a993a6ec8518c919e5>@@QBEKPAX@Z ENDP ; <lambda_90c74cd29502a5a993a6ec8518c919e5>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_nCode$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?ShellProc@@YGJHIJ@Z PROC				; ShellProc

; 248  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 249  :   if (nCode < 0)

	mov	esi, DWORD PTR _nCode$[ebp]
	test	esi, esi
	js	SHORT $LN3@ShellProc

; 250  :     return CallNextHookEx (g_hHookShell, nCode, wParam, lParam);
; 251  : 
; 252  : 
; 253  :   if (hModHookInstance == nullptr && g_hHookShell)

	cmp	DWORD PTR ?hModHookInstance@@3PAUHINSTANCE__@@A, 0 ; hModHookInstance
	jne	SHORT $LN3@ShellProc
	cmp	DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A, 0 ; g_hHookShell
	je	SHORT $LN3@ShellProc

; 254  :   {
; 255  :     static volatile LONG lHookIters = 0L;
; 256  : 
; 257  :     // Don't create that thread more than once, but don't bother with a complete
; 258  :     //   critical section.
; 259  :     if (InterlockedIncrement (&lHookIters) > 1L)

	mov	eax, 1
	lock	 xadd	 DWORD PTR ?lHookIters@?6??ShellProc@@YGJHIJ@Z@4JC, eax
	inc	eax
	cmp	eax, 1
	jg	SHORT $LN3@ShellProc

; 260  :       return CallNextHookEx (g_hHookShell, nCode, wParam, lParam);
; 261  : 
; 262  :     GetModuleHandleEx ( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,

	push	OFFSET ?hModHookInstance@@3PAUHINSTANCE__@@A ; hModHookInstance
	push	OFFSET $SG147632
	push	2
	call	DWORD PTR __imp__GetModuleHandleExW@12

; 263  : #ifdef _WIN64
; 264  :                           L"SpecialK64.dll",
; 265  : #else
; 266  :                           L"SpecialK32.dll",
; 267  : #endif
; 268  :                             (HMODULE *) &hModHookInstance );
; 269  : 
; 270  :     // Get and keep a reference to this DLL if this is the first time we are injecting.
; 271  :     CreateThread ( nullptr, 0,

	push	0
	push	0
	push	0
	push	OFFSET ?<lambda_invoker_stdcall>@<lambda_90c74cd29502a5a993a6ec8518c919e5>@@CGKPAX@Z ; <lambda_90c74cd29502a5a993a6ec8518c919e5>::<lambda_invoker_stdcall>
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24
$LN3@ShellProc:

; 272  :          [](LPVOID user) ->
; 273  :            DWORD
; 274  :              {
; 275  :                UNREFERENCED_PARAMETER (user);
; 276  : 
; 277  :                if (g_hShutdown != nullptr)
; 278  :                  WaitForSingleObject (g_hShutdown, INFINITE);
; 279  : 
; 280  :                hModHookInstance = nullptr;
; 281  : 
; 282  :                CloseHandle (GetCurrentThread ());
; 283  : 
; 284  :                return 0;
; 285  :              },
; 286  :            nullptr,
; 287  :          0x00,
; 288  :        nullptr
; 289  :     );
; 290  :   }
; 291  : 
; 292  : 
; 293  :   return CallNextHookEx (g_hHookShell, nCode, wParam, lParam);

	push	DWORD PTR _lParam$[ebp]
	mov	eax, DWORD PTR ?g_hHookShell@@3RAUHHOOK__@@A ; g_hHookShell
	push	DWORD PTR _wParam$[ebp]
	push	esi
	push	eax
	call	DWORD PTR __imp__CallNextHookEx@16
	pop	esi

; 294  : }

	pop	ebp
	ret	12					; 0000000cH
?ShellProc@@YGJHIJ@Z ENDP				; ShellProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ??B<lambda_0b64b922eede83fc8ad9efc12102c151>@@QBEP6GKPAX@ZXZ
_TEXT	SEGMENT
??B<lambda_0b64b922eede83fc8ad9efc12102c151>@@QBEP6GKPAX@ZXZ PROC ; <lambda_0b64b922eede83fc8ad9efc12102c151>::operator unsigned long (__stdcall*)(void *), COMDAT
; _this$ = ecx

; 232  :              },

	mov	eax, OFFSET ?<lambda_invoker_stdcall>@<lambda_0b64b922eede83fc8ad9efc12102c151>@@CGKPAX@Z ; <lambda_0b64b922eede83fc8ad9efc12102c151>::<lambda_invoker_stdcall>
	ret	0
??B<lambda_0b64b922eede83fc8ad9efc12102c151>@@QBEP6GKPAX@ZXZ ENDP ; <lambda_0b64b922eede83fc8ad9efc12102c151>::operator unsigned long (__stdcall*)(void *)
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ?<lambda_invoker_stdcall>@<lambda_0b64b922eede83fc8ad9efc12102c151>@@CGKPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
?<lambda_invoker_stdcall>@<lambda_0b64b922eede83fc8ad9efc12102c151>@@CGKPAX@Z PROC ; <lambda_0b64b922eede83fc8ad9efc12102c151>::<lambda_invoker_stdcall>, COMDAT

; 224  :                if (g_hShutdown != nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	je	SHORT $LN4@

; 225  :                  WaitForSingleObject (g_hShutdown, INFINITE);

	mov	eax, DWORD PTR ?g_hShutdown@@3RAXA	; g_hShutdown
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN4@:

; 226  : 
; 227  :                hModHookInstance = nullptr;

	mov	DWORD PTR ?hModHookInstance@@3PAUHINSTANCE__@@A, 0 ; hModHookInstance

; 228  : 
; 229  :                CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 232  :              },

	xor	eax, eax
	ret	4
?<lambda_invoker_stdcall>@<lambda_0b64b922eede83fc8ad9efc12102c151>@@CGKPAX@Z ENDP ; <lambda_0b64b922eede83fc8ad9efc12102c151>::<lambda_invoker_stdcall>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ??R<lambda_0b64b922eede83fc8ad9efc12102c151>@@QBEKPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
??R<lambda_0b64b922eede83fc8ad9efc12102c151>@@QBEKPAX@Z PROC ; <lambda_0b64b922eede83fc8ad9efc12102c151>::operator(), COMDAT
; _this$ = ecx

; 222  :                UNREFERENCED_PARAMETER (user);
; 223  : 
; 224  :                if (g_hShutdown != nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	je	SHORT $LN2@operator

; 225  :                  WaitForSingleObject (g_hShutdown, INFINITE);

	mov	eax, DWORD PTR ?g_hShutdown@@3RAXA	; g_hShutdown
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN2@operator:

; 226  : 
; 227  :                hModHookInstance = nullptr;

	mov	DWORD PTR ?hModHookInstance@@3PAUHINSTANCE__@@A, 0 ; hModHookInstance

; 228  : 
; 229  :                CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 230  : 
; 231  :                return 0;

	xor	eax, eax

; 232  :              },

	ret	4
??R<lambda_0b64b922eede83fc8ad9efc12102c151>@@QBEKPAX@Z ENDP ; <lambda_0b64b922eede83fc8ad9efc12102c151>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_dwThreadId$ = 8					; size = 4
?SK_Inject_InvadingProcess@@YA_NK@Z PROC		; SK_Inject_InvadingProcess

; 178  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 179  :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	mov	edx, DWORD PTR _dwThreadId$[ebp]
	mov	eax, OFFSET ?g_sHookedPIDs@@3PAJA
	npad	3
$LL4@SK_Inject_:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	ecx, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 181  :     if (ReadAcquire (&g_sHookedPID) == static_cast <LONG> (dwThreadId))

	cmp	ecx, edx
	je	SHORT $LN10@SK_Inject_

; 179  :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	add	eax, 4
	cmp	eax, OFFSET ?g_sHookedPIDs@@3PAJA+64
	jne	SHORT $LL4@SK_Inject_

; 183  :   }
; 184  : 
; 185  :   return false;

	xor	al, al

; 186  : }

	pop	ebp
	ret	0
$LN10@SK_Inject_:

; 182  :       return true;

	mov	al, 1

; 186  : }

	pop	ebp
	ret	0
?SK_Inject_InvadingProcess@@YA_NK@Z ENDP		; SK_Inject_InvadingProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_dwExitCode$1 = -4					; size = 4
?SK_Inject_ValidateProcesses@@YAXXZ PROC		; SK_Inject_ValidateProcesses

; 77   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 78   :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	mov	ebx, DWORD PTR __imp__CloseHandle@4
	push	esi
	push	edi
	mov	esi, OFFSET ?g_sHookedPIDs@@3PAJA
$LL4@SK_Inject_:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 81   :       OpenProcess ( PROCESS_QUERY_INFORMATION, FALSE, 

	push	eax
	push	0
	push	1024					; 00000400H
	call	DWORD PTR __imp__OpenProcess@12
	mov	edi, eax

; 82   :                       ReadAcquire (&g_sHookedPID) );
; 83   : 
; 84   :     if (hProc == nullptr)

	test	edi, edi
	jne	SHORT $LN5@SK_Inject_
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 89   :     else

	jmp	SHORT $LN2@SK_Inject_
$LN5@SK_Inject_:

; 90   :     {
; 91   :       DWORD dwExitCode = STILL_ACTIVE;
; 92   : 
; 93   :       GetExitCodeProcess (hProc, &dwExitCode);

	lea	eax, DWORD PTR _dwExitCode$1[ebp]
	mov	DWORD PTR _dwExitCode$1[ebp], 259	; 00000103H
	push	eax
	push	edi
	call	DWORD PTR __imp__GetExitCodeProcess@8

; 94   : 
; 95   :       if (dwExitCode != STILL_ACTIVE)

	cmp	DWORD PTR _dwExitCode$1[ebp], 259	; 00000103H
	je	SHORT $LN7@SK_Inject_
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR [esi]
$LN7@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 98   :       CloseHandle (hProc);

	push	edi
	call	ebx
$LN2@SK_Inject_:

; 78   :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	add	esi, 4
	cmp	esi, OFFSET ?g_sHookedPIDs@@3PAJA+64
	jne	SHORT $LL4@SK_Inject_
	pop	edi
	pop	esi
	pop	ebx

; 99   :     }
; 100  :   }
; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_Inject_ValidateProcesses@@YAXXZ ENDP		; SK_Inject_ValidateProcesses
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
;	COMDAT ??__E__SK_InjectionHistory@@YAXXZ
text$di	SEGMENT
??__E__SK_InjectionHistory@@YAXXZ PROC			; `dynamic initializer for '__SK_InjectionHistory'', COMDAT

; 45   :                                     [MAX_INJECTED_PROC_HISTORY] = { };

	npad	2
	push	esi
	push	edi
	mov	edi, 64					; 00000040H
	mov	esi, OFFSET ?__SK_InjectionHistory@@3PAUSK_InjectionRecord_s@@A+561
	npad	2
$LL4@dynamic:
	push	520					; 00000208H
	lea	eax, DWORD PTR [esi-561]
	push	0
	push	eax
	call	_memset
	mov	DWORD PTR [esi-41], 0
	lea	esi, DWORD PTR [esi+568]
	mov	DWORD PTR [esi-601], 0
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi-597], 0
	mov	DWORD PTR [esi-593], 0
	mov	DWORD PTR [esi-589], 0
	mov	DWORD PTR [esi-585], 1
	mov	DWORD PTR [esi-577], 0
	mov	DWORD PTR [esi-573], 0
	mov	DWORD PTR [esi-569], 0
	mov	BYTE PTR [esi-565], 0
	sub	edi, 1
	jne	SHORT $LL4@dynamic
	pop	edi
	pop	esi
	ret	0
??__E__SK_InjectionHistory@@YAXXZ ENDP			; `dynamic initializer for '__SK_InjectionHistory''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT

; 3646 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 3629 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@Check_offs

; 3633 : 			}
; 3634 : 		}

	pop	ebp
	ret	4
$LN14@Check_offs:

; 3631 : 			{
; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN16@Check_offs:
$LN13@Check_offs:
	int	3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT

; 3625 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3602 : 		}

	ret	0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 3588 : 		{	// test if _Ptr points inside string

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@Inside
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN14@Inside
$LN13@Inside:
	mov	edx, ecx
$LN14@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	cmp	edx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*2]
	cmp	DWORD PTR __Ptr$[ebp], eax
	jae	SHORT $LN3@Inside
	mov	al, 1

; 3592 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	xor	al, al

; 3592 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 3572 : 		{	// ensure buffer is big enough

	npad	2
	push	ebp
	mov	ebp, esp

; 3573 : 		if (_Newsize == 0)

	mov	eax, DWORD PTR __Newsize$[ebp]
	test	eax, eax
	jne	SHORT $LN2@Grow

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN16@Grow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN16@Grow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	xor	al, al

; 3585 : 		}

	pop	ebp
	ret	4
$LN2@Grow:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], eax
	jae	SHORT $LN3@Grow

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	eax
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN3@Grow:

; 3582 : 			}
; 3583 : 
; 3584 : 		return (true);	// return true only if more work to do

	mov	al, 1

; 3585 : 		}

	pop	ebp
	ret	4
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 3566 : 		{	// set new length and null terminator

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 3567 : 		auto& _My_data = this->_Get_data();
; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [ecx+edx*2], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Oldres$ = -28						; size = 4
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 3514 : 		{	// reallocate to new buffer of at least _Newsize, copying existing elements there

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 3515 : 		const auto _Max = max_size();
; 3516 : 		if (_Newsize > _Max)

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	eax, 2147483646				; 7ffffffeH
	jbe	SHORT $LN2@Copy

; 3517 : 			{	// too long
; 3518 : 			_Xlen();

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN102@Copy:
$LN2@Copy:

; 3519 : 			}
; 3520 : 
; 3521 : 		auto& _My_data = this->_Get_data();
; 3522 : 		const size_type _Oldres = _My_data._Myres;

	mov	ebx, DWORD PTR [esi+20]

; 3523 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	edi, eax
	or	edi, 7
	mov	DWORD PTR __Oldres$[ebp], ebx

; 3524 : 		if (_Max < _Newres)

	cmp	edi, 2147483646				; 7ffffffeH
	jbe	SHORT $LN3@Copy

; 3525 : 			{
; 3526 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN8@Copy
$LN3@Copy:

; 3527 : 			}
; 3528 : 		else if (_Oldres / 2 <= _Newres / 3)

	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, ebx
	mul	edi
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN8@Copy

; 3529 : 			;
; 3530 : 		else if (_Oldres <= _Max - _Oldres / 2)

	mov	eax, 2147483646				; 7ffffffeH

; 3531 : 			{
; 3532 : 			_Newres = _Oldres + _Oldres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN8@Copy

; 3533 : 			}
; 3534 : 		else
; 3535 : 			{
; 3536 : 			_Newres = _Max;	// settle for max_size()

	mov	edi, 2147483646				; 7ffffffeH
$LN8@Copy:

; 3537 : 			}
; 3538 : 
; 3539 : 		auto& _Al = this->_Getal();
; 3540 : 		pointer _Ptr;
; 3541 : 		_TRY_BEGIN
; 3542 : 			_Ptr = _Al.allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	mov	ecx, esi
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
	jmp	SHORT $LN100@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$0:

; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	mov	ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	DWORD PTR __Newres$[ebp], eax

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	mov	DWORD PTR __Ptr$[ebp], eax

; 3546 : 		_CATCH_END

	mov	eax, $LN97@Copy
	ret	0
$LN97@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR __Oldres$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN100@Copy:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3546 : 		_CATCH_END

	mov	DWORD PTR __Ptr$1$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [eax*2+2]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3550 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN10@Copy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	DWORD PTR [esi]
	push	ecx
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3553 : 			_Al.deallocate(_My_data._Bx._Ptr, _Oldres + 1);

	lea	eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3556 : 		else

	jmp	SHORT $LN101@Copy
$LN10@Copy:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	esi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN101@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3563 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3562 : 		_My_data._Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 3563 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN99@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign, COMDAT
; _this$ = ecx

; 3502 : 		{	// assign _Count copies of _Ch beginning at _Off

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, ecx

; 3503 : 		if (_Count == 1)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN2@Chassign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN15@Chassign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN15@Chassign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	ax, WORD PTR __Ch$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3511 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Chassign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN34@Chassign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN34@Chassign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3509 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	mov	eax, DWORD PTR __Off$[ebp]
	push	edi
	lea	edi, DWORD PTR [edx+eax*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 260  :         for (; 0 < _N; ++_Su, --_N)

	test	ecx, ecx
	je	SHORT $LN52@Chassign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 321  : 		return ((_Elem *)_CSTD wmemset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	edx, ax
	mov	eax, edx
	shl	edx, 16					; 00000010H
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
$LN52@Chassign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3511 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal, COMDAT
; _this$ = ecx

; 3415 : 		{	// compare [0, _Mysize()) with _Right for equality

	npad	2
	push	ebp
	mov	ebp, esp

; 1844 : 		return (_Get_data()._Mysize);

	mov	edx, DWORD PTR __Right$[ebp]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edx+20], 8

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [edx+16]

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN22@Equal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN22@Equal:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8
	push	esi

; 1844 : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [ecx+16]

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN47@Equal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN47@Equal:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3416 : 		return (_Traits_equal<_Traits>(this->_Myptr(), this->_Mysize(), _Right._Myptr(), _Right._Mysize()));

	mov	esi, DWORD PTR [esi]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN55@Equal
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN72@Equal
	npad	7
$LL64@Equal:

; 217  :             if (*_S1 != *_S2)

	mov	ax, WORD PTR [ecx]
	cmp	ax, WORD PTR [edx]
	jne	SHORT $LN73@Equal

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	ecx, 2
	add	edx, 2
	sub	esi, 1
	jne	SHORT $LL64@Equal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	al, 1
	pop	esi

; 3417 : 		}

	pop	ebp
	ret	4
$LN73@Equal:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	jne	SHORT $LN55@Equal
$LN72@Equal:
	mov	al, 1
	pop	esi

; 3417 : 		}

	pop	ebp
	ret	4
$LN55@Equal:

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	xor	al, al
	pop	esi

; 3417 : 		}

	pop	ebp
	ret	4
?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 3410 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3412 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 2
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize, COMDAT
; _this$ = ecx

; 3040 : 		{	// determine new length, padding with _Ch elements as needed

	npad	2
	push	ebp
	mov	ebp, esp

; 3041 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, edx
	ja	SHORT $LN2@resize

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN25@resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN25@resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
	mov	WORD PTR [ecx+eax*2], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3049 : 		}

	pop	ebp
	ret	8
$LN2@resize:

; 3042 : 			{
; 3043 : 			_Eos(_Newsize);
; 3044 : 			}
; 3045 : 		else
; 3046 : 			{
; 3047 : 			append(_Newsize - this->_Mysize(), _Ch);

	sub	eax, edx
	mov	DWORD PTR __Newsize$[ebp], eax

; 3049 : 		}

	pop	ebp

; 3042 : 			{
; 3043 : 			_Eos(_Newsize);
; 3044 : 			}
; 3045 : 		else
; 3046 : 			{
; 3047 : 			append(_Newsize - this->_Mysize(), _Ch);

	jmp	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize, COMDAT
; _this$ = ecx

; 3035 : 		{	// determine new length, padding with null elements as needed

	npad	2
	push	ebp
	mov	ebp, esp

; 3041 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, edx
	ja	SHORT $LN4@resize

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN27@resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN27@resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
	mov	WORD PTR [ecx+eax*2], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3037 : 		}

	pop	ebp
	ret	4
$LN4@resize:

; 3047 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 3037 : 		}

	pop	ebp
	ret	4
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 3030 : 		const size_type _Num = this->_Getal().max_size();
; 3031 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, 2147483646				; 7ffffffeH

; 3032 : 		}

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 3025 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 3026 : 		}

	ret	0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length, COMDAT
; _this$ = ecx

; 3020 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 3021 : 		}

	ret	0
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back, COMDAT
; _this$ = ecx

; 2962 : 		{	// insert element at end

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2963 : 		auto& _My_data = this->_Get_data();
; 2964 : 		auto& _Sz = _My_data._Mysize;
; 2965 : 		if (_Sz == _My_data._Myres)

	mov	eax, DWORD PTR [esi+16]
	push	edi
	lea	edi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, ecx
	jne	SHORT $LN12@push_back

; 2966 : 			{
; 2967 : 			_Grow(_Sz + 1);	// _Grow checks for overflow

	add	eax, 1

; 3573 : 		if (_Newsize == 0)

	jne	SHORT $LN11@push_back

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi], eax

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN24@push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	jmp	SHORT $LN12@push_back
$LN24@push_back:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	jmp	SHORT $LN12@push_back
$LN11@push_back:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	ecx, eax
	jae	SHORT $LN12@push_back

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	eax
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN12@push_back:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN44@push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN44@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2971 : 		_Traits::assign(_Ptr[_Sz], _Ch);

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	ax, WORD PTR __Ch$[ebp]
	mov	WORD PTR [esi+ecx*2], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2972 : 		++_Sz;

	inc	DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2972 : 		++_Sz;

	mov	eax, DWORD PTR [edi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi+eax*2], cx
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2974 : 		}

	pop	ebp
	ret	4
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[], COMDAT
; _this$ = ecx

; 2943 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 2945 : 		return (this->_Myptr()[_Off]);

	mov	eax, DWORD PTR __Off$[ebp]

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2945 : 		return (this->_Myptr()[_Off]);

	lea	eax, DWORD PTR [ecx+eax*2]

; 2946 : 		}

	pop	ebp
	ret	4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end, COMDAT
; _this$ = ecx

; 2870 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN14@end

; 2872 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));

	mov	eax, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2872 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));

	lea	ecx, DWORD PTR [edx+eax*2]

; 1195 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 2873 : 		}

	pop	ebp
	ret	4
$LN14@end:

; 2872 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));

	mov	eax, DWORD PTR [ecx+16]

; 1614 : 		return (_Large_string_engaged()

	mov	edx, ecx

; 2872 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));

	lea	ecx, DWORD PTR [edx+eax*2]

; 1195 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 2873 : 		}

	pop	ebp
	ret	4
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin, COMDAT
; _this$ = ecx

; 2858 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1195 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN14@begin
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN14@begin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1195 : 		: _Ptr(_Parg)

	mov	DWORD PTR [eax], ecx

; 2859 : 		auto _My_data = _STD addressof(this->_Get_data());
; 2860 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()), _My_data));
; 2861 : 		}

	pop	ebp
	ret	4
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Off$[ebp]
	push	ebx
	push	esi

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edi, DWORD PTR [esi+16]
	cmp	edi, edx
	jb	$LN97@erase

; 2593 : 		_Check_offset(_Off);
; 2594 : 		if (this->_Mysize() - _Off <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, edx
	cmp	eax, ebx
	ja	SHORT $LN2@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN38@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN38@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2607 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 2595 : 			{
; 2596 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 2597 : 			}
; 2598 : 		else if (_Count != 0)

	test	ebx, ebx
	je	SHORT $LN94@erase

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN57@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN58@erase
$LN57@erase:
	mov	eax, esi
$LN58@erase:

; 2599 : 			{	// move elements down
; 2600 : 			value_type *_Ptr = this->_Myptr() + _Off;

	lea	ecx, DWORD PTR [eax+edx*2]

; 2601 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, ebx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, edi
	sub	eax, edx
	add	eax, eax
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ecx+ebx*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN87@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN87@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
$LN94@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN97@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN99@erase:
$LN96@erase:
	int	3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 2585 : 		{	// erase elements [_Off, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN36@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	esi, esi
	mov	WORD PTR [edx+eax*2], si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx
	pop	esi

; 2589 : 		}

	pop	ebp
	ret	4
$LN26@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	esi, esi
	mov	WORD PTR [edx+eax*2], si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx
	pop	esi

; 2589 : 		}

	pop	ebp
	ret	4
$LN36@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN38@erase:
$LN35@erase:
	int	3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2433 : 		{	// assign _Count * _Ch

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2434 : 		if (_Count == npos)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	esi, ecx
	cmp	edi, -1
	je	SHORT $LN58@assign

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN6@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN19@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2445 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2446 : 		}

	pop	ebp
	ret	8
$LN19@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2446 : 		}

	pop	ebp
	ret	8
$LN6@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN7@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN7@assign:

; 2437 : 			}
; 2438 : 
; 2439 : 		if (_Grow(_Count))
; 2440 : 			{	// make room and assign new stuff
; 2441 : 			_Chassign(0, _Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, esi
	push	edi
	push	0
	call	?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN47@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2445 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 2446 : 		}

	pop	ebp
	ret	8
$LN47@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2446 : 		}

	pop	ebp
	ret	8
$LN58@assign:

; 2435 : 			{
; 2436 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN60@assign:
$LN57@assign:
	int	3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2428 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2428 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [eax+2]
$LL6@assign:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL6@assign
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
	pop	esi

; 2430 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2412 : 		{	// assign [_Ptr, _Ptr + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN17@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN18@assign
$LN17@assign:
	mov	edx, esi
$LN18@assign:

; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	mov	edi, DWORD PTR __Ptr$[ebp]
	cmp	edx, edi
	ja	SHORT $LN2@assign
	mov	eax, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [edx+eax*2]
	cmp	edi, eax
	jae	SHORT $LN2@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN33@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN34@assign
$LN33@assign:
	mov	eax, esi
$LN34@assign:

; 2413 : 		if (_Inside(_Ptr))
; 2414 : 			{
; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
	sub	edi, eax
	mov	ecx, esi
	sar	edi, 1
	push	edi
	push	esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	ebx

; 3573 : 		if (_Newsize == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	jne	SHORT $LN40@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN53@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN53@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
$LN40@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	ecx, ebx
	jae	SHORT $LN41@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN41@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN81@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN82@assign
$LN81@assign:
	mov	eax, esi
$LN82@assign:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	ecx, DWORD PTR [ebx+ebx]
	push	ecx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN102@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN102@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
	pop	ebx
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jb	$LN161@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	eax, edi
	cmovb	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2382 : 		if (this == _STD addressof(_Right))

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 2383 : 			{	// substring
; 2384 : 			erase(_Roff + _Count);

	lea	eax, DWORD PTR [ecx+edi]

; 3630 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], eax
	jb	$LN163@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN62@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN63@assign
$LN62@assign:
	mov	edx, esi
$LN63@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	push	ecx
	push	edi
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edx+eax*2], di
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	call	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN72@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN85@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN72@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN73@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]
$LN73@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN113@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN113@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN129@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN130@assign
$LN129@assign:
	mov	edx, esi
$LN130@assign:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [edi+edi]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2389 : 			_Traits::copy(this->_Myptr(), _Right._Myptr() + _Roff, _Count);

	lea	eax, DWORD PTR [ebx+ecx*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN150@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN150@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN161@assign:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN164@assign:
$LN163@assign:
	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN165@assign:
$LN160@assign:
	int	3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 2348 : 		{	// append _Count * _Ch

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 2349 : 		if (npos - this->_Mysize() <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, ebx
	jbe	SHORT $LN85@append

; 2352 : 			}
; 2353 : 
; 2354 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+ebx]

; 2355 : 		if (_Count != 0 && _Grow(_Num))

	test	ebx, ebx
	je	SHORT $LN81@append

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN24@append

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN37@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2361 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2362 : 		}

	pop	ebp
	ret	8
$LN37@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2362 : 		}

	pop	ebp
	ret	8
$LN24@append:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN25@append

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN25@append:

; 2356 : 			{	// make room and append new stuff using assign
; 2357 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, esi
	push	ebx
	push	DWORD PTR [esi+16]
	call	?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN74@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2361 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2362 : 		}

	pop	ebp
	ret	8
$LN74@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
$LN81@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2361 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2362 : 		}

	pop	ebp
	ret	8
$LN85@append:

; 2350 : 			{
; 2351 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN87@append:
$LN84@append:
	int	3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 2343 : 		{	// append [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2343 : 		{	// append [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [eax+2]
$LL6@append:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL6@append
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
	pop	edi
	pop	esi

; 2345 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 2321 : 		{	// append [_Ptr, _Ptr + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR [esi+20]
	cmp	edx, 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN19@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
$LN19@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	mov	edi, DWORD PTR __Ptr$[ebp]
	cmp	ecx, edi
	ja	SHORT $LN2@append
	mov	eax, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [ecx+eax*2]
	cmp	edi, eax
	jae	SHORT $LN2@append

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN34@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN35@append
$LN34@append:
	mov	eax, esi
$LN35@append:

; 2322 : 		if (_Inside(_Ptr))
; 2323 : 			{
; 2324 : 			return (append(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
	sub	edi, eax
	mov	ecx, esi
	sar	edi, 1
	push	edi
	push	esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
	pop	edi
	pop	esi

; 2340 : 		}

	pop	ebp
	ret	8
$LN2@append:

; 2325 : 			}
; 2326 : 
; 2327 : 		if (npos - this->_Mysize() <= _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [esi+16]
	mov	eax, ebx
	not	eax
	cmp	eax, ecx
	jbe	$LN142@append

; 2330 : 			}
; 2331 : 
; 2332 : 		const size_type _Num = this->_Mysize() + _Count;

	add	ebx, ecx

; 2333 : 		if (_Count != 0 && _Grow(_Num))

	test	ecx, ecx
	je	SHORT $LN137@append

; 3573 : 		if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN59@append

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN72@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2339 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2340 : 		}

	pop	ebp
	ret	8
$LN72@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2340 : 		}

	pop	ebp
	ret	8
$LN59@append:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	edx, ebx
	jae	SHORT $LN60@append

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]
$LN60@append:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN100@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN101@append
$LN100@append:
	mov	edx, esi
$LN101@append:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [ecx+ecx]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2335 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2335 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	lea	eax, DWORD PTR [edx+eax*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN130@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2339 : 		return (*this);

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi

; 2340 : 		}

	pop	ebp
	ret	8
$LN130@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
$LN137@append:
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2339 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2340 : 		}

	pop	ebp
	ret	8
$LN142@append:

; 2328 : 			{
; 2329 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN144@append:
$LN141@append:
	int	3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
tv494 = 16						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 2288 : 		{	// append _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Roff$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi

; 2288 : 		{	// append _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, edx
	jb	$LN150@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	ecx, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	eax, edx

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	mov	edi, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	eax, ecx
	cmovb	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, edi
	not	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	DWORD PTR __Count$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	cmp	eax, ecx
	jbe	$LN152@append

; 2294 : 			}
; 2295 : 
; 2296 : 		const size_type _Num = this->_Mysize() + _Count;

	add	edi, ecx

; 2297 : 		if (_Count != 0 && _Grow(_Num))

	test	ecx, ecx
	je	$LN146@append

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN52@append

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN65@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN65@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN52@append:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN53@append

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Roff$[ebp]
$LN53@append:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN93@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN93@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN109@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv494[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN110@append
$LN109@append:
	mov	DWORD PTR tv494[ebp], esi
$LN110@append:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [ecx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2299 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);

	mov	ecx, DWORD PTR tv494[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2299 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);

	lea	eax, DWORD PTR [ebx+edx*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2299 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);

	mov	eax, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [ecx+eax*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN139@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN139@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
$LN146@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN150@append:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN153@append:
$LN152@append:

; 2292 : 			{
; 2293 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN154@append:
$LN149@append:
	int	3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 2277 : 		{	// append 1 * _Ch

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 2278 : 		push_back(_Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	esi, ecx
	call	?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back

; 2279 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2280 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2122 : 		{	// assign by stealing _Right's buffer, memcpy optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2123 : 			// pre: this != &_Right
; 2124 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2125 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2126 : 		auto& _Right_data = _Right._Get_data();
; 2127 : 
; 2128 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2129 : 		if (_Right_data._Large_string_engaged())
; 2130 : 			{	// take ownership of _Right's iterators along with its buffer
; 2131 : 			this->_Swap_all(_Right);
; 2132 : 			}
; 2133 : 		else
; 2134 : 			{
; 2135 : 			_Right._Orphan_all();
; 2136 : 			}
; 2137 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2138 : 
; 2139 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2140 : 			+ _Memcpy_move_offset;
; 2141 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2142 : 			+ _Memcpy_move_offset;
; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2145 : 		}

	pop	ebp
	ret	8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Assign_rv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents, COMDAT
; _this$ = ecx

; 2098 : 		{	// assign either as an rvalue or as an lvalue copy, allocators always equal optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2103 : 		}

	pop	ebp
	ret	8
?_Assign_rv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 2075 : 		{	// assign by moving _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2076 : 		if (this != _STD addressof(_Right))

	mov	edi, DWORD PTR __Right$[ebp]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN79@operator

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN8@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	movq	QWORD PTR [esi+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], eax

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edi], ax
$LN79@operator:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2087 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2088 : 		}

	pop	ebp
	ret	4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2054 : 		{	// construct by moving _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [eax], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2056 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1994 : 		{	// construct from _Count * _Ch

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1996 : 		assign(_Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1996 : 		assign(_Count, _Ch);

	push	DWORD PTR __Count$[ebp]

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1996 : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1997 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1980 : 		{	// construct from [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1980 : 		{	// construct from [_Ptr, <null>)

	mov	esi, ecx
	push	edi

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax

; 289  : 		return (_CSTD wcslen(_First));

	mov	eax, edx
	lea	edi, DWORD PTR [eax+2]
$LL25@basic_stri:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL25@basic_stri
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi

; 1981 : 		_Tidy_init();
; 1982 : 		assign(_Ptr);
; 1983 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1941 : 		}

	mov	eax, ecx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 1849 : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 1850 : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1845 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 1839 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1840 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 1824 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1825 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 1714 : 		_Pocma(_Getal(), _Al);
; 1715 : 		}

	ret	4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1697 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1697 : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1686 : 		}

	ret	0
$LN11@Myptr:

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1686 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1634 : 			{	// user-provided, for fancy pointers
; 1635 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 8
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
$LN3@Myptr:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1598 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 2147483647				; 7fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 1064 : 		_Mybase::operator=(_STD move(_Right));
; 1065 : 		return (*this);

	mov	eax, ecx

; 1066 : 		}

	ret	4
??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::address, COMDAT
; _this$ = ecx

; 1026 : 		{	// return address of mutable _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 1027 : 		return (pointer_traits<pointer>::pointer_to(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 1028 : 		}

	pop	ebp
	ret	4
?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 2147483647				; 7fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 2147483647				; 7fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 430  : 		{	// look up a facet in locale object

	npad	2
	push	ebp
	mov	ebp, esp

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR __Id$[ebp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	eax, eax
	jne	SHORT $LN3@Getfacet
	jmp	SHORT $LN10@Getfacet
$LN6@Getfacet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	eax, eax
$LN10@Getfacet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN3@Getfacet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 439  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 440  : 				: 0);	// no entry in current locale
; 441  : 			}
; 442  : 		}

	pop	ebp
	ret	4
$LN8@Getfacet:

; 438  : 			return (_Id < _Ptr0->_Facetcount

	xor	eax, eax
$LN3@Getfacet:
	pop	esi

; 439  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 440  : 				: 0);	// no entry in current locale
; 441  : 			}
; 442  : 		}

	pop	ebp
	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T2 = -64						; size = 24
$T3 = -40						; size = 24
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T5 = 8							; size = 4
___$ReturnUdt$ = 8					; size = 4
?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::locale::name, COMDAT
; _this$ = ecx

; 420  : 		{	// return locale name

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR $T4[ebp], 0

; 421  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR [ecx+4]
	push	esi
	test	eax, eax
	jne	SHORT $LN3@name
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T2[ebp+16], eax

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 421  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());

	lea	ecx, DWORD PTR $T2[ebp]
	mov	eax, 1
	jmp	SHORT $LN4@name
$LN3@name:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 3664 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	edx, DWORD PTR [eax+24]
	test	edx, edx
	jne	SHORT $LN36@name
	lea	edx, DWORD PTR [eax+28]
$LN36@name:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T3[ebp+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0

; 480  : 		return (_CSTD strlen(_First));

	lea	esi, DWORD PTR [ecx+1]
$LL179@name:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL179@name
	sub	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T3[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T3[ebp]
	mov	eax, 2
$LN4@name:

; 1595 : 		_Mysize(0),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	or	eax, 4

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [ecx]

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [esi+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [ecx+16]

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movq	QWORD PTR [esi+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 421  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());

	test	al, 2
	je	SHORT $LN120@name
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR $T3[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 421  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());

	and	eax, -3					; fffffffdH
	mov	DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN123@name
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	eax, DWORD PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	mov	eax, DWORD PTR $T5[ebp]
	add	esp, 12					; 0000000cH
$LN123@name:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T3[ebp+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
$LN120@name:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 421  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());

	test	al, 1
	je	SHORT $LN181@name
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR $T2[ebp+20]
	cmp	ecx, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN181@name
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN181@name:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale

; 422  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0:
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 1
	je	$LN6@name
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@name:
	ret	0
__ehhandler$?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:
	mov	eax, OFFSET __ehfuncinfo$?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::locale::name
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 403  : 		{	// destroy the object

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1locale@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 404  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN4@locale

; 405  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@locale
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@locale:

; 406  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocale
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 304  : 		{	// construct from current locale

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0locale@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	push	1
	mov	esi, ecx
	call	DWORD PTR __imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z

; 305  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
;	COMDAT ??$_LStrxfrm@_W@std@@YAIPA_W0PB_W1PBU_Collvec@@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Vector$ = 24						; size = 4
??$_LStrxfrm@_W@std@@YAIPA_W0PB_W1PBU_Collvec@@@Z PROC	; std::_LStrxfrm<wchar_t>, COMDAT

; 292  : 	{	// perform locale-specific transform of wchar_ts [_First1, _Last1)

	npad	2
	push	ebp
	mov	ebp, esp

; 294  : 	}

	pop	ebp

; 293  : 	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));

	jmp	DWORD PTR __imp___Wcsxfrm
??$_LStrxfrm@_W@std@@YAIPA_W0PB_W1PBU_Collvec@@@Z ENDP	; std::_LStrxfrm<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xlocinfo
;	COMDAT ??$_LStrcoll@_W@std@@YAHPB_W000PBU_Collvec@@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Vector$ = 24						; size = 4
??$_LStrcoll@_W@std@@YAHPB_W000PBU_Collvec@@@Z PROC	; std::_LStrcoll<wchar_t>, COMDAT

; 261  : 	{	// perform locale-specific comparison of wchar_t sequences

	npad	2
	push	ebp
	mov	ebp, esp

; 263  : 	}

	pop	ebp

; 262  : 	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));

	jmp	DWORD PTR __imp___Wcscoll
??$_LStrcoll@_W@std@@YAHPB_W000PBU_Collvec@@@Z ENDP	; std::_LStrcoll<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 65   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 66   :     {
; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_typeinfo.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 125  :     {

	xorps	xmm0, xmm0

; 126  :     }

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 59   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 60   :     {
; 61   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_typeinfo.h

; 125  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 126  :     }

	ret	0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 3646 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 3629 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@Check_offs

; 3633 : 			}
; 3634 : 		}

	pop	ebp
	ret	4
$LN14@Check_offs:

; 3631 : 			{
; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN16@Check_offs:
$LN13@Check_offs:
	int	3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3625 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3596 : 		auto& _My_data = this->_Get_data();
; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3602 : 		}

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 3588 : 		{	// test if _Ptr points inside string

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@Inside
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN14@Inside
$LN13@Inside:
	mov	edx, ecx
$LN14@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	cmp	edx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	eax, DWORD PTR [ecx+16]
	add	eax, edx
	cmp	DWORD PTR __Ptr$[ebp], eax
	jae	SHORT $LN3@Inside
	mov	al, 1

; 3592 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	xor	al, al

; 3592 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 3572 : 		{	// ensure buffer is big enough

	npad	2
	push	ebp
	mov	ebp, esp

; 3573 : 		if (_Newsize == 0)

	mov	eax, DWORD PTR __Newsize$[ebp]
	test	eax, eax
	jne	SHORT $LN2@Grow

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN16@Grow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN16@Grow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	xor	al, al

; 3585 : 		}

	pop	ebp
	ret	4
$LN2@Grow:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], eax
	jae	SHORT $LN3@Grow

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	eax
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN3@Grow:

; 3582 : 			}
; 3583 : 
; 3584 : 		return (true);	// return true only if more work to do

	mov	al, 1

; 3585 : 		}

	pop	ebp
	ret	4
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3566 : 		{	// set new length and null terminator

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3567 : 		auto& _My_data = this->_Get_data();
; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Oldres$ = -28						; size = 4
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 3514 : 		{	// reallocate to new buffer of at least _Newsize, copying existing elements there

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 3515 : 		const auto _Max = max_size();
; 3516 : 		if (_Newsize > _Max)

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	eax, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 3517 : 			{	// too long
; 3518 : 			_Xlen();

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN94@Copy:
$LN2@Copy:

; 3519 : 			}
; 3520 : 
; 3521 : 		auto& _My_data = this->_Get_data();
; 3522 : 		const size_type _Oldres = _My_data._Myres;

	mov	ebx, DWORD PTR [esi+20]

; 3523 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	edi, eax
	or	edi, 15					; 0000000fH
	mov	DWORD PTR __Oldres$[ebp], ebx

; 3524 : 		if (_Max < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN3@Copy

; 3525 : 			{
; 3526 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN8@Copy
$LN3@Copy:

; 3527 : 			}
; 3528 : 		else if (_Oldres / 2 <= _Newres / 3)

	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, ebx
	mul	edi
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN8@Copy

; 3529 : 			;
; 3530 : 		else if (_Oldres <= _Max - _Oldres / 2)

	mov	eax, -2					; fffffffeH

; 3531 : 			{
; 3532 : 			_Newres = _Oldres + _Oldres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN8@Copy

; 3533 : 			}
; 3534 : 		else
; 3535 : 			{
; 3536 : 			_Newres = _Max;	// settle for max_size()

	mov	edi, -2					; fffffffeH
$LN8@Copy:

; 3537 : 			}
; 3538 : 
; 3539 : 		auto& _Al = this->_Getal();
; 3540 : 		pointer _Ptr;
; 3541 : 		_TRY_BEGIN
; 3542 : 			_Ptr = _Al.allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	eax
	mov	ecx, esi
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	ecx, eax
	jmp	SHORT $LN92@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$0:

; 3543 : 		_CATCH_ALL
; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	push	eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 3546 : 		_CATCH_END

	mov	eax, $LN89@Copy
	ret	0
$LN89@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR __Oldres$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN92@Copy:

; 3551 : 			{	// copy and deallocate old buffer
; 3552 : 			_Traits::copy(_Unfancy(_Ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	mov	DWORD PTR __Ptr$1$[ebp], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3550 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN10@Copy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR [esi]
	push	ecx
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3553 : 			_Al.deallocate(_My_data._Bx._Ptr, _Oldres + 1);

	lea	eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3556 : 		else

	jmp	SHORT $LN93@Copy
$LN10@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN93@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3563 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3562 : 		_My_data._Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 3563 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN91@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 3502 : 		{	// assign _Count copies of _Ch beginning at _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 3503 : 		if (_Count == 1)

	mov	eax, DWORD PTR __Count$[ebp]
	mov	edx, ecx
	cmp	eax, 1
	jne	SHORT $LN2@Chassign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN16@Chassign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN16@Chassign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	eax, DWORD PTR __Off$[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx+eax], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3511 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Chassign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN35@Chassign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN35@Chassign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3509 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3511 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 3410 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3412 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3030 : 		const size_type _Num = this->_Getal().max_size();
; 3031 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 3032 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3025 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 3026 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 2858 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1195 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN14@begin
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN14@begin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1195 : 		: _Ptr(_Parg)

	mov	DWORD PTR [eax], ecx

; 2859 : 		auto _My_data = _STD addressof(this->_Get_data());
; 2860 : 		return (iterator(this->_Getal().address(*_My_data->_Myptr()), _My_data));
; 2861 : 		}

	pop	ebp
	ret	4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Off$[ebp]
	push	ebx
	push	esi

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edi, DWORD PTR [esi+16]
	cmp	edi, edx
	jb	SHORT $LN95@erase

; 2593 : 		_Check_offset(_Off);
; 2594 : 		if (this->_Mysize() - _Off <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, edx
	cmp	eax, ebx
	ja	SHORT $LN2@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN38@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN38@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2607 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 2595 : 			{
; 2596 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 2597 : 			}
; 2598 : 		else if (_Count != 0)

	test	ebx, ebx
	je	SHORT $LN92@erase

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN57@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN58@erase
$LN57@erase:
	mov	eax, esi
$LN58@erase:

; 2599 : 			{	// move elements down
; 2600 : 			value_type *_Ptr = this->_Myptr() + _Off;

	lea	ecx, DWORD PTR [eax+edx]

; 2601 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, ebx

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ecx+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN85@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN92@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN95@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN97@erase:
$LN94@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2585 : 		{	// erase elements [_Off, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN36@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx

; 2589 : 		}

	pop	ebp
	ret	4
$LN26@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx

; 2589 : 		}

	pop	ebp
	ret	4
$LN36@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN38@erase:
$LN35@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2433 : 		{	// assign _Count * _Ch

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2434 : 		if (_Count == npos)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	esi, ecx
	cmp	edi, -1
	je	$LN100@assign

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN6@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN19@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2445 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2446 : 		}

	pop	ebp
	ret	8
$LN19@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2446 : 		}

	pop	ebp
	ret	8
$LN6@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN7@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN7@assign:

; 3503 : 		if (_Count == 1)

	cmp	edi, 1
	jne	SHORT $LN38@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN51@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3507 : 		else

	jmp	SHORT $LN77@assign
$LN51@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3507 : 		else

	jmp	SHORT $LN77@assign
$LN38@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN70@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN71@assign
$LN70@assign:
	mov	ecx, esi
$LN71@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	edi
	push	eax
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN77@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN89@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2445 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 2446 : 		}

	pop	ebp
	ret	8
$LN89@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2446 : 		}

	pop	ebp
	ret	8
$LN100@assign:

; 2435 : 			{
; 2436 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN102@assign:
$LN99@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2428 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2428 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	edi, DWORD PTR [eax+1]
$LL6@assign:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL6@assign
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 2430 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2412 : 		{	// assign [_Ptr, _Ptr + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN17@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN18@assign
$LN17@assign:
	mov	edx, esi
$LN18@assign:

; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	mov	ebx, DWORD PTR __Ptr$[ebp]
	cmp	edx, ebx
	ja	SHORT $LN2@assign
	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	ebx, eax
	jae	SHORT $LN2@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN33@assign

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN33@assign:

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 3573 : 		if (_Newsize == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	jne	SHORT $LN40@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN53@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN53@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
$LN40@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	ecx, edi
	jae	SHORT $LN41@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN41@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN81@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN82@assign
$LN81@assign:
	mov	eax, esi
$LN82@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN100@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN100@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Roff$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, eax
	jb	$LN159@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	ecx, edi
	cmovb	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2382 : 		if (this == _STD addressof(_Right))

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 2383 : 			{	// substring
; 2384 : 			erase(_Roff + _Count);

	lea	ecx, DWORD PTR [eax+edi]

; 3630 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], ecx
	jb	$LN161@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN62@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	push	eax
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN62@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, esi

; 2385 : 			erase(0, _Roff);

	push	eax
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN72@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN85@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN72@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN73@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	eax, DWORD PTR __Roff$[ebp]
$LN73@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN113@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN113@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN129@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN130@assign
$LN129@assign:
	mov	ecx, esi
$LN130@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2389 : 			_Traits::copy(this->_Myptr(), _Right._Myptr() + _Roff, _Count);

	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN148@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN148@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN159@assign:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN162@assign:
$LN161@assign:
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN163@assign:
$LN158@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2348 : 		{	// append _Count * _Ch

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 2349 : 		if (npos - this->_Mysize() <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, ebx
	jbe	SHORT $LN85@append

; 2352 : 			}
; 2353 : 
; 2354 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+ebx]

; 2355 : 		if (_Count != 0 && _Grow(_Num))

	test	ebx, ebx
	je	SHORT $LN81@append

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN24@append

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN37@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2361 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2362 : 		}

	pop	ebp
	ret	8
$LN37@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2362 : 		}

	pop	ebp
	ret	8
$LN24@append:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN25@append

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN25@append:

; 2356 : 			{	// make room and append new stuff using assign
; 2357 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, esi
	push	ebx
	push	DWORD PTR [esi+16]
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN74@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2361 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2362 : 		}

	pop	ebp
	ret	8
$LN74@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN81@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2361 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2362 : 		}

	pop	ebp
	ret	8
$LN85@append:

; 2350 : 			{
; 2351 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN87@append:
$LN84@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Assign_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_lv_contents, COMDAT
; _this$ = ecx

; 2172 : 		{	// assign by copying the data stored in _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 2173 : 			// pre: *this is in a valid but unspecified state
; 2174 : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2175 : 		}

	pop	ebp
	ret	4
?_Assign_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2122 : 		{	// assign by stealing _Right's buffer, memcpy optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2123 : 			// pre: this != &_Right
; 2124 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2125 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2126 : 		auto& _Right_data = _Right._Get_data();
; 2127 : 
; 2128 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2129 : 		if (_Right_data._Large_string_engaged())
; 2130 : 			{	// take ownership of _Right's iterators along with its buffer
; 2131 : 			this->_Swap_all(_Right);
; 2132 : 			}
; 2133 : 		else
; 2134 : 			{
; 2135 : 			_Right._Orphan_all();
; 2136 : 			}
; 2137 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2138 : 
; 2139 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2140 : 			+ _Memcpy_move_offset;
; 2141 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2142 : 			+ _Memcpy_move_offset;
; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2145 : 		}

	pop	ebp
	ret	8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2054 : 		{	// construct by moving _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2056 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1994 : 		{	// construct from _Count * _Ch

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1996 : 		assign(_Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	esi, ecx
	push	DWORD PTR __Count$[ebp]

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1996 : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1997 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1980 : 		{	// construct from [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1980 : 		{	// construct from [_Ptr, <null>)

	mov	esi, ecx
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	edi, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
$LL25@basic_stri:

; 480  : 		return (_CSTD strlen(_First));

	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL25@basic_stri
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 1981 : 		_Tidy_init();
; 1982 : 		assign(_Ptr);
; 1983 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 1941 : 		}

	mov	eax, ecx

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1941 : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1925 : 		{	// construct by copying _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2174 : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1926 : 		_Tidy_init();
; 1927 : 		_Assign_lv_contents(_Right);
; 1928 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 1849 : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 1850 : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1845 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 1839 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1840 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1824 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1825 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1697 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1697 : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1686 : 		}

	ret	0
$LN11@Myptr:

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1686 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1634 : 			{	// user-provided, for fancy pointers
; 1635 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
$LN3@Myptr:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1598 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate
$LN15@allocate:

; 1077 : 		return (_Mybase::allocate(_Count));
; 1078 : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN10@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN11@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN11@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 1077 : 		return (_Mybase::allocate(_Count));
; 1078 : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN15@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN17@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::address, COMDAT
; _this$ = ecx

; 1026 : 		{	// return address of mutable _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 1027 : 		return (pointer_traits<pointer>::pointer_to(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 1028 : 		}

	pop	ebp
	ret	4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 1013 : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 1014 : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1015 : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 975  : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 976  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 977  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	or	eax, -1

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 852  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?max@?$numeric_limits@G@std@@SAGXZ
_TEXT	SEGMENT
?max@?$numeric_limits@G@std@@SAGXZ PROC			; std::numeric_limits<unsigned short>::max, COMDAT

; 566  : 		return (USHRT_MAX);

	mov	eax, 65535				; 0000ffffH

; 567  : 		}

	ret	0
?max@?$numeric_limits@G@std@@SAGXZ ENDP			; std::numeric_limits<unsigned short>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?max@?$numeric_limits@_W@std@@SA_WXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_W@std@@SA_WXZ PROC		; std::numeric_limits<wchar_t>::max, COMDAT

; 276  : 		return ((_Ty)WCHAR_MAX);

	mov	eax, 65535				; 0000ffffH

; 277  : 		}

	ret	0
?max@?$numeric_limits@_W@std@@SA_WXZ ENDP		; std::numeric_limits<wchar_t>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
	test	ecx, ecx
	cmovne	eax, ecx

; 90   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 85   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 68   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 61   :         _Data._What = _Message;

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [ecx+4], xmm0
	mov	DWORD PTR [ecx+4], eax

; 62   :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_idx$ = 8						; size = 4
?SK_Inject_GetRecord@@YAPAUSK_InjectionRecord_s@@H@Z PROC ; SK_Inject_GetRecord

; 67   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 68   :   return &__SK_InjectionHistory [idx];

	imul	eax, DWORD PTR _idx$[ebp], 568
	add	eax, OFFSET ?__SK_InjectionHistory@@3PAUSK_InjectionRecord_s@@A ; __SK_InjectionHistory

; 69   : }

	pop	ebp
	ret	0
?SK_Inject_GetRecord@@YAPAUSK_InjectionRecord_s@@H@Z ENDP ; SK_Inject_GetRecord
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SK_InjectionRecord_s@@QAE@XZ
_TEXT	SEGMENT
??0SK_InjectionRecord_s@@QAE@XZ PROC			; SK_InjectionRecord_s::SK_InjectionRecord_s, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	push	520					; 00000208H
	mov	esi, ecx
	push	0
	push	esi
	call	_memset
	mov	DWORD PTR [esi+520], 0
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+528], 0
	mov	eax, esi
	mov	DWORD PTR [esi+532], 0
	mov	DWORD PTR [esi+536], 0
	mov	DWORD PTR [esi+540], 0
	mov	DWORD PTR [esi+544], 1
	mov	DWORD PTR [esi+552], 0
	mov	DWORD PTR [esi+556], 0
	mov	DWORD PTR [esi+560], 0
	mov	BYTE PTR [esi+564], 0
	pop	esi
	ret	0
??0SK_InjectionRecord_s@@QAE@XZ ENDP			; SK_InjectionRecord_s::SK_InjectionRecord_s
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-input>@SK_InjectionRecord_s@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-input>@SK_InjectionRecord_s@@QAE@XZ PROC ; SK_InjectionRecord_s::<unnamed-type-input>::<unnamed-type-input>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 0
	ret	0
??0<unnamed-type-input>@SK_InjectionRecord_s@@QAE@XZ ENDP ; SK_InjectionRecord_s::<unnamed-type-input>::<unnamed-type-input>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-render>@SK_InjectionRecord_s@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-render>@SK_InjectionRecord_s@@QAE@XZ PROC ; SK_InjectionRecord_s::<unnamed-type-render>::<unnamed-type-render>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 1
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0<unnamed-type-render>@SK_InjectionRecord_s@@QAE@XZ ENDP ; SK_InjectionRecord_s::<unnamed-type-render>::<unnamed-type-render>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-process>@SK_InjectionRecord_s@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-process>@SK_InjectionRecord_s@@QAE@XZ PROC ; SK_InjectionRecord_s::<unnamed-type-process>::<unnamed-type-process>, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	push	520					; 00000208H
	mov	esi, ecx
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+520], 0
	mov	DWORD PTR [esi+528], 0
	mov	eax, esi
	mov	DWORD PTR [esi+532], 0
	mov	DWORD PTR [esi+536], 0
	mov	DWORD PTR [esi+540], 0
	pop	esi
	ret	0
??0<unnamed-type-process>@SK_InjectionRecord_s@@QAE@XZ ENDP ; SK_InjectionRecord_s::<unnamed-type-process>::<unnamed-type-process>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 24
?SK_Inject_AcquireProcess@@YAXXZ PROC			; SK_Inject_AcquireProcess

; 131  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 132  :   if (! SK_IsInjected ())

	push	0
	call	?SK_IsInjected@@YG_N_N@Z		; SK_IsInjected
	test	al, al
	je	$LN3@SK_Inject_

; 133  :     return;
; 134  : 
; 135  :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	push	esi
	push	edi
	mov	edi, DWORD PTR __imp__GetCurrentProcessId@0
	mov	esi, OFFSET ?g_sHookedPIDs@@3PAJA
$LL4@SK_Inject_:

; 136  :   {
; 137  :     if (! InterlockedCompareExchange (&g_sHookedPID, GetCurrentProcessId (), 0))

	call	edi
	mov	ecx, eax
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [esi], ecx
	test	eax, eax
	je	SHORT $LN62@SK_Inject_

; 133  :     return;
; 134  : 
; 135  :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	add	esi, 4
	cmp	esi, OFFSET ?g_sHookedPIDs@@3PAJA+64
	jne	SHORT $LL4@SK_Inject_
	pop	edi
	pop	esi

; 167  :                           GET_MODULE_HANDLE_EX_FLAG_PIN,
; 168  :                             (LPCWSTR)&SK_Inject_AcquireProcess,
; 169  :                                &hModHookInstance );
; 170  : 
; 171  :       break;
; 172  :     }
; 173  :   }
; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@SK_Inject_:

; 138  :     {
; 139  :       ULONG injection_idx = InterlockedIncrement (&SK_InjectionRecord_s::count);

	mov	eax, 1
	lock	 xadd	 DWORD PTR ?count@SK_InjectionRecord_s@@2JC, eax
	inc	eax

; 140  : 
; 141  :       // Rollover and start erasing the oldest history
; 142  :       if (injection_idx >= MAX_INJECTED_PROC_HISTORY)

	cmp	eax, 64					; 00000040H
	jb	SHORT $LN9@SK_Inject_

; 143  :       {
; 144  :         if (InterlockedCompareExchange (&SK_InjectionRecord_s::count, 0, injection_idx))

	xor	ecx, ecx
	mov	edx, OFFSET ?count@SK_InjectionRecord_s@@2JC ; SK_InjectionRecord_s::count
	lock	 cmpxchg DWORD PTR [edx], ecx
	test	eax, eax

; 145  :         {
; 146  :           injection_idx = 1;

	mov	eax, 1
	je	SHORT $LN8@SK_Inject_

; 147  :           InterlockedIncrement (&SK_InjectionRecord_s::rollovers);

	lock	 inc	 DWORD PTR ?rollovers@SK_InjectionRecord_s@@2JC

; 148  :         }
; 149  : 
; 150  :         else

	jmp	SHORT $LN9@SK_Inject_
$LN8@SK_Inject_:

; 151  :           injection_idx = InterlockedIncrement (&SK_InjectionRecord_s::count);

	lock	 xadd	 DWORD PTR ?count@SK_InjectionRecord_s@@2JC, eax
	inc	eax
$LN9@SK_Inject_:

; 152  :       }
; 153  : 
; 154  :       local_record =

	imul	eax, eax, 568
	lea	eax, DWORD PTR ?__SK_InjectionHistory@@3PAUSK_InjectionRecord_s@@A[eax-568]
	mov	DWORD PTR ?local_record@@3PAUSK_InjectionRecord_s@@A, eax ; local_record

; 155  :         &__SK_InjectionHistory [injection_idx - 1];
; 156  : 
; 157  :                 local_record->process.id = GetCurrentProcessId ();

	call	edi
	mov	ecx, DWORD PTR ?local_record@@3PAUSK_InjectionRecord_s@@A ; local_record
	mov	DWORD PTR [ecx+520], eax

; 158  :       _time64 (&local_record->process.inject);

	mov	eax, DWORD PTR ?local_record@@3PAUSK_InjectionRecord_s@@A ; local_record
	add	eax, 528				; 00000210H
	push	eax
	call	DWORD PTR __imp___time64
	add	esp, 4

; 159  :       wcsncpy ( local_record->process.name,

	push	0
	call	DWORD PTR __imp__GetModuleHandleW@4
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?SK_GetModuleFullName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleFullName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN25@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN25@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 159  :       wcsncpy ( local_record->process.name,

	push	259					; 00000103H
	push	eax
	push	DWORD PTR ?local_record@@3PAUSK_InjectionRecord_s@@A ; local_record
	call	DWORD PTR __imp__wcsncpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T1[ebp+20]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 159  :       wcsncpy ( local_record->process.name,

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN35@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T1[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN35@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 163  :       PathStripPath (local_record->process.name);

	push	DWORD PTR ?local_record@@3PAUSK_InjectionRecord_s@@A ; local_record
	call	DWORD PTR __imp__PathStripPathW@4

; 164  : 
; 165  :       // Hold a reference so that removing the CBT hook doesn't crash the software
; 166  :       GetModuleHandleEx ( GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |

	push	OFFSET ?hModHookInstance@@3PAUHINSTANCE__@@A ; hModHookInstance
	push	OFFSET ?SK_Inject_AcquireProcess@@YAXXZ	; SK_Inject_AcquireProcess
	push	5
	call	DWORD PTR __imp__GetModuleHandleExW@12
	pop	edi
	pop	esi
$LN3@SK_Inject_:

; 167  :                           GET_MODULE_HANDLE_EX_FLAG_PIN,
; 168  :                             (LPCWSTR)&SK_Inject_AcquireProcess,
; 169  :                                &hModHookInstance );
; 170  : 
; 171  :       break;
; 172  :     }
; 173  :   }
; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_Inject_AcquireProcess@@YAXXZ ENDP			; SK_Inject_AcquireProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
?SK_Inject_ReleaseProcess@@YAXXZ PROC			; SK_Inject_ReleaseProcess

; 106  :   if (! SK_IsInjected ())

	push	0
	call	?SK_IsInjected@@YG_N_N@Z		; SK_IsInjected
	test	al, al
	je	SHORT $LN6@SK_Inject_

; 107  :     return;
; 108  : 
; 109  :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	push	esi
	push	edi
	mov	edi, DWORD PTR __imp__GetCurrentProcessId@0
	mov	esi, OFFSET ?g_sHookedPIDs@@3PAJA
$LL4@SK_Inject_:

; 110  :   {
; 111  :     InterlockedCompareExchange (&g_sHookedPID, 0, GetCurrentProcessId ());

	call	edi
	xor	ecx, ecx
	lock	 cmpxchg DWORD PTR [esi], ecx
	add	esi, 4
	cmp	esi, OFFSET ?g_sHookedPIDs@@3PAJA+64
	jne	SHORT $LL4@SK_Inject_

; 112  :   }
; 113  : 
; 114  :   if (local_record != nullptr)

	mov	eax, DWORD PTR ?local_record@@3PAUSK_InjectionRecord_s@@A ; local_record
	pop	edi
	pop	esi
	test	eax, eax
	je	SHORT $LN6@SK_Inject_

; 115  :   {
; 116  :     _time64 (&local_record->process.eject);

	add	eax, 536				; 00000218H
	push	eax
	call	DWORD PTR __imp___time64
	add	esp, 4

; 117  : 
; 118  :     local_record->render.api    = SK_GetCurrentRenderBackend ().api;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ?local_record@@3PAUSK_InjectionRecord_s@@A ; local_record
	mov	DWORD PTR [eax+544], ecx

; 119  :     local_record->render.frames = SK_GetFramesDrawn ();

	call	?SK_GetFramesDrawn@@YGKXZ		; SK_GetFramesDrawn
	mov	ecx, DWORD PTR ?local_record@@3PAUSK_InjectionRecord_s@@A ; local_record
	mov	DWORD PTR [ecx+552], eax
	mov	DWORD PTR [ecx+556], 0
$LN6@SK_Inject_:

; 120  : 
; 121  :     //local_record.input.xinput  = SK_Input_
; 122  :     // ...
; 123  :     // ...
; 124  :     // ...
; 125  :     // ...
; 126  :   }
; 127  : }

	ret	0
?SK_Inject_ReleaseProcess@@YAXXZ ENDP			; SK_Inject_ReleaseProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_wszIn$ = -2164						; size = 1040
_wszOut$ = -1124					; size = 1040
$T2 = -84						; size = 24
_ver_dir$3 = -60					; size = 24
$T4 = -36						; size = 24
$T5 = -36						; size = 24
$T6 = -36						; size = 24
$T7 = -36						; size = 24
__$EHRec$ = -12						; size = 12
_role$ = 8						; size = 4
?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z PROC ; SK_Inject_SwitchToRenderWrapperEx

; 668  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 669  :   wchar_t wszIn  [MAX_PATH * 2] = { };

	lea	eax, DWORD PTR _wszIn$[ebp]
	sub	esp, 2152				; 00000868H
	push	esi
	push	edi
	push	1040					; 00000410H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 670  :   lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?SK_GetModuleFullName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleFullName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN37@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN37@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 670  :   lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	mov	esi, DWORD PTR __imp__lstrcatW@8
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T7[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN46@SK_Inject_

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T7[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN46@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 672  :   wchar_t wszOut [MAX_PATH * 2] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 673  :   lstrcatW (wszOut, SK_GetHostPath ());

	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 674  : 
; 675  :   switch (role)

	mov	eax, DWORD PTR _role$[ebp]
	cmp	eax, 1
	jg	SHORT $LN14@SK_Inject_
	je	SHORT $LN5@SK_Inject_
	cmp	eax, -1073741808			; c0000010H
	je	SHORT $LN8@SK_Inject_
	cmp	eax, -1073741792			; c0000020H
	jne	SHORT $LN2@SK_Inject_

; 688  : 
; 689  : #ifndef _WIN64
; 690  :     case DLL_ROLE::DDraw:
; 691  :       lstrcatW (wszOut, L"\\ddraw.dll");

	push	OFFSET $SG147856

; 692  :       break;

	jmp	SHORT $LN417@SK_Inject_
$LN8@SK_Inject_:

; 693  : 
; 694  :     case DLL_ROLE::D3D8:
; 695  :       lstrcatW (wszOut, L"\\d3d8.dll");

	push	OFFSET $SG147858
	jmp	SHORT $LN417@SK_Inject_
$LN5@SK_Inject_:

; 679  :       break;
; 680  : 
; 681  :     case DLL_ROLE::DXGI:
; 682  :       lstrcatW (wszOut, L"\\dxgi.dll");

	push	OFFSET $SG147852

; 683  :       break;

	jmp	SHORT $LN417@SK_Inject_
$LN14@SK_Inject_:

; 674  : 
; 675  :   switch (role)

	sub	eax, 2
	je	SHORT $LN4@SK_Inject_
	sub	eax, 2
	jne	SHORT $LN2@SK_Inject_

; 684  : 
; 685  :     case DLL_ROLE::OpenGL:
; 686  :       lstrcatW (wszOut, L"\\OpenGL32.dll");

	push	OFFSET $SG147854

; 687  :       break;

	jmp	SHORT $LN417@SK_Inject_
$LN4@SK_Inject_:

; 676  :   {
; 677  :     case DLL_ROLE::D3D9:
; 678  :       lstrcatW (wszOut, L"\\d3d9.dll");

	push	OFFSET $SG147850
$LN417@SK_Inject_:
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi
$LN2@SK_Inject_:

; 696  :       break;
; 697  : #endif
; 698  : 
; 699  :     //case SK_RenderAPI::Vulkan:
; 700  :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 701  :       //break;
; 702  :   }
; 703  : 
; 704  : 
; 705  :   //std::queue <DWORD> suspended =
; 706  :   //  SK_SuspendAllOtherThreads ();
; 707  :   //
; 708  :   //extern volatile LONG   SK_bypass_dialog_active;
; 709  :   //InterlockedIncrement (&SK_bypass_dialog_active);
; 710  :   //
; 711  :   //int mb_ret = 
; 712  :   //       SK_MessageBox ( L"Link the Installed Wrapper to the Global DLL?\r\n"
; 713  :   //                       L"\r\n"
; 714  :   //                       L"Linked installs allow you to update wrapped games the same way "
; 715  :   //                       L"as global injection, but require administrator privileges to setup.",
; 716  :   //                         L"Perform a Linked Wrapper Install?",
; 717  :   //                           MB_YESNO | MB_ICONQUESTION
; 718  :   //                     );
; 719  :   //
; 720  :   //InterlockedIncrement (&SK_bypass_dialog_active);
; 721  :   //
; 722  :   //SK_ResumeThreads (suspended);
; 723  : 
; 724  :   //if ( mb_ret == IDYES )
; 725  :   //{
; 726  :   //  wchar_t   wszCmd [MAX_PATH * 3] = { };
; 727  :   //  swprintf (wszCmd, L"/c mklink \"%s\" \"%s\"", wszOut, wszIn);
; 728  :   //
; 729  :   //  ShellExecuteW ( GetActiveWindow (),
; 730  :   //                    L"runas",
; 731  :   //                      L"cmd.exe",
; 732  :   //                        wszCmd,
; 733  :   //                          nullptr,
; 734  :   //                            SW_HIDE );
; 735  :   //
; 736  :   //  SK_Inject_EnableCentralizedConfig ();
; 737  :   //
; 738  :   //  return true;
; 739  :   //}
; 740  : 
; 741  : 
; 742  :   if (CopyFile (wszIn, wszOut, TRUE))

	mov	edi, DWORD PTR __imp__CopyFileW@12
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	1
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	edi
	test	eax, eax
	je	$LN9@SK_Inject_

; 743  :   {
; 744  :     SK_Inject_EnableCentralizedConfig ();

	call	?SK_Inject_EnableCentralizedConfig@@YAXXZ ; SK_Inject_EnableCentralizedConfig

; 745  : 
; 746  :     *wszOut = L'\0';

	xor	eax, eax
	mov	WORD PTR _wszOut$[ebp], ax

; 747  :     *wszIn  = L'\0';

	mov	WORD PTR _wszIn$[ebp], ax

; 748  : 
; 749  :     lstrcatW (wszOut, SK_GetHostPath ());

	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 750  : 
; 751  : #ifdef _WIN64
; 752  :     lstrcatW (wszIn,  L"SpecialK64.pdb");
; 753  :     lstrcatW (wszOut, L"\\SpecialK64.pdb");
; 754  : #else
; 755  :     lstrcatW (wszIn,  L"SpecialK32.pdb");

	push	OFFSET $SG147860
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi

; 756  :     lstrcatW (wszOut, L"\\SpecialK32.pdb");

	push	OFFSET $SG147861
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 757  : #endif
; 758  : 
; 759  :     if (! CopyFileW (wszIn, wszOut, TRUE))

	push	1
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	edi
	test	eax, eax
	jne	SHORT $LN10@SK_Inject_

; 760  :       ReplaceFileW (wszOut, wszIn, nullptr, 0x00, nullptr, nullptr);

	push	eax
	push	eax
	push	eax
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	DWORD PTR __imp__ReplaceFileW@24
$LN10@SK_Inject_:

; 761  : 
; 762  :     *wszIn = L'\0';

	xor	eax, eax
	mov	WORD PTR _wszIn$[ebp], ax

; 765  :       SK_FormatString (R"(%ws\Version)", SK_GetConfigPath ());

	call	?SK_GetConfigPath@@YGPB_WXZ		; SK_GetConfigPath
	push	eax
	lea	eax, DWORD PTR _ver_dir$3[ebp]
	push	OFFSET $SG147863
	push	eax
	call	?SK_FormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBDZZ ; SK_FormatString
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _ver_dir$3[ebp+20], 16	; 00000010H

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _ver_dir$3[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 765  :       SK_FormatString (R"(%ws\Version)", SK_GetConfigPath ());

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _ver_dir$3[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 768  :       GetFileAttributesA (ver_dir.c_str ());

	push	eax
	call	DWORD PTR __imp__GetFileAttributesA@4

; 770  :     if ( (dwAttribs != INVALID_FILE_ATTRIBUTES) ||

	cmp	eax, -1
	jne	SHORT $LN12@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _ver_dir$3[ebp+20], 16	; 00000010H

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _ver_dir$3[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 770  :     if ( (dwAttribs != INVALID_FILE_ATTRIBUTES) ||

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _ver_dir$3[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 770  :     if ( (dwAttribs != INVALID_FILE_ATTRIBUTES) ||

	push	eax
	call	DWORD PTR __imp__CreateDirectoryA@8
	test	eax, eax
	je	$LN11@SK_Inject_
$LN12@SK_Inject_:

; 773  :       lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	?SK_GetModuleFullName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleFullName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN124@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN124@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 773  :       lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T6[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN133@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T6[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN133@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 774  :       PathRemoveFileSpecW  (wszIn);

	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	DWORD PTR __imp__PathRemoveFileSpecW@4

; 775  : 
; 776  :       lstrcatW (wszIn, L"\\Version\\installed.ini");

	push	OFFSET $SG147866
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi

; 780  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	sub	esp, 24					; 00000018H
	xor	eax, eax
	mov	ecx, esp
	mov	WORD PTR _wszOut$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	push	-1

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], eax

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2174 : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	lea	eax, DWORD PTR _ver_dir$3[ebp]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 780  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?SK_UTF8ToWideChar@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SK_UTF8ToWideChar
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN213@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN213@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 780  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T5[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN222@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN222@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 781  :       lstrcatW (wszOut, L"\\installed.ini");

	push	OFFSET $SG147867
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 782  : 
; 783  :       DeleteFileW (       wszOut);

	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteFileW@4

; 784  :       CopyFile    (wszIn, wszOut, FALSE);

	push	0
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	edi

; 785  : 
; 786  :       *wszIn = L'\0';

	xor	eax, eax
	mov	WORD PTR _wszIn$[ebp], ax

; 788  :       lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?SK_GetModuleFullName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleFullName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN262@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN262@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 788  :       lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN271@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN271@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 789  :       PathRemoveFileSpecW  (wszIn);

	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	DWORD PTR __imp__PathRemoveFileSpecW@4

; 790  : 
; 791  :       lstrcatW (wszIn, L"\\Version\\repository.ini");

	push	OFFSET $SG147868
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi

; 795  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	sub	esp, 24					; 00000018H
	xor	eax, eax
	mov	ecx, esp
	mov	WORD PTR _wszOut$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	push	-1

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], eax

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2174 : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	lea	eax, DWORD PTR _ver_dir$3[ebp]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 795  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_UTF8ToWideChar@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SK_UTF8ToWideChar
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN351@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN351@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 795  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN360@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN360@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 796  :       lstrcatW (wszOut, L"\\repository.ini");

	push	OFFSET $SG147869
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 797  : 
; 798  :       DeleteFileW (       wszOut);

	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteFileW@4

; 799  :       CopyFile    (wszIn, wszOut, FALSE);

	push	0
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	edi
$LN11@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _ver_dir$3[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN390@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _ver_dir$3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN390@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 802  :     return true;

	mov	al, 1

; 803  :   }
; 804  : 
; 805  :   return false;
; 806  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@SK_Inject_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	al, al
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z$1:
	lea	ecx, DWORD PTR _ver_dir$3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_Inject_SwitchToRenderWrapperEx@@YA_NW4DLL_ROLE@@@Z ENDP ; SK_Inject_SwitchToRenderWrapperEx
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_wszIn$ = -2168						; size = 1040
_wszOut$ = -1128					; size = 1040
$T2 = -88						; size = 24
_ver_dir$3 = -64					; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
__$EHRec$ = -12						; size = 12
?SK_Inject_SwitchToRenderWrapper@@YA_NXZ PROC		; SK_Inject_SwitchToRenderWrapper

; 810  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_Inject_SwitchToRenderWrapper@@YA_NXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 811  :   wchar_t wszIn [MAX_PATH * 2] = { };

	lea	eax, DWORD PTR _wszIn$[ebp]
	sub	esp, 2156				; 0000086cH
	push	esi
	push	edi
	push	1040					; 00000410H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 812  :   lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?SK_GetModuleFullName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleFullName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN37@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN37@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 812  :   lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	mov	esi, DWORD PTR __imp__lstrcatW@8
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T7[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN46@SK_Inject_

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T7[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN46@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 814  :   wchar_t wszOut [MAX_PATH * 2] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 815  :   lstrcatW (wszOut, SK_GetHostPath ());

	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 816  : 
; 817  :   switch (SK_GetCurrentRenderBackend ().api)

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	eax, DWORD PTR [eax]
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN14@SK_Inject_
	je	SHORT $LN7@SK_Inject_
	sub	eax, 2
	je	SHORT $LN8@SK_Inject_
	sub	eax, 6
	je	SHORT $LN4@SK_Inject_
	sub	eax, 16					; 00000010H
	jne	SHORT $LN2@SK_Inject_
$LN4@SK_Inject_:

; 818  :   {
; 819  :     case SK_RenderAPI::D3D9:
; 820  :     case SK_RenderAPI::D3D9Ex:
; 821  :       lstrcatW (wszOut, L"\\d3d9.dll");

	push	OFFSET $SG147890

; 822  :       break;

	jmp	SHORT $LN417@SK_Inject_
$LN8@SK_Inject_:

; 841  :     } break;
; 842  : 
; 843  :     case SK_RenderAPI::OpenGL:
; 844  :       lstrcatW (wszOut, L"\\OpenGL32.dll");

	push	OFFSET $SG147898
	jmp	SHORT $LN417@SK_Inject_
$LN14@SK_Inject_:

; 816  : 
; 817  :   switch (SK_GetCurrentRenderBackend ().api)

	cmp	eax, 64					; 00000040H
	je	SHORT $LN7@SK_Inject_
	cmp	eax, 8256				; 00002040H
	je	SHORT $LN5@SK_Inject_
	cmp	eax, 16448				; 00004040H
	jne	SHORT $LN2@SK_Inject_

; 828  : 
; 829  :     case SK_RenderAPI::DDrawOn11:
; 830  :       lstrcatW (wszOut, L"\\ddraw.dll");

	push	OFFSET $SG147894

; 831  :       break;

	jmp	SHORT $LN417@SK_Inject_
$LN5@SK_Inject_:

; 823  : 
; 824  : #ifndef _WIN64
; 825  :     case SK_RenderAPI::D3D8On11:
; 826  :       lstrcatW (wszOut, L"\\d3d8.dll");

	push	OFFSET $SG147892

; 827  :       break;

	jmp	SHORT $LN417@SK_Inject_
$LN7@SK_Inject_:

; 832  : #endif
; 833  : 
; 834  :     case SK_RenderAPI::D3D10:
; 835  :     case SK_RenderAPI::D3D11:
; 836  : #ifdef _WIN64
; 837  :     case SK_RenderAPI::D3D12:
; 838  : #endif
; 839  :     {
; 840  :       lstrcatW (wszOut, L"\\dxgi.dll");

	push	OFFSET $SG147896
$LN417@SK_Inject_:
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi
$LN2@SK_Inject_:

; 845  :       break;
; 846  : 
; 847  :     //case SK_RenderAPI::Vulkan:
; 848  :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 849  :       //break;
; 850  :   }
; 851  : 
; 852  : 
; 853  :   //std::queue <DWORD> suspended =
; 854  :   //  SK_SuspendAllOtherThreads ();
; 855  :   //
; 856  :   //extern volatile LONG   SK_bypass_dialog_active;
; 857  :   //InterlockedIncrement (&SK_bypass_dialog_active);
; 858  :   //
; 859  :   //int mb_ret = 
; 860  :   //       SK_MessageBox ( L"Link the Installed Wrapper to the Global DLL?\r\n"
; 861  :   //                       L"\r\n"
; 862  :   //                       L"Linked installs allow you to update wrapped games the same way "
; 863  :   //                       L"as global injection, but require administrator privileges to setup.",
; 864  :   //                         L"Perform a Linked Wrapper Install?",
; 865  :   //                           MB_YESNO | MB_ICONQUESTION
; 866  :   //                     );
; 867  :   //
; 868  :   //InterlockedIncrement (&SK_bypass_dialog_active);
; 869  :   //
; 870  :   //SK_ResumeThreads (suspended);
; 871  :   //
; 872  :   //if ( mb_ret == IDYES )
; 873  :   //{
; 874  :   //  wchar_t   wszCmd [MAX_PATH * 3] = { };
; 875  :   //  swprintf (wszCmd, L"/c mklink \"%s\" \"%s\"", wszOut, wszIn);
; 876  :   //
; 877  :   //  ShellExecuteW ( GetActiveWindow (),
; 878  :   //                    L"runas",
; 879  :   //                      L"cmd.exe",
; 880  :   //                        wszCmd,
; 881  :   //                          nullptr,
; 882  :   //                            SW_HIDE );
; 883  :   //
; 884  :   //  SK_Inject_EnableCentralizedConfig ();
; 885  :   //
; 886  :   //  return true;
; 887  :   //}
; 888  : 
; 889  : 
; 890  :   if (CopyFile (wszIn, wszOut, TRUE))

	mov	edi, DWORD PTR __imp__CopyFileW@12
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	1
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	edi
	test	eax, eax
	je	$LN9@SK_Inject_

; 891  :   {
; 892  :     SK_Inject_EnableCentralizedConfig ();

	call	?SK_Inject_EnableCentralizedConfig@@YAXXZ ; SK_Inject_EnableCentralizedConfig

; 893  : 
; 894  :     *wszOut = L'\0';

	xor	eax, eax
	mov	WORD PTR _wszOut$[ebp], ax

; 895  :     *wszIn  = L'\0';

	mov	WORD PTR _wszIn$[ebp], ax

; 896  : 
; 897  :     lstrcatW (wszOut, SK_GetHostPath ());

	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 898  : 
; 899  : #ifdef _WIN64
; 900  :     lstrcatW (wszIn,  L"SpecialK64.pdb");
; 901  :     lstrcatW (wszOut, L"\\SpecialK64.pdb");
; 902  : #else
; 903  :     lstrcatW (wszIn,  L"SpecialK32.pdb");

	push	OFFSET $SG147900
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi

; 904  :     lstrcatW (wszOut, L"\\SpecialK32.pdb");

	push	OFFSET $SG147901
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 905  : #endif
; 906  : 
; 907  :     if (! CopyFileW (wszIn, wszOut, TRUE))

	push	1
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	edi
	test	eax, eax
	jne	SHORT $LN10@SK_Inject_

; 908  :       ReplaceFileW (wszOut, wszIn, nullptr, 0x00, nullptr, nullptr);

	push	eax
	push	eax
	push	eax
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	DWORD PTR __imp__ReplaceFileW@24
$LN10@SK_Inject_:

; 909  : 
; 910  :     *wszIn = L'\0';

	xor	eax, eax
	mov	WORD PTR _wszIn$[ebp], ax

; 913  :       SK_FormatString (R"(%ws\Version)", SK_GetConfigPath ());

	call	?SK_GetConfigPath@@YGPB_WXZ		; SK_GetConfigPath
	push	eax
	lea	eax, DWORD PTR _ver_dir$3[ebp]
	push	OFFSET $SG147903
	push	eax
	call	?SK_FormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBDZZ ; SK_FormatString
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _ver_dir$3[ebp+20], 16	; 00000010H

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _ver_dir$3[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 913  :       SK_FormatString (R"(%ws\Version)", SK_GetConfigPath ());

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _ver_dir$3[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 916  :       GetFileAttributesA (ver_dir.c_str ());

	push	eax
	call	DWORD PTR __imp__GetFileAttributesA@4

; 918  :     if ( (dwAttribs != INVALID_FILE_ATTRIBUTES) ||

	cmp	eax, -1
	jne	SHORT $LN12@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _ver_dir$3[ebp+20], 16	; 00000010H

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _ver_dir$3[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 918  :     if ( (dwAttribs != INVALID_FILE_ATTRIBUTES) ||

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _ver_dir$3[ebp]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 918  :     if ( (dwAttribs != INVALID_FILE_ATTRIBUTES) ||

	push	eax
	call	DWORD PTR __imp__CreateDirectoryA@8
	test	eax, eax
	je	$LN11@SK_Inject_
$LN12@SK_Inject_:

; 921  :       lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	?SK_GetModuleFullName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleFullName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN124@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN124@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 921  :       lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T6[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN133@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T6[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN133@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 922  :       PathRemoveFileSpecW  (wszIn);

	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	DWORD PTR __imp__PathRemoveFileSpecW@4

; 923  : 
; 924  :       lstrcatW (wszIn, L"\\Version\\installed.ini");

	push	OFFSET $SG147906
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi

; 928  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	sub	esp, 24					; 00000018H
	xor	eax, eax
	mov	ecx, esp
	mov	WORD PTR _wszOut$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	push	-1

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], eax

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2174 : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	lea	eax, DWORD PTR _ver_dir$3[ebp]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 928  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?SK_UTF8ToWideChar@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SK_UTF8ToWideChar
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN213@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN213@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 928  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T5[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN222@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN222@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 929  :       lstrcatW (wszOut, L"\\installed.ini");

	push	OFFSET $SG147907
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 930  : 
; 931  :       DeleteFileW (       wszOut);

	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteFileW@4

; 932  :       CopyFile    (wszIn, wszOut, FALSE);

	push	0
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	edi

; 933  : 
; 934  :       *wszIn = L'\0';

	xor	eax, eax
	mov	WORD PTR _wszIn$[ebp], ax

; 936  :       lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?SK_GetModuleFullName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleFullName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN262@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN262@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 936  :       lstrcatW (wszIn, SK_GetModuleFullName (SK_GetDLL ()).c_str ());

	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN271@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN271@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 937  :       PathRemoveFileSpecW  (wszIn);

	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	DWORD PTR __imp__PathRemoveFileSpecW@4

; 938  : 
; 939  :       lstrcatW (wszIn, L"\\Version\\repository.ini");

	push	OFFSET $SG147908
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	esi

; 943  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	sub	esp, 24					; 00000018H
	xor	eax, eax
	mov	ecx, esp
	mov	WORD PTR _wszOut$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	push	-1

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], eax

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2174 : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	lea	eax, DWORD PTR _ver_dir$3[ebp]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 943  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_UTF8ToWideChar@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SK_UTF8ToWideChar
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN351@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN351@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 943  :       lstrcatW (wszOut, SK_UTF8ToWideChar (ver_dir).c_str ());

	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN360@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN360@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 944  :       lstrcatW (wszOut, L"\\repository.ini");

	push	OFFSET $SG147909
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 945  : 
; 946  :       DeleteFileW (       wszOut);

	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteFileW@4

; 947  :       CopyFile    (wszIn, wszOut, FALSE);

	push	0
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszIn$[ebp]
	push	eax
	call	edi
$LN11@SK_Inject_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _ver_dir$3[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN390@SK_Inject_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _ver_dir$3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN390@SK_Inject_:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 950  :     return true;

	mov	al, 1

; 951  :   }
; 952  : 
; 953  :   return false;
; 954  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@SK_Inject_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	al, al
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_Inject_SwitchToRenderWrapper@@YA_NXZ$1:
	lea	ecx, DWORD PTR _ver_dir$3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SK_Inject_SwitchToRenderWrapper@@YA_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?SK_Inject_SwitchToRenderWrapper@@YA_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_Inject_SwitchToRenderWrapper@@YA_NXZ ENDP		; SK_Inject_SwitchToRenderWrapper
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_wszTemp$ = -1560					; size = 520
_wszOut$ = -1040					; size = 1040
_role$ = 8						; size = 4
?SK_Inject_SwitchToGlobalInjectorEx@@YA_NW4DLL_ROLE@@@Z PROC ; SK_Inject_SwitchToGlobalInjectorEx

; 1012 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 1560				; 00000618H

; 1013 :   config.system.central_repository = true;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+820, 1
	push	esi

; 1014 :   SK_EstablishRootPath ();

	call	?SK_EstablishRootPath@@YGXXZ		; SK_EstablishRootPath

; 1015 : 
; 1016 :   wchar_t wszOut [MAX_PATH * 2] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1017 :   lstrcatW (wszOut, SK_GetHostPath ());

	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	mov	esi, DWORD PTR __imp__lstrcatW@8
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 1018 : 
; 1019 :   switch (role)

	mov	eax, DWORD PTR _role$[ebp]
	cmp	eax, 1
	jg	SHORT $LN10@SK_Inject_
	je	SHORT $LN7@SK_Inject_
	cmp	eax, -1073741808			; c0000010H
	je	SHORT $LN5@SK_Inject_
	cmp	eax, -1073741792			; c0000020H
	jne	SHORT $LN2@SK_Inject_

; 1029 :     case DLL_ROLE::DDraw:
; 1030 :       lstrcatW (wszOut, L"\\ddraw.dll");

	push	OFFSET $SG147944

; 1031 :       break;

	jmp	SHORT $LN36@SK_Inject_
$LN5@SK_Inject_:

; 1023 :       break;
; 1024 : 
; 1025 : #ifndef _WIN64
; 1026 :     case DLL_ROLE::D3D8:
; 1027 :       lstrcatW (wszOut, L"\\d3d8.dll");

	push	OFFSET $SG147942

; 1028 :       break;

	jmp	SHORT $LN36@SK_Inject_
$LN7@SK_Inject_:

; 1032 : #endif
; 1033 : 
; 1034 :     case DLL_ROLE::DXGI:
; 1035 :     {
; 1036 :       lstrcatW (wszOut, L"\\dxgi.dll");

	push	OFFSET $SG147946

; 1037 :     } break;

	jmp	SHORT $LN36@SK_Inject_
$LN10@SK_Inject_:

; 1018 : 
; 1019 :   switch (role)

	sub	eax, 2
	je	SHORT $LN4@SK_Inject_
	sub	eax, 2
	jne	SHORT $LN2@SK_Inject_

; 1038 : 
; 1039 :     case DLL_ROLE::OpenGL:
; 1040 :       lstrcatW (wszOut, L"\\OpenGL32.dll");

	push	OFFSET $SG147948
	jmp	SHORT $LN36@SK_Inject_
$LN4@SK_Inject_:

; 1020 :   {
; 1021 :     case DLL_ROLE::D3D9:
; 1022 :       lstrcatW (wszOut, L"\\d3d9.dll");

	push	OFFSET $SG147940
$LN36@SK_Inject_:
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi
$LN2@SK_Inject_:

; 1041 :       break;
; 1042 : 
; 1043 :     //case SK_RenderAPI::Vulkan:
; 1044 :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 1045 :       //break;
; 1046 :   }
; 1047 : 
; 1048 :   wchar_t wszTemp [MAX_PATH] = { };

	push	520					; 00000208H
	lea	eax, DWORD PTR _wszTemp$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1049 :   GetTempFileNameW (SK_GetHostPath (), L"SKI", timeGetTime (), wszTemp);

	lea	eax, DWORD PTR _wszTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__timeGetTime@0
	push	eax
	push	OFFSET $SG147949
	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	push	eax
	call	DWORD PTR __imp__GetTempFileNameW@16

; 1050 : 
; 1051 :   MoveFileW (wszOut, wszTemp);

	lea	eax, DWORD PTR _wszTemp$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	DWORD PTR __imp__MoveFileW@8

; 1053 :   SK_SaveConfig (L"SpecialK");

	push	0
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1053 :   SK_SaveConfig (L"SpecialK");

	mov	ecx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	8

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET $SG147950
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1053 :   SK_SaveConfig (L"SpecialK");

	call	?SK_SaveConfig@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z ; SK_SaveConfig
	add	esp, 28					; 0000001cH

; 1054 : 
; 1055 :   return true;

	mov	al, 1

; 1056 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SK_Inject_SwitchToGlobalInjectorEx@@YA_NW4DLL_ROLE@@@Z ENDP ; SK_Inject_SwitchToGlobalInjectorEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_wszTemp$ = -1564					; size = 520
_wszOut$ = -1044					; size = 1040
?SK_Inject_SwitchToGlobalInjector@@YA_NXZ PROC		; SK_Inject_SwitchToGlobalInjector

; 958  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 1564				; 0000061cH

; 959  :   config.system.central_repository = true;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+820, 1
	push	esi

; 960  :   SK_EstablishRootPath ();

	call	?SK_EstablishRootPath@@YGXXZ		; SK_EstablishRootPath

; 961  : 
; 962  :   wchar_t wszOut [MAX_PATH * 2] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 963  :   lstrcatW (wszOut, SK_GetHostPath ());

	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	mov	esi, DWORD PTR __imp__lstrcatW@8
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi

; 964  : 
; 965  :   switch (SK_GetCurrentRenderBackend ().api)

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	eax, DWORD PTR [eax]
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN10@SK_Inject_
	je	SHORT $LN7@SK_Inject_
	sub	eax, 2
	je	SHORT $LN8@SK_Inject_
	sub	eax, 6
	je	SHORT $LN4@SK_Inject_
	sub	eax, 16					; 00000010H
	jne	SHORT $LN2@SK_Inject_
$LN4@SK_Inject_:

; 966  :   {
; 967  :     case SK_RenderAPI::D3D9:
; 968  :     case SK_RenderAPI::D3D9Ex:
; 969  :       lstrcatW (wszOut, L"\\d3d9.dll");

	push	OFFSET $SG147920

; 970  :       break;

	jmp	SHORT $LN36@SK_Inject_
$LN8@SK_Inject_:

; 989  :     } break;
; 990  : 
; 991  :     case SK_RenderAPI::OpenGL:
; 992  :       lstrcatW (wszOut, L"\\OpenGL32.dll");

	push	OFFSET $SG147928
	jmp	SHORT $LN36@SK_Inject_
$LN10@SK_Inject_:

; 964  : 
; 965  :   switch (SK_GetCurrentRenderBackend ().api)

	cmp	eax, 64					; 00000040H
	je	SHORT $LN7@SK_Inject_
	cmp	eax, 8256				; 00002040H
	je	SHORT $LN5@SK_Inject_
	cmp	eax, 16448				; 00004040H
	jne	SHORT $LN2@SK_Inject_

; 976  : 
; 977  :     case SK_RenderAPI::DDrawOn11:
; 978  :       lstrcatW (wszOut, L"\\ddraw.dll");

	push	OFFSET $SG147924

; 979  :       break;

	jmp	SHORT $LN36@SK_Inject_
$LN5@SK_Inject_:

; 971  : 
; 972  : #ifndef _WIN64
; 973  :     case SK_RenderAPI::D3D8On11:
; 974  :       lstrcatW (wszOut, L"\\d3d8.dll");

	push	OFFSET $SG147922

; 975  :       break;

	jmp	SHORT $LN36@SK_Inject_
$LN7@SK_Inject_:

; 980  : #endif
; 981  : 
; 982  :     case SK_RenderAPI::D3D10:
; 983  :     case SK_RenderAPI::D3D11:
; 984  : #ifdef _WIN64
; 985  :     case SK_RenderAPI::D3D12:
; 986  : #endif
; 987  :     {
; 988  :       lstrcatW (wszOut, L"\\dxgi.dll");

	push	OFFSET $SG147926
$LN36@SK_Inject_:
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	esi
$LN2@SK_Inject_:

; 993  :       break;
; 994  : 
; 995  :     //case SK_RenderAPI::Vulkan:
; 996  :       //lstrcatW (wszOut, L"\\vk-1.dll");
; 997  :       //break;
; 998  :   }
; 999  : 
; 1000 :   wchar_t wszTemp [MAX_PATH] = {  };

	push	520					; 00000208H
	lea	eax, DWORD PTR _wszTemp$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1001 :   GetTempFileNameW (SK_GetHostPath (), L"SKI", timeGetTime (), wszTemp);

	lea	eax, DWORD PTR _wszTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__timeGetTime@0
	push	eax
	push	OFFSET $SG147929
	call	?SK_GetHostPath@@YAPB_WXZ		; SK_GetHostPath
	push	eax
	call	DWORD PTR __imp__GetTempFileNameW@16

; 1002 : 
; 1003 :   MoveFileW (wszOut, wszTemp);

	lea	eax, DWORD PTR _wszTemp$[ebp]
	push	eax
	lea	eax, DWORD PTR _wszOut$[ebp]
	push	eax
	call	DWORD PTR __imp__MoveFileW@8

; 1005 :   SK_SaveConfig (L"SpecialK");

	push	0
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1005 :   SK_SaveConfig (L"SpecialK");

	mov	ecx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	8

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET $SG147930
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1005 :   SK_SaveConfig (L"SpecialK");

	call	?SK_SaveConfig@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z ; SK_SaveConfig
	add	esp, 28					; 0000001cH

; 1006 : 
; 1007 :   return true;

	mov	al, 1

; 1008 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SK_Inject_SwitchToGlobalInjector@@YA_NXZ ENDP		; SK_Inject_SwitchToGlobalInjector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_pdwList$ = 8						; size = 4
_capacity$ = 12						; size = 4
?SKX_GetInjectedPIDs@@YGIPAKI@Z PROC			; SKX_GetInjectedPIDs

; 1241 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1242 :   DWORD*  pdwListIter = pdwList;

	mov	esi, DWORD PTR _pdwList$[ebp]
	push	edi

; 1243 :   SSIZE_T i           = 0;

	xor	edi, edi

; 1244 : 
; 1245 :   SK_Inject_ValidateProcesses ();

	call	?SK_Inject_ValidateProcesses@@YAXXZ	; SK_Inject_ValidateProcesses

; 1246 : 
; 1247 :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	mov	edx, DWORD PTR _capacity$[ebp]
	mov	ecx, OFFSET ?g_sHookedPIDs@@3PAJA
	npad	7
$LL4@SKX_GetInj:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 1249 :     if (ReadAcquire (&g_sHookedPID) != 0)

	test	eax, eax
	je	SHORT $LN2@SKX_GetInj

; 1250 :     {
; 1251 :       if (i < (SSIZE_T)capacity - 1)

	lea	eax, DWORD PTR [edx-1]
	cmp	edi, eax
	jge	SHORT $LN7@SKX_GetInj

; 1252 :       {
; 1253 :         if (pdwListIter != nullptr)

	test	esi, esi
	je	SHORT $LN7@SKX_GetInj

; 1254 :         {
; 1255 :           *pdwListIter = ReadAcquire (&g_sHookedPID);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 1256 :            pdwListIter++;

	add	esi, 4
$LN7@SKX_GetInj:

; 1257 :         }
; 1258 :       }
; 1259 : 
; 1260 :       ++i;

	inc	edi
$LN2@SKX_GetInj:

; 1246 : 
; 1247 :   for (volatile LONG& g_sHookedPID : g_sHookedPIDs)

	add	ecx, 4
	cmp	ecx, OFFSET ?g_sHookedPIDs@@3PAJA+64
	jne	SHORT $LL4@SKX_GetInj

; 1266 : 
; 1267 :   return i;

	mov	eax, edi
	test	esi, esi
	je	SHORT $LN8@SKX_GetInj

; 1261 :     }
; 1262 :   }
; 1263 : 
; 1264 :   if (pdwListIter != nullptr)
; 1265 :      *pdwListIter  = 0;

	mov	DWORD PTR [esi], 0
$LN8@SKX_GetInj:
	pop	edi
	pop	esi

; 1268 : }

	pop	ebp
	ret	8
?SKX_GetInjectedPIDs@@YGIPAKI@Z ENDP			; SKX_GetInjectedPIDs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
?SKX_IsHookingCBT@@YG_NXZ PROC				; SKX_IsHookingCBT

; 445  :   return (g_hHookCBT != nullptr);

	mov	eax, DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A ; g_hHookCBT
	neg	eax
	sbb	eax, eax
	neg	eax

; 446  : }

	ret	0
?SKX_IsHookingCBT@@YG_NXZ ENDP				; SKX_IsHookingCBT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
?SKX_RemoveCBTHook@@YGXXZ PROC				; SKX_RemoveCBTHook

; 421  : #ifdef USE_SHELL_HOOK
; 422  :   SKX_RemoveShellHook ();
; 423  : #endif
; 424  : 
; 425  :   if (g_hShutdown != nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	je	SHORT $LN2@SKX_Remove

; 426  :     SetEvent (g_hShutdown);

	mov	eax, DWORD PTR ?g_hShutdown@@3RAXA	; g_hShutdown
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN2@SKX_Remove:

; 427  : 
; 428  :   if (g_hHookCBT)

	cmp	DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A, 0 ; g_hHookCBT
	je	SHORT $LN4@SKX_Remove

; 429  :   {
; 430  :     if (UnhookWindowsHookEx (g_hHookCBT))

	mov	eax, DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A ; g_hHookCBT
	push	eax
	call	DWORD PTR __imp__UnhookWindowsHookEx@4
	test	eax, eax
	je	SHORT $LN4@SKX_Remove

; 431  :     {
; 432  :       ZeroMemory (whitelist_patterns, sizeof (whitelist_patterns));

	push	8320					; 00002080H
	push	0
	push	OFFSET ?whitelist_patterns@@3PA_WA	; whitelist_patterns
	call	_memset

; 433  :       whitelist_count = 0;

	mov	DWORD PTR ?whitelist_count@@3HA, 0	; whitelist_count
	add	esp, 12					; 0000000cH

; 434  : 
; 435  :       __SK_HookContextOwner = false;

	mov	DWORD PTR ?__SK_HookContextOwner@@3JC, 0 ; __SK_HookContextOwner

; 436  :       g_hHookCBT            = nullptr;

	mov	DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A, 0 ; g_hHookCBT
$LN4@SKX_Remove:

; 437  :     }
; 438  :   }
; 439  : }

	ret	0
?SKX_RemoveCBTHook@@YGXXZ ENDP				; SKX_RemoveCBTHook
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_wszCurrentDir$1 = -2168				; size = 1040
_wszSys32$2 = -1128					; size = 524
_wszWOW64$3 = -604					; size = 524
$T4 = -80						; size = 24
$T5 = -56						; size = 24
$T6 = -32						; size = 24
_hMod$ = -4						; size = 4
?SKX_InstallCBTHook@@YGXXZ PROC				; SKX_InstallCBTHook

; 328  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 2168				; 00000878H

; 329  : #ifdef USE_SHELL_HOOK
; 330  :   SKX_InstallShellHook ();
; 331  : #endif
; 332  : 
; 333  :   // Nothing to do here, move along.
; 334  :   if (g_hHookCBT != nullptr)

	cmp	DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A, 0 ; g_hHookCBT
	push	esi
	jne	$LN133@SKX_Instal

; 335  :     return;
; 336  : 
; 337  :   ZeroMemory (whitelist_patterns, sizeof (whitelist_patterns));

	push	8320					; 00002080H
	push	0
	push	OFFSET ?whitelist_patterns@@3PA_WA	; whitelist_patterns
	call	_memset
	add	esp, 12					; 0000000cH

; 338  :   whitelist_count = 0;

	mov	DWORD PTR ?whitelist_count@@3HA, 0	; whitelist_count

; 339  : 
; 340  :   HMODULE hMod = nullptr;
; 341  : 
; 342  :   GetModuleHandleEx ( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,

	lea	eax, DWORD PTR _hMod$[ebp]
	mov	DWORD PTR _hMod$[ebp], 0
	push	eax
	push	OFFSET $SG147661
	push	2
	call	DWORD PTR __imp__GetModuleHandleExW@12

; 343  : #ifdef _WIN64
; 344  :                           L"SpecialK64.dll",
; 345  : #else
; 346  :                           L"SpecialK32.dll",
; 347  : #endif
; 348  :                           (HMODULE *) &hMod );
; 349  : 
; 350  :   extern HMODULE
; 351  :   __stdcall
; 352  :   SK_GetDLL (void);
; 353  : 
; 354  :   if (hMod == SK_GetDLL ())

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	cmp	DWORD PTR _hMod$[ebp], eax
	jne	$LN133@SKX_Instal

; 355  :   {
; 356  :     if (g_hShutdown == nullptr)

	cmp	DWORD PTR ?g_hShutdown@@3RAXA, 0	; g_hShutdown
	jne	SHORT $LN4@SKX_Instal

; 357  :     {
; 358  : #ifdef _WIN64
; 359  :       g_hShutdown = CreateEvent (nullptr, TRUE, FALSE, L"SpecialK64_Reset");
; 360  : #else
; 361  :       g_hShutdown = CreateEvent (nullptr, TRUE, FALSE, L"SpecialK32_Reset");

	push	OFFSET $SG147664
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	DWORD PTR ?g_hShutdown@@3RAXA, eax	; g_hShutdown
$LN4@SKX_Instal:

; 362  : #endif
; 363  :     }
; 364  : 
; 365  : 
; 366  :   wchar_t wszCurrentDir [MAX_PATH * 2] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _wszCurrentDir$1[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 367  :   GetCurrentDirectoryW  (MAX_PATH * 2 - 1, wszCurrentDir);

	lea	eax, DWORD PTR _wszCurrentDir$1[ebp]
	push	eax
	push	519					; 00000207H
	call	DWORD PTR __imp__GetCurrentDirectoryW@8

; 369  :   SetCurrentDirectory (SK_SYS_GetInstallPath ().c_str ());

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	?SK_SYS_GetInstallPath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; SK_SYS_GetInstallPath
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@SKX_Instal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN26@SKX_Instal:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 369  :   SetCurrentDirectory (SK_SYS_GetInstallPath ().c_str ());

	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryW@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T6[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN35@SKX_Instal

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T6[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN35@SKX_Instal:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T6[ebp+16], 0
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 375  :   wchar_t wszWOW64 [MAX_PATH + 2] = { };

	push	524					; 0000020cH
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR $T6[ebp], ax
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 375  :   wchar_t wszWOW64 [MAX_PATH + 2] = { };

	lea	eax, DWORD PTR _wszWOW64$3[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T6[ebp+20], 7
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 375  :   wchar_t wszWOW64 [MAX_PATH + 2] = { };

	call	_memset

; 376  :   GetSystemDirectoryW      (wszWOW64, MAX_PATH);

	mov	esi, DWORD PTR __imp__GetSystemDirectoryW@8
	lea	eax, DWORD PTR _wszWOW64$3[ebp]
	add	esp, 12					; 0000000cH
	push	260					; 00000104H
	push	eax
	call	esi

; 377  : #endif
; 378  : 
; 379  :   wchar_t wszSys32 [MAX_PATH + 2] = { };

	push	524					; 0000020cH
	lea	eax, DWORD PTR _wszSys32$2[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 380  :   GetSystemDirectoryW      (wszSys32, MAX_PATH);

	lea	eax, DWORD PTR _wszSys32$2[ebp]
	push	260					; 00000104H
	push	eax
	call	esi

; 381  : 
; 382  :     // Shell hooks don't work very well, they run into problems with
; 383  :     //   hooking XInput -- CBT is more reliable, but slower.
; 384  :     g_hHookCBT =

	push	0
	push	DWORD PTR _hMod$[ebp]
	push	OFFSET ?CBTProc@@YGJHIJ@Z		; CBTProc
	push	5
	call	DWORD PTR __imp__SetWindowsHookExW@16
	mov	DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A, eax ; g_hHookCBT

; 385  :       SetWindowsHookEx (WH_CBT, CBTProc, hMod, 0);
; 386  : 
; 387  :     if (g_hHookCBT != nullptr)

	cmp	DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A, 0 ; g_hHookCBT
	je	$LN133@SKX_Instal

; 388  :     {
; 389  :       __SK_HookContextOwner = true;
; 390  : 
; 391  : #ifdef _WIN64
; 392  :       GetSystemDirectoryW (wszSys32, MAX_PATH);
; 393  :       PathAppendW         (wszSys32, L"rundll32.exe");
; 394  :       ShellExecuteA       (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_HookManager_D3D9 dump", nullptr, SW_HIDE);
; 395  : 
; 396  :       GetSystemDirectoryW (wszSys32, MAX_PATH);
; 397  :       PathAppendW         (wszSys32, L"rundll32.exe");
; 398  :       ShellExecuteA       (nullptr, "open", SK_WideCharToUTF8 (wszSys32).c_str (), "SpecialK64.dll,RunDLL_HookManager_DXGI dump", nullptr, SW_HIDE);
; 399  : #else
; 400  :       GetSystemWow64DirectoryW (wszWOW64, MAX_PATH);

	push	260					; 00000104H
	lea	eax, DWORD PTR _wszWOW64$3[ebp]
	mov	DWORD PTR ?__SK_HookContextOwner@@3JC, 1 ; __SK_HookContextOwner
	push	eax
	call	DWORD PTR __imp__GetSystemWow64DirectoryW@8

; 401  :       PathAppendW              (wszWOW64, L"rundll32.exe");

	push	OFFSET $SG147666
	lea	eax, DWORD PTR _wszWOW64$3[ebp]
	push	eax
	call	DWORD PTR __imp__PathAppendW@8

; 402  :       ShellExecuteA            (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_HookManager_D3D9 dump", nullptr, SW_HIDE);

	push	0
	push	0
	push	OFFSET $SG147667
	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _wszWOW64$3[ebp]
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN75@SKX_Instal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN75@SKX_Instal:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 402  :       ShellExecuteA            (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_HookManager_D3D9 dump", nullptr, SW_HIDE);

	mov	esi, DWORD PTR __imp__ShellExecuteA@24
	push	eax
	push	OFFSET $SG147668
	push	0
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T5[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN84@SKX_Instal

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN84@SKX_Instal:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 404  :       GetSystemWow64DirectoryW (wszWOW64, MAX_PATH);

	push	260					; 00000104H
	lea	eax, DWORD PTR _wszWOW64$3[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemWow64DirectoryW@8

; 405  :       PathAppendW              (wszWOW64, L"rundll32.exe");

	push	OFFSET $SG147669
	lea	eax, DWORD PTR _wszWOW64$3[ebp]
	push	eax
	call	DWORD PTR __imp__PathAppendW@8

; 406  :       ShellExecuteA            (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_HookManager_DXGI dump", nullptr, SW_HIDE);

	push	0
	push	0
	push	OFFSET $SG147670
	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _wszWOW64$3[ebp]
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?SK_WideCharToUTF8@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; SK_WideCharToUTF8
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN124@SKX_Instal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN124@SKX_Instal:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 406  :       ShellExecuteA            (nullptr, "open", SK_WideCharToUTF8 (wszWOW64).c_str (), "SpecialK32.dll,RunDLL_HookManager_DXGI dump", nullptr, SW_HIDE);

	push	eax
	push	OFFSET $SG147671
	push	0
	call	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN133@SKX_Instal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN133@SKX_Instal:
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp

; 410  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SKX_InstallCBTHook@@YGXXZ ENDP				; SKX_InstallCBTHook
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\injection\injection.cpp
_TEXT	SEGMENT
_nCode$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?CBTProc@@YGJHIJ@Z PROC					; CBTProc

; 195  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 196  :   if (nCode < 0)

	mov	esi, DWORD PTR _nCode$[ebp]
	test	esi, esi
	js	SHORT $LN3@CBTProc

; 197  :     return CallNextHookEx (g_hHookCBT, nCode, wParam, lParam);
; 198  : 
; 199  : 
; 200  :   if (hModHookInstance == nullptr && g_hHookCBT)

	cmp	DWORD PTR ?hModHookInstance@@3PAUHINSTANCE__@@A, 0 ; hModHookInstance
	jne	SHORT $LN3@CBTProc
	cmp	DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A, 0 ; g_hHookCBT
	je	SHORT $LN3@CBTProc

; 201  :   {
; 202  :     static volatile LONG lHookIters = 0L;
; 203  : 
; 204  :     // Don't create that thread more than once, but don't bother with a complete
; 205  :     //   critical section.
; 206  :     if (InterlockedIncrement (&lHookIters) > 1L)

	mov	eax, 1
	lock	 xadd	 DWORD PTR ?lHookIters@?6??CBTProc@@YGJHIJ@Z@4JC, eax
	inc	eax
	cmp	eax, 1
	jg	SHORT $LN3@CBTProc

; 207  :       return CallNextHookEx (g_hHookCBT, nCode, wParam, lParam);
; 208  : 
; 209  :     GetModuleHandleEx ( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,

	push	OFFSET ?hModHookInstance@@3PAUHINSTANCE__@@A ; hModHookInstance
	push	OFFSET $SG147563
	push	2
	call	DWORD PTR __imp__GetModuleHandleExW@12

; 210  : #ifdef _WIN64
; 211  :                           L"SpecialK64.dll",
; 212  : #else
; 213  :                           L"SpecialK32.dll",
; 214  : #endif
; 215  :                             (HMODULE *) &hModHookInstance );
; 216  : 
; 217  :     // Get and keep a reference to this DLL if this is the first time we are injecting.
; 218  :     CreateThread ( nullptr, 0,

	push	0
	push	0
	push	0
	push	OFFSET ?<lambda_invoker_stdcall>@<lambda_0b64b922eede83fc8ad9efc12102c151>@@CGKPAX@Z ; <lambda_0b64b922eede83fc8ad9efc12102c151>::<lambda_invoker_stdcall>
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24
$LN3@CBTProc:

; 219  :          [](LPVOID user) ->
; 220  :            DWORD
; 221  :              {
; 222  :                UNREFERENCED_PARAMETER (user);
; 223  : 
; 224  :                if (g_hShutdown != nullptr)
; 225  :                  WaitForSingleObject (g_hShutdown, INFINITE);
; 226  : 
; 227  :                hModHookInstance = nullptr;
; 228  : 
; 229  :                CloseHandle (GetCurrentThread ());
; 230  : 
; 231  :                return 0;
; 232  :              },
; 233  :            nullptr,
; 234  :          0x00,
; 235  :        nullptr
; 236  :     );
; 237  :   }
; 238  : 
; 239  : 
; 240  :   return CallNextHookEx (g_hHookCBT, nCode, wParam, lParam);

	push	DWORD PTR _lParam$[ebp]
	mov	eax, DWORD PTR ?g_hHookCBT@@3RAUHHOOK__@@A ; g_hHookCBT
	push	DWORD PTR _wParam$[ebp]
	push	esi
	push	eax
	call	DWORD PTR __imp__CallNextHookEx@16
	pop	esi

; 241  : }

	pop	ebp
	ret	12					; 0000000cH
?CBTProc@@YGJHIJ@Z ENDP					; CBTProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 79   : 		return (0);

	xor	eax, eax

; 80   : 		}

	ret	0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 516  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 517  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 518  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADQADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 511  : 		{	// assign _Count * _Ch to [_First, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR __Count$[ebp]
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	push	DWORD PTR __First$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 513  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADQADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 505  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 507  : 		}

	pop	ebp

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 485  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH

; 487  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 479  : 		{	// find length of null-terminated string

	npad	2
	push	ebp
	mov	ebp, esp

; 480  : 		return (_CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 481  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?eof@?$char_traits@_W@std@@SAGXZ
_TEXT	SEGMENT
?eof@?$char_traits@_W@std@@SAGXZ PROC			; std::char_traits<wchar_t>::eof, COMDAT

; 361  : 		return (WEOF);

	mov	eax, 65535				; 0000ffffH

; 362  : 		}

	ret	0
?eof@?$char_traits@_W@std@@SAGXZ ENDP			; std::char_traits<wchar_t>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@_W@std@@SAGABG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@_W@std@@SAGABG@Z PROC		; std::char_traits<wchar_t>::not_eof, COMDAT

; 355  : 		{	// return anything but EOF

	npad	2
	push	ebp
	mov	ebp, esp

; 356  : 		return (_Meta != eof() ? _Meta : !eof());

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	ecx, 65535				; 0000ffffH
	movzx	eax, WORD PTR [eax]
	cmp	ax, cx
	jne	SHORT $LN4@not_eof
	xor	eax, eax
$LN4@not_eof:

; 357  : 		}

	pop	ebp
	ret	0
?not_eof@?$char_traits@_W@std@@SAGABG@Z ENDP		; std::char_traits<wchar_t>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z PROC	; std::char_traits<wchar_t>::eq_int_type, COMDAT

; 350  : 		{	// test for metacharacter equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	cx, WORD PTR [eax]
	sete	al

; 351  : 		return (_Left == _Right);
; 352  : 		}

	pop	ebp
	ret	0
?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z ENDP	; std::char_traits<wchar_t>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z PROC	; std::char_traits<wchar_t>::to_int_type, COMDAT

; 345  : 		{	// convert character to metacharacter

	npad	2
	push	ebp
	mov	ebp, esp

; 346  : 		return (_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
	mov	ax, WORD PTR [eax]

; 347  : 		}

	pop	ebp
	ret	0
?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z ENDP	; std::char_traits<wchar_t>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@_W@std@@SA_WABG@Z PROC	; std::char_traits<wchar_t>::to_char_type, COMDAT

; 340  : 		{	// convert metacharacter to character

	npad	2
	push	ebp
	mov	ebp, esp

; 341  : 		return (_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	ax, WORD PTR [eax]

; 342  : 		}

	pop	ebp
	ret	0
?to_char_type@?$char_traits@_W@std@@SA_WABG@Z ENDP	; std::char_traits<wchar_t>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 325  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 326  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	WORD PTR [eax], cx

; 327  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAPA_WQA_WI_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?assign@?$char_traits@_W@std@@SAPA_WQA_WI_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 320  : 		{	// assign _Count * _Ch to [_First, ...)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 260  :         for (; 0 < _N; ++_Su, --_N)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 321  : 		return ((_Elem *)_CSTD wmemset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	edx, ax
	mov	eax, edx
	shl	edx, 16					; 00000010H
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
	pop	edi
$LN12@assign:
	mov	eax, DWORD PTR __First$[ebp]

; 322  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@_W@std@@SAPA_WQA_WI_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 314  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, eax
	mov	DWORD PTR __Count$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 316  : 		}

	pop	ebp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 294  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, eax
	push	eax
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 296  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIQB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIQB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 288  : 		{	// find length of null-terminated sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 289  : 		return (_CSTD wcslen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+2]
	npad	5
$LL3@length:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL3@length
	sub	eax, edx
	sar	eax, 1

; 290  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@_W@std@@SAIQB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?compare@?$char_traits@_W@std@@SAHQB_W0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@_W@std@@SAHQB_W0I@Z PROC		; std::char_traits<wchar_t>::compare, COMDAT

; 283  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __First1$[ebp]
	push	esi
	mov	esi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN5@compare
$LL6@compare:

; 217  :             if (*_S1 != *_S2)

	mov	cx, WORD PTR [eax]
	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN14@compare

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	eax, 2
	add	edx, 2
	sub	esi, 1
	jne	SHORT $LL6@compare
$LN5@compare:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	xor	eax, eax
	pop	esi

; 285  : 		}

	pop	ebp
	ret	0
$LN14@compare:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	sbb	eax, eax
	and	eax, -2					; fffffffeH
	inc	eax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 285  : 		}

	pop	ebp
	ret	0
?compare@?$char_traits@_W@std@@SAHQB_W0I@Z ENDP		; std::char_traits<wchar_t>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 98   :         return;
; 99   :     }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemset
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 2
__N$ = 16						; size = 4
_wmemset PROC						; COMDAT

; 258  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 260  :         for (; 0 < _N; ++_Su, --_N)

	mov	ecx, DWORD PTR __N$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@wmemset

; 259  :         wchar_t *_Su = _S;

	mov	eax, DWORD PTR __C$[ebp]
	movzx	edx, ax
	mov	eax, edx
	shl	edx, 16					; 00000010H
	push	edi
	mov	edi, DWORD PTR __S$[ebp]
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
	pop	edi
$LN10@wmemset:

; 261  :         {
; 262  :             *_Su = _C;
; 263  :         }
; 264  :         return _S;

	mov	eax, DWORD PTR __S$[ebp]

; 265  :     }

	pop	ebp
	ret	0
_wmemset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __N$[ebp]
	add	eax, eax
	mov	DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

	pop	ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	jmp	DWORD PTR __imp__memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __N$[ebp]
	add	eax, eax
	mov	DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

	pop	ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	jmp	_memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcmp
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcmp PROC						; COMDAT

; 215  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	mov	esi, DWORD PTR __N$[ebp]
	test	esi, esi
	je	SHORT $LN3@wmemcmp
	mov	ecx, DWORD PTR __S2$[ebp]
	mov	edx, DWORD PTR __S1$[ebp]
$LL4@wmemcmp:

; 217  :             if (*_S1 != *_S2)

	mov	ax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	jne	SHORT $LN8@wmemcmp

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	edx, 2
	add	ecx, 2
	sub	esi, 1
	jne	SHORT $LL4@wmemcmp
$LN3@wmemcmp:

; 219  : 
; 220  :         return 0;

	xor	eax, eax
	pop	esi

; 221  :     }

	pop	ebp
	ret	0
$LN8@wmemcmp:

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	movzx	eax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	pop	esi
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	inc	eax

; 221  :     }

	pop	ebp
	ret	0
_wmemcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ?_Hash_seq@std@@YAIPBEI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Hash_seq@std@@YAIPBEI@Z PROC				; std::_Hash_seq, COMDAT

; 331  : 	{	// FNV-1a hash function for bytes in [_First, _First + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 332  :  #if defined(_WIN64)
; 333  : 	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 334  : 	const size_t _FNV_offset_basis = 14695981039346656037ULL;
; 335  : 	const size_t _FNV_prime = 1099511628211ULL;
; 336  : 
; 337  :  #else /* defined(_WIN64) */
; 338  : 	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
; 339  : 	const size_t _FNV_offset_basis = 2166136261U;
; 340  : 	const size_t _FNV_prime = 16777619U;
; 341  :  #endif /* defined(_WIN64) */
; 342  : 
; 343  : 	size_t _Val = _FNV_offset_basis;
; 344  : 	for (size_t _Next = 0; _Next < _Count; ++_Next)

	mov	esi, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	mov	edx, -2128831035			; 811c9dc5H
	test	esi, esi
	je	SHORT $LN12@Hash_seq
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
$LL8@Hash_seq:

; 345  : 		{	// fold in another byte
; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ecx+edi]
	inc	ecx
	xor	eax, edx

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	cmp	ecx, esi
	jb	SHORT $LL8@Hash_seq
	pop	edi
$LN12@Hash_seq:

; 348  : 		}
; 349  : 	return (_Val);

	mov	eax, edx
	pop	esi

; 350  : 	}

	pop	ebp
	ret	0
?_Hash_seq@std@@YAIPBEI@Z ENDP				; std::_Hash_seq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _ReadAcquire
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_ReadAcquire PROC					; COMDAT

; 8059 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8060 : 
; 8061 :     LONG Value;
; 8062 : 
; 8063 :     Value = *Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	eax, DWORD PTR [eax]

; 8064 :     return Value;
; 8065 : }

	pop	ebp
	ret	0
_ReadAcquire ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_memcpy_s.h
_TEXT	SEGMENT
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memcpy_s PROC

; 41   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 42   :         if (_SourceSize == 0)

	mov	esi, DWORD PTR __SourceSize$[ebp]
	test	esi, esi
	jne	SHORT $LN2@memcpy_s

; 43   :         {
; 44   :             return 0;

	xor	eax, eax
	pop	esi

; 61   :     }

	pop	ebp
	ret	0
$LN2@memcpy_s:

; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	mov	eax, DWORD PTR __Destination$[ebp]
	test	eax, eax
	jne	SHORT $LN3@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	pop	esi

; 61   :     }

	pop	ebp
	ret	0
$LN3@memcpy_s:
	push	ebx

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

	mov	ebx, DWORD PTR __Source$[ebp]
	push	edi
	mov	edi, DWORD PTR __DestinationSize$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@memcpy_s
	cmp	edi, esi
	jb	SHORT $LN5@memcpy_s

; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

	push	esi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 60   :         return 0;

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 61   :     }

	pop	ebp
	ret	0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

	push	edi
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	test	ebx, ebx
	jne	SHORT $LN6@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

	pop	edi
	pop	ebx
	mov	eax, 22					; 00000016H
	pop	esi

; 61   :     }

	pop	ebp
	ret	0
$LN6@memcpy_s:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	cmp	edi, esi
	jae	SHORT $LN7@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 34			; 00000022H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	pop	edi
	pop	ebx
	mov	eax, 34					; 00000022H
	pop	esi

; 61   :     }

	pop	ebp
	ret	0
_memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
