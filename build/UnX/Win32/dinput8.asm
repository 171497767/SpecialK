; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\input\dinput8.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA ; DirectInput8Create_Import
PUBLIC	?IDirectInput8_CreateDevice_Original@@3P6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@ZA ; IDirectInput8_CreateDevice_Original
PUBLIC	?IDirectInputDevice8_GetDeviceState_MOUSE_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA ; IDirectInputDevice8_GetDeviceState_MOUSE_Original
PUBLIC	?IDirectInputDevice8_GetDeviceState_KEYBOARD_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA ; IDirectInputDevice8_GetDeviceState_KEYBOARD_Original
PUBLIC	?IDirectInputDevice8_GetDeviceState_GAMEPAD_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Original
PUBLIC	?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA ; IDirectInputDevice8_SetCooperativeLevel_Original
PUBLIC	?__di8_ready@@3JC				; __di8_ready
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	?di8_to_xi@@3U_XINPUT_STATE@@A			; di8_to_xi
PUBLIC	?joy_to_xi@@3U_XINPUT_STATE@@A			; joy_to_xi
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?SK_DI8_Backend@@3Usk_input_api_context_s@@A	; SK_DI8_Backend
PUBLIC	_LIBID_ATLLib
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	_CLSID_Registrar
PUBLIC	_IID_IRegistrar
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
_BSS	SEGMENT
?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA DD 01H DUP (?) ; DirectInput8Create_Import
?IDirectInput8_CreateDevice_Original@@3P6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@ZA DD 01H DUP (?) ; IDirectInput8_CreateDevice_Original
?IDirectInputDevice8_GetDeviceState_MOUSE_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA DD 01H DUP (?) ; IDirectInputDevice8_GetDeviceState_MOUSE_Original
?IDirectInputDevice8_GetDeviceState_KEYBOARD_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA DD 01H DUP (?) ; IDirectInputDevice8_GetDeviceState_KEYBOARD_Original
?IDirectInputDevice8_GetDeviceState_GAMEPAD_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA DD 01H DUP (?) ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Original
?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA DD 01H DUP (?) ; IDirectInputDevice8_SetCooperativeLevel_Original
?__di8_ready@@3JC DD 01H DUP (?)			; __di8_ready
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
_BSS	SEGMENT
?di8_to_xi@@3U_XINPUT_STATE@@A DB 010H DUP (?)		; di8_to_xi
?joy_to_xi@@3U_XINPUT_STATE@@A DB 010H DUP (?)		; joy_to_xi
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
_BSS	SEGMENT
?SK_DI8_Backend@@3Usk_input_api_context_s@@A DB 044H DUP (?) ; SK_DI8_Backend
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:$SG252928		; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:$SG252926		; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:$SG252940			; ATL::szDelete
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:$SG252938		; ATL::szNoRemove
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:$SG252936		; ATL::szForceRemove
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:$SG252934		; ATL::szValToken
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:$SG252932		; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:$SG252930		; ATL::szDwordVal
CONST	ENDS
CONST	SEGMENT
$SG252928 DB	'M', 00H, 00H, 00H
$SG252930 DB	'D', 00H, 00H, 00H
$SG252932 DB	'B', 00H, 00H, 00H
$SG252934 DB	'V', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG252936 DB	'F', 00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG252938 DB	'N', 00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'v', 00H, 'e', 00H, 00H, 00H
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
	ORG $+1
$SG252940 DB	'D', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG241678 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG241725 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG241772 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e'
	DB	00H, 00H, 00H
$SG241819 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'l', 00H, 00H, 00H
$SG258235 DB	'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, '8', 00H, 'C'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG258240 DB	'I', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, '8'
	DB	00H, ':', 00H, ':', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, 00H, 00H
$SG241918 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG258236 DB	'[', 00H, ' ', 00H, 'D', 00H, 'I', 00H, 'n', 00H, 'p', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '8', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, '%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' '
	DB	00H, '%', 00H, 'l', 00H, 'u', 00H, ',', 00H, ' ', 00H, '{', 00H
	DB	'.', 00H, '.', 00H, '.', 00H, '}', 00H, ',', 00H, ' ', 00H, 'p'
	DB	00H, 'p', 00H, 'v', 00H, 'O', 00H, 'u', 00H, 't', 00H, '=', 00H
	DB	'%', 00H, 'p', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, ')'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG241866 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG241913 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H
$SG258340 DB	'd', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'8', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG258347 DB	'DirectInput8Create', 00H
	ORG $+1
$SG258341 DB	'[', 00H, ' ', 00H, 'D', 00H, 'I', 00H, 'n', 00H, 'p', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '8', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'I', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 'r'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'I', 00H, 'n', 00H, 'p', 00H
	DB	'u', 00H, 't', 00H, '8', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, '.', 00H, '.', 00H, '.', 00H, '.', 00H
	DB	00H, 00H
$SG241965 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG258342 DB	'[', 00H, ' ', 00H, 'D', 00H, 'I', 00H, 'n', 00H, 'p', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '8', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	00H, 00H
$SG258346 DB	'd', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'8', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG258352 DB	'DirectInput8Create', 00H
	ORG $+1
$SG258348 DB	'[', 00H, ' ', 00H, 'D', 00H, 'I', 00H, 'n', 00H, 'p', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '8', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't'
	DB	00H, '8', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, '%', 00H, 'p'
	DB	00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG258350 DB	'd', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'8', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG258353 DB	'd', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'8', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG258355 DB	'DirectInput8Create', 00H
	ORG $+1
$SG258356 DB	'[', 00H, ' ', 00H, 'D', 00H, 'I', 00H, 'n', 00H, 'p', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '8', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't'
	DB	00H, '8', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, '%', 00H, 'p'
	DB	00H, ' ', 00H, ' ', 00H, '{', 00H, ' ', 00H, 'H', 00H, 'o', 00H
	DB	'o', 00H, 'k', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '}', 00H, 00H
	DB	00H
$SG258371 DB	'd', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'8', 00H, 00H, 00H
$SG258375 DB	'd', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'8', 00H, 00H, 00H
$SG242012 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+2
$SG242059 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I'
	DB	00H, 00H, 00H
$SG241043 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG241114 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H
$SG241161 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H
	ORG $+2
$SG241208 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H
$SG241255 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG241302 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG253616 DB	'A', 00H, 'p', 00H, 'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG253617 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG253618 DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG253619 DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG253620 DB	'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG253621 DB	'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG253622 DB	'M', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG253623 DB	'S', 00H, 'A', 00H, 'M', 00H, 00H, 00H
$SG253624 DB	'S', 00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H
	DB	'T', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG253625 DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	00H, 00H
	ORG $+2
$SG253626 DB	'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG253627 DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H
	DB	'b', 00H, 00H, 00H
$SG258754 DB	'IDirectInputDevice8_GetDeviceState_Detour', 00H
	ORG $+2
$SG241349 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r'
	DB	00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG258755 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG241396 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG258849 DB	'D', 00H, 'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, ' ', 00H, 'S', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'm', 00H, ' ', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 's', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG258757 DB	'[', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'p', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' '
	DB	00H, '8', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'G', 00H, 'e', 00H
	DB	't', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ':', 00H
	DB	' ', 00H, 'c', 00H, 'b', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a'
	DB	00H, ' ', 00H, '=', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'u', 00H
	DB	00H, 00H
	ORG $+2
$SG258848 DB	'D', 00H, 'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, ' ', 00H, 'S', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'm', 00H, ' ', 00H, 'K', 00H, 'e', 00H, 'y', 00H, 'b', 00H
	DB	'o', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 00H, 00H
$SG258850 DB	'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 'p', 00H, 'a', 00H
	DB	'd', 00H, ' ', 00H, '/', 00H, ' ', 00H, 'J', 00H, 'o', 00H, 'y'
	DB	00H, 's', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG258851 DB	'O', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG241443 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG258852 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H, 'n', 00H
	DB	'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, ' ', 00H, ']', 00H, '['
	DB	00H, '!', 00H, ']', 00H, ' ', 00H, 'I', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'I', 00H, 'n', 00H, 'p'
	DB	00H, 'u', 00H, 't', 00H, '8', 00H, ':', 00H, ':', 00H, 'C', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'D', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H
	DB	'%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H, 's'
	DB	00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, ',', 00H
	DB	' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, ')', 00H, 00H, 00H
$SG258853 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H, 'n', 00H
	DB	'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'g'
	DB	00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 'f', 00H
	DB	'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, ':', 00H, ' ', 00H, 00H, 00H
$SG258856 DB	'(', 00H, 'r', 00H, 'e', 00H, 't', 00H, '=', 00H, '0', 00H
	DB	'x', 00H, '%', 00H, '0', 00H, '4', 00H, 'x', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, ')', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG258857 DB	'(', 00H, 'r', 00H, 'e', 00H, 't', 00H, '=', 00H, 'S', 00H
	DB	'_', 00H, 'O', 00H, 'K', 00H, ')', 00H, 0aH, 00H, 00H, 00H
$SG258877 DB	'DirectInput8Create', 00H
	ORG $+1
$SG258860 DB	'I', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, 'D'
	DB	00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, '8', 00H
	DB	':', 00H, ':', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'D', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'S', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 00H, 00H
$SG258862 DB	'I', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, 'D'
	DB	00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, '8', 00H
	DB	':', 00H, ':', 00H, 'S', 00H, 'e', 00H, 't', 00H, 'C', 00H, 'o'
	DB	00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, 'L', 00H, 'e', 00H, 'v', 00H, 'e'
	DB	00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG258876 DB	'd', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'8', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG258884 DB	'dinput.dll', 00H
	ORG $+1
$SG258875 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H, 'n', 00H
	DB	'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 'r'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'I', 00H, 'n', 00H, 'p', 00H
	DB	'u', 00H, 't', 00H, ',', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'h', 00H, 'o', 00H, 'o', 00H, 'k', 00H, 's', 00H
	DB	'.', 00H, '.', 00H, '.', 00H, 00H, 00H
$SG258878 DB	'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, '8', 00H, 'C'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG258885 DB	'dinput8.dll', 00H
$SG258890 DB	'd', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'8', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG241490 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o'
	DB	00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG241537 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i'
	DB	00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG241584 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm'
	DB	00H, 'p', 00H, 'l', 00H, 00H, 00H
$SG241631 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG252926 DB	'S', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	_IsEqualGUID
PUBLIC	_==
PUBLIC	_ReadAcquire
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	?_InterlockedCompareExchange@@YAKPCKKK@Z	; _InterlockedCompareExchange
PUBLIC	?Startup@DI8@SK@@YA_NXZ				; SK::DI8::Startup
PUBLIC	?Shutdown@DI8@SK@@YA_NXZ			; SK::DI8::Shutdown
PUBLIC	?SK_Input_HookDI8@@YAXXZ			; SK_Input_HookDI8
PUBLIC	?SK_Input_PreHookDI8@@YAXXZ			; SK_Input_PreHookDI8
PUBLIC	??0SK_DI8_Keyboard@@QAE@XZ			; SK_DI8_Keyboard::SK_DI8_Keyboard
PUBLIC	??0SK_DI8_Mouse@@QAE@XZ				; SK_DI8_Mouse::SK_DI8_Mouse
PUBLIC	?SK_Input_GetDI8Keyboard@@YGPAUSK_DI8_Keyboard@@XZ ; SK_Input_GetDI8Keyboard
PUBLIC	?SK_Input_GetDI8Mouse@@YGPAUSK_DI8_Mouse@@XZ	; SK_Input_GetDI8Mouse
PUBLIC	?SK_Input_DI8Mouse_Acquire@@YG_NPAUSK_DI8_Mouse@@@Z ; SK_Input_DI8Mouse_Acquire
PUBLIC	?SK_Input_DI8Mouse_Release@@YG_NPAUSK_DI8_Mouse@@@Z ; SK_Input_DI8Mouse_Release
PUBLIC	?SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z ; SK_JOY_TranslateToXInput
PUBLIC	?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z ; sk_input_api_context_s::markRead
PUBLIC	?max@?$numeric_limits@G@std@@SAGXZ		; std::numeric_limits<unsigned short>::max
PUBLIC	?max@?$numeric_limits@K@std@@SAKXZ		; std::numeric_limits<unsigned long>::max
PUBLIC	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z	; std::char_traits<wchar_t>::assign
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z		; _com_error::_com_error
PUBLIC	??1_com_error@@UAE@XZ				; _com_error::~_com_error
PUBLIC	?WCode@_com_error@@QBEGXZ			; _com_error::WCode
PUBLIC	?ErrorMessage@_com_error@@QBEPB_WXZ		; _com_error::ErrorMessage
PUBLIC	?HRESULTToWCode@_com_error@@SAGJ@Z		; _com_error::HRESULTToWCode
PUBLIC	??_G_com_error@@UAEPAXI@Z			; _com_error::`scalar deleting destructor'
PUBLIC	?IDirectInput8_CreateDevice_Detour@@YGJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z ; IDirectInput8_CreateDevice_Detour
PUBLIC	?WaitForInit_DI8@@YGXXZ				; WaitForInit_DI8
PUBLIC	?DirectInput8Create@@YAJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z ; DirectInput8Create
PUBLIC	??$static_cast_p2p@X$$A6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z@@YAPAPAXPAP6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z@Z ; static_cast_p2p<void,long __stdcall(IDirectInput8W *,_GUID const &,IDirectInputDeviceW * *,IUnknown *)>
PUBLIC	?SK_BootDI8@@YGXXZ				; SK_BootDI8
PUBLIC	??$static_cast_p2p@X$$A6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z@@YAPAPAXPAP6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z@Z ; static_cast_p2p<void,long __stdcall(HINSTANCE__ *,unsigned long,_GUID const &,void * *,IUnknown *)>
PUBLIC	?SK_HookDI8@@YGIPAX@Z				; SK_HookDI8
PUBLIC	?di8_init_callback@@YGXP6GXXZ@Z			; di8_init_callback
PUBLIC	?SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z ; SK_DI8_TranslateToXInput
PUBLIC	?IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ; IDirectInputDevice8_GetDeviceState_Detour
PUBLIC	?SK_DInput8_HasKeyboard@@YA_NXZ			; SK_DInput8_HasKeyboard
PUBLIC	?SK_DInput8_BlockWindowsKey@@YA_N_N@Z		; SK_DInput8_BlockWindowsKey
PUBLIC	?SK_DInput8_HasMouse@@YA_NXZ			; SK_DInput8_HasMouse
PUBLIC	?IDirectInputDevice8_GetDeviceState_MOUSE_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ; IDirectInputDevice8_GetDeviceState_MOUSE_Detour
PUBLIC	?IDirectInputDevice8_GetDeviceState_KEYBOARD_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ; IDirectInputDevice8_GetDeviceState_KEYBOARD_Detour
PUBLIC	?IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour
PUBLIC	?IDirectInputDevice8_SetCooperativeLevel_Detour@@YGJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z ; IDirectInputDevice8_SetCooperativeLevel_Detour
PUBLIC	??$static_cast_p2p@X$$A6GJPAUIDirectInputDeviceW@@KPAX@Z@@YAPAPAXPAP6GJPAUIDirectInputDeviceW@@KPAX@Z@Z ; static_cast_p2p<void,long __stdcall(IDirectInputDeviceW *,unsigned long,void *)>
PUBLIC	??$static_cast_p2p@X$$A6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z@@YAPAPAXPAP6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z@Z ; static_cast_p2p<void,long __stdcall(IDirectInputDeviceW *,HWND__ *,unsigned long)>
PUBLIC	??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z		; std::addressof<wchar_t *>
PUBLIC	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$_Unfancy@_W@std@@YAPA_WPA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	??_7_com_error@@6B@				; _com_error::`vftable'
PUBLIC	??_C@_1CI@KPMALOMG@?$AAI?$AAD?$AAi?$AAs?$AAp?$AAa?$AAt?$AAc?$AAh?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$CD?$AA?$CF?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@DOIMBAJG@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AAl?$AAX?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@HHEPHKEC@?$AAO?$AAp?$AAe?$AAn?$AAG?$AAL?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@LLFFMIOK@?$AAd?$AA3?$AAd?$AA9?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@FHHGECGN@?$AAd?$AA3?$AAd?$AA1?$AA1?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@IPOKGKHK@?$AAd?$AAx?$AAg?$AAi?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	?_dik@@3USK_DI8_Keyboard@@A			; _dik
PUBLIC	?_dim@@3USK_DI8_Mouse@@A			; _dim
PUBLIC	??_R4_com_error@@6B@				; _com_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_com_error@@@8				; _com_error `RTTI Type Descriptor'
PUBLIC	??_R3_com_error@@8				; _com_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_com_error@@8				; _com_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_com_error@@8			; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f000000
PUBLIC	__real@43007f7f
PUBLIC	__real@46fffe00
PUBLIC	__real@477fff00
PUBLIC	__real@c3007f7f
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___wcsicmp:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__SleepEx@8:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LocalAlloc@8:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageW@28:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	?SK_ImGui_WantMouseCapture@@YA_NXZ:PROC		; SK_ImGui_WantMouseCapture
EXTRN	?SK_ImGui_WantKeyboardCapture@@YA_NXZ:PROC	; SK_ImGui_WantKeyboardCapture
EXTRN	_swprintf_s:PROC
EXTRN	?SK_GetModuleName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z:PROC ; SK_GetModuleName
EXTRN	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ:PROC		; SK_GetDLL
EXTRN	?SK_TestImports@@YGXPAUHINSTANCE__@@PAUsk_import_test_s@@H@Z:PROC ; SK_TestImports
EXTRN	?SK_TestRenderImports@@YAXPAUHINSTANCE__@@PA_N1111111@Z:PROC ; SK_TestRenderImports
EXTRN	?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ:PROC ; SK::DXGI::StartBudgetThread_NoAdapter
EXTRN	?SK_StartupCore@@YG_NPB_WPAX@Z:PROC		; SK_StartupCore
EXTRN	?SK_ShutdownCore@@YG_NPB_W@Z:PROC		; SK_ShutdownCore
EXTRN	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ:PROC		; SK_GetDLLRole
EXTRN	?SK_IsHostAppSKIM@@YA_NXZ:PROC			; SK_IsHostAppSKIM
EXTRN	?LogEx@iSK_Logger@@UAAX_NQB_WZZ:PROC		; iSK_Logger::LogEx
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z:PROC ; SK_SummarizeCaller
EXTRN	?SK_LoadEarlyImports32@@YAXXZ:PROC		; SK_LoadEarlyImports32
EXTRN	?SK_LoadPlugIns32@@YAXXZ:PROC			; SK_LoadPlugIns32
EXTRN	?SK_BootD3D9@@YAXXZ:PROC			; SK_BootD3D9
EXTRN	?SK_BootDXGI@@YAXXZ:PROC			; SK_BootDXGI
EXTRN	?SK_BootOpenGL@@YAXXZ:PROC			; SK_BootOpenGL
EXTRN	_MH_QueueEnableHook@4:PROC
EXTRN	?SK_CreateFuncHook@@YG?AW4MH_STATUS@@PB_WPAX1PAPAX@Z:PROC ; SK_CreateFuncHook
EXTRN	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z:PROC ; SK_CreateDLLHook2
EXTRN	?SK_EnableHook@@YG?AW4MH_STATUS@@PAX@Z:PROC	; SK_EnableHook
EXTRN	??_E_com_error@@UAEPAXI@Z:PROC			; _com_error::`vector deleting destructor'
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_GUID_SysMouse:BYTE
EXTRN	_GUID_SysKeyboard:BYTE
EXTRN	_GUID_Joystick:BYTE
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?backend_dll@@3PAUHINSTANCE__@@A:DWORD		; backend_dll
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?game_window@@3Usk_window_s@@A:BYTE		; game_window
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
EXTRN	?nav_usable@@3_NA:BYTE				; nav_usable
EXTRN	__fltused:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?hooked@?1??SK_BootDI8@@YGXXZ@4KC
_BSS	SEGMENT
?hooked@?1??SK_BootDI8@@YGXXZ@4KC DD 01H DUP (?)	; `SK_BootDI8'::`2'::hooked
_BSS	ENDS
;	COMDAT ?gl@?1??SK_BootDI8@@YGXXZ@4_NA
_BSS	SEGMENT
?gl@?1??SK_BootDI8@@YGXXZ@4_NA DB 01H DUP (?)		; `SK_BootDI8'::`2'::gl
_BSS	ENDS
;	COMDAT ?vulkan@?1??SK_BootDI8@@YGXXZ@4_NA
_BSS	SEGMENT
?vulkan@?1??SK_BootDI8@@YGXXZ@4_NA DB 01H DUP (?)	; `SK_BootDI8'::`2'::vulkan
_BSS	ENDS
;	COMDAT ?d3d9@?1??SK_BootDI8@@YGXXZ@4_NA
_BSS	SEGMENT
?d3d9@?1??SK_BootDI8@@YGXXZ@4_NA DB 01H DUP (?)		; `SK_BootDI8'::`2'::d3d9
_BSS	ENDS
;	COMDAT ?d3d11@?1??SK_BootDI8@@YGXXZ@4_NA
_BSS	SEGMENT
?d3d11@?1??SK_BootDI8@@YGXXZ@4_NA DB 01H DUP (?)	; `SK_BootDI8'::`2'::d3d11
_BSS	ENDS
;	COMDAT ?dxgi@?1??SK_BootDI8@@YGXXZ@4_NA
_BSS	SEGMENT
?dxgi@?1??SK_BootDI8@@YGXXZ@4_NA DB 01H DUP (?)		; `SK_BootDI8'::`2'::dxgi
_BSS	ENDS
;	COMDAT ?d3d8@?1??SK_BootDI8@@YGXXZ@4_NA
_BSS	SEGMENT
?d3d8@?1??SK_BootDI8@@YGXXZ@4_NA DB 01H DUP (?)		; `SK_BootDI8'::`2'::d3d8
_BSS	ENDS
;	COMDAT ?ddraw@?1??SK_BootDI8@@YGXXZ@4_NA
_BSS	SEGMENT
?ddraw@?1??SK_BootDI8@@YGXXZ@4_NA DB 01H DUP (?)	; `SK_BootDI8'::`2'::ddraw
_BSS	ENDS
;	COMDAT ?glide@?1??SK_BootDI8@@YGXXZ@4_NA
_BSS	SEGMENT
?glide@?1??SK_BootDI8@@YGXXZ@4_NA DB 01H DUP (?)	; `SK_BootDI8'::`2'::glide
_BSS	ENDS
_BSS	SEGMENT
?_dik@@3USK_DI8_Keyboard@@A DB 0208H DUP (?)		; _dik
?_dim@@3USK_DI8_Mouse@@A DB 020H DUP (?)		; _dim
_BSS	ENDS
;	COMDAT ?dwPacket@?1??SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z@4KA
_BSS	SEGMENT
?dwPacket@?1??SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z@4KA DD 01H DUP (?) ; `SK_JOY_TranslateToXInput'::`2'::dwPacket
_BSS	ENDS
;	COMDAT ?dwPacket@?1??SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z@4KA
_BSS	SEGMENT
?dwPacket@?1??SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z@4KA DD 01H DUP (?) ; `SK_DI8_TranslateToXInput'::`2'::dwPacket
_BSS	ENDS
;	COMDAT ?called@?2??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4_NA
_BSS	SEGMENT
?called@?2??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4_NA DB 01H DUP (?) ; `IDirectInputDevice8_GetDeviceState_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?last_state@?BA@??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4UDIJOYSTATE2@@A
_BSS	SEGMENT
?last_state@?BA@??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4UDIJOYSTATE2@@A DB 0110H DUP (?) ; `IDirectInputDevice8_GetDeviceState_Detour'::`16'::last_state
_BSS	ENDS
;	COMDAT ?last_state@?BI@??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4UDIJOYSTATE@@A
_BSS	SEGMENT
?last_state@?BI@??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4UDIJOYSTATE@@A DB 050H DUP (?) ; `IDirectInputDevice8_GetDeviceState_Detour'::`24'::last_state
_BSS	ENDS
;	COMDAT ?hooked@?1??SK_Input_HookDI8@@YAXXZ@4JC
_BSS	SEGMENT
?hooked@?1??SK_Input_HookDI8@@YAXXZ@4JC DD 01H DUP (?)	; `SK_Input_HookDI8'::`2'::hooked
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c3007f7f
CONST	SEGMENT
__real@c3007f7f DD 0c3007f7fr			; -128.498
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@43007f7f
CONST	SEGMENT
__real@43007f7f DD 043007f7fr			; 128.498
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_com_error@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_com_error@@8 DD FLAT:??_R0?AV_com_error@@@8 ; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R2_com_error@@8
rdata$r	SEGMENT
??_R2_com_error@@8 DD FLAT:??_R1A@?0A@EA@_com_error@@8	; _com_error::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_com_error@@8
rdata$r	SEGMENT
??_R3_com_error@@8 DD 00H				; _com_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_com_error@@@8
data$r	SEGMENT
??_R0?AV_com_error@@@8 DD FLAT:??_7type_info@@6B@	; _com_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_com_error@@', 00H
data$r	ENDS
;	COMDAT ??_R4_com_error@@6B@
rdata$r	SEGMENT
??_R4_com_error@@6B@ DD 00H				; _com_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_com_error@@@8
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ?tests@?6??SK_Input_PreHookDI8@@YAXXZ@4PAUsk_import_test_s@@A
_DATA	SEGMENT
?tests@?6??SK_Input_PreHookDI8@@YAXXZ@4PAUsk_import_test_s@@A DD FLAT:$SG258884 ; `SK_Input_PreHookDI8'::`7'::tests
	DB	00H
	ORG $+3
	DD	FLAT:$SG258885
	DB	00H
	ORG $+3
_DATA	ENDS
;	COMDAT ??_C@_1BC@IPOKGKHK@?$AAd?$AAx?$AAg?$AAi?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@IPOKGKHK@?$AAd?$AAx?$AAg?$AAi?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB 'd'
	DB	00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H, 'l', 00H
	DB	'l', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@FHHGECGN@?$AAd?$AA3?$AAd?$AA1?$AA1?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@FHHGECGN@?$AAd?$AA3?$AAd?$AA1?$AA1?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB 'd'
	DB	00H, '3', 00H, 'd', 00H, '1', 00H, '1', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@LLFFMIOK@?$AAd?$AA3?$AAd?$AA9?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@LLFFMIOK@?$AAd?$AA3?$AAd?$AA9?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB 'd'
	DB	00H, '3', 00H, 'd', 00H, '9', 00H, '.', 00H, 'd', 00H, 'l', 00H
	DB	'l', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@HHEPHKEC@?$AAO?$AAp?$AAe?$AAn?$AAG?$AAL?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@HHEPHKEC@?$AAO?$AAp?$AAe?$AAn?$AAG?$AAL?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB 'O'
	DB	00H, 'p', 00H, 'e', 00H, 'n', 00H, 'G', 00H, 'L', 00H, '3', 00H
	DB	'2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@DOIMBAJG@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AAl?$AAX?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@DOIMBAJG@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AAl?$AAX?$AA?$AA@ DB 'U'
	DB	00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H, 'w', 00H, 'n', 00H
	DB	' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H, 'l', 00H, 'X', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@KPMALOMG@?$AAI?$AAD?$AAi?$AAs?$AAp?$AAa?$AAt?$AAc?$AAh?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$CD?$AA?$CF?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@KPMALOMG@?$AAI?$AAD?$AAi?$AAs?$AAp?$AAa?$AAt?$AAc?$AAh?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$CD?$AA?$CF?$AAd?$AA?$AA@ DB 'I'
	DB	00H, 'D', 00H, 'i', 00H, 's', 00H, 'p', 00H, 'a', 00H, 't', 00H
	DB	'c', 00H, 'h', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '#', 00H, '%', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_com_error@@6B@
CONST	SEGMENT
??_7_com_error@@6B@ DD FLAT:??_R4_com_error@@6B@	; _com_error::`vftable'
	DD	FLAT:??_E_com_error@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_DATA	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 04H DUP (?)
	DD	FLAT:___ImageBase			; ATL::_AtlComModule
	DD	FLAT:___pobjMapEntryFirst+4
	DD	FLAT:___pobjMapEntryLast
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__F_AtlComModule@ATL@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__F_AtlComModule@ATL@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z@@YAPAPAXPAP6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z@@YAPAPAXPAP6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z@Z PROC ; static_cast_p2p<void,long __stdcall(IDirectInputDeviceW *,HWND__ *,unsigned long)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z@@YAPAPAXPAP6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z@Z ENDP ; static_cast_p2p<void,long __stdcall(IDirectInputDeviceW *,HWND__ *,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GJPAUIDirectInputDeviceW@@KPAX@Z@@YAPAPAXPAP6GJPAUIDirectInputDeviceW@@KPAX@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GJPAUIDirectInputDeviceW@@KPAX@Z@@YAPAPAXPAP6GJPAUIDirectInputDeviceW@@KPAX@Z@Z PROC ; static_cast_p2p<void,long __stdcall(IDirectInputDeviceW *,unsigned long,void *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GJPAUIDirectInputDeviceW@@KPAX@Z@@YAPAPAXPAP6GJPAUIDirectInputDeviceW@@KPAX@Z@Z ENDP ; static_cast_p2p<void,long __stdcall(IDirectInputDeviceW *,unsigned long,void *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_This$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_dwFlags$ = 16						; size = 4
?IDirectInputDevice8_SetCooperativeLevel_Detour@@YGJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z PROC ; IDirectInputDevice8_SetCooperativeLevel_Detour

; 901  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 902  :   if (config.input.keyboard.block_windows_key)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+708, 0
	push	ebx
	push	esi

; 903  :     dwFlags |= DISCL_NOWINKEY;

	mov	esi, DWORD PTR _dwFlags$[ebp]
	push	edi
	je	SHORT $LN2@IDirectInp
	or	esi, 16					; 00000010H
$LN2@IDirectInp:

; 904  : 
; 905  :   HRESULT hr =
; 906  :     IDirectInputDevice8_SetCooperativeLevel_Original (This, hwnd, dwFlags);

	mov	edi, DWORD PTR _This$[ebp]
	push	esi
	push	DWORD PTR _hwnd$[ebp]
	push	edi
	call	DWORD PTR ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA ; IDirectInputDevice8_SetCooperativeLevel_Original
	mov	ebx, eax

; 907  : 
; 908  :   if (SUCCEEDED (hr))

	test	ebx, ebx
	js	SHORT $LN6@IDirectInp

; 909  :   {
; 910  :     // Mouse
; 911  :     if (This == _dim.pDev)

	cmp	edi, DWORD PTR ?_dim@@3USK_DI8_Mouse@@A
	jne	SHORT $LN4@IDirectInp

; 912  :       _dim.coop_level = dwFlags;

	mov	DWORD PTR ?_dim@@3USK_DI8_Mouse@@A+24, esi
	jmp	SHORT $LN6@IDirectInp
$LN4@IDirectInp:

; 913  : 
; 914  :     // Keyboard   (why do people use DirectInput for keyboards? :-\)
; 915  :     else if (This == _dik.pDev)

	mov	eax, DWORD PTR ?_dik@@3USK_DI8_Keyboard@@A+516
	cmp	edi, DWORD PTR ?_dik@@3USK_DI8_Keyboard@@A
	cmove	eax, esi
	mov	DWORD PTR ?_dik@@3USK_DI8_Keyboard@@A+516, eax
$LN6@IDirectInp:

; 916  :       _dik.coop_level = dwFlags;
; 917  : 
; 918  :     // Anything else is probably not important
; 919  :   }
; 920  : 
; 921  :   if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN9@IDirectInp

; 922  :   {
; 923  :     dwFlags &= ~DISCL_EXCLUSIVE;

	and	esi, -2					; fffffffeH

; 924  : 
; 925  :     IDirectInputDevice8_SetCooperativeLevel_Original (This, hwnd, dwFlags);

	push	esi
	push	DWORD PTR _hwnd$[ebp]
	push	edi
	call	DWORD PTR ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA ; IDirectInputDevice8_SetCooperativeLevel_Original
$LN9@IDirectInp:

; 926  :   }
; 927  : 
; 928  :   return hr;

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 929  : }

	pop	ebp
	ret	12					; 0000000cH
?IDirectInputDevice8_SetCooperativeLevel_Detour@@YGJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z ENDP ; IDirectInputDevice8_SetCooperativeLevel_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_This$ = 8						; size = 4
_cbData$ = 12						; size = 4
_lpvData$ = 16						; size = 4
?IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z PROC ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour

; 885  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 886  :   HRESULT hr = IDirectInputDevice8_GetDeviceState_GAMEPAD_Original ( This, cbData, lpvData );

	push	DWORD PTR _lpvData$[ebp]
	push	DWORD PTR _cbData$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?IDirectInputDevice8_GetDeviceState_GAMEPAD_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Original
	mov	esi, eax

; 887  : 
; 888  :   if (SUCCEEDED (hr))

	test	esi, esi
	js	SHORT $LN2@IDirectInp

; 889  :     IDirectInputDevice8_GetDeviceState_Detour ( This, cbData, lpvData );

	push	DWORD PTR _lpvData$[ebp]
	push	DWORD PTR _cbData$[ebp]
	push	DWORD PTR _This$[ebp]
	call	?IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ; IDirectInputDevice8_GetDeviceState_Detour

; 890  : 
; 891  :   return hr;

	mov	eax, esi
$LN2@IDirectInp:
	pop	esi

; 892  : }

	pop	ebp
	ret	12					; 0000000cH
?IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ENDP ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_This$ = 8						; size = 4
_cbData$ = 12						; size = 4
_lpvData$ = 16						; size = 4
?IDirectInputDevice8_GetDeviceState_KEYBOARD_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z PROC ; IDirectInputDevice8_GetDeviceState_KEYBOARD_Detour

; 871  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 872  :   HRESULT hr = IDirectInputDevice8_GetDeviceState_KEYBOARD_Original ( This, cbData, lpvData );

	push	DWORD PTR _lpvData$[ebp]
	push	DWORD PTR _cbData$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?IDirectInputDevice8_GetDeviceState_KEYBOARD_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA ; IDirectInputDevice8_GetDeviceState_KEYBOARD_Original
	mov	esi, eax

; 873  : 
; 874  :   if (SUCCEEDED (hr))

	test	esi, esi
	js	SHORT $LN2@IDirectInp

; 875  :     IDirectInputDevice8_GetDeviceState_Detour ( This, cbData, lpvData );

	push	DWORD PTR _lpvData$[ebp]
	push	DWORD PTR _cbData$[ebp]
	push	DWORD PTR _This$[ebp]
	call	?IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ; IDirectInputDevice8_GetDeviceState_Detour

; 876  : 
; 877  :   return hr;

	mov	eax, esi
$LN2@IDirectInp:
	pop	esi

; 878  : }

	pop	ebp
	ret	12					; 0000000cH
?IDirectInputDevice8_GetDeviceState_KEYBOARD_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ENDP ; IDirectInputDevice8_GetDeviceState_KEYBOARD_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_This$ = 8						; size = 4
_cbData$ = 12						; size = 4
_lpvData$ = 16						; size = 4
?IDirectInputDevice8_GetDeviceState_MOUSE_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z PROC ; IDirectInputDevice8_GetDeviceState_MOUSE_Detour

; 857  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 858  :   HRESULT hr = IDirectInputDevice8_GetDeviceState_MOUSE_Original ( This, cbData, lpvData );

	push	DWORD PTR _lpvData$[ebp]
	push	DWORD PTR _cbData$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?IDirectInputDevice8_GetDeviceState_MOUSE_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA ; IDirectInputDevice8_GetDeviceState_MOUSE_Original
	mov	esi, eax

; 859  : 
; 860  :   if (SUCCEEDED (hr))

	test	esi, esi
	js	SHORT $LN2@IDirectInp

; 861  :     IDirectInputDevice8_GetDeviceState_Detour ( This, cbData, lpvData );

	push	DWORD PTR _lpvData$[ebp]
	push	DWORD PTR _cbData$[ebp]
	push	DWORD PTR _This$[ebp]
	call	?IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ; IDirectInputDevice8_GetDeviceState_Detour

; 862  : 
; 863  :   return hr;

	mov	eax, esi
$LN2@IDirectInp:
	pop	esi

; 864  : }

	pop	ebp
	ret	12					; 0000000cH
?IDirectInputDevice8_GetDeviceState_MOUSE_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ENDP ; IDirectInputDevice8_GetDeviceState_MOUSE_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?SK_DInput8_HasMouse@@YA_NXZ PROC			; SK_DInput8_HasMouse

; 844  :   return (_dim.pDev && IDirectInputDevice8_SetCooperativeLevel_Original);

	cmp	DWORD PTR ?_dim@@3USK_DI8_Mouse@@A, 0
	je	SHORT $LN3@SK_DInput8
	cmp	DWORD PTR ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA, 0 ; IDirectInputDevice8_SetCooperativeLevel_Original
	je	SHORT $LN3@SK_DInput8
	mov	al, 1

; 845  : }

	ret	0
$LN3@SK_DInput8:

; 844  :   return (_dim.pDev && IDirectInputDevice8_SetCooperativeLevel_Original);

	xor	al, al

; 845  : }

	ret	0
?SK_DInput8_HasMouse@@YA_NXZ ENDP			; SK_DInput8_HasMouse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_block$ = 8						; size = 1
?SK_DInput8_BlockWindowsKey@@YA_N_N@Z PROC		; SK_DInput8_BlockWindowsKey

; 823  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 824  :   DWORD dwFlags =
; 825  :     block ? DISCL_NOWINKEY : 0x0;
; 826  : 
; 827  :   dwFlags &= ~DISCL_EXCLUSIVE;
; 828  :   dwFlags &= ~DISCL_BACKGROUND;
; 829  : 
; 830  :   dwFlags |= DISCL_NONEXCLUSIVE;
; 831  :   dwFlags |= DISCL_FOREGROUND;
; 832  : 
; 833  :   if (SK_DInput8_HasKeyboard ())

	call	?SK_DInput8_HasKeyboard@@YA_NXZ		; SK_DInput8_HasKeyboard
	test	al, al
	je	SHORT $LN2@SK_DInput8

; 834  :     IDirectInputDevice8_SetCooperativeLevel_Original (_dik.pDev, game_window.hWnd, dwFlags);

	push	ebx
	mov	bl, BYTE PTR _block$[ebp]
	mov	eax, 22					; 00000016H
	test	bl, bl
	mov	ecx, 6
	cmovne	ecx, eax
	push	ecx
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	push	DWORD PTR ?_dik@@3USK_DI8_Keyboard@@A
	call	DWORD PTR ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA ; IDirectInputDevice8_SetCooperativeLevel_Original

; 837  : 
; 838  :   return block;

	mov	al, bl
	pop	ebx

; 839  : }

	pop	ebp
	ret	0
$LN2@SK_DInput8:

; 835  :   else
; 836  :     return false;

	xor	al, al

; 839  : }

	pop	ebp
	ret	0
?SK_DInput8_BlockWindowsKey@@YA_N_N@Z ENDP		; SK_DInput8_BlockWindowsKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?SK_DInput8_HasKeyboard@@YA_NXZ PROC			; SK_DInput8_HasKeyboard

; 819  :   return (_dik.pDev && IDirectInputDevice8_SetCooperativeLevel_Original);

	cmp	DWORD PTR ?_dik@@3USK_DI8_Keyboard@@A, 0
	je	SHORT $LN3@SK_DInput8
	cmp	DWORD PTR ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA, 0 ; IDirectInputDevice8_SetCooperativeLevel_Original
	je	SHORT $LN3@SK_DInput8
	mov	al, 1

; 820  : }

	ret	0
$LN3@SK_DInput8:

; 819  :   return (_dik.pDev && IDirectInputDevice8_SetCooperativeLevel_Original);

	xor	al, al

; 820  : }

	ret	0
?SK_DInput8_HasKeyboard@@YA_NXZ ENDP			; SK_DInput8_HasKeyboard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 16
$T2 = -16						; size = 16
_This$ = 8						; size = 4
_cbData$ = 12						; size = 4
_lpvData$ = 16						; size = 4
?IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z PROC ; IDirectInputDevice8_GetDeviceState_Detour

; 688  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 689  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4_NA, 0
	jne	SHORT $LN92@IDirectInp
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+808, 0
	jl	SHORT $LN5@IDirectInp
	push	OFFSET $SG258754
	push	OFFSET $SG258755
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN5@IDirectInp:
	mov	BYTE PTR ?called@?2??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4_NA, 1
$LN92@IDirectInp:

; 690  : 
; 691  :   SK_LOG4 ( ( L" DirectInput 8 - GetDeviceState: cbData = %lu",

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+808, 4
	push	esi
	push	edi
	mov	edi, DWORD PTR _cbData$[ebp]
	jl	SHORT $LN6@IDirectInp
	push	edi
	push	OFFSET $SG258757
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN6@IDirectInp:

; 692  :                 cbData ),
; 693  :               L"Direct Inp" );
; 694  : 
; 695  :   HRESULT hr = S_OK;
; 696  : 
; 697  :   if (SUCCEEDED (hr) && lpvData != nullptr)

	mov	esi, DWORD PTR _lpvData$[ebp]
	test	esi, esi
	je	$LN19@IDirectInp

; 698  :   {
; 699  :     if (cbData == sizeof DIJOYSTATE2) 

	cmp	edi, 272				; 00000110H
	jne	SHORT $LN8@IDirectInp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_DI8_Backend@@3Usk_input_api_context_s@@A+40
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 707  :       SK_DI8_TranslateToXInput (reinterpret_cast <DIJOYSTATE *> (out));

	lea	eax, DWORD PTR $T2[ebp]
	push	esi
	push	eax
	call	?SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z ; SK_DI8_TranslateToXInput
	add	esp, 8

; 708  : 
; 709  :       if (nav_usable)

	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable

; 710  :       {
; 711  :         memcpy (out, &last_state, cbData);

	push	edi
	je	SHORT $LN10@IDirectInp
	push	OFFSET ?last_state@?BA@??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4UDIJOYSTATE2@@A
	push	esi
	call	_memcpy

; 778  :         memset (lpvData, 0, cbData);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+32], -1
	mov	DWORD PTR [esi+36], -1

; 804  :             static_cast <DIMOUSESTATE *> (lpvData)->lY = 0;
; 805  :             static_cast <DIMOUSESTATE *> (lpvData)->lZ = 0;
; 806  :             memset (static_cast <DIMOUSESTATE *> (lpvData)->rgbButtons, 0, 4);
; 807  :             break;
; 808  :         }
; 809  :       }
; 810  :     }
; 811  :   }
; 812  : 
; 813  :   return hr;

	xor	eax, eax
	mov	DWORD PTR [esi+40], -1
	mov	DWORD PTR [esi+44], -1
	pop	edi
	pop	esi

; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN10@IDirectInp:

; 712  : 
; 713  :         out->rgdwPOV [0] = std::numeric_limits <DWORD>::max ();
; 714  :         out->rgdwPOV [1] = std::numeric_limits <DWORD>::max ();
; 715  :         out->rgdwPOV [2] = std::numeric_limits <DWORD>::max ();
; 716  :         out->rgdwPOV [3] = std::numeric_limits <DWORD>::max ();
; 717  :       } else
; 718  :         memcpy (&last_state, out, cbData);

	push	esi
	push	OFFSET ?last_state@?BA@??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4UDIJOYSTATE2@@A
	call	_memcpy

; 778  :         memset (lpvData, 0, cbData);

	add	esp, 12					; 0000000cH

; 804  :             static_cast <DIMOUSESTATE *> (lpvData)->lY = 0;
; 805  :             static_cast <DIMOUSESTATE *> (lpvData)->lZ = 0;
; 806  :             memset (static_cast <DIMOUSESTATE *> (lpvData)->rgbButtons, 0, 4);
; 807  :             break;
; 808  :         }
; 809  :       }
; 810  :     }
; 811  :   }
; 812  : 
; 813  :   return hr;

	xor	eax, eax
	pop	edi
	pop	esi

; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN8@IDirectInp:

; 719  :     }
; 720  : 
; 721  :     else if (cbData == sizeof DIJOYSTATE) 

	cmp	edi, 80					; 00000050H
	jne	SHORT $LN12@IDirectInp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_DI8_Backend@@3Usk_input_api_context_s@@A+40
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 732  :       SK_DI8_TranslateToXInput (out);

	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	push	eax
	call	?SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z ; SK_DI8_TranslateToXInput
	add	esp, 8

; 733  : 
; 734  :       if (nav_usable)

	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable

; 735  :       {
; 736  :         memcpy (out, &last_state, cbData);

	push	edi
	je	SHORT $LN14@IDirectInp
	push	OFFSET ?last_state@?BI@??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4UDIJOYSTATE@@A
	push	esi
	call	_memcpy

; 778  :         memset (lpvData, 0, cbData);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+32], -1
	mov	DWORD PTR [esi+36], -1

; 804  :             static_cast <DIMOUSESTATE *> (lpvData)->lY = 0;
; 805  :             static_cast <DIMOUSESTATE *> (lpvData)->lZ = 0;
; 806  :             memset (static_cast <DIMOUSESTATE *> (lpvData)->rgbButtons, 0, 4);
; 807  :             break;
; 808  :         }
; 809  :       }
; 810  :     }
; 811  :   }
; 812  : 
; 813  :   return hr;

	xor	eax, eax
	mov	DWORD PTR [esi+40], -1
	mov	DWORD PTR [esi+44], -1
	pop	edi
	pop	esi

; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN14@IDirectInp:

; 737  : 
; 738  :         out->rgdwPOV [0] = std::numeric_limits <DWORD>::max ();
; 739  :         out->rgdwPOV [1] = std::numeric_limits <DWORD>::max ();
; 740  :         out->rgdwPOV [2] = std::numeric_limits <DWORD>::max ();
; 741  :         out->rgdwPOV [3] = std::numeric_limits <DWORD>::max ();
; 742  :       }
; 743  :       else
; 744  :         memcpy (&last_state, out, cbData);

	push	esi
	push	OFFSET ?last_state@?BI@??IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z@4UDIJOYSTATE@@A
	call	_memcpy

; 778  :         memset (lpvData, 0, cbData);

	add	esp, 12					; 0000000cH

; 804  :             static_cast <DIMOUSESTATE *> (lpvData)->lY = 0;
; 805  :             static_cast <DIMOUSESTATE *> (lpvData)->lZ = 0;
; 806  :             memset (static_cast <DIMOUSESTATE *> (lpvData)->rgbButtons, 0, 4);
; 807  :             break;
; 808  :         }
; 809  :       }
; 810  :     }
; 811  :   }
; 812  : 
; 813  :   return hr;

	xor	eax, eax
	pop	edi
	pop	esi

; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN12@IDirectInp:

; 745  : 
; 746  : #if 0
; 747  :       XINPUT_STATE xis;
; 748  :       SK_XInput_PollController (0, &xis);
; 749  : 
; 750  :       out->rgbButtons [ 9] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_START          ) != 0x0 ? 0xFF : 0x00);
; 751  :       out->rgbButtons [ 8] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_BACK           ) != 0x0 ? 0xFF : 0x00);
; 752  :       out->rgbButtons [10] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB     ) != 0x0 ? 0xFF : 0x00);
; 753  :       out->rgbButtons [11] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB    ) != 0x0 ? 0xFF : 0x00);
; 754  :       out->rgbButtons [ 6] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_TRIGGER   ) != 0x0 ? 0xFF : 0x00);
; 755  :       out->rgbButtons [ 7] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_TRIGGER  ) != 0x0 ? 0xFF : 0x00);
; 756  :       out->rgbButtons [ 4] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER  ) != 0x0 ? 0xFF : 0x00);
; 757  :       out->rgbButtons [ 5] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER ) != 0x0 ? 0xFF : 0x00);
; 758  :       out->rgbButtons [ 1] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_A              ) != 0x0 ? 0xFF : 0x00);
; 759  :       out->rgbButtons [ 2] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_B              ) != 0x0 ? 0xFF : 0x00);
; 760  :       out->rgbButtons [ 0] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_X              ) != 0x0 ? 0xFF : 0x00);
; 761  :       out->rgbButtons [ 3] = (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_Y              ) != 0x0 ? 0xFF : 0x00);
; 762  : 
; 763  :       out->rgdwPOV [0] += (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP           ) != 0x0 ?      0 : 0);
; 764  :       out->rgdwPOV [0] += (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT        ) != 0x0 ?  90000 : 0);
; 765  :       out->rgdwPOV [0] += (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN         ) != 0x0 ? 180000 : 0);
; 766  :       out->rgdwPOV [0] += (( xis.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT         ) != 0x0 ? 270000 : 0);
; 767  : 
; 768  :       if (out->rgdwPOV [0] == 0)
; 769  :         out->rgdwPOV [0] = -1;
; 770  : #endif
; 771  :     }
; 772  : 
; 773  :     else if (This == _dik.pDev || cbData == 256)

	mov	eax, DWORD PTR _This$[ebp]
	cmp	eax, DWORD PTR ?_dik@@3USK_DI8_Keyboard@@A
	je	SHORT $LN18@IDirectInp
	cmp	edi, 256				; 00000100H
	je	SHORT $LN18@IDirectInp

; 779  :     }
; 780  : 
; 781  :     else if ( cbData == sizeof (DIMOUSESTATE2) ||

	cmp	edi, 20					; 00000014H
	je	SHORT $LN21@IDirectInp
	cmp	edi, 16					; 00000010H
	jne	$LN19@IDirectInp
$LN21@IDirectInp:
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_DI8_Backend@@3Usk_input_api_context_s@@A+32
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 791  :       if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN19@IDirectInp

; 792  :       {
; 793  :         switch (cbData)

	cmp	edi, 16					; 00000010H
	je	SHORT $LN24@IDirectInp
	cmp	edi, 20					; 00000014H
	jne	SHORT $LN19@IDirectInp

; 794  :         {
; 795  :           case sizeof (DIMOUSESTATE2):
; 796  :             static_cast <DIMOUSESTATE2 *> (lpvData)->lX = 0;

	mov	DWORD PTR [esi], 0
	xorps	xmm0, xmm0

; 797  :             static_cast <DIMOUSESTATE2 *> (lpvData)->lY = 0;

	mov	DWORD PTR [esi+4], 0

; 804  :             static_cast <DIMOUSESTATE *> (lpvData)->lY = 0;
; 805  :             static_cast <DIMOUSESTATE *> (lpvData)->lZ = 0;
; 806  :             memset (static_cast <DIMOUSESTATE *> (lpvData)->rgbButtons, 0, 4);
; 807  :             break;
; 808  :         }
; 809  :       }
; 810  :     }
; 811  :   }
; 812  : 
; 813  :   return hr;

	xor	eax, eax
	mov	DWORD PTR [esi+8], 0
	pop	edi
	movq	QWORD PTR [esi+12], xmm0
	pop	esi

; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN24@IDirectInp:

; 798  :             static_cast <DIMOUSESTATE2 *> (lpvData)->lZ = 0;
; 799  :             memset (static_cast <DIMOUSESTATE2 *> (lpvData)->rgbButtons, 0, 8);
; 800  :             break;
; 801  : 
; 802  :           case sizeof (DIMOUSESTATE):
; 803  :             static_cast <DIMOUSESTATE *> (lpvData)->lX = 0;

	mov	DWORD PTR [esi], 0

; 804  :             static_cast <DIMOUSESTATE *> (lpvData)->lY = 0;
; 805  :             static_cast <DIMOUSESTATE *> (lpvData)->lZ = 0;
; 806  :             memset (static_cast <DIMOUSESTATE *> (lpvData)->rgbButtons, 0, 4);
; 807  :             break;
; 808  :         }
; 809  :       }
; 810  :     }
; 811  :   }
; 812  : 
; 813  :   return hr;

	xor	eax, eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	pop	edi
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN18@IDirectInp:
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_DI8_Backend@@3Usk_input_api_context_s@@A+36
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 777  :       if (SK_ImGui_WantKeyboardCapture () && lpvData != nullptr)

	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture
	test	al, al
	je	SHORT $LN19@IDirectInp

; 778  :         memset (lpvData, 0, cbData);

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
$LN19@IDirectInp:

; 804  :             static_cast <DIMOUSESTATE *> (lpvData)->lY = 0;
; 805  :             static_cast <DIMOUSESTATE *> (lpvData)->lZ = 0;
; 806  :             memset (static_cast <DIMOUSESTATE *> (lpvData)->rgbButtons, 0, 4);
; 807  :             break;
; 808  :         }
; 809  :       }
; 810  :     }
; 811  :   }
; 812  : 
; 813  :   return hr;

	pop	edi
	xor	eax, eax
	pop	esi

; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IDirectInputDevice8_GetDeviceState_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ENDP ; IDirectInputDevice8_GetDeviceState_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
$T1 = 8							; size = 4
_pJoy$ = 12						; size = 4
?SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z PROC ; SK_DI8_TranslateToXInput

; 612  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 613  :   static DWORD dwPacket = 0;
; 614  : 
; 615  :   ZeroMemory (&di8_to_xi.Gamepad, sizeof (XINPUT_STATE::Gamepad));
; 616  : 
; 617  :   //
; 618  :   // Hard-coded mappings for DualShock 4 -> XInput
; 619  :   //
; 620  : 
; 621  :   if (pJoy->rgbButtons [ 9])

	mov	ecx, DWORD PTR _pJoy$[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, xmm0

; 622  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_START;

	mov	ax, WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4
	mov	DWORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+12, 0
	cmp	BYTE PTR [ecx+57], 0
	je	SHORT $LN2@SK_DI8_Tra
	or	ax, 16					; 00000010H
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN2@SK_DI8_Tra:

; 623  : 
; 624  :   if (pJoy->rgbButtons [ 8])

	cmp	BYTE PTR [ecx+56], 0
	je	SHORT $LN3@SK_DI8_Tra

; 625  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_BACK;

	or	ax, 32					; 00000020H
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN3@SK_DI8_Tra:

; 626  : 
; 627  :   if (pJoy->rgbButtons [10])

	cmp	BYTE PTR [ecx+58], 0
	je	SHORT $LN4@SK_DI8_Tra

; 628  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_THUMB;

	or	ax, 64					; 00000040H
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN4@SK_DI8_Tra:

; 629  : 
; 630  :   if (pJoy->rgbButtons [11])

	cmp	BYTE PTR [ecx+59], 0
	je	SHORT $LN5@SK_DI8_Tra

; 631  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_THUMB;

	mov	edx, 128				; 00000080H
	or	ax, dx
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN5@SK_DI8_Tra:

; 632  : 
; 633  :   if (pJoy->rgbButtons [ 6])
; 634  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_TRIGGER;
; 635  : 
; 636  :   if (pJoy->rgbButtons [ 7])
; 637  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_TRIGGER;
; 638  : 
; 639  :   if (pJoy->rgbButtons [ 4])

	cmp	BYTE PTR [ecx+52], 0
	je	SHORT $LN8@SK_DI8_Tra

; 640  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_SHOULDER;

	mov	edx, 256				; 00000100H
	or	ax, dx
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN8@SK_DI8_Tra:

; 641  : 
; 642  :   if (pJoy->rgbButtons [ 5])

	cmp	BYTE PTR [ecx+53], 0
	je	SHORT $LN9@SK_DI8_Tra

; 643  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_SHOULDER;

	mov	edx, 512				; 00000200H
	or	ax, dx
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN9@SK_DI8_Tra:

; 644  : 
; 645  :   if (pJoy->rgbButtons [ 1])

	cmp	BYTE PTR [ecx+49], 0
	je	SHORT $LN10@SK_DI8_Tra

; 646  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_A;

	mov	edx, 4096				; 00001000H
	or	ax, dx
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN10@SK_DI8_Tra:

; 647  : 
; 648  :   if (pJoy->rgbButtons [ 2])

	cmp	BYTE PTR [ecx+50], 0
	je	SHORT $LN11@SK_DI8_Tra

; 649  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_B;

	mov	edx, 8192				; 00002000H
	or	ax, dx
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN11@SK_DI8_Tra:

; 650  : 
; 651  :   if (pJoy->rgbButtons [ 0])

	cmp	BYTE PTR [ecx+48], 0
	je	SHORT $LN12@SK_DI8_Tra

; 652  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_X;

	mov	edx, 16384				; 00004000H
	or	ax, dx
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN12@SK_DI8_Tra:

; 653  : 
; 654  :   if (pJoy->rgbButtons [ 3])

	cmp	BYTE PTR [ecx+51], 0
	je	SHORT $LN13@SK_DI8_Tra

; 655  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_Y;

	mov	edx, 32768				; 00008000H
	or	ax, dx
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN13@SK_DI8_Tra:

; 656  : 
; 657  :   if (pJoy->rgdwPOV [0] == 0)

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN14@SK_DI8_Tra

; 658  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP;

	or	ax, 1
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN14@SK_DI8_Tra:

; 659  : 
; 660  :   if (pJoy->rgdwPOV [0] == 9000)

	cmp	DWORD PTR [ecx+32], 9000		; 00002328H
	jne	SHORT $LN15@SK_DI8_Tra

; 661  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT;

	or	ax, 8
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN15@SK_DI8_Tra:

; 662  : 
; 663  :   if (pJoy->rgdwPOV [0] == 18000)

	cmp	DWORD PTR [ecx+32], 18000		; 00004650H
	jne	SHORT $LN16@SK_DI8_Tra

; 664  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN;

	or	ax, 2
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN16@SK_DI8_Tra:

; 665  : 
; 666  :   if (pJoy->rgdwPOV [0] == 27000)

	cmp	DWORD PTR [ecx+32], 27000		; 00006978H
	jne	SHORT $LN17@SK_DI8_Tra

; 667  :     di8_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT;

	or	ax, 4
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+4, ax
$LN17@SK_DI8_Tra:

; 668  : 
; 669  :   di8_to_xi.Gamepad.sThumbLX      =  (SHORT)((float)MAXSHORT * ((float)pJoy->lX / 255.0f));

	movd	xmm0, DWORD PTR [ecx]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@43007f7f
	cvttss2si eax, xmm0
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+8, ax
	movd	xmm0, DWORD PTR [ecx+4]

; 670  :   di8_to_xi.Gamepad.sThumbLY      = -(SHORT)((float)MAXSHORT * ((float)pJoy->lY / 255.0f));

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@c3007f7f
	cvttss2si eax, xmm0
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+10, ax
	movd	xmm0, DWORD PTR [ecx+8]

; 671  : 
; 672  :   di8_to_xi.Gamepad.sThumbRX      =  (SHORT)((float)MAXSHORT * ((float)pJoy->lZ  / 255.0f));

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@43007f7f
	cvttss2si eax, xmm0
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+12, ax
	movd	xmm0, DWORD PTR [ecx+20]

; 673  :   di8_to_xi.Gamepad.sThumbRY      = -(SHORT)((float)MAXSHORT * ((float)pJoy->lRz / 255.0f));

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@c3007f7f
	cvttss2si eax, xmm0
	mov	WORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+14, ax

; 674  : 
; 675  :   di8_to_xi.Gamepad.bLeftTrigger  =   (BYTE)((float)MAXBYTE  * ((float)pJoy->lRx / 255.0f));

	movzx	eax, BYTE PTR [ecx+12]
	mov	BYTE PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+6, al

; 676  :   di8_to_xi.Gamepad.bRightTrigger =   (BYTE)((float)MAXBYTE  * ((float)pJoy->lRy / 255.0f));

	movzx	eax, BYTE PTR [ecx+16]
	mov	BYTE PTR ?di8_to_xi@@3U_XINPUT_STATE@@A+7, al

; 677  : 
; 678  :   di8_to_xi.dwPacketNumber = dwPacket++;

	mov	eax, DWORD PTR ?dwPacket@?1??SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z@4KA
	mov	DWORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A, eax
	inc	eax

; 679  : 
; 680  :   return di8_to_xi;

	movups	xmm0, XMMWORD PTR ?di8_to_xi@@3U_XINPUT_STATE@@A
	mov	DWORD PTR ?dwPacket@?1??SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z@4KA, eax
	mov	eax, DWORD PTR $T1[ebp]
	movups	XMMWORD PTR [eax], xmm0

; 681  : }

	pop	ebp
	ret	0
?SK_DI8_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUDIJOYSTATE@@@Z ENDP ; SK_DI8_TranslateToXInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
;	COMDAT ??R<lambda_56d1d3dc192781aff6ae561813c7f09c>@@QBEXIIMKAA_N0@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
_threshold$ = 16					; size = 4
_pos$ = 20						; size = 4
_lt$ = 24						; size = 4
_rt$ = 28						; size = 4
??R<lambda_56d1d3dc192781aff6ae561813c7f09c>@@QBEXIIMKAA_N0@Z PROC ; <lambda_56d1d3dc192781aff6ae561813c7f09c>::operator(), COMDAT
; _this$ = ecx

; 454  :   {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 455  :     float range = ( static_cast <float> ( max ) - static_cast <float> ( min ) );

	mov	esi, DWORD PTR _min$[ebp]
	push	edi
	mov	edi, DWORD PTR _max$[ebp]
	mov	eax, edi
	shr	eax, 31					; 0000001fH
	movd	xmm1, esi
	cvtdq2pd xmm1, xmm1
	movd	xmm0, edi
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, esi
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm0, xmm0
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm1, xmm1
	subss	xmm0, xmm1

; 456  : 
; 457  :     if (pos <= min + static_cast <UINT> ( threshold * range ))

	mulss	xmm0, DWORD PTR _threshold$[ebp]
	call	__ftoui3
	mov	edx, DWORD PTR _pos$[ebp]
	lea	ecx, DWORD PTR [eax+esi]
	cmp	edx, ecx
	ja	SHORT $LN2@operator

; 458  :       rt = true;

	mov	ecx, DWORD PTR _rt$[ebp]
	mov	BYTE PTR [ecx], 1
$LN2@operator:

; 459  : 
; 460  :     if (pos >= max - static_cast <UINT> ( threshold * range ))

	sub	edi, eax
	cmp	edx, edi
	pop	edi
	pop	esi
	jb	SHORT $LN3@operator

; 461  :       lt = true;

	mov	eax, DWORD PTR _lt$[ebp]
	mov	BYTE PTR [eax], 1
$LN3@operator:

; 462  :   };

	pop	ebp
	ret	24					; 00000018H
??R<lambda_56d1d3dc192781aff6ae561813c7f09c>@@QBEXIIMKAA_N0@Z ENDP ; <lambda_56d1d3dc192781aff6ae561813c7f09c>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
;	COMDAT ??R<lambda_9edb06091c12c988ebabcf846446a6cf>@@QBEFIIK@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
_pos$ = 16						; size = 4
??R<lambda_9edb06091c12c988ebabcf846446a6cf>@@QBEFIIK@Z PROC ; <lambda_9edb06091c12c988ebabcf846446a6cf>::operator(), COMDAT
; _this$ = ecx

; 432  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 433  :     float range = ( static_cast <float> ( max ) - static_cast <float> ( min ) );

	mov	eax, DWORD PTR _max$[ebp]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _min$[ebp]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	movaps	xmm4, xmm1
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 434  :     float center = ( static_cast <float> ( max ) + static_cast <float> ( min ) ) / 2.0f;
; 435  :     float rpos = 0.5f;
; 436  : 
; 437  :     if (static_cast <float> ( pos ) < center)

	mov	eax, DWORD PTR _pos$[ebp]
	cvtpd2ps xmm3, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	movaps	xmm2, xmm3
	subss	xmm4, xmm3
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	addss	xmm2, xmm1
	cvtpd2ps xmm1, xmm0
	mulss	xmm2, DWORD PTR __real@3f000000
	comiss	xmm2, xmm1
	jbe	SHORT $LN2@operator

; 438  :       rpos = center - ( center - static_cast <float> ( pos ) );

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	subss	xmm2, xmm0

; 439  :     else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 440  :       rpos = static_cast <float> ( pos ) - static_cast <float> ( min );

	movaps	xmm2, xmm1
	subss	xmm2, xmm3
$LN3@operator:

; 441  : 
; 442  :     std::numeric_limits <unsigned short>::max ( );
; 443  : 
; 444  :     float max_xi = static_cast <float> ( std::numeric_limits <unsigned short>::max ( ) );
; 445  :     float center_xi = static_cast <float> ( std::numeric_limits <unsigned short>::max ( ) / 2 );
; 446  : 
; 447  :     return

	divss	xmm2, xmm4
	mulss	xmm2, DWORD PTR __real@477fff00
	subss	xmm2, DWORD PTR __real@46fffe00
	cvttss2si eax, xmm2

; 448  :       static_cast <SHORT> ( max_xi * ( rpos / range ) - center_xi );
; 449  :   };

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_9edb06091c12c988ebabcf846446a6cf>@@QBEFIIK@Z ENDP ; <lambda_9edb06091c12c988ebabcf846446a6cf>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_finish$ = 8						; size = 4
?di8_init_callback@@YGXP6GXXZ@Z PROC			; di8_init_callback

; 325  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 326  :   if (! SK_IsHostAppSKIM ())

	call	?SK_IsHostAppSKIM@@YA_NXZ		; SK_IsHostAppSKIM
	test	al, al
	jne	SHORT $LN2@di8_init_c

; 327  :   {
; 328  :     SK_HookDI8 (nullptr);

	push	0
	call	?SK_HookDI8@@YGIPAX@Z			; SK_HookDI8

; 329  : 
; 330  :     WaitForInit_DI8 ();

	call	?WaitForInit_DI8@@YGXXZ			; WaitForInit_DI8
$LN2@di8_init_c:

; 331  :   }
; 332  : 
; 333  :   finish ();

	call	DWORD PTR _finish$[ebp]

; 334  : }

	pop	ebp
	ret	4
?di8_init_callback@@YGXP6GXXZ@Z ENDP			; di8_init_callback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_user$ = 8						; size = 4
?SK_HookDI8@@YGIPAX@Z PROC				; SK_HookDI8

; 297  : {

	npad	2
	push	ebx

; 298  :   UNREFERENCED_PARAMETER (user);
; 299  : 
; 300  :   //if (! config.apis.di8.hook)
; 301  :   //{
; 302  :   //  return 0;
; 303  :   //}
; 304  : 
; 305  :   const bool success = SUCCEEDED (

	push	0
	push	0
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	setns	bl

; 306  :     CoInitializeEx (nullptr, COINIT_MULTITHREADED)
; 307  :   );
; 308  : 
; 309  :   {
; 310  :     SK_BootDI8 ();

	call	?SK_BootDI8@@YGXXZ			; SK_BootDI8

; 311  : 
; 312  :     if (! (SK_GetDLLRole () & DLL_ROLE::DXGI))

	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	test	al, 1
	jne	SHORT $LN2@SK_HookDI8

; 313  :       SK::DXGI::StartBudgetThread_NoAdapter ();

	call	?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ ; SK::DXGI::StartBudgetThread_NoAdapter
$LN2@SK_HookDI8:

; 314  :   }
; 315  : 
; 316  :   if (success)

	test	bl, bl
	pop	ebx
	je	SHORT $LN5@SK_HookDI8

; 317  :     CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN5@SK_HookDI8:

; 318  :  
; 319  :   return 0;

	xor	eax, eax

; 320  : }

	ret	4
?SK_HookDI8@@YGIPAX@Z ENDP				; SK_HookDI8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
;	COMDAT ??B<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@QBEP6GKPAX@ZXZ
_TEXT	SEGMENT
??B<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@QBEP6GKPAX@ZXZ PROC ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::operator unsigned long (__stdcall*)(void *), COMDAT
; _this$ = ecx

; 291  : }, nullptr, 0x00, nullptr);

	mov	eax, OFFSET ?<lambda_invoker_stdcall>@<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@CGKPAX@Z ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::<lambda_invoker_stdcall>
	ret	0
??B<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@QBEP6GKPAX@ZXZ ENDP ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::operator unsigned long (__stdcall*)(void *)
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
;	COMDAT ?<lambda_invoker_stdcall>@<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@CGKPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
?<lambda_invoker_stdcall>@<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@CGKPAX@Z PROC ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::<lambda_invoker_stdcall>, COMDAT

; 291  : }, nullptr, 0x00, nullptr);

	npad	2
	push	ebp
	mov	ebp, esp
	xor	ecx, ecx
	pop	ebp
	jmp	??R<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@QBEKPAX@Z ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::operator()
?<lambda_invoker_stdcall>@<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@CGKPAX@Z ENDP ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::<lambda_invoker_stdcall>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
;	COMDAT ??R<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@QBEKPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
??R<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@QBEKPAX@Z PROC ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::operator(), COMDAT
; _this$ = ecx

; 251  :   UNREFERENCED_PARAMETER (user);
; 252  : 
; 253  :   // OpenGL
; 254  :   //
; 255  :   if (gl && GetModuleHandle (L"OpenGL32.dll"))

	cmp	BYTE PTR ?gl@?1??SK_BootDI8@@YGXXZ@4_NA, 0
	push	esi
	mov	esi, DWORD PTR __imp__GetModuleHandleW@4
	je	SHORT $LN2@operator
	push	OFFSET ??_C@_1BK@HHEPHKEC@?$AAO?$AAp?$AAe?$AAn?$AAG?$AAL?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
	call	esi
	test	eax, eax
	je	SHORT $LN2@operator

; 256  :     SK_BootOpenGL ();

	call	?SK_BootOpenGL@@YAXXZ			; SK_BootOpenGL
$LN2@operator:

; 257  : 
; 258  : 
; 259  :   // Vulkan
; 260  :   //
; 261  :   //if (vulkan && GetModuleHandle (L"Vulkan-1.dll"))
; 262  :   //  SK_BootVulkan ();
; 263  : 
; 264  : 
; 265  :   // D3D9
; 266  :   //
; 267  :   if (d3d9 && GetModuleHandle (L"d3d9.dll"))

	cmp	BYTE PTR ?d3d9@?1??SK_BootDI8@@YGXXZ@4_NA, 0
	je	SHORT $LN3@operator
	push	OFFSET ??_C@_1BC@LLFFMIOK@?$AAd?$AA3?$AAd?$AA9?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
	call	esi
	test	eax, eax
	je	SHORT $LN3@operator

; 268  :     SK_BootD3D9 ();

	call	?SK_BootD3D9@@YAXXZ			; SK_BootD3D9
$LN3@operator:

; 269  : 
; 270  : 
; 271  :   // D3D11
; 272  :   //
; 273  :   if (d3d11 || GetModuleHandle (L"d3d11.dll"))

	cmp	BYTE PTR ?d3d11@?1??SK_BootDI8@@YGXXZ@4_NA, 0
	jne	SHORT $LN6@operator
	push	OFFSET ??_C@_1BE@FHHGECGN@?$AAd?$AA3?$AAd?$AA1?$AA1?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
	call	esi
	test	eax, eax
	jne	SHORT $LN6@operator

; 275  : 
; 276  :   // Alternate form (or D3D12, but we don't care about that right now)
; 277  :   else if (dxgi || GetModuleHandle (L"dxgi.dll"))

	cmp	BYTE PTR ?dxgi@?1??SK_BootDI8@@YGXXZ@4_NA, al
	jne	SHORT $LN6@operator
	push	OFFSET ??_C@_1BC@IPOKGKHK@?$AAd?$AAx?$AAg?$AAi?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
	call	esi
	test	eax, eax
	je	SHORT $LN7@operator
$LN6@operator:

; 274  :     SK_BootDXGI ();

	call	?SK_BootDXGI@@YAXXZ			; SK_BootDXGI
$LN7@operator:

; 278  :     SK_BootDXGI ();
; 279  : 
; 280  : 
; 281  : // Load user-defined DLLs (Plug-In)
; 282  : #ifdef _WIN64
; 283  :   SK_LoadPlugIns64 ();
; 284  : #else
; 285  :   SK_LoadPlugIns32 ();

	call	?SK_LoadPlugIns32@@YAXXZ		; SK_LoadPlugIns32

; 286  : #endif
; 287  : 
; 288  :   CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 289  : 
; 290  :   return 0;

	xor	eax, eax
	pop	esi

; 291  : }, nullptr, 0x00, nullptr);

	ret	4
??R<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@QBEKPAX@Z ENDP ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z@@YAPAPAXPAP6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z@@YAPAPAXPAP6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z@Z PROC ; static_cast_p2p<void,long __stdcall(HINSTANCE__ *,unsigned long,_GUID const &,void * *,IUnknown *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z@@YAPAPAXPAP6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z@Z ENDP ; static_cast_p2p<void,long __stdcall(HINSTANCE__ *,unsigned long,_GUID const &,void * *,IUnknown *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 24
tv354 = -1						; size = 1
_bProxy$1$ = -1						; size = 1
?SK_BootDI8@@YGXXZ PROC					; SK_BootDI8

; 167  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	edx, OFFSET ?hooked@?1??SK_BootDI8@@YGXXZ@4KC
	xor	eax, eax
	push	edi
	mov	edi, 1
	mov	ecx, edi
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 170  :   if (InterlockedCompareExchange (&hooked, TRUE, FALSE))

	test	eax, eax
	jne	$LN1@SK_BootDI8

; 171  :   {
; 172  :     return;
; 173  :   }
; 174  : 
; 175  :   HMODULE hBackend = 
; 176  :     (SK_GetDLLRole () & DLL_ROLE::DInput8) ? backend_dll :

	push	ebx
	push	esi
	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	mov	ebx, DWORD PTR __imp__GetModuleHandleW@4
	test	eax, 256				; 00000100H
	je	SHORT $LN9@SK_BootDI8
	mov	esi, DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	jmp	SHORT $LN10@SK_BootDI8
$LN9@SK_BootDI8:
	push	OFFSET $SG258340
	call	ebx
	mov	esi, eax
$LN10@SK_BootDI8:

; 177  :                                     GetModuleHandle (L"dinput8.dll");
; 178  : 
; 179  :   dll_log.Log (L"[ DInput 8 ] Importing DirectInput8Create....");

	push	OFFSET $SG258341
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 180  :   dll_log.Log (L"[ DInput 8 ] ================================");

	push	OFFSET $SG258342
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 182  :   if (! _wcsicmp (SK_GetModuleName (SK_GetDLL ()).c_str (), L"dinput8.dll"))

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?SK_GetModuleName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN27@SK_BootDI8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN27@SK_BootDI8:
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 182  :   if (! _wcsicmp (SK_GetModuleName (SK_GetDLL ()).c_str (), L"dinput8.dll"))

	push	OFFSET $SG258346
	push	eax
	call	DWORD PTR __imp___wcsicmp
	add	esp, 8
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T1[ebp+20]
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 182  :   if (! _wcsicmp (SK_GetModuleName (SK_GetDLL ()).c_str (), L"dinput8.dll"))

	sete	BYTE PTR tv354[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN37@SK_BootDI8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T1[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN37@SK_BootDI8:
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 182  :   if (! _wcsicmp (SK_GetModuleName (SK_GetDLL ()).c_str (), L"dinput8.dll"))

	cmp	BYTE PTR tv354[ebp], 0
	je	SHORT $LN3@SK_BootDI8

; 183  :   {
; 184  :     dll_log.Log (L"[ DInput 8 ]   DirectInput8Create:   %ph",

	push	OFFSET $SG258347
	push	esi
	call	DWORD PTR __imp__GetProcAddress@8
	push	eax
	mov	DWORD PTR ?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA, eax ; DirectInput8Create_Import
	push	OFFSET $SG258348
	jmp	SHORT $LN69@SK_BootDI8
$LN3@SK_BootDI8:

; 185  :       (DirectInput8Create_Import) =  \
; 186  :         reinterpret_cast <DirectInput8Create_pfn> (
; 187  :           GetProcAddress (hBackend, "DirectInput8Create")
; 188  :         )
; 189  :     );
; 190  :   }
; 191  : 
; 192  :   else if (hBackend != nullptr)

	test	esi, esi
	je	SHORT $LN6@SK_BootDI8

; 193  :   {
; 194  :     const bool bProxy =
; 195  :       ( GetModuleHandle (L"dinput8.dll") != hBackend );

	push	OFFSET $SG258350
	call	ebx

; 196  : 
; 197  : 
; 198  :     if ( MH_OK ==

	push	0
	push	OFFSET ?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA ; DirectInput8Create_Import
	push	OFFSET ?DirectInput8Create@@YAJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z ; DirectInput8Create
	cmp	eax, esi
	push	OFFSET $SG258352
	push	OFFSET $SG258353
	setne	BYTE PTR _bProxy$1$[ebp]
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2
	test	eax, eax
	jne	SHORT $LN6@SK_BootDI8

; 199  :             SK_CreateDLLHook2 (      L"dinput8.dll",
; 200  :                                       "DirectInput8Create",
; 201  :                                        DirectInput8Create,
; 202  :               static_cast_p2p <void> (&DirectInput8Create_Import) )
; 203  :         )
; 204  :     {
; 205  :       if (bProxy)

	cmp	BYTE PTR _bProxy$1$[ebp], al
	je	SHORT $LN68@SK_BootDI8

; 206  :       {
; 207  :         (DirectInput8Create_Import) =  \

	push	OFFSET $SG258355
	push	esi
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA, eax ; DirectInput8Create_Import
	jmp	SHORT $LN7@SK_BootDI8
$LN68@SK_BootDI8:
	mov	eax, DWORD PTR ?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA ; DirectInput8Create_Import
$LN7@SK_BootDI8:

; 208  :           reinterpret_cast <DirectInput8Create_pfn> (
; 209  :             GetProcAddress (hBackend, "DirectInput8Create")
; 210  :           );
; 211  :       }
; 212  : 
; 213  :       dll_log.Log (L"[ DInput 8 ]   DirectInput8Create:   %p  { Hooked }",

	push	eax
	push	OFFSET $SG258356
$LN69@SK_BootDI8:
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN6@SK_BootDI8:

; 214  :         (DirectInput8Create_Import) );
; 215  :     }
; 216  :   }
; 217  : 
; 218  : 
; 219  : 
; 220  : 
; 221  : 
; 222  :   //
; 223  :   // This whole thing is as smart as a sack of wet mice in DirectInput mode...
; 224  :   //   let's get to the real work and start booting graphics APIs!
; 225  :   //
; 226  :   static bool gl   = false, vulkan = false, d3d9  = false, d3d11 = false,
; 227  :               dxgi = false, d3d8   = false, ddraw = false, glide = false;
; 228  : 
; 229  :   SK_TestRenderImports (

	push	OFFSET ?glide@?1??SK_BootDI8@@YGXXZ@4_NA
	push	OFFSET ?ddraw@?1??SK_BootDI8@@YGXXZ@4_NA
	push	OFFSET ?d3d8@?1??SK_BootDI8@@YGXXZ@4_NA
	push	OFFSET ?d3d11@?1??SK_BootDI8@@YGXXZ@4_NA
	push	OFFSET ?dxgi@?1??SK_BootDI8@@YGXXZ@4_NA
	push	OFFSET ?d3d9@?1??SK_BootDI8@@YGXXZ@4_NA
	push	OFFSET ?vulkan@?1??SK_BootDI8@@YGXXZ@4_NA
	push	OFFSET ?gl@?1??SK_BootDI8@@YGXXZ@4_NA
	push	0
	call	ebx
	push	eax
	call	?SK_TestRenderImports@@YAXPAUHINSTANCE__@@PA_N1111111@Z ; SK_TestRenderImports
	add	esp, 36					; 00000024H

; 230  :     GetModuleHandle (nullptr),
; 231  :       &gl, &vulkan,
; 232  :         &d3d9, &dxgi, &d3d11,
; 233  :           &d3d8, &ddraw, &glide
; 234  :   );
; 235  : 
; 236  : 
; 237  : // Load user-defined DLLs (Plug-In)
; 238  : #ifdef _WIN64
; 239  :     SK_LoadEarlyImports64 ();
; 240  : #else
; 241  :     SK_LoadEarlyImports32 ();

	call	?SK_LoadEarlyImports32@@YAXXZ		; SK_LoadEarlyImports32

; 242  : #endif
; 243  : 
; 244  : 
; 245  : 
; 246  :   InterlockedExchange (&__di8_ready, TRUE);

	mov	eax, OFFSET ?__di8_ready@@3JC		; __di8_ready
	xchg	DWORD PTR [eax], edi

; 247  : 
; 248  : 
; 249  : CreateThread (nullptr, 0x00, [](LPVOID user) -> DWORD

	push	0
	push	0
	push	0
	push	OFFSET ?<lambda_invoker_stdcall>@<lambda_79af748b3932cd1bb65dc9c9a5b90f4e>@@CGKPAX@Z ; <lambda_79af748b3932cd1bb65dc9c9a5b90f4e>::<lambda_invoker_stdcall>
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24
	pop	esi
	pop	ebx
$LN1@SK_BootDI8:
	pop	edi

; 250  : {
; 251  :   UNREFERENCED_PARAMETER (user);
; 252  : 
; 253  :   // OpenGL
; 254  :   //
; 255  :   if (gl && GetModuleHandle (L"OpenGL32.dll"))
; 256  :     SK_BootOpenGL ();
; 257  : 
; 258  : 
; 259  :   // Vulkan
; 260  :   //
; 261  :   //if (vulkan && GetModuleHandle (L"Vulkan-1.dll"))
; 262  :   //  SK_BootVulkan ();
; 263  : 
; 264  : 
; 265  :   // D3D9
; 266  :   //
; 267  :   if (d3d9 && GetModuleHandle (L"d3d9.dll"))
; 268  :     SK_BootD3D9 ();
; 269  : 
; 270  : 
; 271  :   // D3D11
; 272  :   //
; 273  :   if (d3d11 || GetModuleHandle (L"d3d11.dll"))
; 274  :     SK_BootDXGI ();
; 275  : 
; 276  :   // Alternate form (or D3D12, but we don't care about that right now)
; 277  :   else if (dxgi || GetModuleHandle (L"dxgi.dll"))
; 278  :     SK_BootDXGI ();
; 279  : 
; 280  : 
; 281  : // Load user-defined DLLs (Plug-In)
; 282  : #ifdef _WIN64
; 283  :   SK_LoadPlugIns64 ();
; 284  : #else
; 285  :   SK_LoadPlugIns32 ();
; 286  : #endif
; 287  : 
; 288  :   CloseHandle (GetCurrentThread ());
; 289  : 
; 290  :   return 0;
; 291  : }, nullptr, 0x00, nullptr);
; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_BootDI8@@YGXXZ ENDP					; SK_BootDI8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z@@YAPAPAXPAP6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z@@YAPAPAXPAP6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z@Z PROC ; static_cast_p2p<void,long __stdcall(IDirectInput8W *,_GUID const &,IDirectInputDeviceW * *,IUnknown *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z@@YAPAPAXPAP6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z@Z ENDP ; static_cast_p2p<void,long __stdcall(IDirectInput8W *,_GUID const &,IDirectInputDeviceW * *,IUnknown *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 24
__$ReturnAddr$ = 4					; size = 4
_hinst$ = 8						; size = 4
_dwVersion$ = 12					; size = 4
_riidltf$ = 16						; size = 4
_ppvOut$ = 20						; size = 4
_punkOuter$ = 24					; size = 4
?DirectInput8Create@@YAJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z PROC ; DirectInput8Create

; 124  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 125  :   if (SK_GetDLLRole () == DLL_ROLE::DInput8)

	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	cmp	eax, 256				; 00000100H
	jne	SHORT $LN2@DirectInpu

; 126  :   {
; 127  :     WaitForInit_DI8 ();

	call	?WaitForInit_DI8@@YGXXZ			; WaitForInit_DI8
$LN2@DirectInpu:

; 130  :   dll_log.Log ( L"[ DInput 8 ] [!] %s (%ph, %lu, {...}, ppvOut=%p, %p) - "

	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN21@DirectInpu
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN21@DirectInpu:
	push	esi
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 130  :   dll_log.Log ( L"[ DInput 8 ] [!] %s (%ph, %lu, {...}, ppvOut=%p, %p) - "

	mov	esi, DWORD PTR _ppvOut$[ebp]
	push	edi
	mov	edi, DWORD PTR _punkOuter$[ebp]
	push	eax
	push	edi
	push	esi
	push	DWORD PTR _dwVersion$[ebp]
	push	DWORD PTR _hinst$[ebp]
	push	OFFSET $SG258235
	push	OFFSET $SG258236
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T1[ebp+20]
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 130  :   dll_log.Log ( L"[ DInput 8 ] [!] %s (%ph, %lu, {...}, ppvOut=%p, %p) - "

	add	esp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN31@DirectInpu
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T1[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN31@DirectInpu:
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 139  :   if (DirectInput8Create_Import != nullptr)

	mov	eax, DWORD PTR ?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA ; DirectInput8Create_Import
	test	eax, eax
	je	SHORT $LN61@DirectInpu

; 140  :   {
; 141  :     if ( SUCCEEDED (

	push	edi
	push	esi
	push	DWORD PTR _riidltf$[ebp]
	push	DWORD PTR _dwVersion$[ebp]
	push	DWORD PTR _hinst$[ebp]
	call	eax
	mov	edi, eax
	test	edi, edi
	js	SHORT $LN59@DirectInpu

; 142  :            (hr = DirectInput8Create_Import (hinst, dwVersion, riidltf, ppvOut, punkOuter))
; 143  :          )
; 144  :        )
; 145  :     {
; 146  :       if (! IDirectInput8_CreateDevice_Original)

	cmp	DWORD PTR ?IDirectInput8_CreateDevice_Original@@3P6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@ZA, 0 ; IDirectInput8_CreateDevice_Original
	jne	SHORT $LN59@DirectInpu

; 147  :       {
; 148  :         void** vftable = *(void***)*ppvOut;

	mov	ecx, DWORD PTR [esi]

; 149  :         
; 150  :         SK_CreateFuncHook (       L"IDirectInput8::CreateDevice",

	push	OFFSET ?IDirectInput8_CreateDevice_Original@@3P6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@ZA ; IDirectInput8_CreateDevice_Original
	push	OFFSET ?IDirectInput8_CreateDevice_Detour@@YGJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z ; IDirectInput8_CreateDevice_Detour
	mov	esi, DWORD PTR [ecx]
	push	DWORD PTR [esi+12]
	push	OFFSET $SG258240
	call	?SK_CreateFuncHook@@YG?AW4MH_STATUS@@PB_WPAX1PAPAX@Z ; SK_CreateFuncHook

; 151  :                                    vftable [3],
; 152  :                                    IDirectInput8_CreateDevice_Detour,
; 153  :           static_cast_p2p <void> (&IDirectInput8_CreateDevice_Original) );
; 154  :         
; 155  :         SK_EnableHook (vftable [3]);

	push	DWORD PTR [esi+12]
	call	?SK_EnableHook@@YG?AW4MH_STATUS@@PAX@Z	; SK_EnableHook
$LN59@DirectInpu:

; 156  :       }
; 157  :     }
; 158  :   }
; 159  : 
; 160  :   return hr;

	mov	eax, edi
	pop	edi
	pop	esi

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@DirectInpu:
	pop	edi

; 156  :       }
; 157  :     }
; 158  :   }
; 159  : 
; 160  :   return hr;

	mov	eax, -2147467262			; 80004002H
	pop	esi

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DirectInput8Create@@YAJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z ENDP ; DirectInput8Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?WaitForInit_DI8@@YGXXZ PROC				; WaitForInit_DI8
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__di8_ready@@3JC	; __di8_ready
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 112  :   while (! ReadAcquire (&__di8_ready))

	test	eax, eax
	jne	SHORT $LN3@WaitForIni
	push	esi
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@WaitForIni:

; 113  :     SleepEx (config.system.init_delay, TRUE);

	push	1
	push	DWORD PTR ?config@@3Usk_config_t@@A+800
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__di8_ready@@3JC	; __di8_ready
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 112  :   while (! ReadAcquire (&__di8_ready))

	test	eax, eax
	je	SHORT $LL2@WaitForIni
	pop	esi
$LN3@WaitForIni:

; 114  : }

	ret	0
?WaitForInit_DI8@@YGXXZ ENDP				; WaitForInit_DI8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_err$1 = -16						; size = 16
_This$ = 8						; size = 4
_rguid$ = 12						; size = 4
_lplpDirectInputDevice$ = 16				; size = 4
_pUnkOuter$ = 20					; size = 4
?IDirectInput8_CreateDevice_Detour@@YGJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z PROC ; IDirectInput8_CreateDevice_Detour

; 937  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, OFFSET _GUID_SysKeyboard
	push	ebx
	mov	ebx, DWORD PTR _rguid$[ebp]
	mov	ecx, ebx
	push	esi
	push	edi
	mov	esi, 12					; 0000000cH
	npad	6
$LL54@IDirectInp:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN13@IDirectInp
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL54@IDirectInp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 938  :   const wchar_t* wszDevice = (rguid == GUID_SysKeyboard)   ? L"Default System Keyboard" :

	mov	eax, OFFSET $SG258848
	jmp	SHORT $LN60@IDirectInp
$LN13@IDirectInp:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET _GUID_SysMouse
	mov	esi, 12					; 0000000cH
$LL56@IDirectInp:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN11@IDirectInp
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL56@IDirectInp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 938  :   const wchar_t* wszDevice = (rguid == GUID_SysKeyboard)   ? L"Default System Keyboard" :

	mov	eax, OFFSET $SG258849
	jmp	SHORT $LN60@IDirectInp
$LN11@IDirectInp:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET _GUID_Joystick
	mov	esi, 12					; 0000000cH
$LL59@IDirectInp:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN58@IDirectInp
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL59@IDirectInp
	mov	eax, OFFSET $SG258850
	jmp	SHORT $LN60@IDirectInp
$LN58@IDirectInp:
	mov	eax, OFFSET $SG258851
$LN60@IDirectInp:
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 943  :   dll_log.Log ( L"[   Input  ][!] IDirectInput8::CreateDevice (%ph, %s, %ph, %ph)",

	mov	edi, DWORD PTR _pUnkOuter$[ebp]
	mov	ecx, DWORD PTR _lplpDirectInputDevice$[ebp]
	mov	esi, DWORD PTR _This$[ebp]
	push	edi
	push	ecx
	push	eax
	push	esi
	push	OFFSET $SG258852
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 950  :   DINPUT8_CALL ( hr,

	push	OFFSET $SG258853
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 36					; 00000024H
	push	edi
	mov	edi, DWORD PTR _lplpDirectInputDevice$[ebp]
	push	edi
	push	ebx
	push	esi
	call	DWORD PTR ?IDirectInput8_CreateDevice_Original@@3P6GJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@ZA ; IDirectInput8_CreateDevice_Original
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h

; 301  : {

	mov	DWORD PTR _err$1[ebp], OFFSET ??_7_com_error@@6B@

; 300  :     : m_hresult(hr), m_perrinfo(perrinfo), m_pszMsg(NULL)

	mov	DWORD PTR _err$1[ebp+4], esi
	mov	DWORD PTR _err$1[ebp+8], 0
	mov	DWORD PTR _err$1[ebp+12], 0
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 950  :   DINPUT8_CALL ( hr,

	test	esi, esi
	je	SHORT $LN2@IDirectInp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	lea	ecx, DWORD PTR [esi+2147220992]
	cmp	ecx, 65023				; 0000fdffH
	ja	SHORT $LN35@IDirectInp
	lea	eax, DWORD PTR [esi-512]
	movzx	edi, ax
	jmp	SHORT $LN36@IDirectInp
$LN35@IDirectInp:
	xor	edi, edi
$LN36@IDirectInp:
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 950  :   DINPUT8_CALL ( hr,

	lea	ecx, DWORD PTR _err$1[ebp]
	call	?ErrorMessage@_com_error@@QBEPB_WXZ	; _com_error::ErrorMessage
	push	eax
	movzx	eax, di
	push	eax
	push	OFFSET $SG258856
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	mov	edi, DWORD PTR _lplpDirectInputDevice$[ebp]
	add	esp, 20					; 00000014H
	jmp	SHORT $LN3@IDirectInp
$LN2@IDirectInp:
	push	OFFSET $SG258857
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
$LN3@IDirectInp:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h

; 317  :     if (m_perrinfo != NULL) {

	mov	ecx, DWORD PTR _err$1[ebp+8]
	mov	DWORD PTR _err$1[ebp], OFFSET ??_7_com_error@@6B@
	test	ecx, ecx
	je	SHORT $LN38@IDirectInp

; 318  :         m_perrinfo->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN38@IDirectInp:

; 319  :     }
; 320  :     if (m_pszMsg != NULL) {

	mov	eax, DWORD PTR _err$1[ebp+12]
	test	eax, eax
	je	SHORT $LN39@IDirectInp

; 321  :         LocalFree((HLOCAL)m_pszMsg);

	push	eax
	call	DWORD PTR __imp__LocalFree@4
$LN39@IDirectInp:
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 956  :   if (SUCCEEDED (hr))

	test	esi, esi
	js	$LN65@IDirectInp

; 957  :   {
; 958  :     void** vftable =
; 959  :       *reinterpret_cast <void ***> (*lplpDirectInputDevice);
; 960  : 
; 961  :     //
; 962  :     // This weird hack is necessary for EverQuest; crazy game hooks itself to try and thwart
; 963  :     //   macro programs.
; 964  :     //
; 965  :     /*
; 966  :     if (rguid == GUID_SysMouse && _dim.pDev == nullptr)
; 967  :     {
; 968  :       SK_CreateFuncHook ( L"IDirectInputDevice8::GetDeviceState",
; 969  :                            vftable [9],
; 970  :                            IDirectInputDevice8_GetDeviceState_MOUSE_Detour,
; 971  :                 (LPVOID *)&IDirectInputDevice8_GetDeviceState_MOUSE_Original );
; 972  :       MH_QueueEnableHook (vftable [9]);
; 973  :     }
; 974  : 
; 975  :     else if (rguid == GUID_SysKeyboard && _dik.pDev == nullptr)
; 976  :     {
; 977  :       SK_CreateFuncHook ( L"IDirectInputDevice8::GetDeviceState",
; 978  :                            vftable [9],
; 979  :                            IDirectInputDevice8_GetDeviceState_KEYBOARD_Detour,
; 980  :                 (LPVOID *)&IDirectInputDevice8_GetDeviceState_KEYBOARD_Original );
; 981  :       MH_QueueEnableHook (vftable [9]);
; 982  :     }
; 983  : 
; 984  :     else if (rguid != GUID_SysMouse && rguid != GUID_SysKeyboard)
; 985  :     {
; 986  :     */
; 987  :     if (IDirectInputDevice8_GetDeviceState_GAMEPAD_Original == nullptr)

	cmp	DWORD PTR ?IDirectInputDevice8_GetDeviceState_GAMEPAD_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA, 0 ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Original
	mov	eax, DWORD PTR [edi]
	mov	edi, DWORD PTR [eax]
	jne	SHORT $LN5@IDirectInp

; 988  :     {
; 989  :       SK_CreateFuncHook (      L"IDirectInputDevice8::GetDeviceState",

	push	OFFSET ?IDirectInputDevice8_GetDeviceState_GAMEPAD_Original@@3P6GJPAUIDirectInputDeviceW@@KPAX@ZA ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Original
	push	OFFSET ?IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour@@YGJPAUIDirectInputDeviceW@@KPAX@Z ; IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour
	push	DWORD PTR [edi+36]
	push	OFFSET $SG258860
	call	?SK_CreateFuncHook@@YG?AW4MH_STATUS@@PB_WPAX1PAPAX@Z ; SK_CreateFuncHook

; 990  :                                  vftable [9],
; 991  :                                  IDirectInputDevice8_GetDeviceState_GAMEPAD_Detour,
; 992  :         static_cast_p2p <void> (&IDirectInputDevice8_GetDeviceState_GAMEPAD_Original) );
; 993  :       MH_QueueEnableHook (vftable [9]);

	push	DWORD PTR [edi+36]
	call	_MH_QueueEnableHook@4
$LN5@IDirectInp:

; 994  :     }
; 995  :     //}
; 996  : 
; 997  :     if (! IDirectInputDevice8_SetCooperativeLevel_Original)

	cmp	DWORD PTR ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA, 0 ; IDirectInputDevice8_SetCooperativeLevel_Original
	jne	SHORT $LN6@IDirectInp

; 998  :     {
; 999  :       SK_CreateFuncHook (      L"IDirectInputDevice8::SetCooperativeLevel",

	push	OFFSET ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA ; IDirectInputDevice8_SetCooperativeLevel_Original
	push	OFFSET ?IDirectInputDevice8_SetCooperativeLevel_Detour@@YGJPAUIDirectInputDeviceW@@PAUHWND__@@K@Z ; IDirectInputDevice8_SetCooperativeLevel_Detour
	push	DWORD PTR [edi+52]
	push	OFFSET $SG258862
	call	?SK_CreateFuncHook@@YG?AW4MH_STATUS@@PB_WPAX1PAPAX@Z ; SK_CreateFuncHook

; 1000 :                                  vftable [13],
; 1001 :                                  IDirectInputDevice8_SetCooperativeLevel_Detour,
; 1002 :         static_cast_p2p <void> (&IDirectInputDevice8_SetCooperativeLevel_Original) );
; 1003 :       MH_QueueEnableHook (vftable [13]);

	push	DWORD PTR [edi+52]
	call	_MH_QueueEnableHook@4
$LN6@IDirectInp:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET _GUID_SysMouse
	mov	edi, 12					; 0000000cH
	npad	1
$LL62@IDirectInp:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN7@IDirectInp
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL62@IDirectInp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 1008 :       _dim.pDev = *lplpDirectInputDevice;

	mov	ecx, DWORD PTR _lplpDirectInputDevice$[ebp]
	pop	edi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?_dim@@3USK_DI8_Mouse@@A, eax

; 1012 :   }
; 1013 : 
; 1014 : #if 0
; 1015 :   if (SUCCEEDED (hr) && lplpDirectInputDevice != nullptr)
; 1016 :   {
; 1017 :     DWORD dwFlag = DISCL_FOREGROUND | DISCL_NONEXCLUSIVE;
; 1018 : 
; 1019 :     if (config.input.block_windows)
; 1020 :       dwFlag |= DISCL_NOWINKEY;
; 1021 : 
; 1022 :     (*lplpDirectInputDevice)->SetCooperativeLevel (SK_GetGameWindow (), dwFlag);
; 1023 :   }
; 1024 : #endif
; 1025 : 
; 1026 :   return hr;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1027 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN7@IDirectInp:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, OFFSET _GUID_SysKeyboard
	mov	edx, 12					; 0000000cH
$LL64@IDirectInp:
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN65@IDirectInp
	add	ebx, 4
	add	ecx, 4
	sub	edx, 4
	jae	SHORT $LL64@IDirectInp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp

; 1011 :       _dik.pDev = *lplpDirectInputDevice;

	mov	ecx, DWORD PTR _lplpDirectInputDevice$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?_dik@@3USK_DI8_Keyboard@@A, eax
$LN65@IDirectInp:

; 1012 :   }
; 1013 : 
; 1014 : #if 0
; 1015 :   if (SUCCEEDED (hr) && lplpDirectInputDevice != nullptr)
; 1016 :   {
; 1017 :     DWORD dwFlag = DISCL_FOREGROUND | DISCL_NONEXCLUSIVE;
; 1018 : 
; 1019 :     if (config.input.block_windows)
; 1020 :       dwFlag |= DISCL_NOWINKEY;
; 1021 : 
; 1022 :     (*lplpDirectInputDevice)->SetCooperativeLevel (SK_GetGameWindow (), dwFlag);
; 1023 :   }
; 1024 : #endif
; 1025 : 
; 1026 :   return hr;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 1027 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?IDirectInput8_CreateDevice_Detour@@YGJPAUIDirectInput8W@@ABU_GUID@@PAPAUIDirectInputDeviceW@@PAUIUnknown@@@Z ENDP ; IDirectInput8_CreateDevice_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ??_G_com_error@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_com_error@@UAEPAXI@Z PROC				; _com_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 317  :     if (m_perrinfo != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
	test	ecx, ecx
	je	SHORT $LN5@scalar

; 318  :         m_perrinfo->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN5@scalar:

; 319  :     }
; 320  :     if (m_pszMsg != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@scalar

; 321  :         LocalFree((HLOCAL)m_pszMsg);

	push	eax
	call	DWORD PTR __imp__LocalFree@4
$LN6@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_com_error@@UAEPAXI@Z ENDP				; _com_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ?HRESULTToWCode@_com_error@@SAGJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?HRESULTToWCode@_com_error@@SAGJ@Z PROC			; _com_error::HRESULTToWCode, COMDAT

; 454  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	mov	ecx, DWORD PTR _hr$[ebp]
	lea	eax, DWORD PTR [ecx+2147220992]
	cmp	eax, 65023				; 0000fdffH
	ja	SHORT $LN3@HRESULTToW
	lea	eax, DWORD PTR [ecx-512]
	movzx	eax, ax

; 456  :         ? WORD(hr - WCODE_HRESULT_FIRST)
; 457  :         : 0;
; 458  : }

	pop	ebp
	ret	0
$LN3@HRESULTToW:

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	xor	eax, eax

; 456  :         ? WORD(hr - WCODE_HRESULT_FIRST)
; 457  :         : 0;
; 458  : }

	pop	ebp
	ret	0
?HRESULTToWCode@_com_error@@SAGJ@Z ENDP			; _com_error::HRESULTToWCode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ?ErrorMessage@_com_error@@QBEPB_WXZ
_TEXT	SEGMENT
?ErrorMessage@_com_error@@QBEPB_WXZ PROC		; _com_error::ErrorMessage, COMDAT
; _this$ = ecx

; 408  : {

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 409  :     if (m_pszMsg == NULL) {

	cmp	DWORD PTR [edi+12], 0
	lea	esi, DWORD PTR [edi+12]
	jne	$LN19@ErrorMessa

; 410  :         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|

	push	0
	push	0
	push	esi
	push	1024					; 00000400H
	push	DWORD PTR [edi+4]
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageW@28

; 411  :                           FORMAT_MESSAGE_FROM_SYSTEM|
; 412  :                           FORMAT_MESSAGE_IGNORE_INSERTS,
; 413  :                       NULL,
; 414  :                       m_hresult,
; 415  :                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 416  :                       (LPTSTR)&m_pszMsg,
; 417  :                       0,
; 418  :                       NULL);
; 419  :         if (m_pszMsg != NULL) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN3@ErrorMessa

; 420  :             #ifdef UNICODE
; 421  :             size_t const nLen = wcslen(m_pszMsg);

	mov	edx, ecx
	lea	edi, DWORD PTR [edx+2]
	npad	8
$LL17@ErrorMessa:
	mov	ax, WORD PTR [edx]
	add	edx, 2
	test	ax, ax
	jne	SHORT $LL17@ErrorMessa
	sub	edx, edi
	sar	edx, 1

; 422  :             #else
; 423  :             size_t const nLen = strlen(m_pszMsg);
; 424  :             #endif
; 425  :             if (nLen > 1 && m_pszMsg[nLen - 1] == '\n') {

	cmp	edx, 1
	jbe	SHORT $LN20@ErrorMessa
	cmp	WORD PTR [ecx+edx*2-2], 10		; 0000000aH
	jne	SHORT $LN20@ErrorMessa

; 426  :                 m_pszMsg[nLen - 1] = 0;

	xor	eax, eax
	mov	WORD PTR [ecx+edx*2-2], ax

; 427  :                 if (m_pszMsg[nLen - 2] == '\r') {

	mov	ecx, DWORD PTR [esi]
	cmp	WORD PTR [ecx+edx*2-4], 13		; 0000000dH
	jne	SHORT $LN20@ErrorMessa

; 428  :                         m_pszMsg[nLen - 2] = 0;

	mov	WORD PTR [ecx+edx*2-4], ax

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi

; 446  : }

	ret	0
$LN20@ErrorMessa:
	pop	edi

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

	mov	eax, ecx
	pop	esi

; 446  : }

	ret	0
$LN3@ErrorMessa:

; 429  :                 }
; 430  :             }
; 431  :         }
; 432  :         else {
; 433  :             m_pszMsg = (LPTSTR)LocalAlloc(0, 32 * sizeof(TCHAR));

	push	64					; 00000040H
	push	0
	call	DWORD PTR __imp__LocalAlloc@8
	mov	edx, eax
	mov	DWORD PTR [esi], edx

; 434  :             if (m_pszMsg != NULL) {

	test	edx, edx
	je	SHORT $LN9@ErrorMessa

; 341  :     return HRESULTToWCode(m_hresult);

	mov	edi, DWORD PTR [edi+4]

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	lea	ecx, DWORD PTR [edi+2147220992]
	cmp	ecx, 65023				; 0000fdffH
	ja	SHORT $LN8@ErrorMessa
	lea	eax, DWORD PTR [edi-512]
	movzx	eax, ax

; 435  :                 WORD wCode = WCode();
; 436  :                 if (wCode != 0) {

	test	ax, ax
	je	SHORT $LN8@ErrorMessa

; 437  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("IDispatch error #%d"), (int)wCode);

	push	eax
	push	OFFSET ??_C@_1CI@KPMALOMG@?$AAI?$AAD?$AAi?$AAs?$AAp?$AAa?$AAt?$AAc?$AAh?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$CD?$AA?$CF?$AAd?$AA?$AA@

; 438  :                 }
; 439  :                 else {
; 440  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);

	push	32					; 00000020H
	push	edx
	call	_swprintf_s

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 446  : }

	ret	0
$LN8@ErrorMessa:

; 438  :                 }
; 439  :                 else {
; 440  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);

	push	edi
	push	OFFSET ??_C@_1CK@DOIMBAJG@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AAl?$AAX?$AA?$AA@
	push	32					; 00000020H
	push	edx
	call	_swprintf_s
	add	esp, 16					; 00000010H
$LN19@ErrorMessa:

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

	mov	eax, DWORD PTR [esi]
$LN9@ErrorMessa:
	pop	edi
	pop	esi

; 446  : }

	ret	0
?ErrorMessage@_com_error@@QBEPB_WXZ ENDP		; _com_error::ErrorMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ?WCode@_com_error@@QBEGXZ
_TEXT	SEGMENT
?WCode@_com_error@@QBEGXZ PROC				; _com_error::WCode, COMDAT
; _this$ = ecx

; 341  :     return HRESULTToWCode(m_hresult);

	mov	ecx, DWORD PTR [ecx+4]

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	lea	eax, DWORD PTR [ecx+2147220992]
	cmp	eax, 65023				; 0000fdffH
	ja	SHORT $LN5@WCode
	lea	eax, DWORD PTR [ecx-512]
	movzx	eax, ax

; 342  : }

	ret	0
$LN5@WCode:

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	xor	eax, eax

; 342  : }

	ret	0
?WCode@_com_error@@QBEGXZ ENDP				; _com_error::WCode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ??1_com_error@@UAE@XZ
_TEXT	SEGMENT
??1_com_error@@UAE@XZ PROC				; _com_error::~_com_error, COMDAT
; _this$ = ecx

; 316  : {

	npad	2
	push	esi
	mov	esi, ecx

; 317  :     if (m_perrinfo != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
	test	ecx, ecx
	je	SHORT $LN2@com_error

; 318  :         m_perrinfo->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@com_error:

; 319  :     }
; 320  :     if (m_pszMsg != NULL) {

	mov	eax, DWORD PTR [esi+12]
	pop	esi
	test	eax, eax
	je	SHORT $LN3@com_error

; 321  :         LocalFree((HLOCAL)m_pszMsg);

	push	eax
	call	DWORD PTR __imp__LocalFree@4
$LN3@com_error:

; 322  :     }
; 323  : }

	ret	0
??1_com_error@@UAE@XZ ENDP				; _com_error::~_com_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
_perrinfo$ = 12						; size = 4
_fAddRef$ = 16						; size = 1
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z PROC		; _com_error::_com_error, COMDAT
; _this$ = ecx

; 301  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 300  :     : m_hresult(hr), m_perrinfo(perrinfo), m_pszMsg(NULL)

	mov	eax, DWORD PTR _hr$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _perrinfo$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], 0

; 302  :     if (m_perrinfo != NULL && fAddRef) {

	test	ecx, ecx
	je	SHORT $LN4@com_error
	cmp	BYTE PTR _fAddRef$[ebp], 0
	je	SHORT $LN4@com_error

; 303  :         m_perrinfo->AddRef();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+4]
$LN4@com_error:

; 304  :     }
; 305  : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	12					; 0000000cH
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z ENDP		; _com_error::_com_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
	test	eax, eax
	je	SHORT $LN29@dynamic

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN29@dynamic:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
	ret	0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2979 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET ??__F_AtlWinModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlWinModule''
	call	_atexit
	pop	ecx
	ret	0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	ecx
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2965 : 	}

	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2958 : 	{

	npad	2
	push	esi

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4

; 2958 : 	{

	mov	esi, ecx

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	esi
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN26@CAtlWinMod

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN26@CAtlWinMod:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2960 : 	}

	ret	0
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2944 : 	CAtlWinModule()

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [esi+4], xmm0
	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2944 : 	CAtlWinModule()

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2946 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	DWORD PTR [esi], 44			; 0000002cH

; 8412 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN26@CAtlWinMod

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN27@CAtlWinMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2948 : 		if (FAILED(hr))

	test	eax, eax
$LN27@CAtlWinMod:

; 2953 : 			return;
; 2954 : 		}
; 2955 : 	}

	mov	eax, esi

; 2948 : 		if (FAILED(hr))

	jns	SHORT $LN2@CAtlWinMod

; 2949 : 		{
; 2950 : 			ATLASSERT(0);
; 2951 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2952 : 			cbSize = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 2953 : 			return;
; 2954 : 		}
; 2955 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@CAtlWinMod:
	mov	eax, esi
$LN2@CAtlWinMod:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__F_AtlComModule@ATL@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 2615 : 		Term();

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2616 : 	}

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__F_AtlComModule@ATL@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN4@dynamic

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN20@dynamic
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2602 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN20@dynamic:
	jns	SHORT $LN4@dynamic

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2606 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
$LN4@dynamic:
	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2610 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2620 : 	{

	npad	2
	push	edi
	mov	edi, ecx

; 2621 : 		if (cbSize == 0)

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN1@Term

; 2622 : 			return;
; 2623 : 
; 2624 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	push	esi
	mov	esi, DWORD PTR [edi+8]
	cmp	esi, DWORD PTR [edi+12]
	jae	SHORT $LN3@Term
	push	ebx
$LL4@Term:

; 2625 : 		{
; 2626 : 			if (*ppEntry != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Term

; 2627 : 			{
; 2628 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

	mov	ebx, DWORD PTR [eax+16]

; 2629 : 
; 2630 : 				if (pCache->pCF != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN2@Term

; 2631 : 				{
; 2632 : 					// Decode factory pointer if it's not null
; 2633 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

	push	eax
	call	DWORD PTR __imp__DecodePointer@4

; 2634 : 					_Analysis_assume_(factory != nullptr);
; 2635 : 					factory->Release();

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 2636 : 					pCache->pCF = NULL;

	mov	DWORD PTR [ebx], 0
$LN2@Term:

; 2622 : 			return;
; 2623 : 
; 2624 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	add	esi, 4
	cmp	esi, DWORD PTR [edi+12]
	jb	SHORT $LL4@Term
	pop	ebx
$LN3@Term:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2644 : 		cbSize = 0;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN1@Term:
	pop	edi

; 2645 : 	}

	ret	0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2614 : 	{

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1CAtlComModule@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 2615 : 		Term();

	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2616 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2593 : 	CAtlComModule() throw()

	npad	2
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [eax], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2595 : 		cbSize = 0;

	mov	DWORD PTR [esi], 0

; 2596 : 
; 2597 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

	mov	DWORD PTR [esi+4], OFFSET ___ImageBase

; 2598 : 
; 2599 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

	mov	DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4

; 2600 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

	mov	DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN2@CAtlComMod

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN18@CAtlComMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2602 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN18@CAtlComMod:
	jns	SHORT $LN2@CAtlComMod

; 2611 : 	}

	mov	eax, esi
	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
	pop	esi
	ret	0
$LN2@CAtlComMod:

; 2603 : 		{
; 2604 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2605 : 			ATLASSERT(0);
; 2606 : 			CAtlBaseModule::m_bInitFailed = true;
; 2607 : 			return;
; 2608 : 		}
; 2609 : 		// Set cbSize on success.
; 2610 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR [esi], 40			; 00000028H

; 2611 : 	}

	mov	eax, esi
	pop	esi
	ret	0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7660 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 7661 : 	if (pWinModule == NULL)

	mov	esi, DWORD PTR _pWinModule$[ebp]
	test	esi, esi
	jne	SHORT $LN5@AtlWinModu
$LN35@AtlWinModu:

; 7662 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	pop	esi

; 7674 : }

	pop	ebp
	ret	8
$LN5@AtlWinModu:

; 7663 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN34@AtlWinModu

; 7664 : 		return S_OK;
; 7665 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN35@AtlWinModu

; 7666 : 		return E_INVALIDARG;
; 7667 : 
; 7668 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+36], edi
	jle	SHORT $LN3@AtlWinModu

; 7669 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	push	ebx
	mov	ebx, DWORD PTR _hInst$[ebp]
	npad	2
$LL4@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

	test	edi, edi
	js	SHORT $LN36@AtlWinModu
	cmp	edi, DWORD PTR [esi+36]
	jge	SHORT $LN36@AtlWinModu
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 7669 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	eax, DWORD PTR [esi+32]
	push	ebx
	movzx	eax, WORD PTR [eax+edi*2]
	push	eax
	call	DWORD PTR __imp__UnregisterClassW@8
	inc	edi
	cmp	edi, DWORD PTR [esi+36]
	jl	SHORT $LL4@AtlWinModu
	pop	ebx
$LN3@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	pop	edi
	test	eax, eax
	je	SHORT $LN20@AtlWinModu

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN20@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 223  : 		m_nSize = 0;

	mov	DWORD PTR [esi+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 7672 : 	pWinModule->cbSize = 0;

	mov	DWORD PTR [esi], 0
$LN34@AtlWinModu:

; 7673 : 	return S_OK;

	xor	eax, eax
	pop	esi

; 7674 : }

	pop	ebp
	ret	8
$LN36@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN37@AtlWinModu:
$LN33@AtlWinModu:
	int	3
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8404 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8405 : 	if (pWinModule == NULL)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	test	eax, eax
	jne	SHORT $LN2@AtlWinModu
$LN15@AtlWinModu:

; 8406 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 8421 : }

	pop	ebp
	ret	4
$LN2@AtlWinModu:

; 8407 : 
; 8408 : 	// check only in the DLL
; 8409 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	DWORD PTR [eax], 44			; 0000002cH
	jne	SHORT $LN15@AtlWinModu
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 170  : 		HRESULT hRes = S_OK;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 8412 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	esi
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN14@AtlWinModu

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	esi, eax
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	esi, esi
	jle	SHORT $LN14@AtlWinModu
	movzx	esi, si
	or	esi, -2147024896			; 80070000H
$LN14@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 8420 : 	return hr;

	mov	eax, esi
	pop	esi

; 8421 : }

	pop	ebp
	ret	4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN19@ATL_WIN_MO

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN19@ATL_WIN_MO:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [ecx+4], xmm0
	mov	eax, ecx
	movq	QWORD PTR [ecx+20], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

	npad	2
	push	ebp
	mov	ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

	mov	edx, DWORD PTR _nIndex$[ebp]
	test	edx, edx
	js	SHORT $LN6@operator
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN6@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*2]

; 243  : 	}

	pop	ebp
	ret	4
$LN6@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN7@operator:
$LN5@operator:
	int	3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN11@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 225  :     }

	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 161  : 		return m_nSize;

	mov	eax, DWORD PTR [ecx+4]

; 162  : 	}

	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@CSimpleArr

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN13@CSimpleArr:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 311  : 	RemoveAll();
; 312  : }

	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [ecx], 0

; 121  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	ret	0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	mov	eax, ecx

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [ecx+16], xmm0
	movq	QWORD PTR [ecx+32], xmm0
	ret	0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 316  : 		return m_hInst;

	mov	eax, DWORD PTR [ecx+4]

; 317  : 	}

	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 180  : 	{

	npad	2

; 181  : 		DeleteCriticalSection(&m_sec);

	push	ecx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 182  : 		return S_OK;

	xor	eax, eax

; 183  : 	}

	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	ecx
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN10@Init

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN9@Init
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 177  : 	}

	ret	0
$LN10@Init:

; 174  : 		}
; 175  : 
; 176  : 		return hRes;

	xor	eax, eax
$LN9@Init:

; 177  : 	}

	ret	0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 156  : 	}

	ret	0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 149  : 	CComCriticalSection() throw()

	xorps	xmm0, xmm0

; 150  : 	{
; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
; 152  : 	}

	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	DWORD PTR _Flags$[ebp]
	push	DWORD PTR _dwSpinCount$[ebp]
	push	DWORD PTR _lpCriticalSection$[ebp]
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

	pop	ebp
	ret	0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	push	0
	push	0
	push	DWORD PTR _dwExceptionFlags$[ebp]
	push	DWORD PTR _dwExceptionCode$[ebp]
	call	DWORD PTR __imp__RaiseException@16

; 32   : }

	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 8
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 325  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 326  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	WORD PTR [eax], cx

; 327  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?max@?$numeric_limits@K@std@@SAKXZ
_TEXT	SEGMENT
?max@?$numeric_limits@K@std@@SAKXZ PROC			; std::numeric_limits<unsigned long>::max, COMDAT

; 857  : 		return (ULONG_MAX);

	or	eax, -1

; 858  : 		}

	ret	0
?max@?$numeric_limits@K@std@@SAKXZ ENDP			; std::numeric_limits<unsigned long>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?max@?$numeric_limits@G@std@@SAGXZ
_TEXT	SEGMENT
?max@?$numeric_limits@G@std@@SAGXZ PROC			; std::numeric_limits<unsigned short>::max, COMDAT

; 566  : 		return (USHRT_MAX);

	mov	eax, 65535				; 0000ffffH

; 567  : 		}

	ret	0
?max@?$numeric_limits@G@std@@SAGXZ ENDP			; std::numeric_limits<unsigned short>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
;	COMDAT ?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z PROC ; sk_input_api_context_s::markRead, COMDAT
; _this$ = ecx

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _type$[ebp]
	cmp	edx, 1
	jne	SHORT $LN5@markRead
	xor	eax, eax
	lock	 inc	 DWORD PTR [ecx+eax*4+32]

; 105  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 106  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
$LN5@markRead:

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	cmp	edx, 2
	jne	SHORT $LN3@markRead
	mov	eax, 1
	lock	 inc	 DWORD PTR [ecx+eax*4+32]

; 105  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 106  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
$LN3@markRead:

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	xor	eax, eax
	cmp	edx, 4
	setne	al
	lock	 inc	 DWORD PTR [ecx+eax*4+40]

; 105  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 106  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z ENDP ; sk_input_api_context_s::markRead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
$T1 = 8							; size = 4
_pJoy$ = 12						; size = 4
_ComputeAxialPos_XInput$ = 15				; size = 1
_pCaps$ = 16						; size = 4
?SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z PROC ; SK_JOY_TranslateToXInput

; 421  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 422  :   UNREFERENCED_PARAMETER (pCaps);
; 423  : 
; 424  :   static DWORD dwPacket = 0;
; 425  : 
; 426  :   ZeroMemory (&joy_to_xi.Gamepad, sizeof (XINPUT_STATE::Gamepad));
; 427  : 
; 428  : 
; 429  :   auto ComputeAxialPos_XInput =
; 430  :     [ ] (UINT min, UINT max, DWORD pos) ->
; 431  :     SHORT
; 432  :   {
; 433  :     float range = ( static_cast <float> ( max ) - static_cast <float> ( min ) );
; 434  :     float center = ( static_cast <float> ( max ) + static_cast <float> ( min ) ) / 2.0f;
; 435  :     float rpos = 0.5f;
; 436  : 
; 437  :     if (static_cast <float> ( pos ) < center)
; 438  :       rpos = center - ( center - static_cast <float> ( pos ) );
; 439  :     else
; 440  :       rpos = static_cast <float> ( pos ) - static_cast <float> ( min );
; 441  : 
; 442  :     std::numeric_limits <unsigned short>::max ( );
; 443  : 
; 444  :     float max_xi = static_cast <float> ( std::numeric_limits <unsigned short>::max ( ) );
; 445  :     float center_xi = static_cast <float> ( std::numeric_limits <unsigned short>::max ( ) / 2 );
; 446  : 
; 447  :     return
; 448  :       static_cast <SHORT> ( max_xi * ( rpos / range ) - center_xi );
; 449  :   };
; 450  : 
; 451  :   auto TestTriggerThreshold_XInput =
; 452  :     [ ] (UINT min, UINT max, float threshold, DWORD pos, bool& lt, bool& rt) ->
; 453  :     void
; 454  :   {
; 455  :     float range = ( static_cast <float> ( max ) - static_cast <float> ( min ) );
; 456  : 
; 457  :     if (pos <= min + static_cast <UINT> ( threshold * range ))
; 458  :       rt = true;
; 459  : 
; 460  :     if (pos >= max - static_cast <UINT> ( threshold * range ))
; 461  :       lt = true;
; 462  :   };
; 463  : 
; 464  :   bool lt = false,
; 465  :        rt = false;
; 466  :   
; 467  :   switch (config.input.gamepad.predefined_layout)

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+676
	xorps	xmm0, xmm0
	movq	QWORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, xmm0
	mov	DWORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+12, 0
	push	esi

; 521  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_A;

	mov	si, WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4
	push	edi
	mov	edi, DWORD PTR _pJoy$[ebp]
	sub	eax, 0
	je	$LN4@SK_JOY_Tra

; 422  :   UNREFERENCED_PARAMETER (pCaps);
; 423  : 
; 424  :   static DWORD dwPacket = 0;
; 425  : 
; 426  :   ZeroMemory (&joy_to_xi.Gamepad, sizeof (XINPUT_STATE::Gamepad));
; 427  : 
; 428  : 
; 429  :   auto ComputeAxialPos_XInput =
; 430  :     [ ] (UINT min, UINT max, DWORD pos) ->
; 431  :     SHORT
; 432  :   {
; 433  :     float range = ( static_cast <float> ( max ) - static_cast <float> ( min ) );
; 434  :     float center = ( static_cast <float> ( max ) + static_cast <float> ( min ) ) / 2.0f;
; 435  :     float rpos = 0.5f;
; 436  : 
; 437  :     if (static_cast <float> ( pos ) < center)
; 438  :       rpos = center - ( center - static_cast <float> ( pos ) );
; 439  :     else
; 440  :       rpos = static_cast <float> ( pos ) - static_cast <float> ( min );
; 441  : 
; 442  :     std::numeric_limits <unsigned short>::max ( );
; 443  : 
; 444  :     float max_xi = static_cast <float> ( std::numeric_limits <unsigned short>::max ( ) );
; 445  :     float center_xi = static_cast <float> ( std::numeric_limits <unsigned short>::max ( ) / 2 );
; 446  : 
; 447  :     return
; 448  :       static_cast <SHORT> ( max_xi * ( rpos / range ) - center_xi );
; 449  :   };
; 450  : 
; 451  :   auto TestTriggerThreshold_XInput =
; 452  :     [ ] (UINT min, UINT max, float threshold, DWORD pos, bool& lt, bool& rt) ->
; 453  :     void
; 454  :   {
; 455  :     float range = ( static_cast <float> ( max ) - static_cast <float> ( min ) );
; 456  : 
; 457  :     if (pos <= min + static_cast <UINT> ( threshold * range ))
; 458  :       rt = true;
; 459  : 
; 460  :     if (pos >= max - static_cast <UINT> ( threshold * range ))
; 461  :       lt = true;
; 462  :   };
; 463  : 
; 464  :   bool lt = false,
; 465  :        rt = false;
; 466  :   
; 467  :   switch (config.input.gamepad.predefined_layout)

	sub	eax, 1
	jne	$LN40@SK_JOY_Tra

; 510  : 
; 511  :       TestTriggerThreshold_XInput (pCaps->wZmin, pCaps->wZmax, 0.00400f, pJoy->dwZpos, lt, rt);
; 512  : 
; 513  :       if (lt)
; 514  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_TRIGGER;
; 515  :       if (rt)
; 516  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_TRIGGER;
; 517  :       break;
; 518  : 
; 519  :     case 1:
; 520  :       if (pJoy->dwButtons & (1 << 0))

	test	BYTE PTR [edi+32], 1
	je	SHORT $LN20@SK_JOY_Tra

; 521  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_A;

	mov	eax, 4096				; 00001000H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN20@SK_JOY_Tra:

; 522  :       if (pJoy->dwButtons & (1 << 1))

	test	BYTE PTR [edi+32], 2
	je	SHORT $LN21@SK_JOY_Tra

; 523  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_B;

	mov	eax, 8192				; 00002000H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN21@SK_JOY_Tra:

; 524  :       if (pJoy->dwButtons & (1 << 2))

	test	BYTE PTR [edi+32], 4
	je	SHORT $LN22@SK_JOY_Tra

; 525  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_X;

	mov	eax, 16384				; 00004000H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN22@SK_JOY_Tra:

; 526  :       if (pJoy->dwButtons & (1 << 3))

	test	BYTE PTR [edi+32], 8
	je	SHORT $LN23@SK_JOY_Tra

; 527  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_Y;

	mov	eax, 32768				; 00008000H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN23@SK_JOY_Tra:

; 528  : 
; 529  :       if (pJoy->dwButtons & (1 << 4))

	test	BYTE PTR [edi+32], 16			; 00000010H
	je	SHORT $LN24@SK_JOY_Tra

; 530  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_SHOULDER;

	mov	eax, 256				; 00000100H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN24@SK_JOY_Tra:

; 531  :       if (pJoy->dwButtons & (1 << 5))

	test	BYTE PTR [edi+32], 32			; 00000020H
	je	SHORT $LN25@SK_JOY_Tra

; 532  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_SHOULDER;

	mov	eax, 512				; 00000200H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN25@SK_JOY_Tra:

; 533  : 
; 534  :       if (pJoy->dwButtons & (1 << 6))

	test	BYTE PTR [edi+32], 64			; 00000040H
	je	SHORT $LN26@SK_JOY_Tra

; 535  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_BACK;

	or	si, 32					; 00000020H
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN26@SK_JOY_Tra:

; 536  :       if (pJoy->dwButtons & (1 << 7))

	test	BYTE PTR [edi+32], 128			; 00000080H
	je	SHORT $LN27@SK_JOY_Tra

; 537  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_START;

	or	si, 16					; 00000010H
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN27@SK_JOY_Tra:

; 538  : 
; 539  :       if (pJoy->dwButtons & (1 << 8))

	test	DWORD PTR [edi+32], 256			; 00000100H
	je	SHORT $LN28@SK_JOY_Tra

; 540  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_THUMB;

	or	si, 64					; 00000040H
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN28@SK_JOY_Tra:

; 541  : 
; 542  :       if (pJoy->dwButtons & (1 << 9))

	test	DWORD PTR [edi+32], 512			; 00000200H
	je	$LN16@SK_JOY_Tra

; 543  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_THUMB;

	mov	eax, 128				; 00000080H

; 544  : 
; 545  :       if (pJoy->dwButtons & (1 << 10))
; 546  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_TRIGGER;
; 547  : 
; 548  :       if (pJoy->dwButtons & (1 << 11))
; 549  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_TRIGGER;
; 550  : 
; 551  :       joy_to_xi.Gamepad.sThumbLX = ComputeAxialPos_XInput (pCaps->wXmin, pCaps->wXmax, pJoy->dwXpos);
; 552  :       joy_to_xi.Gamepad.sThumbLY = ComputeAxialPos_XInput (pCaps->wYmin, pCaps->wYmax, pJoy->dwYpos);
; 553  : 
; 554  :       // Invert Y-Axis for Steam controller
; 555  :       joy_to_xi.Gamepad.sThumbLY = -joy_to_xi.Gamepad.sThumbLY;
; 556  : 
; 557  :       joy_to_xi.Gamepad.sThumbRX = ComputeAxialPos_XInput (pCaps->wRmin, pCaps->wRmax, pJoy->dwRpos);
; 558  :       joy_to_xi.Gamepad.sThumbRY = ComputeAxialPos_XInput (pCaps->wUmin, pCaps->wUmax, pJoy->dwUpos);
; 559  : 
; 560  :       TestTriggerThreshold_XInput (pCaps->wZmin, pCaps->wZmax, 0.00400f, pJoy->dwZpos, lt, rt);
; 561  : 
; 562  :       if (lt)
; 563  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_TRIGGER;
; 564  :       if (rt)
; 565  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_TRIGGER;

	jmp	$LN50@SK_JOY_Tra
$LN4@SK_JOY_Tra:

; 468  :   {
; 469  :     case 0:
; 470  :       if (pJoy->dwButtons & (1 << 1))

	test	BYTE PTR [edi+32], 2
	je	SHORT $LN5@SK_JOY_Tra

; 471  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_A;

	mov	eax, 4096				; 00001000H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN5@SK_JOY_Tra:

; 472  :       if (pJoy->dwButtons & (1 << 2))

	test	BYTE PTR [edi+32], 4
	je	SHORT $LN6@SK_JOY_Tra

; 473  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_B;

	mov	eax, 8192				; 00002000H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN6@SK_JOY_Tra:

; 474  :       if (pJoy->dwButtons & 1)

	test	BYTE PTR [edi+32], 1
	je	SHORT $LN7@SK_JOY_Tra

; 475  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_X;

	mov	eax, 16384				; 00004000H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN7@SK_JOY_Tra:

; 476  :       if (pJoy->dwButtons & (1 << 3))

	test	BYTE PTR [edi+32], 8
	je	SHORT $LN8@SK_JOY_Tra

; 477  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_Y;

	mov	eax, 32768				; 00008000H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN8@SK_JOY_Tra:

; 478  : 
; 479  :       if (pJoy->dwButtons & (1 << 9))

	test	DWORD PTR [edi+32], 512			; 00000200H
	je	SHORT $LN9@SK_JOY_Tra

; 480  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_START;

	or	si, 16					; 00000010H
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN9@SK_JOY_Tra:

; 481  :       if (pJoy->dwButtons & (1 << 8))

	test	DWORD PTR [edi+32], 256			; 00000100H
	je	SHORT $LN10@SK_JOY_Tra

; 482  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_BACK;

	or	si, 32					; 00000020H
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN10@SK_JOY_Tra:

; 483  : 
; 484  :       if (pJoy->dwButtons & (1 << 10))

	test	DWORD PTR [edi+32], 1024		; 00000400H
	je	SHORT $LN11@SK_JOY_Tra

; 485  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_THUMB;

	or	si, 64					; 00000040H
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN11@SK_JOY_Tra:

; 486  : 
; 487  :       if (pJoy->dwButtons & (1 << 11))

	test	DWORD PTR [edi+32], 2048		; 00000800H
	je	SHORT $LN12@SK_JOY_Tra

; 488  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_THUMB;

	mov	eax, 128				; 00000080H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN12@SK_JOY_Tra:

; 489  : 
; 490  :       if (pJoy->dwButtons & (1 << 6))
; 491  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_TRIGGER;
; 492  : 
; 493  :       if (pJoy->dwButtons & (1 << 7))
; 494  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_TRIGGER;
; 495  : 
; 496  :       if (pJoy->dwButtons & (1 << 4))

	test	BYTE PTR [edi+32], 16			; 00000010H
	je	SHORT $LN15@SK_JOY_Tra

; 497  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_SHOULDER;

	mov	eax, 256				; 00000100H
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN15@SK_JOY_Tra:

; 498  : 
; 499  :       if (pJoy->dwButtons & (1 << 5))

	test	BYTE PTR [edi+32], 32			; 00000020H
	je	SHORT $LN16@SK_JOY_Tra

; 500  :         joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_SHOULDER;

	mov	eax, 512				; 00000200H
$LN50@SK_JOY_Tra:
	or	si, ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN16@SK_JOY_Tra:

; 501  : 
; 502  :       joy_to_xi.Gamepad.sThumbLX = ComputeAxialPos_XInput (pCaps->wXmin, pCaps->wXmax, pJoy->dwXpos);

	mov	edx, DWORD PTR _pCaps$[ebp]
	lea	ecx, DWORD PTR _ComputeAxialPos_XInput$[ebp]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edx+72]
	push	DWORD PTR [edx+68]
	call	??R<lambda_9edb06091c12c988ebabcf846446a6cf>@@QBEFIIK@Z ; <lambda_9edb06091c12c988ebabcf846446a6cf>::operator()
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+8, ax

; 503  :       joy_to_xi.Gamepad.sThumbLY = ComputeAxialPos_XInput (pCaps->wYmin, pCaps->wYmax, pJoy->dwYpos);

	push	DWORD PTR [edi+12]
	push	DWORD PTR [edx+80]
	push	DWORD PTR [edx+76]
	call	??R<lambda_9edb06091c12c988ebabcf846446a6cf>@@QBEFIIK@Z ; <lambda_9edb06091c12c988ebabcf846446a6cf>::operator()

; 504  : 
; 505  :       // Invert Y-Axis for Steam controller
; 506  :       joy_to_xi.Gamepad.sThumbLY = -joy_to_xi.Gamepad.sThumbLY;

	neg	ax
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+10, ax

; 507  : 
; 508  :       joy_to_xi.Gamepad.sThumbRX = ComputeAxialPos_XInput (pCaps->wRmin, pCaps->wRmax, pJoy->dwRpos);

	push	DWORD PTR [edi+20]
	push	DWORD PTR [edx+108]
	push	DWORD PTR [edx+104]
	call	??R<lambda_9edb06091c12c988ebabcf846446a6cf>@@QBEFIIK@Z ; <lambda_9edb06091c12c988ebabcf846446a6cf>::operator()
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+12, ax

; 509  :       joy_to_xi.Gamepad.sThumbRY = ComputeAxialPos_XInput (pCaps->wUmin, pCaps->wUmax, pJoy->dwUpos);

	push	DWORD PTR [edi+24]
	push	DWORD PTR [edx+116]
	push	DWORD PTR [edx+112]
	call	??R<lambda_9edb06091c12c988ebabcf846446a6cf>@@QBEFIIK@Z ; <lambda_9edb06091c12c988ebabcf846446a6cf>::operator()
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+14, ax
$LN40@SK_JOY_Tra:

; 566  :       break;
; 567  :   };
; 568  : 
; 569  :   //joy_to_xi.Gamepad.bLeftTrigger  =   (BYTE)((float)MAXBYTE  * ((float)pJoy->dwZpos / 255.0f));
; 570  :   //joy_to_xi.Gamepad.bRightTrigger =  -(BYTE)((float)MAXBYTE  * ((float)pJoy->dwZpos / 255.0f));
; 571  :   //joy_to_xi.Gamepad.bLeftTrigger  =   (BYTE)((float)MAXBYTE  * ((float)pJoy->dwZpos / 255.0f));
; 572  :   //joy_to_xi.Gamepad.bRightTrigger =   (BYTE)((float)MAXBYTE  * ((float)pJoy->dwZpos / 255.0f));
; 573  : 
; 574  :   // One-eighth of a full rotation
; 575  :   //DWORD JOY_OCTSPACE = JOY_POVRIGHT / 2;
; 576  : 
; 577  : #if 0
; 578  :   // 315 - 45
; 579  :   if ( (pJoy->dwPOV >= JOY_POVLEFT   + JOY_OCTSPACE && pJoy->dwPOV != JOY_POVCENTERED) || pJoy->dwPOV <= JOY_POVRIGHT - JOY_OCTSPACE )
; 580  :     joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP;
; 581  : 
; 582  :   if (pJoy->dwPOV >= JOY_POVBACKWARD - JOY_OCTSPACE && pJoy->dwPOV <= JOY_POVBACKWARD + JOY_OCTSPACE)
; 583  :     joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN;
; 584  : 
; 585  :   if (pJoy->dwPOV >= JOY_POVLEFT     - JOY_OCTSPACE && pJoy->dwPOV <= JOY_POVLEFT     + JOY_OCTSPACE)
; 586  :     joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT;
; 587  : 
; 588  :   if (pJoy->dwPOV >= JOY_POVRIGHT    - JOY_OCTSPACE && pJoy->dwPOV <= JOY_POVRIGHT    + JOY_OCTSPACE)
; 589  :     joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT;
; 590  : #else
; 591  :   // 315 - 45
; 592  :   if (pJoy->dwPOV == JOY_POVFORWARD)

	cmp	DWORD PTR [edi+40], 0
	jne	SHORT $LN34@SK_JOY_Tra

; 593  :     joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP;

	or	si, 1
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN34@SK_JOY_Tra:

; 594  : 
; 595  :   if (pJoy->dwPOV == JOY_POVBACKWARD)

	cmp	DWORD PTR [edi+40], 18000		; 00004650H
	jne	SHORT $LN35@SK_JOY_Tra

; 596  :     joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN;

	or	si, 2
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN35@SK_JOY_Tra:

; 597  : 
; 598  :   if (pJoy->dwPOV == JOY_POVLEFT)

	cmp	DWORD PTR [edi+40], 27000		; 00006978H
	jne	SHORT $LN36@SK_JOY_Tra

; 599  :     joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT;

	or	si, 4
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN36@SK_JOY_Tra:

; 600  : 
; 601  :   if (pJoy->dwPOV == JOY_POVRIGHT)

	cmp	DWORD PTR [edi+40], 9000		; 00002328H
	jne	SHORT $LN37@SK_JOY_Tra

; 602  :     joy_to_xi.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT;

	or	si, 8
	mov	WORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A+4, si
$LN37@SK_JOY_Tra:

; 603  : #endif
; 604  : 
; 605  :   joy_to_xi.dwPacketNumber = dwPacket++;

	mov	eax, DWORD PTR ?dwPacket@?1??SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z@4KA
	mov	DWORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A, eax
	inc	eax

; 606  : 
; 607  :   return joy_to_xi;

	movups	xmm0, XMMWORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A
	mov	DWORD PTR ?dwPacket@?1??SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z@4KA, eax
	mov	eax, DWORD PTR $T1[ebp]
	pop	edi
	pop	esi
	movups	XMMWORD PTR [eax], xmm0

; 608  : }

	pop	ebp
	ret	0
?SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z ENDP ; SK_JOY_TranslateToXInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_pMouse$ = 8						; size = 4
?SK_Input_DI8Mouse_Release@@YG_NPAUSK_DI8_Mouse@@@Z PROC ; SK_Input_DI8Mouse_Release

; 396  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 397  :   if (pMouse == nullptr && _dim.pDev != nullptr)

	mov	ecx, DWORD PTR _pMouse$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@SK_Input_D
	cmp	DWORD PTR ?_dim@@3USK_DI8_Mouse@@A, ecx
	je	SHORT $LN3@SK_Input_D

; 398  :     pMouse = &_dim;

	mov	ecx, OFFSET ?_dim@@3USK_DI8_Mouse@@A	; _dim
$LN5@SK_Input_D:

; 399  : 
; 400  :   if (pMouse != nullptr)
; 401  :   {
; 402  :     IDirectInputDevice8_SetCooperativeLevel_Original (

	mov	eax, DWORD PTR [ecx+24]
	and	eax, -2					; fffffffeH
	or	eax, 2
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	push	DWORD PTR [ecx]
	call	DWORD PTR ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA ; IDirectInputDevice8_SetCooperativeLevel_Original

; 403  :       pMouse->pDev,
; 404  :         game_window.hWnd,
; 405  :           (pMouse->coop_level & (~DISCL_EXCLUSIVE)) | DISCL_NONEXCLUSIVE
; 406  :     );
; 407  : 
; 408  :     return true;

	mov	al, 1

; 412  : }

	pop	ebp
	ret	4
$LN3@SK_Input_D:

; 409  :   }
; 410  : 
; 411  :   return false;

	xor	al, al

; 412  : }

	pop	ebp
	ret	4
?SK_Input_DI8Mouse_Release@@YG_NPAUSK_DI8_Mouse@@@Z ENDP ; SK_Input_DI8Mouse_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
_pMouse$ = 8						; size = 4
?SK_Input_DI8Mouse_Acquire@@YG_NPAUSK_DI8_Mouse@@@Z PROC ; SK_Input_DI8Mouse_Acquire

; 374  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 375  :   if (pMouse == nullptr && _dim.pDev != nullptr)

	mov	eax, DWORD PTR _pMouse$[ebp]
	test	eax, eax
	jne	SHORT $LN5@SK_Input_D
	cmp	DWORD PTR ?_dim@@3USK_DI8_Mouse@@A, eax
	je	SHORT $LN3@SK_Input_D

; 376  :     pMouse = &_dim;

	mov	eax, OFFSET ?_dim@@3USK_DI8_Mouse@@A	; _dim
$LN5@SK_Input_D:

; 377  : 
; 378  :   if (pMouse != nullptr)
; 379  :   {
; 380  :     IDirectInputDevice8_SetCooperativeLevel_Original (

	push	DWORD PTR [eax+24]
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	push	DWORD PTR [eax]
	call	DWORD PTR ?IDirectInputDevice8_SetCooperativeLevel_Original@@3P6GJPAUIDirectInputDeviceW@@PAUHWND__@@K@ZA ; IDirectInputDevice8_SetCooperativeLevel_Original

; 381  :       pMouse->pDev,
; 382  :         game_window.hWnd,
; 383  :           pMouse->coop_level
; 384  :     );
; 385  : 
; 386  :     return true;

	mov	al, 1

; 390  : }

	pop	ebp
	ret	4
$LN3@SK_Input_D:

; 387  :   }
; 388  : 
; 389  :   return false;

	xor	al, al

; 390  : }

	pop	ebp
	ret	4
?SK_Input_DI8Mouse_Acquire@@YG_NPAUSK_DI8_Mouse@@@Z ENDP ; SK_Input_DI8Mouse_Acquire
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?SK_Input_GetDI8Mouse@@YGPAUSK_DI8_Mouse@@XZ PROC	; SK_Input_GetDI8Mouse

; 367  :   return &_dim;

	mov	eax, OFFSET ?_dim@@3USK_DI8_Mouse@@A	; _dim

; 368  : }

	ret	0
?SK_Input_GetDI8Mouse@@YGPAUSK_DI8_Mouse@@XZ ENDP	; SK_Input_GetDI8Mouse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?SK_Input_GetDI8Keyboard@@YGPAUSK_DI8_Keyboard@@XZ PROC	; SK_Input_GetDI8Keyboard

; 359  :   return &_dik;

	mov	eax, OFFSET ?_dik@@3USK_DI8_Keyboard@@A	; _dik

; 360  : }

	ret	0
?SK_Input_GetDI8Keyboard@@YGPAUSK_DI8_Keyboard@@XZ ENDP	; SK_Input_GetDI8Keyboard
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SK_DI8_Mouse@@QAE@XZ
_TEXT	SEGMENT
??0SK_DI8_Mouse@@QAE@XZ PROC				; SK_DI8_Mouse::SK_DI8_Mouse, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+28], 0
	ret	0
??0SK_DI8_Mouse@@QAE@XZ ENDP				; SK_DI8_Mouse::SK_DI8_Mouse
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SK_DI8_Keyboard@@QAE@XZ
_TEXT	SEGMENT
??0SK_DI8_Keyboard@@QAE@XZ PROC				; SK_DI8_Keyboard::SK_DI8_Keyboard, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0SK_DI8_Keyboard@@QAE@XZ ENDP				; SK_DI8_Keyboard::SK_DI8_Keyboard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?SK_Input_PreHookDI8@@YAXXZ PROC			; SK_Input_PreHookDI8

; 1057 :   if (! config.input.gamepad.hook_dinput8)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+671, 0
	je	SHORT $LN6@SK_Input_P

; 1058 :     return;
; 1059 : 
; 1060 :   if (DirectInput8Create_Import == nullptr)

	cmp	DWORD PTR ?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA, 0 ; DirectInput8Create_Import
	jne	SHORT $LN6@SK_Input_P

; 1061 :   {
; 1062 :     static sk_import_test_s tests [] = { { "dinput.dll",  false },
; 1063 :                                          { "dinput8.dll", false } };
; 1064 : 
; 1065 :     SK_TestImports (GetModuleHandle (nullptr), tests, 2);

	push	2
	push	OFFSET ?tests@?6??SK_Input_PreHookDI8@@YAXXZ@4PAUsk_import_test_s@@A
	push	0
	call	DWORD PTR __imp__GetModuleHandleW@4
	push	eax
	call	?SK_TestImports@@YGXPAUHINSTANCE__@@PAUsk_import_test_s@@H@Z ; SK_TestImports

; 1066 : 
; 1067 :     if (tests [0].used || tests [1].used || GetModuleHandle (L"dinput8.dll"))

	cmp	BYTE PTR ?tests@?6??SK_Input_PreHookDI8@@YAXXZ@4PAUsk_import_test_s@@A+4, 0
	jne	SHORT $LN5@SK_Input_P
	cmp	BYTE PTR ?tests@?6??SK_Input_PreHookDI8@@YAXXZ@4PAUsk_import_test_s@@A+12, 0
	jne	SHORT $LN5@SK_Input_P
	push	OFFSET $SG258890
	call	DWORD PTR __imp__GetModuleHandleW@4
	test	eax, eax
	je	SHORT $LN6@SK_Input_P
$LN5@SK_Input_P:

; 1068 :     {
; 1069 :       if (SK_GetDLLRole () != DLL_ROLE::DInput8)

	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	cmp	eax, 256				; 00000100H
	jne	?SK_Input_HookDI8@@YAXXZ		; SK_Input_HookDI8
$LN6@SK_Input_P:

; 1070 :         SK_Input_HookDI8 ();
; 1071 :     }
; 1072 :   }
; 1073 : }

	ret	0
?SK_Input_PreHookDI8@@YAXXZ ENDP			; SK_Input_PreHookDI8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?SK_Input_HookDI8@@YAXXZ PROC				; SK_Input_HookDI8

; 1032 :   if (! config.input.gamepad.hook_dinput8)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+671, 0
	je	SHORT $LN3@SK_Input_H

; 1033 :     return;
; 1034 : 
; 1035 :   static volatile LONG hooked = FALSE;
; 1036 : 
; 1037 :   if (! InterlockedExchangeAdd (&hooked, 1))

	mov	eax, 1
	mov	ecx, OFFSET ?hooked@?1??SK_Input_HookDI8@@YAXXZ@4JC
	lock	 xadd	 DWORD PTR [ecx], eax
	test	eax, eax
	jne	SHORT $LN3@SK_Input_H

; 1038 :   {
; 1039 :     SK_LOG0 ( ( L"Game uses DirectInput, installing input hooks..." ),

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+808, eax
	jl	SHORT $LN4@SK_Input_H
	push	OFFSET $SG258875
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN4@SK_Input_H:

; 1040 :                   L"   Input  " );
; 1041 : 
; 1042 :     HMODULE hBackend = 
; 1043 :       (SK_GetDLLRole () & DLL_ROLE::DInput8) ? backend_dll :

	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	test	eax, 256				; 00000100H
	je	SHORT $LN6@SK_Input_H
	mov	eax, DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	jmp	SHORT $LN7@SK_Input_H
$LN6@SK_Input_H:
	push	OFFSET $SG258876
	call	DWORD PTR __imp__GetModuleHandleW@4
$LN7@SK_Input_H:

; 1044 :                                       GetModuleHandle (L"dinput8.dll");
; 1045 : 
; 1046 :     SK_CreateFuncHook (      L"DirectInput8Create",

	push	OFFSET ?DirectInput8Create_Import@@3P6GJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@ZA ; DirectInput8Create_Import
	push	OFFSET ?DirectInput8Create@@YAJPAUHINSTANCE__@@KABU_GUID@@PAPAXPAUIUnknown@@@Z ; DirectInput8Create
	push	OFFSET $SG258877
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	push	eax
	push	OFFSET $SG258878
	call	?SK_CreateFuncHook@@YG?AW4MH_STATUS@@PB_WPAX1PAPAX@Z ; SK_CreateFuncHook
$LN3@SK_Input_H:

; 1047 :              GetProcAddress ( hBackend,
; 1048 :                               "DirectInput8Create" ),
; 1049 :                                DirectInput8Create,
; 1050 :       static_cast_p2p <void> (&DirectInput8Create_Import) );
; 1051 :   }
; 1052 : }

	ret	0
?SK_Input_HookDI8@@YAXXZ ENDP				; SK_Input_HookDI8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?Shutdown@DI8@SK@@YA_NXZ PROC				; SK::DI8::Shutdown

; 346  :   return SK_ShutdownCore (L"dinput8");

	push	OFFSET $SG258375
	call	?SK_ShutdownCore@@YG_NPB_W@Z		; SK_ShutdownCore

; 347  : }

	ret	0
?Shutdown@DI8@SK@@YA_NXZ ENDP				; SK::DI8::Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
_TEXT	SEGMENT
?Startup@DI8@SK@@YA_NXZ PROC				; SK::DI8::Startup

; 340  :   return SK_StartupCore (L"dinput8", di8_init_callback);

	push	OFFSET ?di8_init_callback@@YGXP6GXXZ@Z	; di8_init_callback
	push	OFFSET $SG258371
	call	?SK_StartupCore@@YG_NPB_WPAX@Z		; SK_StartupCore

; 341  : }

	ret	0
?Startup@DI8@SK@@YA_NXZ ENDP				; SK::DI8::Startup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
;	COMDAT ?_InterlockedCompareExchange@@YAKPCKKK@Z
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Exchange$ = 12						; size = 4
_Comperand$ = 16					; size = 4
?_InterlockedCompareExchange@@YAKPCKKK@Z PROC		; _InterlockedCompareExchange, COMDAT

; 9002 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	edx, DWORD PTR _Exchange$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	eax, DWORD PTR _Comperand$[ebp]
	lock	 cmpxchg DWORD PTR [ecx], edx

; 9004 : }

	pop	ebp
	ret	0
?_InterlockedCompareExchange@@YAKPCKKK@Z ENDP		; _InterlockedCompareExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	jle	SHORT $LN4@HRESULT_FR
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
$LN4@HRESULT_FR:
	pop	ebp
	ret	0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _ReadAcquire
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_ReadAcquire PROC					; COMDAT

; 8059 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8060 : 
; 8061 :     LONG Value;
; 8062 : 
; 8063 :     Value = *Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	eax, DWORD PTR [eax]

; 8064 :     return Value;
; 8065 : }

	pop	ebp
	ret	0
_ReadAcquire ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _==
_TEXT	SEGMENT
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC						; COMDAT

; 193  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, DWORD PTR _guidOne$[ebp]
	mov	eax, DWORD PTR _guidOther$[ebp]
	push	esi
	mov	esi, 12					; 0000000cH
$LL7@:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN6@
	add	edx, 4
	add	eax, 4
	sub	esi, 4
	jae	SHORT $LL7@

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

	mov	al, 1
	pop	esi

; 195  : }

	pop	ebp
	ret	0
$LN6@:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

	xor	al, al
	pop	esi

; 195  : }

	pop	ebp
	ret	0
_==	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 160  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, DWORD PTR _rguid1$[ebp]
	mov	eax, DWORD PTR _rguid2$[ebp]
	push	esi
	mov	esi, 12					; 0000000cH
$LL5@IsEqualGUI:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@IsEqualGUI
	add	edx, 4
	add	eax, 4
	sub	esi, 4
	jae	SHORT $LL5@IsEqualGUI
	mov	eax, 1
	pop	esi

; 162  : }

	pop	ebp
	ret	0
$LN4@IsEqualGUI:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	xor	eax, eax
	pop	esi

; 162  : }

	pop	ebp
	ret	0
_IsEqualGUID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 1076 : sk_input_api_context_s SK_DI8_Backend;

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\dinput8.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 1076 : sk_input_api_context_s SK_DI8_Backend;

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
