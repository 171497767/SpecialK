; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\imgui\backends\imgui_gl3.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?g_Time@@3_JA DQ 01H DUP (?)				; g_Time
?g_TicksPerSecond@@3_JA DQ 01H DUP (?)			; g_TicksPerSecond
?g_MousePressed@@3PA_NA DB 03H DUP (?)			; g_MousePressed
	ALIGN	4

?g_MouseWheel@@3MA DD 01H DUP (?)			; g_MouseWheel
?g_FontTexture@@3IA DD 01H DUP (?)			; g_FontTexture
?g_ShaderHandle@@3HA DD 01H DUP (?)			; g_ShaderHandle
?g_VertHandle@@3HA DD 01H DUP (?)			; g_VertHandle
?g_FragHandle@@3HA DD 01H DUP (?)			; g_FragHandle
?g_AttribLocationTex@@3HA DD 01H DUP (?)		; g_AttribLocationTex
?g_AttribLocationProjMtx@@3HA DD 01H DUP (?)		; g_AttribLocationProjMtx
?g_AttribLocationPosition@@3HA DD 01H DUP (?)		; g_AttribLocationPosition
?g_AttribLocationUV@@3HA DD 01H DUP (?)			; g_AttribLocationUV
?g_AttribLocationColor@@3HA DD 01H DUP (?)		; g_AttribLocationColor
?g_VboHandle@@3IA DD 01H DUP (?)			; g_VboHandle
?g_VaoHandle@@3IA DD 01H DUP (?)			; g_VaoHandle
?g_ElementsHandle@@3IA DD 01H DUP (?)			; g_ElementsHandle
_BSS	ENDS
CONST	SEGMENT
$SG99248 DB	'#version 330', 0aH, 'uniform mat4 ProjMtx;', 0aH, 'in ve'
	DB	'c2 Position;', 0aH, 'in vec2 UV;', 0aH, 'in vec4 Color;', 0aH
	DB	'out vec2 Frag_UV;', 0aH, 'out vec4 Frag_Color;', 0aH, 'void m'
	DB	'ain()', 0aH, '{', 0aH, 09H, 'Frag_UV = UV;', 0aH, 09H, 'Frag_'
	DB	'Color = Color;', 0aH, 09H, 'gl_Position = ProjMtx * vec4(Posi'
	DB	'tion.xy,0,1);', 0aH, '}', 0aH, 00H
$SG99252 DB	'Position', 00H
	ORG $+3
$SG99249 DB	'#version 330', 0aH, 'uniform sampler2D Texture;', 0aH, 'i'
	DB	'n vec2 Frag_UV;', 0aH, 'in vec4 Frag_Color;', 0aH, 'out vec4 '
	DB	'Out_Color;', 0aH, 'void main()', 0aH, '{', 0aH, 09H, 'Out_Col'
	DB	'or = Frag_Color * texture( Texture, Frag_UV.st);', 0aH, '}', 0aH
	DB	00H
	ORG $+1
$SG99250 DB	'Texture', 00H
$SG99251 DB	'ProjMtx', 00H
$SG99253 DB	'UV', 00H
	ORG $+1
$SG99254 DB	'Color', 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?ImGui_ImplGL3_RenderDrawLists@@YAXPAUImDrawData@@@Z ; ImGui_ImplGL3_RenderDrawLists
PUBLIC	?ImGui_ImplGL3_GetClipboardText@@YAPBDPAX@Z	; ImGui_ImplGL3_GetClipboardText
PUBLIC	?ImGui_ImplGL3_SetClipboardText@@YAXPAXPBD@Z	; ImGui_ImplGL3_SetClipboardText
PUBLIC	?ImGui_ImplGL3_CreateFontsTexture@@YA_NXZ	; ImGui_ImplGL3_CreateFontsTexture
PUBLIC	?ImGui_ImplGlfwGL3_CreateDeviceObjects@@YA_NXZ	; ImGui_ImplGlfwGL3_CreateDeviceObjects
PUBLIC	?ImGui_ImplGL3_InvalidateDeviceObjects@@YAXXZ	; ImGui_ImplGL3_InvalidateDeviceObjects
PUBLIC	?ImGui_ImplGL3_Init@@YA_NXZ			; ImGui_ImplGL3_Init
PUBLIC	?ImGui_ImplGL3_Shutdown@@YAXXZ			; ImGui_ImplGL3_Shutdown
PUBLIC	?ImGui_ImplGL3_NewFrame@@YAXXZ			; ImGui_ImplGL3_NewFrame
PUBLIC	__real@3f800000
PUBLIC	__real@c0000000
PUBLIC	__xmm@3f800000bf80000000000000bf800000
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?NewFrame@ImGui@@YAXXZ:PROC			; ImGui::NewFrame
EXTRN	?Shutdown@ImGui@@YAXXZ:PROC			; ImGui::Shutdown
EXTRN	?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z:PROC ; ImDrawData::ScaleClipRects
EXTRN	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z:PROC ; ImFontAtlas::GetTexDataAsRGBA32
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	_glBindTexture@8:PROC
EXTRN	_glBlendFunc@8:PROC
EXTRN	_glDeleteTextures@8:PROC
EXTRN	_glDisable@4:PROC
EXTRN	_glDrawElements@16:PROC
EXTRN	_glEnable@4:PROC
EXTRN	_glGenTextures@8:PROC
EXTRN	_glGetIntegerv@8:PROC
EXTRN	_glScissor@16:PROC
EXTRN	_glTexImage2D@36:PROC
EXTRN	_glTexParameteri@12:PROC
EXTRN	_glViewport@16:PROC
EXTRN	?SK_ImGui_LoadFonts@@YAXXZ:PROC			; SK_ImGui_LoadFonts
EXTRN	?SK_ImGui_ResetExternal@@YAXXZ:PROC		; SK_ImGui_ResetExternal
EXTRN	?SK_ImGui_PollGamepad@@YAXXZ:PROC		; SK_ImGui_PollGamepad
EXTRN	__ltod3:PROC
EXTRN	___glewActiveTexture:DWORD
EXTRN	___glewBlendEquation:DWORD
EXTRN	___glewBindBuffer:DWORD
EXTRN	___glewBufferData:DWORD
EXTRN	___glewDeleteBuffers:DWORD
EXTRN	___glewGenBuffers:DWORD
EXTRN	___glewAttachShader:DWORD
EXTRN	___glewCompileShader:DWORD
EXTRN	___glewCreateProgram:DWORD
EXTRN	___glewCreateShader:DWORD
EXTRN	___glewDeleteProgram:DWORD
EXTRN	___glewDeleteShader:DWORD
EXTRN	___glewDetachShader:DWORD
EXTRN	___glewEnableVertexAttribArray:DWORD
EXTRN	___glewGetAttribLocation:DWORD
EXTRN	___glewGetUniformLocation:DWORD
EXTRN	___glewLinkProgram:DWORD
EXTRN	___glewShaderSource:DWORD
EXTRN	___glewUniform1i:DWORD
EXTRN	___glewUniformMatrix4fv:DWORD
EXTRN	___glewUseProgram:DWORD
EXTRN	___glewVertexAttribPointer:DWORD
EXTRN	___glewBindVertexArray:DWORD
EXTRN	___glewDeleteVertexArrays:DWORD
EXTRN	___glewGenVertexArrays:DWORD
EXTRN	?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA:DWORD ; QueryPerformanceCounter_Original
EXTRN	?game_window@@3Usk_window_s@@A:BYTE		; game_window
EXTRN	__fltused:DWORD
;	COMDAT __xmm@3f800000bf80000000000000bf800000
CONST	SEGMENT
__xmm@3f800000bf80000000000000bf800000 DB 00H, 00H, 080H, 0bfH, 00H, 00H, 00H
	DB	00H, 00H, 00H, 080H, 0bfH, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ?first@?1??ImGui_ImplGL3_Init@@YA_NXZ@4_NA
_DATA	SEGMENT
?first@?1??ImGui_ImplGL3_Init@@YA_NXZ@4_NA DB 01H	; `ImGui_ImplGL3_Init'::`2'::first
_DATA	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
_client$ = -32						; size = 16
_current_time$ = -16					; size = 8
$T1 = -8						; size = 8
$T2 = -8						; size = 8
tv205 = -4						; size = 4
?ImGui_ImplGL3_NewFrame@@YAXXZ PROC			; ImGui_ImplGL3_NewFrame

; 415  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 416  :   if (! g_FontTexture)

	cmp	DWORD PTR ?g_FontTexture@@3IA, 0
	jne	SHORT $LN2@ImGui_Impl

; 417  :     ImGui_ImplGlfwGL3_CreateDeviceObjects ();

	call	?ImGui_ImplGlfwGL3_CreateDeviceObjects@@YA_NXZ ; ImGui_ImplGlfwGL3_CreateDeviceObjects
$LN2@ImGui_Impl:
	push	esi

; 418  : 
; 419  :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	esi, eax

; 420  : 
; 421  :   RECT client;
; 422  :   GetClientRect (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 423  : 
; 424  :   // Setup display size (every frame to accommodate for window resizing)
; 425  :   int w = client.right  - client.left,

	mov	ecx, DWORD PTR _client$[ebp+8]
	sub	ecx, DWORD PTR _client$[ebp]

; 426  :       h = client.bottom - client.top;

	mov	eax, DWORD PTR _client$[ebp+12]
	sub	eax, DWORD PTR _client$[ebp+4]
	movd	xmm1, ecx

; 428  :   io.DisplaySize             =

	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp

; 428  :   io.DisplaySize             =

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [esi], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp

; 428  :   io.DisplaySize             =

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [esi+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp

; 430  :   io.DisplayFramebufferScale = 

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esi+144], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp

; 430  :   io.DisplayFramebufferScale = 

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [esi+148], eax

; 431  :     ImVec2 ( static_cast <float> (w), static_cast <float> (h) );
; 432  :   //ImVec2 (w > 0 ? ((float)display_w / w) : 0, h > 0 ? ((float)display_h / h) : 0);
; 433  : 
; 434  :   // Setup time step
; 435  :   INT64 current_time;
; 436  : 
; 437  :   QueryPerformanceCounter_Original (

	lea	eax, DWORD PTR _current_time$[ebp]
	push	eax
	call	DWORD PTR ?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA ; QueryPerformanceCounter_Original

; 438  :     reinterpret_cast <LARGE_INTEGER *> (&current_time)
; 439  :   );
; 440  : 
; 441  :   io.DeltaTime = static_cast <float> (current_time - g_Time) /

	mov	ecx, DWORD PTR _current_time$[ebp]
	sub	ecx, DWORD PTR ?g_Time@@3_JA
	mov	edx, DWORD PTR _current_time$[ebp+4]
	sbb	edx, DWORD PTR ?g_Time@@3_JA+4
	call	__ltod3
	mov	edx, DWORD PTR ?g_TicksPerSecond@@3_JA+4
	mov	ecx, DWORD PTR ?g_TicksPerSecond@@3_JA
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv205[ebp], xmm0
	call	__ltod3
	movss	xmm1, DWORD PTR tv205[ebp]
	cvtsd2ss xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [esi+8], xmm1

; 442  :                  static_cast <float> (g_TicksPerSecond);
; 443  :   g_Time       =                      current_time;

	mov	eax, DWORD PTR _current_time$[ebp]
	mov	DWORD PTR ?g_Time@@3_JA, eax
	mov	eax, DWORD PTR _current_time$[ebp+4]
	mov	DWORD PTR ?g_Time@@3_JA+4, eax

; 444  : 
; 445  :   // Read keyboard modifiers inputS
; 446  :   io.KeyCtrl   = (io.KeysDown [VK_CONTROL]) != 0;

	cmp	BYTE PTR [esi+246], 0
	setne	al
	mov	BYTE PTR [esi+225], al

; 447  :   io.KeyShift  = (io.KeysDown [VK_SHIFT])   != 0;

	cmp	BYTE PTR [esi+245], 0
	setne	al
	mov	BYTE PTR [esi+226], al

; 448  :   io.KeyAlt    = (io.KeysDown [VK_MENU])    != 0;

	cmp	BYTE PTR [esi+247], 0

; 449  : 
; 450  :   io.KeySuper  = false;

	mov	BYTE PTR [esi+228], 0
	setne	al
	mov	BYTE PTR [esi+227], al

; 451  : 
; 452  : 
; 453  :   // For games that hijack the mouse cursor using Direct Input 8.
; 454  :   //
; 455  :   //  -- Acquire actually means release their exclusive ownership : )
; 456  :   //
; 457  :   //if (SK_ImGui_WantMouseCapture ())
; 458  :   //  SK_Input_DI8Mouse_Acquire ();
; 459  :   //else
; 460  :   //  SK_Input_DI8Mouse_Release ();
; 461  : 
; 462  : 
; 463  :   SK_ImGui_PollGamepad ();

	call	?SK_ImGui_PollGamepad@@YAXXZ		; SK_ImGui_PollGamepad

; 464  : 
; 465  :   // Start the frame
; 466  :   ImGui::NewFrame ();

	call	?NewFrame@ImGui@@YAXXZ			; ImGui::NewFrame
	pop	esi

; 467  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplGL3_NewFrame@@YAXXZ ENDP			; ImGui_ImplGL3_NewFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
?ImGui_ImplGL3_Shutdown@@YAXXZ PROC			; ImGui_ImplGL3_Shutdown

; 406  :   ImGui_ImplGL3_InvalidateDeviceObjects ();

	call	?ImGui_ImplGL3_InvalidateDeviceObjects@@YAXXZ ; ImGui_ImplGL3_InvalidateDeviceObjects

; 407  :   ImGui::Shutdown ();

	jmp	?Shutdown@ImGui@@YAXXZ			; ImGui::Shutdown
?ImGui_ImplGL3_Shutdown@@YAXXZ ENDP			; ImGui_ImplGL3_Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
?ImGui_ImplGL3_Init@@YA_NXZ PROC			; ImGui_ImplGL3_Init

; 358  :   static bool first = true;
; 359  : 
; 360  :   if (first) {

	cmp	BYTE PTR ?first@?1??ImGui_ImplGL3_Init@@YA_NXZ@4_NA, 0
	je	SHORT $LN2@ImGui_Impl

; 361  :     if (! QueryPerformanceFrequency        (reinterpret_cast <LARGE_INTEGER *> (&g_TicksPerSecond)))

	push	OFFSET ?g_TicksPerSecond@@3_JA
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	test	eax, eax
	jne	SHORT $LN3@ImGui_Impl
$LN6@ImGui_Impl:

; 362  :       return false;

	xor	al, al

; 401  : }

	ret	0
$LN3@ImGui_Impl:

; 363  : 
; 364  :     if (! QueryPerformanceCounter_Original (reinterpret_cast <LARGE_INTEGER *> (&g_Time)))

	push	OFFSET ?g_Time@@3_JA
	call	DWORD PTR ?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA ; QueryPerformanceCounter_Original
	test	eax, eax
	je	SHORT $LN6@ImGui_Impl

; 365  :       return false;
; 366  : 
; 367  :     first = false;

	mov	BYTE PTR ?first@?1??ImGui_ImplGL3_Init@@YA_NXZ@4_NA, 0
$LN2@ImGui_Impl:

; 368  :   }
; 369  : 
; 370  :   //g_Window = window;
; 371  : 
; 372  :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	ecx, eax

; 373  : 
; 374  :   // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array that we will update during the application lifetime.
; 375  :   io.KeyMap [ImGuiKey_Tab]        = VK_TAB;

	mov	DWORD PTR [ecx+36], 9

; 376  :   io.KeyMap [ImGuiKey_LeftArrow]  = VK_LEFT;

	mov	DWORD PTR [ecx+48], 37			; 00000025H

; 377  :   io.KeyMap [ImGuiKey_RightArrow] = VK_RIGHT;

	mov	DWORD PTR [ecx+52], 39			; 00000027H

; 378  :   io.KeyMap [ImGuiKey_UpArrow]    = VK_UP;

	mov	DWORD PTR [ecx+40], 38			; 00000026H

; 379  :   io.KeyMap [ImGuiKey_DownArrow]  = VK_DOWN;

	mov	DWORD PTR [ecx+44], 40			; 00000028H

; 380  :   io.KeyMap [ImGuiKey_PageUp]     = VK_PRIOR;

	mov	DWORD PTR [ecx+56], 33			; 00000021H

; 381  :   io.KeyMap [ImGuiKey_PageDown]   = VK_NEXT;

	mov	DWORD PTR [ecx+60], 34			; 00000022H

; 382  :   io.KeyMap [ImGuiKey_Home]       = VK_HOME;

	mov	DWORD PTR [ecx+64], 36			; 00000024H

; 383  :   io.KeyMap [ImGuiKey_End]        = VK_END;

	mov	DWORD PTR [ecx+68], 35			; 00000023H

; 384  :   io.KeyMap [ImGuiKey_Delete]     = VK_DELETE;

	mov	DWORD PTR [ecx+72], 46			; 0000002eH

; 385  :   io.KeyMap [ImGuiKey_Backspace]  = VK_BACK;

	mov	DWORD PTR [ecx+76], 8

; 386  :   io.KeyMap [ImGuiKey_Enter]      = VK_RETURN;

	mov	DWORD PTR [ecx+80], 13			; 0000000dH

; 387  :   io.KeyMap [ImGuiKey_Escape]     = VK_ESCAPE;

	mov	DWORD PTR [ecx+84], 27			; 0000001bH

; 388  :   io.KeyMap [ImGuiKey_A]          = 'A';

	mov	DWORD PTR [ecx+88], 65			; 00000041H

; 389  :   io.KeyMap [ImGuiKey_C]          = 'C';

	mov	DWORD PTR [ecx+92], 67			; 00000043H

; 390  :   io.KeyMap [ImGuiKey_V]          = 'V';

	mov	DWORD PTR [ecx+96], 86			; 00000056H

; 391  :   io.KeyMap [ImGuiKey_X]          = 'X';

	mov	DWORD PTR [ecx+100], 88			; 00000058H

; 392  :   io.KeyMap [ImGuiKey_Y]          = 'Y';

	mov	DWORD PTR [ecx+104], 89			; 00000059H

; 393  :   io.KeyMap [ImGuiKey_Z]          = 'Z';

	mov	DWORD PTR [ecx+108], 90			; 0000005aH

; 394  : 
; 395  :   io.RenderDrawListsFn  = ImGui_ImplGL3_RenderDrawLists;       // Alternatively you can set this to NULL and call ImGui::GetDrawData() after ImGui::Render() to get the same ImDrawData pointer.

	mov	DWORD PTR [ecx+172], OFFSET ?ImGui_ImplGL3_RenderDrawLists@@YAXPAUImDrawData@@@Z ; ImGui_ImplGL3_RenderDrawLists

; 396  :   //io.SetClipboardTextFn = ImGui_ImplGL3_SetClipboardText;
; 397  :   //io.GetClipboardTextFn = ImGui_ImplGL3_GetClipboardText;
; 398  :   io.ClipboardUserData  = game_window.hWnd;

	mov	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	mov	DWORD PTR [ecx+184], eax

; 399  : 
; 400  :   return true;

	mov	al, 1

; 401  : }

	ret	0
?ImGui_ImplGL3_Init@@YA_NXZ ENDP			; ImGui_ImplGL3_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
?ImGui_ImplGL3_InvalidateDeviceObjects@@YAXXZ PROC	; ImGui_ImplGL3_InvalidateDeviceObjects

; 321  :   extern void
; 322  :   SK_ImGui_ResetExternal (void);
; 323  :   SK_ImGui_ResetExternal ();

	call	?SK_ImGui_ResetExternal@@YAXXZ		; SK_ImGui_ResetExternal

; 324  : 
; 325  :   if (g_VaoHandle)      glDeleteVertexArrays (1, &g_VaoHandle);

	cmp	DWORD PTR ?g_VaoHandle@@3IA, 0
	je	SHORT $LN2@ImGui_Impl
	push	OFFSET ?g_VaoHandle@@3IA
	push	1
	call	DWORD PTR ___glewDeleteVertexArrays
$LN2@ImGui_Impl:

; 326  :   if (g_VboHandle)      glDeleteBuffers      (1, &g_VboHandle);

	cmp	DWORD PTR ?g_VboHandle@@3IA, 0
	je	SHORT $LN3@ImGui_Impl
	push	OFFSET ?g_VboHandle@@3IA
	push	1
	call	DWORD PTR ___glewDeleteBuffers
$LN3@ImGui_Impl:

; 327  :   if (g_ElementsHandle) glDeleteBuffers      (1, &g_ElementsHandle);

	cmp	DWORD PTR ?g_ElementsHandle@@3IA, 0
	je	SHORT $LN4@ImGui_Impl
	push	OFFSET ?g_ElementsHandle@@3IA
	push	1
	call	DWORD PTR ___glewDeleteBuffers
$LN4@ImGui_Impl:

; 328  : 
; 329  :   g_VaoHandle = g_VboHandle = g_ElementsHandle = 0;
; 330  : 
; 331  :   if (g_ShaderHandle && g_VertHandle) glDetachShader (g_ShaderHandle, g_VertHandle);

	mov	eax, DWORD PTR ?g_ShaderHandle@@3HA
	mov	DWORD PTR ?g_ElementsHandle@@3IA, 0
	mov	DWORD PTR ?g_VboHandle@@3IA, 0
	mov	DWORD PTR ?g_VaoHandle@@3IA, 0
	test	eax, eax
	je	SHORT $LN5@ImGui_Impl
	mov	ecx, DWORD PTR ?g_VertHandle@@3HA
	test	ecx, ecx
	je	SHORT $LN6@ImGui_Impl
	push	ecx
	push	eax
	call	DWORD PTR ___glewDetachShader
	mov	eax, DWORD PTR ?g_ShaderHandle@@3HA
$LN5@ImGui_Impl:

; 332  :   if (g_VertHandle)                   glDeleteShader (g_VertHandle);

	mov	ecx, DWORD PTR ?g_VertHandle@@3HA
	test	ecx, ecx
	je	SHORT $LN6@ImGui_Impl
	push	ecx
	call	DWORD PTR ___glewDeleteShader
	mov	eax, DWORD PTR ?g_ShaderHandle@@3HA
$LN6@ImGui_Impl:

; 333  : 
; 334  :   g_VertHandle = 0;

	mov	DWORD PTR ?g_VertHandle@@3HA, 0

; 335  : 
; 336  :   if (g_ShaderHandle && g_FragHandle) glDetachShader (g_ShaderHandle, g_FragHandle);

	test	eax, eax
	je	SHORT $LN7@ImGui_Impl
	mov	ecx, DWORD PTR ?g_FragHandle@@3HA
	test	ecx, ecx
	je	SHORT $LN8@ImGui_Impl
	push	ecx
	push	eax
	call	DWORD PTR ___glewDetachShader
	mov	eax, DWORD PTR ?g_ShaderHandle@@3HA
$LN7@ImGui_Impl:

; 337  :   if (g_FragHandle)                   glDeleteShader (g_FragHandle);

	mov	ecx, DWORD PTR ?g_FragHandle@@3HA
	test	ecx, ecx
	je	SHORT $LN8@ImGui_Impl
	push	ecx
	call	DWORD PTR ___glewDeleteShader
	mov	eax, DWORD PTR ?g_ShaderHandle@@3HA
$LN8@ImGui_Impl:

; 338  : 
; 339  :   g_FragHandle = 0;

	mov	DWORD PTR ?g_FragHandle@@3HA, 0

; 340  : 
; 341  :   if (g_ShaderHandle) glDeleteProgram (g_ShaderHandle);

	test	eax, eax
	je	SHORT $LN9@ImGui_Impl
	push	eax
	call	DWORD PTR ___glewDeleteProgram
$LN9@ImGui_Impl:

; 342  : 
; 343  :   g_ShaderHandle = 0;
; 344  : 
; 345  :   if (g_FontTexture)

	cmp	DWORD PTR ?g_FontTexture@@3IA, 0
	mov	DWORD PTR ?g_ShaderHandle@@3HA, 0
	je	SHORT $LN10@ImGui_Impl

; 346  :   {
; 347  :     ImGuiIO& io (ImGui::GetIO ());

	push	esi
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 348  : 
; 349  :     glDeleteTextures (1, &g_FontTexture);

	push	OFFSET ?g_FontTexture@@3IA
	push	1
	mov	esi, eax
	call	_glDeleteTextures@8

; 350  :     io.Fonts->TexID = 0;

	mov	eax, DWORD PTR [esi+128]
	pop	esi
	mov	DWORD PTR [eax], 0

; 351  :     g_FontTexture   = 0;

	mov	DWORD PTR ?g_FontTexture@@3IA, 0
$LN10@ImGui_Impl:

; 352  :   }
; 353  : }

	ret	0
?ImGui_ImplGL3_InvalidateDeviceObjects@@YAXXZ ENDP	; ImGui_ImplGL3_InvalidateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
_last_vertex_array$ = -20				; size = 4
_last_array_buffer$ = -16				; size = 4
_last_texture$ = -12					; size = 4
_fragment_shader$ = -8					; size = 4
_vertex_shader$ = -4					; size = 4
?ImGui_ImplGlfwGL3_CreateDeviceObjects@@YA_NXZ PROC	; ImGui_ImplGlfwGL3_CreateDeviceObjects

; 219  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 220  :   // Backup GL state
; 221  :   GLint last_texture,
; 222  :         last_array_buffer,
; 223  :         last_vertex_array;
; 224  : 
; 225  :   glGetIntegerv (GL_TEXTURE_BINDING_2D,   &last_texture     );

	lea	eax, DWORD PTR _last_texture$[ebp]
	push	eax
	push	32873					; 00008069H
	call	_glGetIntegerv@8

; 226  :   glGetIntegerv (GL_ARRAY_BUFFER_BINDING, &last_array_buffer);

	lea	eax, DWORD PTR _last_array_buffer$[ebp]
	push	eax
	push	34964					; 00008894H
	call	_glGetIntegerv@8

; 227  :   glGetIntegerv (GL_VERTEX_ARRAY_BINDING, &last_vertex_array);

	lea	eax, DWORD PTR _last_vertex_array$[ebp]
	push	eax
	push	34229					; 000085b5H
	call	_glGetIntegerv@8

; 228  : 
; 229  :   const GLchar *vertex_shader =
; 230  :       "#version 330\n"

	mov	DWORD PTR _vertex_shader$[ebp], OFFSET $SG99248

; 231  :       "uniform mat4 ProjMtx;\n"
; 232  :       "in vec2 Position;\n"
; 233  :       "in vec2 UV;\n"
; 234  :       "in vec4 Color;\n"
; 235  :       "out vec2 Frag_UV;\n"
; 236  :       "out vec4 Frag_Color;\n"
; 237  :       "void main()\n"
; 238  :       "{\n"
; 239  :       "	Frag_UV = UV;\n"
; 240  :       "	Frag_Color = Color;\n"
; 241  :       "	gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
; 242  :       "}\n";
; 243  : 
; 244  :   const GLchar* fragment_shader =
; 245  :       "#version 330\n"

	mov	DWORD PTR _fragment_shader$[ebp], OFFSET $SG99249

; 246  :       "uniform sampler2D Texture;\n"
; 247  :       "in vec2 Frag_UV;\n"
; 248  :       "in vec4 Frag_Color;\n"
; 249  :       "out vec4 Out_Color;\n"
; 250  :       "void main()\n"
; 251  :       "{\n"
; 252  :       "	Out_Color = Frag_Color * texture( Texture, Frag_UV.st);\n"
; 253  :       "}\n";
; 254  : 
; 255  :   g_ShaderHandle = glCreateProgram (                  );

	call	DWORD PTR ___glewCreateProgram

; 256  :   g_VertHandle   = glCreateShader  ( GL_VERTEX_SHADER );

	push	35633					; 00008b31H
	mov	DWORD PTR ?g_ShaderHandle@@3HA, eax
	call	DWORD PTR ___glewCreateShader

; 257  :   g_FragHandle   = glCreateShader  (GL_FRAGMENT_SHADER);

	push	35632					; 00008b30H
	mov	DWORD PTR ?g_VertHandle@@3HA, eax
	call	DWORD PTR ___glewCreateShader

; 258  : 
; 259  :   glShaderSource  (g_VertHandle, 1, &vertex_shader,   0);

	push	0
	mov	DWORD PTR ?g_FragHandle@@3HA, eax
	lea	eax, DWORD PTR _vertex_shader$[ebp]
	push	eax
	push	1
	push	DWORD PTR ?g_VertHandle@@3HA
	call	DWORD PTR ___glewShaderSource

; 260  :   glShaderSource  (g_FragHandle, 1, &fragment_shader, 0);

	push	0
	lea	eax, DWORD PTR _fragment_shader$[ebp]
	push	eax
	push	1
	push	DWORD PTR ?g_FragHandle@@3HA
	call	DWORD PTR ___glewShaderSource

; 261  :   glCompileShader (g_VertHandle);

	push	DWORD PTR ?g_VertHandle@@3HA
	call	DWORD PTR ___glewCompileShader

; 262  :   glCompileShader (g_FragHandle);

	push	DWORD PTR ?g_FragHandle@@3HA
	call	DWORD PTR ___glewCompileShader

; 263  :   glAttachShader  (g_ShaderHandle, g_VertHandle);

	push	DWORD PTR ?g_VertHandle@@3HA
	push	DWORD PTR ?g_ShaderHandle@@3HA
	call	DWORD PTR ___glewAttachShader

; 264  :   glAttachShader  (g_ShaderHandle, g_FragHandle);

	push	DWORD PTR ?g_FragHandle@@3HA
	push	DWORD PTR ?g_ShaderHandle@@3HA
	call	DWORD PTR ___glewAttachShader

; 265  :   glLinkProgram   (g_ShaderHandle);

	push	DWORD PTR ?g_ShaderHandle@@3HA
	call	DWORD PTR ___glewLinkProgram

; 266  : 
; 267  :   g_AttribLocationTex      = glGetUniformLocation (g_ShaderHandle, "Texture" );

	push	OFFSET $SG99250
	push	DWORD PTR ?g_ShaderHandle@@3HA
	call	DWORD PTR ___glewGetUniformLocation

; 268  :   g_AttribLocationProjMtx  = glGetUniformLocation (g_ShaderHandle, "ProjMtx" );

	push	OFFSET $SG99251
	push	DWORD PTR ?g_ShaderHandle@@3HA
	mov	DWORD PTR ?g_AttribLocationTex@@3HA, eax
	call	DWORD PTR ___glewGetUniformLocation

; 269  :   g_AttribLocationPosition = glGetAttribLocation  (g_ShaderHandle, "Position");

	push	OFFSET $SG99252
	push	DWORD PTR ?g_ShaderHandle@@3HA
	mov	DWORD PTR ?g_AttribLocationProjMtx@@3HA, eax
	call	DWORD PTR ___glewGetAttribLocation

; 270  :   g_AttribLocationUV       = glGetAttribLocation  (g_ShaderHandle, "UV"      );

	push	OFFSET $SG99253
	push	DWORD PTR ?g_ShaderHandle@@3HA
	mov	DWORD PTR ?g_AttribLocationPosition@@3HA, eax
	call	DWORD PTR ___glewGetAttribLocation

; 271  :   g_AttribLocationColor    = glGetAttribLocation  (g_ShaderHandle, "Color"   );

	push	OFFSET $SG99254
	push	DWORD PTR ?g_ShaderHandle@@3HA
	mov	DWORD PTR ?g_AttribLocationUV@@3HA, eax
	call	DWORD PTR ___glewGetAttribLocation

; 272  : 
; 273  :   glGenBuffers (1, &g_VboHandle);

	push	OFFSET ?g_VboHandle@@3IA
	push	1
	mov	DWORD PTR ?g_AttribLocationColor@@3HA, eax
	call	DWORD PTR ___glewGenBuffers

; 274  :   glGenBuffers (1, &g_ElementsHandle);

	push	OFFSET ?g_ElementsHandle@@3IA
	push	1
	call	DWORD PTR ___glewGenBuffers

; 275  : 
; 276  :   glGenVertexArrays (1,              &g_VaoHandle);

	push	OFFSET ?g_VaoHandle@@3IA
	push	1
	call	DWORD PTR ___glewGenVertexArrays

; 277  :   glBindVertexArray (                 g_VaoHandle);

	push	DWORD PTR ?g_VaoHandle@@3IA
	call	DWORD PTR ___glewBindVertexArray

; 278  :   glBindBuffer      (GL_ARRAY_BUFFER, g_VboHandle);

	push	DWORD PTR ?g_VboHandle@@3IA
	push	34962					; 00008892H
	call	DWORD PTR ___glewBindBuffer

; 279  : 
; 280  :   glEnableVertexAttribArray (g_AttribLocationPosition);

	push	DWORD PTR ?g_AttribLocationPosition@@3HA
	call	DWORD PTR ___glewEnableVertexAttribArray

; 281  :   glEnableVertexAttribArray (g_AttribLocationUV);

	push	DWORD PTR ?g_AttribLocationUV@@3HA
	call	DWORD PTR ___glewEnableVertexAttribArray

; 282  :   glEnableVertexAttribArray (g_AttribLocationColor);

	push	DWORD PTR ?g_AttribLocationColor@@3HA
	call	DWORD PTR ___glewEnableVertexAttribArray

; 283  : 
; 284  : #define OFFSETOF(TYPE, ELEMENT) ( reinterpret_cast <size_t> (     \
; 285  :                                     &(reinterpret_cast <TYPE *> ( \
; 286  :                                       nullptr                     \
; 287  :                                      )->ELEMENT)                  \
; 288  :                                   )                               \
; 289  :                                 )
; 290  : 
; 291  :   glVertexAttribPointer ( g_AttribLocationPosition,

	push	0
	push	20					; 00000014H
	push	0
	push	5126					; 00001406H
	push	2
	push	DWORD PTR ?g_AttribLocationPosition@@3HA
	call	DWORD PTR ___glewVertexAttribPointer

; 292  :                             2, GL_FLOAT,
; 293  :                               GL_FALSE, sizeof (ImDrawVert),
; 294  :   reinterpret_cast <GLvoid *> ( OFFSETOF       (ImDrawVert, pos) )
; 295  :                         );
; 296  :   glVertexAttribPointer ( g_AttribLocationUV,

	push	8
	push	20					; 00000014H
	push	0
	push	5126					; 00001406H
	push	2
	push	DWORD PTR ?g_AttribLocationUV@@3HA
	call	DWORD PTR ___glewVertexAttribPointer

; 297  :                             2, GL_FLOAT,
; 298  :                               GL_FALSE, sizeof (ImDrawVert),
; 299  :   reinterpret_cast <GLvoid *> ( OFFSETOF       (ImDrawVert, uv) )
; 300  :                         );
; 301  :   glVertexAttribPointer ( g_AttribLocationColor,

	push	16					; 00000010H
	push	20					; 00000014H
	push	1
	push	5121					; 00001401H
	push	4
	push	DWORD PTR ?g_AttribLocationColor@@3HA
	call	DWORD PTR ___glewVertexAttribPointer

; 302  :                             4, GL_UNSIGNED_BYTE,
; 303  :                               GL_TRUE,  sizeof (ImDrawVert),
; 304  :   reinterpret_cast <GLvoid *> ( OFFSETOF       (ImDrawVert, col) )
; 305  :                         );
; 306  : #undef OFFSETOF
; 307  : 
; 308  :   ImGui_ImplGL3_CreateFontsTexture ();

	call	?ImGui_ImplGL3_CreateFontsTexture@@YA_NXZ ; ImGui_ImplGL3_CreateFontsTexture

; 309  : 
; 310  :   // Restore modified GL state
; 311  :   glBindTexture     (GL_TEXTURE_2D,   last_texture);

	push	DWORD PTR _last_texture$[ebp]
	push	3553					; 00000de1H
	call	_glBindTexture@8

; 312  :   glBindBuffer      (GL_ARRAY_BUFFER, last_array_buffer);

	push	DWORD PTR _last_array_buffer$[ebp]
	push	34962					; 00008892H
	call	DWORD PTR ___glewBindBuffer

; 313  :   glBindVertexArray (last_vertex_array);

	push	DWORD PTR _last_vertex_array$[ebp]
	call	DWORD PTR ___glewBindVertexArray

; 314  : 
; 315  :   return true;

	mov	al, 1

; 316  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplGlfwGL3_CreateDeviceObjects@@YA_NXZ ENDP	; ImGui_ImplGlfwGL3_CreateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
_last_texture$ = -16					; size = 4
_width$ = -12						; size = 4
_height$ = -8						; size = 4
_pixels$ = -4						; size = 4
?ImGui_ImplGL3_CreateFontsTexture@@YA_NXZ PROC		; ImGui_ImplGL3_CreateFontsTexture

; 176  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 177  :   // Build texture atlas
; 178  :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	esi, eax

; 179  : 
; 180  :   extern void
; 181  :   SK_ImGui_LoadFonts (void);
; 182  : 
; 183  :   SK_ImGui_LoadFonts ();

	call	?SK_ImGui_LoadFonts@@YAXXZ		; SK_ImGui_LoadFonts

; 184  : 
; 185  :   unsigned char* pixels = nullptr;
; 186  :   int            width  = 0,
; 187  :                  height = 0;
; 188  : 
; 189  :   // Load as RGBA 32-bits (75% of the memory is wasted, but default font is so small)
; 190  :   //   because it is more likely to be compatible with user's existing shaders.
; 191  :   //
; 192  :   //  If your ImTextureId represent a higher-level concept than just a GL texture id,
; 193  :   //    consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
; 194  :   io.Fonts->GetTexDataAsRGBA32 (&pixels, &width, &height);

	push	0
	lea	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _pixels$[ebp], 0
	push	eax
	lea	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _width$[ebp], 0
	push	eax
	lea	eax, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR _height$[ebp], 0
	mov	ecx, DWORD PTR [esi+128]
	push	eax
	call	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32

; 195  :   
; 196  :   // Upload texture to graphics system
; 197  :   GLint last_texture;
; 198  : 
; 199  :   glGetIntegerv   ( GL_TEXTURE_BINDING_2D, &last_texture               );

	lea	eax, DWORD PTR _last_texture$[ebp]
	push	eax
	push	32873					; 00008069H
	call	_glGetIntegerv@8

; 200  :   glGenTextures   ( 1,                     &g_FontTexture              );

	push	OFFSET ?g_FontTexture@@3IA
	push	1
	call	_glGenTextures@8

; 201  :   glBindTexture   ( GL_TEXTURE_2D,          g_FontTexture              );

	push	DWORD PTR ?g_FontTexture@@3IA
	push	3553					; 00000de1H
	call	_glBindTexture@8

; 202  :   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR    );

	push	9729					; 00002601H
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	_glTexParameteri@12

; 203  :   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR    );

	push	9729					; 00002601H
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	_glTexParameteri@12

; 204  :   glTexImage2D    ( GL_TEXTURE_2D, 0, GL_RGBA, width, height,    0,

	push	DWORD PTR _pixels$[ebp]
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	push	DWORD PTR _height$[ebp]
	push	DWORD PTR _width$[ebp]
	push	6408					; 00001908H
	push	0
	push	3553					; 00000de1H
	call	_glTexImage2D@36

; 205  :                                      GL_RGBA, GL_UNSIGNED_BYTE, pixels );
; 206  :   
; 207  :   // Store our identifier
; 208  :   io.Fonts->TexID =

	mov	ecx, DWORD PTR [esi+128]
	mov	eax, DWORD PTR ?g_FontTexture@@3IA
	mov	DWORD PTR [ecx], eax

; 209  :     (void *)(intptr_t)g_FontTexture;
; 210  :   
; 211  :   // Restore state
; 212  :   glBindTexture (GL_TEXTURE_2D, last_texture);

	push	DWORD PTR _last_texture$[ebp]
	push	3553					; 00000de1H
	call	_glBindTexture@8

; 213  :   
; 214  :   return true;

	mov	al, 1
	pop	esi

; 215  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplGL3_CreateFontsTexture@@YA_NXZ ENDP		; ImGui_ImplGL3_CreateFontsTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
_user_data$ = 8						; size = 4
_text$ = 12						; size = 4
?ImGui_ImplGL3_SetClipboardText@@YAXPAXPBD@Z PROC	; ImGui_ImplGL3_SetClipboardText

; 168  :   UNREFERENCED_PARAMETER (user_data);
; 169  :   UNREFERENCED_PARAMETER (text);
; 170  : 
; 171  :   //glfwSetClipboardString((GLFWwindow*)user_data, text);
; 172  : }

	ret	0
?ImGui_ImplGL3_SetClipboardText@@YAXPAXPBD@Z ENDP	; ImGui_ImplGL3_SetClipboardText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
_user_data$ = 8						; size = 4
?ImGui_ImplGL3_GetClipboardText@@YAPBDPAX@Z PROC	; ImGui_ImplGL3_GetClipboardText

; 160  :   UNREFERENCED_PARAMETER (user_data);
; 161  : 
; 162  :   return nullptr;//return glfwGetClipboardString((GLFWwindow*)user_data);

	xor	eax, eax

; 163  : }

	ret	0
?ImGui_ImplGL3_GetClipboardText@@YAPBDPAX@Z ENDP	; ImGui_ImplGL3_GetClipboardText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp
_TEXT	SEGMENT
_ortho_projection$ = -84				; size = 64
_fb_height$1$ = -20					; size = 4
$T1 = -16						; size = 8
_n$1$ = -12						; size = 4
_cmd_i$1$ = -8						; size = 4
_idx_buffer_offset$1$ = -4				; size = 4
_draw_data$ = 8						; size = 4
?ImGui_ImplGL3_RenderDrawLists@@YAXPAUImDrawData@@@Z PROC ; ImGui_ImplGL3_RenderDrawLists

; 41   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 42   :   // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
; 43   :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	esi, eax

; 44   : 
; 45   :   int fb_width  = static_cast <int> (io.DisplaySize.x);// * io.DisplayFramebufferScale.x);

	cvttss2si edi, DWORD PTR [esi]

; 46   :   int fb_height = static_cast <int> (io.DisplaySize.y);// * io.DisplayFramebufferScale.y);

	cvttss2si ebx, DWORD PTR [esi+4]
	mov	DWORD PTR _fb_height$1$[ebp], ebx

; 47   : 
; 48   :   if (fb_width == 0 || fb_height == 0)

	test	edi, edi
	je	$LN9@ImGui_Impl
	test	ebx, ebx
	je	$LN9@ImGui_Impl

; 51   :   draw_data->ScaleClipRects (ImVec2 (1.0f, 1.0f));//io.DisplayFramebufferScale);

	mov	ecx, DWORD PTR _draw_data$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 1065353216		; 3f800000H
	mov	DWORD PTR $T1[ebp+4], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_gl3.cpp

; 51   :   draw_data->ScaleClipRects (ImVec2 (1.0f, 1.0f));//io.DisplayFramebufferScale);

	call	?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z ; ImDrawData::ScaleClipRects

; 52   : 
; 53   :   //
; 54   :   // nb: State bckup/restore is handled higher up the callstack
; 55   :   //
; 56   : #if 0
; 57   :   // Backup GL state
; 58   :   GLint     last_program;              glGetIntegerv (GL_CURRENT_PROGRAM,              &last_program);
; 59   :   GLint     last_texture;              glGetIntegerv (GL_TEXTURE_BINDING_2D,           &last_texture);
; 60   :   GLint     last_active_texture;       glGetIntegerv (GL_ACTIVE_TEXTURE,               &last_active_texture);
; 61   :   GLint     last_array_buffer;         glGetIntegerv (GL_ARRAY_BUFFER_BINDING,         &last_array_buffer);
; 62   :   GLint     last_element_array_buffer; glGetIntegerv (GL_ELEMENT_ARRAY_BUFFER_BINDING, &last_element_array_buffer);
; 63   :   GLint     last_vertex_array;         glGetIntegerv (GL_VERTEX_ARRAY_BINDING,         &last_vertex_array);
; 64   :   GLint     last_blend_src;            glGetIntegerv (GL_BLEND_SRC,                    &last_blend_src);
; 65   :   GLint     last_blend_dst;            glGetIntegerv (GL_BLEND_DST,                    &last_blend_dst);
; 66   :   GLint     last_blend_equation_rgb;   glGetIntegerv (GL_BLEND_EQUATION_RGB,           &last_blend_equation_rgb);
; 67   :   GLint     last_blend_equation_alpha; glGetIntegerv (GL_BLEND_EQUATION_ALPHA,         &last_blend_equation_alpha);
; 68   :   GLint     last_viewport    [4];      glGetIntegerv (GL_VIEWPORT,                      last_viewport);
; 69   :   GLint     last_scissor_box [4];      glGetIntegerv (GL_SCISSOR_BOX,                   last_scissor_box); 
; 70   :   GLboolean last_enable_blend        = glIsEnabled   (GL_BLEND);
; 71   :   GLboolean last_enable_cull_face    = glIsEnabled   (GL_CULL_FACE);
; 72   :   GLboolean last_enable_depth_test   = glIsEnabled   (GL_DEPTH_TEST);
; 73   :   GLboolean last_enable_scissor_test = glIsEnabled   (GL_SCISSOR_TEST);
; 74   : #endif
; 75   : 
; 76   :   // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
; 77   :   glEnable        (GL_BLEND);

	push	3042					; 00000be2H
	call	_glEnable@4

; 78   :   glBlendEquation (GL_FUNC_ADD);

	push	32774					; 00008006H
	call	DWORD PTR ___glewBlendEquation

; 79   :   glBlendFunc     (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	push	771					; 00000303H
	push	770					; 00000302H
	call	_glBlendFunc@8

; 80   :   glDisable       (GL_CULL_FACE);

	push	2884					; 00000b44H
	call	_glDisable@4

; 81   :   glDisable       (GL_DEPTH_TEST);

	push	2929					; 00000b71H
	call	_glDisable@4

; 82   :   glEnable        (GL_SCISSOR_TEST);

	push	3089					; 00000c11H
	call	_glEnable@4

; 83   :   glActiveTexture (GL_TEXTURE0);

	push	33984					; 000084c0H
	call	DWORD PTR ___glewActiveTexture

; 84   : 
; 85   :   // Setup viewport, orthographic projection matrix
; 86   :   glViewport ( 0, 0,

	push	ebx
	push	edi
	push	0
	push	0
	call	_glViewport@16

; 87   :                  static_cast <GLsizei> (fb_width),
; 88   :                  static_cast <GLsizei> (fb_height) );
; 89   : 
; 90   :   const float ortho_projection [4][4] =
; 91   :   {
; 92   :       { 2.0f/io.DisplaySize.x, 0.0f,                   0.0f, 0.0f },

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [esi]

; 93   :       { 0.0f,                  2.0f/-io.DisplaySize.y, 0.0f, 0.0f },
; 94   :       { 0.0f,                  0.0f,                  -1.0f, 0.0f },
; 95   :       {-1.0f,                  1.0f,                   0.0f, 1.0f },
; 96   :   };
; 97   : 
; 98   :   glUseProgram       (g_ShaderHandle);

	push	DWORD PTR ?g_ShaderHandle@@3HA
	addss	xmm0, xmm0
	movss	DWORD PTR _ortho_projection$[ebp], xmm0
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _ortho_projection$[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@c0000000
	divss	xmm0, DWORD PTR [esi+4]
	mov	DWORD PTR _ortho_projection$[ebp+56], 0
	mov	DWORD PTR _ortho_projection$[ebp+60], 1065353216 ; 3f800000H
	movss	DWORD PTR _ortho_projection$[ebp+20], xmm0
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _ortho_projection$[ebp+24], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f800000bf80000000000000bf800000
	movups	XMMWORD PTR _ortho_projection$[ebp+40], xmm0
	call	DWORD PTR ___glewUseProgram

; 99   :   glUniform1i        (g_AttribLocationTex,     0);

	push	0
	push	DWORD PTR ?g_AttribLocationTex@@3HA
	call	DWORD PTR ___glewUniform1i

; 100  :   glUniformMatrix4fv (g_AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);

	lea	eax, DWORD PTR _ortho_projection$[ebp]
	push	eax
	push	0
	push	1
	push	DWORD PTR ?g_AttribLocationProjMtx@@3HA
	call	DWORD PTR ___glewUniformMatrix4fv

; 101  :   glBindVertexArray  (g_VaoHandle);

	push	DWORD PTR ?g_VaoHandle@@3IA
	call	DWORD PTR ___glewBindVertexArray

; 102  : 
; 103  :   for (int n = 0; n < draw_data->CmdListsCount; n++)

	mov	eax, DWORD PTR _draw_data$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	DWORD PTR [eax+8], ecx
	jle	$LN9@ImGui_Impl
	npad	7
$LL4@ImGui_Impl:

; 104  :   {
; 105  :     const ImDrawList* cmd_list          = draw_data->CmdLists [n];

	mov	eax, DWORD PTR [eax+4]

; 106  :     const ImDrawIdx*  idx_buffer_offset = 0;
; 107  : 
; 108  :     glBindBuffer (GL_ARRAY_BUFFER,         g_VboHandle);

	push	DWORD PTR ?g_VboHandle@@3IA
	mov	DWORD PTR _idx_buffer_offset$1$[ebp], 0
	push	34962					; 00008892H
	mov	edi, DWORD PTR [eax+ecx*4]
	call	DWORD PTR ___glewBindBuffer

; 109  :     glBufferData (GL_ARRAY_BUFFER,         (GLsizeiptr)cmd_list->VtxBuffer.Size * sizeof (ImDrawVert),

	mov	eax, DWORD PTR [edi+24]
	push	35040					; 000088e0H
	push	DWORD PTR [edi+32]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR ___glewBufferData

; 110  :                                        (const GLvoid *)cmd_list->VtxBuffer.Data, GL_STREAM_DRAW);
; 111  : 
; 112  :     glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);

	push	DWORD PTR ?g_ElementsHandle@@3IA
	push	34963					; 00008893H
	call	DWORD PTR ___glewBindBuffer

; 113  :     glBufferData (GL_ELEMENT_ARRAY_BUFFER, (GLsizeiptr)cmd_list->IdxBuffer.Size * sizeof (ImDrawIdx),

	mov	eax, DWORD PTR [edi+12]
	push	35040					; 000088e0H
	push	DWORD PTR [edi+20]
	add	eax, eax
	push	eax
	push	34963					; 00008893H
	call	DWORD PTR ___glewBufferData

; 114  :                                        (const GLvoid *)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW);
; 115  : 
; 116  :     for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	cmp	DWORD PTR [edi], 0
	mov	DWORD PTR _cmd_i$1$[ebp], 0
	jle	$LN2@ImGui_Impl

; 104  :   {
; 105  :     const ImDrawList* cmd_list          = draw_data->CmdLists [n];

	xor	ebx, ebx
$LL7@ImGui_Impl:

; 114  :                                        (const GLvoid *)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW);
; 115  : 
; 116  :     for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	mov	esi, DWORD PTR [edi+8]
	add	esi, ebx

; 117  :     {
; 118  :       const ImDrawCmd* pcmd = &cmd_list->CmdBuffer [cmd_i];
; 119  :       if (pcmd->UserCallback)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@ImGui_Impl

; 120  :       {
; 121  :         pcmd->UserCallback (cmd_list, pcmd);

	push	esi
	push	edi
	call	eax
	add	esp, 8

; 122  :       }
; 123  :       else

	jmp	SHORT $LN11@ImGui_Impl
$LN10@ImGui_Impl:

; 124  :       {
; 125  :         glBindTexture  (GL_TEXTURE_2D, (GLuint)(intptr_t)pcmd->TextureId);

	push	DWORD PTR [esi+20]
	push	3553					; 00000de1H
	call	_glBindTexture@8

; 126  :         glScissor      ( (int) pcmd->ClipRect.x,                     (int)(fb_height        - pcmd->ClipRect.w),

	movss	xmm0, DWORD PTR [esi+16]
	subss	xmm0, DWORD PTR [esi+8]
	cvttss2si eax, xmm0
	movss	xmm0, DWORD PTR [esi+12]
	subss	xmm0, DWORD PTR [esi+4]
	push	eax
	cvttss2si eax, xmm0
	movd	xmm0, DWORD PTR _fb_height$1$[ebp]
	cvtdq2ps xmm0, xmm0
	push	eax
	subss	xmm0, DWORD PTR [esi+16]
	cvttss2si eax, xmm0
	push	eax
	cvttss2si eax, DWORD PTR [esi+4]
	push	eax
	call	_glScissor@16

; 127  :                          (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y) );
; 128  :         glDrawElements ( GL_TRIANGLES, (GLsizei)pcmd->ElemCount,

	push	DWORD PTR _idx_buffer_offset$1$[ebp]
	push	5123					; 00001403H
	push	DWORD PTR [esi]
	push	4
	call	_glDrawElements@16
$LN11@ImGui_Impl:

; 129  :                            sizeof (ImDrawIdx) == 2 ?
; 130  :                                      GL_UNSIGNED_SHORT :
; 131  :                                      GL_UNSIGNED_INT,
; 132  :                                        idx_buffer_offset );
; 133  :       }
; 134  :       idx_buffer_offset += pcmd->ElemCount;

	mov	ecx, DWORD PTR _idx_buffer_offset$1$[ebp]
	add	ebx, 32					; 00000020H
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _idx_buffer_offset$1$[ebp], ecx
	mov	ecx, DWORD PTR _cmd_i$1$[ebp]
	inc	ecx
	mov	DWORD PTR _cmd_i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi]
	jl	$LL7@ImGui_Impl
$LN2@ImGui_Impl:

; 102  : 
; 103  :   for (int n = 0; n < draw_data->CmdListsCount; n++)

	mov	ecx, DWORD PTR _n$1$[ebp]
	mov	eax, DWORD PTR _draw_data$[ebp]
	inc	ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+8]
	jl	$LL4@ImGui_Impl
$LN9@ImGui_Impl:
	pop	edi
	pop	esi
	pop	ebx

; 135  :     }
; 136  :   }
; 137  : 
; 138  : #if 0
; 139  :   // Restore modified GL state
; 140  :   glUseProgram            (last_program);
; 141  :   glActiveTexture         (last_active_texture);
; 142  :   glBindTexture           (GL_TEXTURE_2D,           last_texture);
; 143  :   glBindVertexArray       (last_vertex_array);
; 144  :   glBlendEquationSeparate (last_blend_equation_rgb, last_blend_equation_alpha);
; 145  :   glBlendFunc             (last_blend_src,          last_blend_dst);
; 146  : 
; 147  :   if (last_enable_blend)        glEnable (GL_BLEND);        else glDisable (GL_BLEND);
; 148  :   if (last_enable_cull_face)    glEnable (GL_CULL_FACE);    else glDisable (GL_CULL_FACE);
; 149  :   if (last_enable_depth_test)   glEnable (GL_DEPTH_TEST);   else glDisable (GL_DEPTH_TEST);
; 150  :   if (last_enable_scissor_test) glEnable (GL_SCISSOR_TEST); else glDisable (GL_SCISSOR_TEST);
; 151  : 
; 152  :   glViewport ( last_viewport    [0], last_viewport    [1], (GLsizei)last_viewport    [2], (GLsizei)last_viewport    [3]);
; 153  :   glScissor  ( last_scissor_box [0], last_scissor_box [1], (GLsizei)last_scissor_box [2], (GLsizei)last_scissor_box [3]);
; 154  : #endif
; 155  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplGL3_RenderDrawLists@@YAXPAUImDrawData@@@Z ENDP ; ImGui_ImplGL3_RenderDrawLists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
