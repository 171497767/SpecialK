; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\input\input.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?keybd_event_Original@@3P6GXEEKK@ZA		; keybd_event_Original
PUBLIC	?SetCursor_Original@@3P6GPAUHICON__@@PAU1@@ZA	; SetCursor_Original
PUBLIC	?game_cursor@@3PAUHICON__@@A			; game_cursor
PUBLIC	?GetKeyState_Original@@3P6GFH@ZA		; GetKeyState_Original
PUBLIC	?GetAsyncKeyState_Original@@3P6GFH@ZA		; GetAsyncKeyState_Original
PUBLIC	?GetKeyboardState_Original@@3P6GHPAE@ZA		; GetKeyboardState_Original
PUBLIC	?GetRawInputData_Original@@3P6GIPAUHRAWINPUT__@@IPAXPAII@ZA ; GetRawInputData_Original
PUBLIC	?GetRawInputBuffer_Original@@3P6GIPAUtagRAWINPUT@@PAII@ZA ; GetRawInputBuffer_Original
PUBLIC	?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
PUBLIC	?GetMouseMovePointsEx_Original@@3P6GHIPAUtagMOUSEMOVEPOINT@@0HK@ZA ; GetMouseMovePointsEx_Original
PUBLIC	?SK_HID_PreparsedDataP@@3PAPAU_HIDP_PREPARSED_DATA@@A ; SK_HID_PreparsedDataP
PUBLIC	?SK_HID_PreparsedData@@3PAU_HIDP_PREPARSED_DATA@@A ; SK_HID_PreparsedData
PUBLIC	?HidP_GetCaps_Original@@3P6GJPAU_HIDP_PREPARSED_DATA@@PAU_HIDP_CAPS@@@ZA ; HidP_GetCaps_Original
PUBLIC	?HidD_GetPreparsedData_Original@@3P6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@ZA ; HidD_GetPreparsedData_Original
PUBLIC	?HidD_FreePreparsedData_Original@@3P6GEPAU_HIDP_PREPARSED_DATA@@@ZA ; HidD_FreePreparsedData_Original
PUBLIC	?HidD_GetFeature_Original@@3P6GEPAX0K@ZA	; HidD_GetFeature_Original
PUBLIC	?HidP_GetData_Original@@3P6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@ZA ; HidP_GetData_Original
PUBLIC	?GetRegisteredRawInputDevices_Original@@3P6GIPAUtagRAWINPUTDEVICE@@PAII@ZA ; GetRegisteredRawInputDevices_Original
PUBLIC	?SK_XInput_Backend@@3Usk_input_api_context_s@@A	; SK_XInput_Backend
PUBLIC	?SK_HID_Backend@@3Usk_input_api_context_s@@A	; SK_HID_Backend
PUBLIC	?SK_RawInput_Backend@@3Usk_input_api_context_s@@A ; SK_RawInput_Backend
_BSS	SEGMENT
?keybd_event_Original@@3P6GXEEKK@ZA DD 01H DUP (?)	; keybd_event_Original
?SetCursor_Original@@3P6GPAUHICON__@@PAU1@@ZA DD 01H DUP (?) ; SetCursor_Original
?game_cursor@@3PAUHICON__@@A DD 01H DUP (?)		; game_cursor
?GetKeyState_Original@@3P6GFH@ZA DD 01H DUP (?)		; GetKeyState_Original
?GetAsyncKeyState_Original@@3P6GFH@ZA DD 01H DUP (?)	; GetAsyncKeyState_Original
?GetKeyboardState_Original@@3P6GHPAE@ZA DD 01H DUP (?)	; GetKeyboardState_Original
?GetRawInputData_Original@@3P6GIPAUHRAWINPUT__@@IPAXPAII@ZA DD 01H DUP (?) ; GetRawInputData_Original
?GetRawInputBuffer_Original@@3P6GIPAUtagRAWINPUT@@PAII@ZA DD 01H DUP (?) ; GetRawInputBuffer_Original
?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA DD 01H DUP (?) ; RegisterRawInputDevices_Original
?GetMouseMovePointsEx_Original@@3P6GHIPAUtagMOUSEMOVEPOINT@@0HK@ZA DD 01H DUP (?) ; GetMouseMovePointsEx_Original
?SK_HID_PreparsedDataP@@3PAPAU_HIDP_PREPARSED_DATA@@A DD 01H DUP (?) ; SK_HID_PreparsedDataP
?SK_HID_PreparsedData@@3PAU_HIDP_PREPARSED_DATA@@A DD 01H DUP (?) ; SK_HID_PreparsedData
?HidP_GetCaps_Original@@3P6GJPAU_HIDP_PREPARSED_DATA@@PAU_HIDP_CAPS@@@ZA DD 01H DUP (?) ; HidP_GetCaps_Original
?HidD_GetPreparsedData_Original@@3P6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@ZA DD 01H DUP (?) ; HidD_GetPreparsedData_Original
?HidD_FreePreparsedData_Original@@3P6GEPAU_HIDP_PREPARSED_DATA@@@ZA DD 01H DUP (?) ; HidD_FreePreparsedData_Original
?HidD_GetFeature_Original@@3P6GEPAX0K@ZA DD 01H DUP (?)	; HidD_GetFeature_Original
?HidP_GetData_Original@@3P6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@ZA DD 01H DUP (?) ; HidP_GetData_Original
?GetRegisteredRawInputDevices_Original@@3P6GIPAUtagRAWINPUTDEVICE@@PAII@ZA DD 01H DUP (?) ; GetRegisteredRawInputDevices_Original
?SK_XInput_Backend@@3Usk_input_api_context_s@@A DB 044H DUP (?) ; SK_XInput_Backend
?SK_HID_Backend@@3Usk_input_api_context_s@@A DB 044H DUP (?) ; SK_HID_Backend
?SK_RawInput_Backend@@3Usk_input_api_context_s@@A DB 044H DUP (?) ; SK_RawInput_Backend
_BSS	ENDS
CONST	SEGMENT
$SG162819 DB	'GetRegisteredRawInputDevices_Detour', 00H
$SG163888 DB	'GetAsyncKeyState', 00H
	ORG $+3
$SG162820 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163886 DB	'GetRawInputData', 00H
$SG163887 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163889 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163890 DB	'GetKeyState', 00H
$SG163891 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163892 DB	'GetKeyboardState', 00H
	ORG $+3
$SG163893 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163894 DB	'GetCursorPos', 00H
	ORG $+3
$SG163895 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163896 DB	'GetCursorInfo', 00H
	ORG $+2
$SG163897 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163898 DB	'GetMouseMovePointsEx', 00H
	ORG $+3
$SG163899 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163900 DB	'SetCursor', 00H
	ORG $+2
$SG163901 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163902 DB	'SetCursorPos', 00H
	ORG $+3
$SG163903 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163904 DB	'SendInput', 00H
	ORG $+2
$SG163905 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163906 DB	'mouse_event', 00H
$SG163907 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163908 DB	'keybd_event', 00H
$SG163909 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163910 DB	'RegisterRawInputDevices', 00H
$SG163911 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163912 DB	'GetRegisteredRawInputDevices', 00H
	ORG $+3
$SG163913 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG163914 DB	'GetRawInputBuffer', 00H
	ORG $+2
$SG163915 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG162904 DB	'RegisterRawInputDevices_Detour', 00H
	ORG $+1
$SG162905 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+6
$SG162907 DB	'[', 00H, ' ', 00H, 'R', 00H, 'a', 00H, 'w', 00H, 'I', 00H
	DB	'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'R', 00H, 'a', 00H, 'w', 00H, 'I', 00H, 'n'
	DB	00H, 'p', 00H, 'u', 00H, 't', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'h', 00H, 'a'
	DB	00H, 's', 00H, ' ', 00H, 'w', 00H, 'r', 00H, 'o', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c'
	DB	00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 'l'
	DB	00H, 'u', 00H, ' ', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H
	DB	's', 00H, ')', 00H, ',', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 'p'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 'z', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG162946 DB	'GetRawInputBuffer_Detour', 00H
	ORG $+3
$SG162947 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG162980 DB	'GetRawInputData_Detour', 00H
	ORG $+5
$SG162981 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163262 DB	'GetMouseMovePointsEx_Detour', 00H
$SG163263 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163277 DB	'SetCursor_Detour', 00H
	ORG $+3
$SG163278 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163311 DB	'GetCursorInfo_Detour', 00H
	ORG $+7
$SG163312 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163331 DB	'GetCursorPos_Detour', 00H
$SG163332 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163349 DB	'SetCursorPos_Detour', 00H
$SG163350 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163367 DB	'SendInput_Detour', 00H
	ORG $+3
$SG163368 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163380 DB	'keybd_event_Detour', 00H
	ORG $+1
$SG163381 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163394 DB	'mouse_event_Detour', 00H
	ORG $+1
$SG163395 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163404 DB	'GetAsyncKeyState_Detour', 00H
	ORG $+4
$SG163405 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163420 DB	'GetKeyState_Detour', 00H
	ORG $+1
$SG163421 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG163437 DB	'GetKeyboardState_Detour', 00H
	ORG $+4
$SG163438 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG161455 DB	'HidD_GetPreparsedData_Detour', 00H
	ORG $+7
$SG161456 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG161490 DB	'HidP_GetData_Detour', 00H
$SG161491 DB	'[', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'M', 00H, 'g', 00H, 'r', 00H, '.', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+6
$SG161525 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H, 'n', 00H
	DB	'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'H', 00H, 'I', 00H, 'D'
	DB	00H, ',', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H
	DB	'h', 00H, 'o', 00H, 'o', 00H, 'k', 00H, 's', 00H, '.', 00H, '.'
	DB	00H, '.', 00H, 00H, 00H
$SG161526 DB	'HidP_GetData', 00H
	ORG $+3
$SG161527 DB	'H', 00H, 'I', 00H, 'D', 00H, '.', 00H, 'D', 00H, 'L', 00H
	DB	'L', 00H, 00H, 00H
$SG161528 DB	'HidD_GetPreparsedData', 00H
	ORG $+2
$SG161529 DB	'H', 00H, 'I', 00H, 'D', 00H, '.', 00H, 'D', 00H, 'L', 00H
	DB	'L', 00H, 00H, 00H
$SG161530 DB	'HidD_FreePreparsedData', 00H
	ORG $+1
$SG161531 DB	'H', 00H, 'I', 00H, 'D', 00H, '.', 00H, 'D', 00H, 'L', 00H
	DB	'L', 00H, 00H, 00H
$SG161532 DB	'HidD_GetFeature', 00H
$SG161533 DB	'H', 00H, 'I', 00H, 'D', 00H, '.', 00H, 'D', 00H, 'L', 00H
	DB	'L', 00H, 00H, 00H
$SG161534 DB	'HidP_GetCaps', 00H
	ORG $+3
$SG161535 DB	'H', 00H, 'I', 00H, 'D', 00H, '.', 00H, 'D', 00H, 'L', 00H
	DB	'L', 00H, 00H, 00H
$SG161542 DB	'hid.dll', 00H
CONST	ENDS
PUBLIC	?SK_ImGui_WantGamepadCapture@@YA_NXZ		; SK_ImGui_WantGamepadCapture
PUBLIC	?SK_ImGui_WantMouseCapture@@YA_NXZ		; SK_ImGui_WantMouseCapture
PUBLIC	?SK_ImGui_WantMouseCaptureEx@@YA_NK@Z		; SK_ImGui_WantMouseCaptureEx
PUBLIC	?SK_ImGui_WantKeyboardCapture@@YA_NXZ		; SK_ImGui_WantKeyboardCapture
PUBLIC	?SK_ImGui_WantTextCapture@@YA_NXZ		; SK_ImGui_WantTextCapture
PUBLIC	?SK_Input_HookHID@@YAXXZ			; SK_Input_HookHID
PUBLIC	?SK_Input_Init@@YAXXZ				; SK_Input_Init
PUBLIC	?showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z	; sk_imgui_cursor_s::showSystemCursor
PUBLIC	?update@sk_imgui_cursor_s@@QAEXXZ		; sk_imgui_cursor_s::update
PUBLIC	?LocalToScreen@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::LocalToScreen
PUBLIC	?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::LocalToClient
PUBLIC	?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::ClientToLocal
PUBLIC	?ScreenToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::ScreenToLocal
PUBLIC	?activateWindow@sk_imgui_cursor_s@@QAEX_N@Z	; sk_imgui_cursor_s::activateWindow
PUBLIC	??0<unnamed-type-no_warp>@<unnamed-type-prefs>@sk_imgui_cursor_s@@QAE@XZ ; sk_imgui_cursor_s::<unnamed-type-prefs>::<unnamed-type-no_warp>::<unnamed-type-no_warp>
PUBLIC	??0<unnamed-type-prefs>@sk_imgui_cursor_s@@QAE@XZ ; sk_imgui_cursor_s::<unnamed-type-prefs>::<unnamed-type-prefs>
PUBLIC	??0sk_imgui_cursor_s@@QAE@XZ			; sk_imgui_cursor_s::sk_imgui_cursor_s
PUBLIC	?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z ; sk_input_api_context_s::markRead
PUBLIC	?SK_ImGui_HandlesMessage@@YA_NPAUtagMSG@@_N1@Z	; SK_ImGui_HandlesMessage
PUBLIC	?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z	; SK_RawInput_EnableLegacyMouse
PUBLIC	?SK_RawInput_RestoreLegacyMouse@@YAXXZ		; SK_RawInput_RestoreLegacyMouse
PUBLIC	?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z	; SK_RawInput_EnableLegacyKeyboard
PUBLIC	?SK_RawInput_RestoreLegacyKeyboard@@YAXXZ	; SK_RawInput_RestoreLegacyKeyboard
PUBLIC	?max@?$numeric_limits@I@std@@SAIXZ		; std::numeric_limits<unsigned int>::max
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z	; std::_Container_base0::_Swap_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?isVisible@SK_Console@@QAE_NXZ			; SK_Console::isVisible
PUBLIC	?SK_InputUtil_IsHWCursorVisible@@YA_NXZ		; SK_InputUtil_IsHWCursorVisible
PUBLIC	?SK_HID_FilterPreparsedData@@YA_NPAU_HIDP_PREPARSED_DATA@@@Z ; SK_HID_FilterPreparsedData
PUBLIC	?HidD_GetPreparsedData_Detour@@YGEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z ; HidD_GetPreparsedData_Detour
PUBLIC	?HidD_FreePreparsedData_Detour@@YGEPAU_HIDP_PREPARSED_DATA@@@Z ; HidD_FreePreparsedData_Detour
PUBLIC	?HidD_GetFeature_Detour@@YGEPAX0K@Z		; HidD_GetFeature_Detour
PUBLIC	?HidP_GetData_Detour@@YGJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z ; HidP_GetData_Detour
PUBLIC	??$static_cast_p2p@X$$A6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@@YAPAPAXPAP6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@Z ; static_cast_p2p<void,long __stdcall(enum _HIDP_REPORT_TYPE,_HIDP_DATA *,unsigned long *,_HIDP_PREPARSED_DATA *,char *,unsigned long)>
PUBLIC	??$static_cast_p2p@X$$A6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@@YAPAPAXPAP6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@Z ; static_cast_p2p<void,unsigned char __stdcall(void *,_HIDP_PREPARSED_DATA * *)>
PUBLIC	??$static_cast_p2p@X$$A6GEPAU_HIDP_PREPARSED_DATA@@@Z@@YAPAPAXPAP6GEPAU_HIDP_PREPARSED_DATA@@@Z@Z ; static_cast_p2p<void,unsigned char __stdcall(_HIDP_PREPARSED_DATA *)>
PUBLIC	??$static_cast_p2p@X$$A6GEPAX0K@Z@@YAPAPAXPAP6GEPAX0K@Z@Z ; static_cast_p2p<void,unsigned char __stdcall(void *,void *,unsigned long)>
PUBLIC	?SK_Input_PreHookHID@@YAXXZ			; SK_Input_PreHookHID
PUBLIC	??0?$allocator@UtagRAWINPUTDEVICE@@@std@@QAE@XZ	; std::allocator<tagRAWINPUTDEVICE>::allocator<tagRAWINPUTDEVICE>
PUBLIC	??0?$allocator@UtagRAWINPUTDEVICE@@@std@@QAE@ABV01@@Z ; std::allocator<tagRAWINPUTDEVICE>::allocator<tagRAWINPUTDEVICE>
PUBLIC	?deallocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@I@Z ; std::allocator<tagRAWINPUTDEVICE>::deallocate
PUBLIC	?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ; std::allocator<tagRAWINPUTDEVICE>::allocate
PUBLIC	?max_size@?$allocator@UtagRAWINPUTDEVICE@@@std@@QBEIXZ ; std::allocator<tagRAWINPUTDEVICE>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAIABV?$allocator@UtagRAWINPUTDEVICE@@@2@@Z ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SA?AV?$allocator@UtagRAWINPUTDEVICE@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@I@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Orphan_all
PUBLIC	?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXAAV12@@Z ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Swap_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_second
PUBLIC	??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@ABV01@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	?_Move_from@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Move_from
PUBLIC	??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	?push_back@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::push_back
PUBLIC	?clear@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::clear
PUBLIC	?data@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEPAUtagRAWINPUTDEVICE@@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::data
PUBLIC	?begin@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@2@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::begin
PUBLIC	?end@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@2@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::end
PUBLIC	?empty@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBE_NXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::empty
PUBLIC	?size@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::size
PUBLIC	?max_size@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::max_size
PUBLIC	?capacity@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::capacity
PUBLIC	?_Has_unused_capacity@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABE_NXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Has_unused_capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@00U?$integral_constant@_N$00@2@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@00@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@0@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABEII@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Calculate_growth
PUBLIC	?_Buy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAE_NI@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Buy
PUBLIC	?_Change_array@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXQAUtagRAWINPUTDEVICE@@II@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Change_array
PUBLIC	?_Tidy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Tidy
PUBLIC	?_Xlength@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@CAXXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABEXPAUtagRAWINPUTDEVICE@@0@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Orphan_range
PUBLIC	??0<unnamed-type-mouse>@<unnamed-type-raw_overrides>@@QAE@XZ ; <unnamed-type-raw_overrides>::<unnamed-type-mouse>::<unnamed-type-mouse>
PUBLIC	??0<unnamed-type-raw_overrides>@@QAE@XZ		; <unnamed-type-raw_overrides>::<unnamed-type-raw_overrides>
PUBLIC	?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z ; SK_RawInput_GetMice
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@PAUtagRAWINPUTDEVICE@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABUtagRAWINPUTDEVICE@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@PAUtagRAWINPUTDEVICE@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEAAUtagRAWINPUTDEVICE@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator++
PUBLIC	??$emplace_back@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXAAUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE &>
PUBLIC	?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z ; SK_RawInput_GetKeyboards
PUBLIC	?SK_RawInput_GetRegisteredGamepads@@YAAAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@XZ ; SK_RawInput_GetRegisteredGamepads
PUBLIC	?SK_RawInput_ClassifyDevices@@YAXXZ		; SK_RawInput_ClassifyDevices
PUBLIC	?SK_RawInput_PopulateDeviceList@@YAIXZ		; SK_RawInput_PopulateDeviceList
PUBLIC	?GetRegisteredRawInputDevices_Detour@@YGIPAUtagRAWINPUTDEVICE@@PAII@Z ; GetRegisteredRawInputDevices_Detour
PUBLIC	?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z ; RegisterRawInputDevices_Detour
PUBLIC	?GetRawInputBuffer_Detour@@YGIPAUtagRAWINPUT@@PAII@Z ; GetRawInputBuffer_Detour
PUBLIC	?GetRawInputData_Detour@@YGIPAUHRAWINPUT__@@IPAXPAII@Z ; GetRawInputData_Detour
PUBLIC	?GetGameCursor@@YAPAUHICON__@@XZ		; GetGameCursor
PUBLIC	?SK_ImGui_IsMouseRelevant@@YA_NXZ		; SK_ImGui_IsMouseRelevant
PUBLIC	??$max@M@std@@YAABMABM0@Z			; std::max<float>
PUBLIC	?ImGui_DesiredCursor@@YAPAUHICON__@@XZ		; ImGui_DesiredCursor
PUBLIC	?ImGuiCursor_Impl@@YAXXZ			; ImGuiCursor_Impl
PUBLIC	?ImGui_ToggleCursor@@YAXXZ			; ImGui_ToggleCursor
PUBLIC	?GetMouseMovePointsEx_Detour@@YGHIPAUtagMOUSEMOVEPOINT@@0HK@Z ; GetMouseMovePointsEx_Detour
PUBLIC	?SetCursor_Detour@@YGPAUHICON__@@PAU1@@Z	; SetCursor_Detour
PUBLIC	?GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z	; GetCursorInfo_Detour
PUBLIC	?GetCursorPos_Detour@@YGHPAUtagPOINT@@@Z	; GetCursorPos_Detour
PUBLIC	?SetCursorPos_Detour@@YGHHH@Z			; SetCursorPos_Detour
PUBLIC	?SendInput_Detour@@YGIIPAUtagINPUT@@H@Z		; SendInput_Detour
PUBLIC	?keybd_event_Detour@@YGXEEKK@Z			; keybd_event_Detour
PUBLIC	?mouse_event_Detour@@YGXKKKKK@Z			; mouse_event_Detour
PUBLIC	?GetAsyncKeyState_Detour@@YGFH@Z		; GetAsyncKeyState_Detour
PUBLIC	?GetKeyState_Detour@@YGFH@Z			; GetKeyState_Detour
PUBLIC	?GetKeyboardState_Detour@@YGHPAE@Z		; GetKeyboardState_Detour
PUBLIC	?SK_Input_PreInit@@YAXXZ			; SK_Input_PreInit
PUBLIC	??$static_cast_p2p@X$$A6GIPAUHRAWINPUT__@@IPAXPAII@Z@@YAPAPAXPAP6GIPAUHRAWINPUT__@@IPAXPAII@Z@Z ; static_cast_p2p<void,unsigned int __stdcall(HRAWINPUT__ *,unsigned int,void *,unsigned int *,unsigned int)>
PUBLIC	??$static_cast_p2p@X$$A6GFH@Z@@YAPAPAXPAP6GFH@Z@Z ; static_cast_p2p<void,short __stdcall(int)>
PUBLIC	??$static_cast_p2p@X$$A6GHPAE@Z@@YAPAPAXPAP6GHPAE@Z@Z ; static_cast_p2p<void,int __stdcall(unsigned char *)>
PUBLIC	??$static_cast_p2p@X$$A6GHPAUtagPOINT@@@Z@@YAPAPAXPAP6GHPAUtagPOINT@@@Z@Z ; static_cast_p2p<void,int __stdcall(tagPOINT *)>
PUBLIC	??$static_cast_p2p@X$$A6GHPAUtagCURSORINFO@@@Z@@YAPAPAXPAP6GHPAUtagCURSORINFO@@@Z@Z ; static_cast_p2p<void,int __stdcall(tagCURSORINFO *)>
PUBLIC	??$static_cast_p2p@X$$A6GHIPAUtagMOUSEMOVEPOINT@@0HK@Z@@YAPAPAXPAP6GHIPAUtagMOUSEMOVEPOINT@@0HK@Z@Z ; static_cast_p2p<void,int __stdcall(unsigned int,tagMOUSEMOVEPOINT *,tagMOUSEMOVEPOINT *,int,unsigned long)>
PUBLIC	??$static_cast_p2p@X$$A6GPAUHICON__@@PAU1@@Z@@YAPAPAXPAP6GPAUHICON__@@PAU0@@Z@Z ; static_cast_p2p<void,HICON__ * __stdcall(HICON__ *)>
PUBLIC	??$static_cast_p2p@X$$A6GHHH@Z@@YAPAPAXPAP6GHHH@Z@Z ; static_cast_p2p<void,int __stdcall(int,int)>
PUBLIC	??$static_cast_p2p@X$$A6GIIPAUtagINPUT@@H@Z@@YAPAPAXPAP6GIIPAUtagINPUT@@H@Z@Z ; static_cast_p2p<void,unsigned int __stdcall(unsigned int,tagINPUT *,int)>
PUBLIC	??$static_cast_p2p@X$$A6GXKKKKK@Z@@YAPAPAXPAP6GXKKKKK@Z@Z ; static_cast_p2p<void,void __stdcall(unsigned long,unsigned long,unsigned long,unsigned long,unsigned long)>
PUBLIC	??$static_cast_p2p@X$$A6GXEEKK@Z@@YAPAPAXPAP6GXEEKK@Z@Z ; static_cast_p2p<void,void __stdcall(unsigned char,unsigned char,unsigned long,unsigned long)>
PUBLIC	??$static_cast_p2p@X$$A6GHPBUtagRAWINPUTDEVICE@@II@Z@@YAPAPAXPAP6GHPBUtagRAWINPUTDEVICE@@II@Z@Z ; static_cast_p2p<void,int __stdcall(tagRAWINPUTDEVICE const *,unsigned int,unsigned int)>
PUBLIC	??$static_cast_p2p@X$$A6GIPAUtagRAWINPUTDEVICE@@PAII@Z@@YAPAPAXPAP6GIPAUtagRAWINPUTDEVICE@@PAII@Z@Z ; static_cast_p2p<void,unsigned int __stdcall(tagRAWINPUTDEVICE *,unsigned int *,unsigned int)>
PUBLIC	??$static_cast_p2p@X$$A6GIPAUtagRAWINPUT@@PAII@Z@@YAPAPAXPAP6GIPAUtagRAWINPUT@@PAII@Z@Z ; static_cast_p2p<void,unsigned int __stdcall(tagRAWINPUT *,unsigned int *,unsigned int)>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >
PUBLIC	??$_Unfancy_maybe_null@UtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z ; std::_Unfancy_maybe_null<tagRAWINPUTDEVICE>
PUBLIC	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > ><std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,void>
PUBLIC	??$move@AAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAV10@@Z ; std::move<std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > &>
PUBLIC	??$_Ucopy@PAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEPAUtagRAWINPUTDEVICE@@PAU2@00@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Ucopy<tagRAWINPUTDEVICE *>
PUBLIC	??$?0V?$allocator@UtagRAWINPUTDEVICE@@@std@@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAV?$allocator@UtagRAWINPUTDEVICE@@@1@@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> ><std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@UtagRAWINPUTDEVICE@@@std@@PAUtagRAWINPUTDEVICE@@@std@@YAXPAUtagRAWINPUTDEVICE@@0AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<tagRAWINPUTDEVICE>,tagRAWINPUTDEVICE *>
PUBLIC	??$forward@AAUtagRAWINPUTDEVICE@@@std@@YAAAUtagRAWINPUTDEVICE@@AAU1@@Z ; std::forward<tagRAWINPUTDEVICE &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXAAUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Emplace_back_with_unused_capacity<tagRAWINPUTDEVICE &>
PUBLIC	??$_Unfancy@UtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z ; std::_Unfancy<tagRAWINPUTDEVICE>
PUBLIC	??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>
PUBLIC	??$destroy@UtagRAWINPUTDEVICE@@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::destroy<tagRAWINPUTDEVICE>
PUBLIC	??$forward@ABUtagRAWINPUTDEVICE@@@std@@YAABUtagRAWINPUTDEVICE@@ABU1@@Z ; std::forward<tagRAWINPUTDEVICE const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Emplace_back_with_unused_capacity<tagRAWINPUTDEVICE const &>
PUBLIC	??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1><std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > >
PUBLIC	??$_Uninitialized_copy@PAUtagRAWINPUTDEVICE@@PAU1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z ; std::_Uninitialized_copy<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *,std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??$forward@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YA$$QAV?$allocator@UtagRAWINPUTDEVICE@@@0@AAV10@@Z ; std::forward<std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??$_Destroy_range1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@PAUtagRAWINPUTDEVICE@@@std@@YAXPAUtagRAWINPUTDEVICE@@0AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<tagRAWINPUTDEVICE>,tagRAWINPUTDEVICE *>
PUBLIC	??$_Uninitialized_move@PAUtagRAWINPUTDEVICE@@PAU1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z ; std::_Uninitialized_move<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *,std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@AAU3@@Z ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>
PUBLIC	??$destroy@UtagRAWINPUTDEVICE@@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@@Z ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::destroy<tagRAWINPUTDEVICE>
PUBLIC	??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@ABU3@@Z ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>
PUBLIC	??$_Unchecked@PAUtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z ; std::_Unchecked<tagRAWINPUTDEVICE *>
PUBLIC	??$_Ptr_copy_cat@UtagRAWINPUTDEVICE@@U1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAUtagRAWINPUTDEVICE@@0@Z ; std::_Ptr_copy_cat<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE>
PUBLIC	??$_Uninitialized_copy_al_unchecked@UtagRAWINPUTDEVICE@@U1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??$_Rechecked@PAUtagRAWINPUTDEVICE@@PAU1@@std@@YAAAPAUtagRAWINPUTDEVICE@@AAPAU1@PAU1@@Z ; std::_Rechecked<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *>
PUBLIC	??$_Ptr_move_cat@UtagRAWINPUTDEVICE@@U1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAUtagRAWINPUTDEVICE@@0@Z ; std::_Ptr_move_cat<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE>
PUBLIC	??$_Uninitialized_move_al_unchecked@UtagRAWINPUTDEVICE@@U1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
PUBLIC	??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@AAU2@@Z ; std::allocator<tagRAWINPUTDEVICE>::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>
PUBLIC	??$destroy@UtagRAWINPUTDEVICE@@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@@Z ; std::allocator<tagRAWINPUTDEVICE>::destroy<tagRAWINPUTDEVICE>
PUBLIC	??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@ABU2@@Z ; std::allocator<tagRAWINPUTDEVICE>::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>
PUBLIC	??$_Copy_memmove@PAUtagRAWINPUTDEVICE@@PAU1@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00@Z ; std::_Copy_memmove<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *>
PUBLIC	?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A	; SK_ImGui_Cursor
PUBLIC	?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_devices
PUBLIC	?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_mice
PUBLIC	?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_keyboards
PUBLIC	?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_gamepads
PUBLIC	?raw_overrides@@3U<unnamed-type-raw_overrides>@@A ; raw_overrides
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetCursor@0:PROC
EXTRN	__imp__ClientToScreen@8:PROC
EXTRN	__imp__ScreenToClient@8:PROC
EXTRN	__imp__LoadCursorW@8:PROC
EXTRN	?SK_Input_PreHookXInput@@YAXXZ:PROC		; SK_Input_PreHookXInput
EXTRN	?SK_ImGui_CenterCursorOnWindow@@YAXXZ:PROC	; SK_ImGui_CenterCursorOnWindow
EXTRN	?SK_Input_PreHookDI8@@YAXXZ:PROC		; SK_Input_PreHookDI8
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	?getInstance@SK_Console@@SAPAV1@XZ:PROC		; SK_Console::getInstance
EXTRN	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ:PROC		; SK_GetDLL
EXTRN	?SK_TestImports@@YGXPAUHINSTANCE__@@PAUsk_import_test_s@@H@Z:PROC ; SK_TestImports
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ:PROC ; SK_GetCurrentRenderBackend
EXTRN	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z:PROC ; SK_CreateDLLHook2
EXTRN	?SK_ApplyQueuedHooks@@YG?AW4MH_STATUS@@XZ:PROC	; SK_ApplyQueuedHooks
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?IsAnyWindowHovered@ImGui@@YA_NXZ:PROC		; ImGui::IsAnyWindowHovered
EXTRN	?GetMouseCursor@ImGui@@YAHXZ:PROC		; ImGui::GetMouseCursor
EXTRN	?SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z:PROC ; SK_ImGui_ProcessRawInput
EXTRN	?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z:PROC	; ImGui_WndProcHandler
EXTRN	?SK_XInput_InitHotPlugHooks@@YAXXZ:PROC		; SK_XInput_InitHotPlugHooks
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?GetCursorPos_Original@@3P6GHPAUtagPOINT@@@ZA:DWORD ; GetCursorPos_Original
EXTRN	?SetCursorPos_Original@@3P6GHHH@ZA:DWORD	; SetCursorPos_Original
EXTRN	?GetCursorInfo_Original@@3P6GHPAUtagCURSORINFO@@@ZA:DWORD ; GetCursorInfo_Original
EXTRN	?SendInput_Original@@3P6GIIPAUtagINPUT@@H@ZA:DWORD ; SendInput_Original
EXTRN	?mouse_event_Original@@3P6GXKKKKK@ZA:DWORD	; mouse_event_Original
EXTRN	?game_window@@3Usk_window_s@@A:BYTE		; game_window
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?SK_ImGui_Visible@@3_NA:BYTE			; SK_ImGui_Visible
EXTRN	?SK_ReShade_Visible@@3_NA:BYTE			; SK_ReShade_Visible
EXTRN	?nav_usable@@3_NA:BYTE				; nav_usable
EXTRN	?SK_ImGui_GamepadComboDialogActive@@3_NA:BYTE	; SK_ImGui_GamepadComboDialogActive
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?called@?2??HidD_GetPreparsedData_Detour@@YGEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@4_NA
_BSS	SEGMENT
?called@?2??HidD_GetPreparsedData_Detour@@YGEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@4_NA DB 01H DUP (?) ; `HidD_GetPreparsedData_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??HidP_GetData_Detour@@YGJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@4_NA
_BSS	SEGMENT
?called@?2??HidP_GetData_Detour@@YGJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@4_NA DB 01H DUP (?) ; `HidP_GetData_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?hooked@?1??SK_Input_HookHID@@YAXXZ@4JC
_BSS	SEGMENT
?hooked@?1??SK_Input_HookHID@@YAXXZ@4JC DD 01H DUP (?)	; `SK_Input_HookHID'::`2'::hooked
_BSS	ENDS
_BSS	SEGMENT
?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A DB 0cH DUP (?) ; raw_devices
?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A DB 0cH DUP (?) ; raw_mice
?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A DB 0cH DUP (?) ; raw_keyboards
?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A DB 0cH DUP (?) ; raw_gamepads
?raw_overrides@@3U<unnamed-type-raw_overrides>@@A DD 01H DUP (?) ; raw_overrides
_BSS	ENDS
;	COMDAT ?called@?2??GetRegisteredRawInputDevices_Detour@@YGIPAUtagRAWINPUTDEVICE@@PAII@Z@4_NA
_BSS	SEGMENT
?called@?2??GetRegisteredRawInputDevices_Detour@@YGIPAUtagRAWINPUTDEVICE@@PAII@Z@4_NA DB 01H DUP (?) ; `GetRegisteredRawInputDevices_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z@4_NA
_BSS	SEGMENT
?called@?2??RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z@4_NA DB 01H DUP (?) ; `RegisterRawInputDevices_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??GetRawInputBuffer_Detour@@YGIPAUtagRAWINPUT@@PAII@Z@4_NA
_BSS	SEGMENT
?called@?2??GetRawInputBuffer_Detour@@YGIPAUtagRAWINPUT@@PAII@Z@4_NA DB 01H DUP (?) ; `GetRawInputBuffer_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??GetRawInputData_Detour@@YGIPAUHRAWINPUT__@@IPAXPAII@Z@4_NA
_BSS	SEGMENT
?called@?2??GetRawInputData_Detour@@YGIPAUHRAWINPUT__@@IPAXPAII@Z@4_NA DB 01H DUP (?) ; `GetRawInputData_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?last_cursor@?1??ImGui_DesiredCursor@@YAPAUHICON__@@XZ@4PAU2@A
_BSS	SEGMENT
?last_cursor@?1??ImGui_DesiredCursor@@YAPAUHICON__@@XZ@4PAU2@A DD 01H DUP (?) ; `ImGui_DesiredCursor'::`2'::last_cursor
_BSS	ENDS
;	COMDAT ?wait_cursor@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4PAUHICON__@@A
_BSS	SEGMENT
?wait_cursor@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4PAUHICON__@@A DD 01H DUP (?) ; `sk_imgui_cursor_s::showSystemCursor'::`2'::wait_cursor
_BSS	ENDS
;	COMDAT ?$TSS0@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',sk_imgui_cursor_s::howSystemCursor,unsigned char * const,void,bool>
_BSS	ENDS
;	COMDAT ?sk_imgui_arrow@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
_BSS	SEGMENT
?sk_imgui_arrow@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A DD 01H DUP (?) ; `GetGameCursor'::`2'::sk_imgui_arrow
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',tGameCursor,APAUHICON__,void,int, ?? &>
_BSS	ENDS
;	COMDAT ?sk_imgui_horz@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
_BSS	SEGMENT
?sk_imgui_horz@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A DD 01H DUP (?) ; `GetGameCursor'::`2'::sk_imgui_horz
_BSS	ENDS
;	COMDAT ?$TSS1@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
_BSS	SEGMENT
?$TSS1@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA DD 01H DUP (?) ; TSS1<`template-parameter-2',tGameCursor,APAUHICON__,void,int, ?? &>
_BSS	ENDS
;	COMDAT ?sk_imgui_ibeam@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
_BSS	SEGMENT
?sk_imgui_ibeam@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A DD 01H DUP (?) ; `GetGameCursor'::`2'::sk_imgui_ibeam
_BSS	ENDS
;	COMDAT ?sys_arrow@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
_BSS	SEGMENT
?sys_arrow@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A DD 01H DUP (?) ; `GetGameCursor'::`2'::sys_arrow
_BSS	ENDS
;	COMDAT ?sys_wait@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
_BSS	SEGMENT
?sys_wait@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A DD 01H DUP (?) ; `GetGameCursor'::`2'::sys_wait
_BSS	ENDS
;	COMDAT ?hCurLast@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
_BSS	SEGMENT
?hCurLast@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A DD 01H DUP (?) ; `GetGameCursor'::`2'::hCurLast
_BSS	ENDS
;	COMDAT ?called@?2??GetMouseMovePointsEx_Detour@@YGHIPAUtagMOUSEMOVEPOINT@@0HK@Z@4_NA
_BSS	SEGMENT
?called@?2??GetMouseMovePointsEx_Detour@@YGHIPAUtagMOUSEMOVEPOINT@@0HK@Z@4_NA DB 01H DUP (?) ; `GetMouseMovePointsEx_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??SetCursor_Detour@@YGPAUHICON__@@PAU2@@Z@4_NA
_BSS	SEGMENT
?called@?2??SetCursor_Detour@@YGPAUHICON__@@PAU2@@Z@4_NA DB 01H DUP (?) ; `SetCursor_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z@4_NA
_BSS	SEGMENT
?called@?2??GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z@4_NA DB 01H DUP (?) ; `GetCursorInfo_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??GetCursorPos_Detour@@YGHPAUtagPOINT@@@Z@4_NA
_BSS	SEGMENT
?called@?2??GetCursorPos_Detour@@YGHPAUtagPOINT@@@Z@4_NA DB 01H DUP (?) ; `GetCursorPos_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??SetCursorPos_Detour@@YGHHH@Z@4_NA
_BSS	SEGMENT
?called@?2??SetCursorPos_Detour@@YGHHH@Z@4_NA DB 01H DUP (?) ; `SetCursorPos_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??SendInput_Detour@@YGIIPAUtagINPUT@@H@Z@4_NA
_BSS	SEGMENT
?called@?2??SendInput_Detour@@YGIIPAUtagINPUT@@H@Z@4_NA DB 01H DUP (?) ; `SendInput_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??keybd_event_Detour@@YGXEEKK@Z@4_NA
_BSS	SEGMENT
?called@?2??keybd_event_Detour@@YGXEEKK@Z@4_NA DB 01H DUP (?) ; `keybd_event_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??mouse_event_Detour@@YGXKKKKK@Z@4_NA
_BSS	SEGMENT
?called@?2??mouse_event_Detour@@YGXKKKKK@Z@4_NA DB 01H DUP (?) ; `mouse_event_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??GetAsyncKeyState_Detour@@YGFH@Z@4_NA
_BSS	SEGMENT
?called@?2??GetAsyncKeyState_Detour@@YGFH@Z@4_NA DB 01H DUP (?) ; `GetAsyncKeyState_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??GetKeyState_Detour@@YGFH@Z@4_NA
_BSS	SEGMENT
?called@?2??GetKeyState_Detour@@YGFH@Z@4_NA DB 01H DUP (?) ; `GetKeyState_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??GetKeyboardState_Detour@@YGHPAE@Z@4_NA
_BSS	SEGMENT
?called@?2??GetKeyboardState_Detour@@YGHPAE@Z@4_NA DB 01H DUP (?) ; `GetKeyboardState_Detour'::`3'::called
_BSS	ENDS
CRT$XCU	SEGMENT
?raw_devices$initializer$@@3P6AXXZA DD FLAT:??__Eraw_devices@@YAXXZ ; raw_devices$initializer$
CRT$XCU	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?tests@?1??SK_Input_PreHookHID@@YAXXZ@4PAUsk_import_test_s@@A
_DATA	SEGMENT
?tests@?1??SK_Input_PreHookHID@@YAXXZ@4PAUsk_import_test_s@@A DD FLAT:$SG161542 ; `SK_Input_PreHookHID'::`2'::tests
	DB	00H
	ORG $+3
_DATA	ENDS
_DATA	SEGMENT
?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A DB 020H DUP (?)
	DD	0ffffffffH				; SK_ImGui_Cursor
	DB	01H
	DB	00H
	DB	01H
_DATA	ENDS
xdata$x	SEGMENT
__unwindtable$?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z$0
__unwindtable$?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z$0
__unwindtable$?GetGameCursor@@YAPAUHICON__@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGameCursor@@YAPAUHICON__@@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGameCursor@@YAPAUHICON__@@XZ$1
__unwindtable$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z$1
__unwindtable$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z$1
__unwindtable$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z$3
__ehfuncinfo$?GetGameCursor@@YAPAUHICON__@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetGameCursor@@YAPAUHICON__@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?raw_mice$initializer$@@3P6AXXZA DD FLAT:??__Eraw_mice@@YAXXZ ; raw_mice$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?raw_keyboards$initializer$@@3P6AXXZA DD FLAT:??__Eraw_keyboards@@YAXXZ ; raw_keyboards$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?raw_gamepads$initializer$@@3P6AXXZA DD FLAT:??__Eraw_gamepads@@YAXXZ ; raw_gamepads$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_memmove@PAUtagRAWINPUTDEVICE@@PAU1@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUtagRAWINPUTDEVICE@@PAU1@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00@Z PROC ; std::_Copy_memmove<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *>, COMDAT

; 2295 : 	{	// implement copy-like function as memmove

	npad	2
	push	ebp
	mov	ebp, esp

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2302 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAUtagRAWINPUTDEVICE@@PAU1@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00@Z ENDP ; std::_Copy_memmove<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@ABU2@@Z PROC ; std::allocator<tagRAWINPUTDEVICE>::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@ABU2@@Z ENDP ; std::allocator<tagRAWINPUTDEVICE>::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@UtagRAWINPUTDEVICE@@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UtagRAWINPUTDEVICE@@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@@Z PROC ; std::allocator<tagRAWINPUTDEVICE>::destroy<tagRAWINPUTDEVICE>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@UtagRAWINPUTDEVICE@@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@@Z ENDP ; std::allocator<tagRAWINPUTDEVICE>::destroy<tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@AAU2@@Z PROC ; std::allocator<tagRAWINPUTDEVICE>::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@AAU2@@Z ENDP ; std::allocator<tagRAWINPUTDEVICE>::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@UtagRAWINPUTDEVICE@@U1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@UtagRAWINPUTDEVICE@@U1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >, COMDAT

; 157  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 159  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@UtagRAWINPUTDEVICE@@U1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@UtagRAWINPUTDEVICE@@U1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAUtagRAWINPUTDEVICE@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@UtagRAWINPUTDEVICE@@U1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAUtagRAWINPUTDEVICE@@0@Z PROC ; std::_Ptr_move_cat<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE>, COMDAT

; 892  : 	{	// return pointer move optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 893  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 894  : 	}

	pop	ebp
	ret	0
??$_Ptr_move_cat@UtagRAWINPUTDEVICE@@U1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAUtagRAWINPUTDEVICE@@0@Z ENDP ; std::_Ptr_move_cat<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAUtagRAWINPUTDEVICE@@PAU1@@std@@YAAAPAUtagRAWINPUTDEVICE@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUtagRAWINPUTDEVICE@@PAU1@@std@@YAAAPAUtagRAWINPUTDEVICE@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAUtagRAWINPUTDEVICE@@PAU1@@std@@YAAAPAUtagRAWINPUTDEVICE@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@UtagRAWINPUTDEVICE@@U1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked@UtagRAWINPUTDEVICE@@U1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >, COMDAT

; 108  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 110  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@UtagRAWINPUTDEVICE@@U1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_copy_cat@UtagRAWINPUTDEVICE@@U1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAUtagRAWINPUTDEVICE@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@UtagRAWINPUTDEVICE@@U1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAUtagRAWINPUTDEVICE@@0@Z PROC ; std::_Ptr_copy_cat<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE>, COMDAT

; 875  : 	{	// return pointer copy optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 876  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 877  : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@UtagRAWINPUTDEVICE@@U1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAUtagRAWINPUTDEVICE@@0@Z ENDP ; std::_Ptr_copy_cat<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAUtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z PROC ; std::_Unchecked<tagRAWINPUTDEVICE *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAUtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z ENDP ; std::_Unchecked<tagRAWINPUTDEVICE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@UtagRAWINPUTDEVICE@@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UtagRAWINPUTDEVICE@@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@@Z PROC ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::destroy<tagRAWINPUTDEVICE>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@UtagRAWINPUTDEVICE@@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@@Z ENDP ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::destroy<tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAXAAV?$allocator@UtagRAWINPUTDEVICE@@@1@PAUtagRAWINPUTDEVICE@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUtagRAWINPUTDEVICE@@PAU1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUtagRAWINPUTDEVICE@@PAU1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z PROC ; std::_Uninitialized_move<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *,std::allocator<tagRAWINPUTDEVICE> >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 176  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move@PAUtagRAWINPUTDEVICE@@PAU1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *,std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@PAUtagRAWINPUTDEVICE@@@std@@YAXPAUtagRAWINPUTDEVICE@@0AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@PAUtagRAWINPUTDEVICE@@@std@@YAXPAUtagRAWINPUTDEVICE@@0AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<tagRAWINPUTDEVICE>,tagRAWINPUTDEVICE *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@PAUtagRAWINPUTDEVICE@@@std@@YAXPAUtagRAWINPUTDEVICE@@0AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<tagRAWINPUTDEVICE>,tagRAWINPUTDEVICE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YA$$QAV?$allocator@UtagRAWINPUTDEVICE@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YA$$QAV?$allocator@UtagRAWINPUTDEVICE@@@0@AAV10@@Z PROC ; std::forward<std::allocator<tagRAWINPUTDEVICE> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YA$$QAV?$allocator@UtagRAWINPUTDEVICE@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAUtagRAWINPUTDEVICE@@PAU1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUtagRAWINPUTDEVICE@@PAU1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *,std::allocator<tagRAWINPUTDEVICE> >, COMDAT

; 117  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 127  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAUtagRAWINPUTDEVICE@@PAU1@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<tagRAWINPUTDEVICE *,tagRAWINPUTDEVICE *,std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1><std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1><std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@UtagRAWINPUTDEVICE@@ABU1@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXABUtagRAWINPUTDEVICE@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXABUtagRAWINPUTDEVICE@@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Emplace_back_with_unused_capacity<tagRAWINPUTDEVICE const &>, COMDAT
; _this$ = ecx

; 898  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $LN71@Emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [edx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$LN71@Emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 902  : 		++this->_Mylast();

	add	DWORD PTR [ecx+4], 12			; 0000000cH

; 903  : 		}

	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXABUtagRAWINPUTDEVICE@@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Emplace_back_with_unused_capacity<tagRAWINPUTDEVICE const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABUtagRAWINPUTDEVICE@@@std@@YAABUtagRAWINPUTDEVICE@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUtagRAWINPUTDEVICE@@@std@@YAABUtagRAWINPUTDEVICE@@ABU1@@Z PROC ; std::forward<tagRAWINPUTDEVICE const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABUtagRAWINPUTDEVICE@@@std@@YAABUtagRAWINPUTDEVICE@@ABU1@@Z ENDP ; std::forward<tagRAWINPUTDEVICE const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@UtagRAWINPUTDEVICE@@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UtagRAWINPUTDEVICE@@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::destroy<tagRAWINPUTDEVICE>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@UtagRAWINPUTDEVICE@@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::destroy<tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@UtagRAWINPUTDEVICE@@AAU1@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::construct<tagRAWINPUTDEVICE,tagRAWINPUTDEVICE &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@UtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z PROC ; std::_Unfancy<tagRAWINPUTDEVICE>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@UtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z ENDP ; std::_Unfancy<tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXAAUtagRAWINPUTDEVICE@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXAAUtagRAWINPUTDEVICE@@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Emplace_back_with_unused_capacity<tagRAWINPUTDEVICE &>, COMDAT
; _this$ = ecx

; 898  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $LN71@Emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [edx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$LN71@Emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 902  : 		++this->_Mylast();

	add	DWORD PTR [ecx+4], 12			; 0000000cH

; 903  : 		}

	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXAAUtagRAWINPUTDEVICE@@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Emplace_back_with_unused_capacity<tagRAWINPUTDEVICE &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAUtagRAWINPUTDEVICE@@@std@@YAAAUtagRAWINPUTDEVICE@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUtagRAWINPUTDEVICE@@@std@@YAAAUtagRAWINPUTDEVICE@@AAU1@@Z PROC ; std::forward<tagRAWINPUTDEVICE &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAUtagRAWINPUTDEVICE@@@std@@YAAAUtagRAWINPUTDEVICE@@AAU1@@Z ENDP ; std::forward<tagRAWINPUTDEVICE &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@UtagRAWINPUTDEVICE@@@std@@PAUtagRAWINPUTDEVICE@@@std@@YAXPAUtagRAWINPUTDEVICE@@0AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UtagRAWINPUTDEVICE@@@std@@PAUtagRAWINPUTDEVICE@@@std@@YAXPAUtagRAWINPUTDEVICE@@0AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<tagRAWINPUTDEVICE>,tagRAWINPUTDEVICE *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@UtagRAWINPUTDEVICE@@@std@@PAUtagRAWINPUTDEVICE@@@std@@YAXPAUtagRAWINPUTDEVICE@@0AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagRAWINPUTDEVICE>,tagRAWINPUTDEVICE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0V?$allocator@UtagRAWINPUTDEVICE@@@std@@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAV?$allocator@UtagRAWINPUTDEVICE@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@UtagRAWINPUTDEVICE@@@std@@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAV?$allocator@UtagRAWINPUTDEVICE@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> ><std::allocator<tagRAWINPUTDEVICE> >, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@UtagRAWINPUTDEVICE@@@std@@@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAV?$allocator@UtagRAWINPUTDEVICE@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> ><std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Ucopy@PAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEPAUtagRAWINPUTDEVICE@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEPAUtagRAWINPUTDEVICE@@PAU2@00@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Ucopy<tagRAWINPUTDEVICE *>, COMDAT
; _this$ = ecx

; 1858 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1860 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEPAUtagRAWINPUTDEVICE@@PAU2@00@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Ucopy<tagRAWINPUTDEVICE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAV10@@Z PROC ; std::move<std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAV10@@Z ENDP ; std::move<std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > ><std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,void>, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 517  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 517  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > ><std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z
_TEXT	SEGMENT
__Newvec$1$ = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>, COMDAT
; _this$ = ecx

; 908  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi

; 1731 : 		return (this->_Myend() != this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx

; 909  : 		if (_Has_unused_capacity())

	je	SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN70@emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN70@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 902  : 		++this->_Mylast();

	add	DWORD PTR [esi+4], 12			; 0000000cH
	pop	edi
	pop	esi

; 942  : 			}
; 943  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@emplace_ba:

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	ecx, DWORD PTR [esi]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	push	ebx
	sar	edx, 1
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 910  : 			{
; 911  : 			_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 912  : 			}
; 913  : 		else
; 914  : 			{	// reallocate
; 915  : 			const size_type _Oldsize = size();
; 916  : 
; 917  : 			if (_Oldsize == max_size())

	cmp	ebx, 357913941				; 15555555H
	je	$LN271@emplace_ba

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, DWORD PTR [esi]

; 920  : 				}
; 921  : 
; 922  : 			const size_type _Newsize = _Oldsize + 1;

	lea	ecx, DWORD PTR [ebx+1]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	imul	edi

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 357913941				; 15555555H

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, edi
	shr	edx, 1
	sub	eax, edx
	cmp	edi, eax
	jbe	SHORT $LN146@emplace_ba

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	edi, ecx
	jmp	SHORT $LN147@emplace_ba
$LN146@emplace_ba:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	edi, edx

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	edi, ecx
	cmovb	edi, ecx
$LN147@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	mov	ecx, esi
	call	?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ; std::allocator<tagRAWINPUTDEVICE>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 925  : 			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	edx, eax

; 926  : 
; 927  : 			_TRY_BEGIN
; 928  : 			this->_Getal().construct(_Unfancy(_Newvec + _Oldsize), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	DWORD PTR __Newvec$1$[ebp], edx
	lea	ecx, DWORD PTR [edx+ecx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN219@emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN219@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ecx, DWORD PTR [esi]

; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR [esi+4]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 941  : 			_Change_array(_Newvec, _Newsize, _Newcapacity);

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, esi
	push	edi
	push	eax
	push	DWORD PTR __Newvec$1$[ebp]
	call	?_Change_array@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXQAUtagRAWINPUTDEVICE@@II@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Change_array
	pop	ebx
	pop	edi
	pop	esi

; 942  : 			}
; 943  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN271@emplace_ba:

; 918  : 				{
; 919  : 				_Xlength();

	call	?_Xlength@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@CAXXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Xlength
$LN273@emplace_ba:
$LN270@emplace_ba:
	int	3
??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Unfancy_maybe_null@UtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy_maybe_null@UtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z PROC ; std::_Unfancy_maybe_null<tagRAWINPUTDEVICE>, COMDAT

; 692  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 693  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 694  : 	}

	pop	ebp
	ret	0
??$_Unfancy_maybe_null@UtagRAWINPUTDEVICE@@@std@@YAPAUtagRAWINPUTDEVICE@@PAU1@@Z ENDP ; std::_Unfancy_maybe_null<tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GIPAUtagRAWINPUT@@PAII@Z@@YAPAPAXPAP6GIPAUtagRAWINPUT@@PAII@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GIPAUtagRAWINPUT@@PAII@Z@@YAPAPAXPAP6GIPAUtagRAWINPUT@@PAII@Z@Z PROC ; static_cast_p2p<void,unsigned int __stdcall(tagRAWINPUT *,unsigned int *,unsigned int)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GIPAUtagRAWINPUT@@PAII@Z@@YAPAPAXPAP6GIPAUtagRAWINPUT@@PAII@Z@Z ENDP ; static_cast_p2p<void,unsigned int __stdcall(tagRAWINPUT *,unsigned int *,unsigned int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GIPAUtagRAWINPUTDEVICE@@PAII@Z@@YAPAPAXPAP6GIPAUtagRAWINPUTDEVICE@@PAII@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GIPAUtagRAWINPUTDEVICE@@PAII@Z@@YAPAPAXPAP6GIPAUtagRAWINPUTDEVICE@@PAII@Z@Z PROC ; static_cast_p2p<void,unsigned int __stdcall(tagRAWINPUTDEVICE *,unsigned int *,unsigned int)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GIPAUtagRAWINPUTDEVICE@@PAII@Z@@YAPAPAXPAP6GIPAUtagRAWINPUTDEVICE@@PAII@Z@Z ENDP ; static_cast_p2p<void,unsigned int __stdcall(tagRAWINPUTDEVICE *,unsigned int *,unsigned int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GHPBUtagRAWINPUTDEVICE@@II@Z@@YAPAPAXPAP6GHPBUtagRAWINPUTDEVICE@@II@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GHPBUtagRAWINPUTDEVICE@@II@Z@@YAPAPAXPAP6GHPBUtagRAWINPUTDEVICE@@II@Z@Z PROC ; static_cast_p2p<void,int __stdcall(tagRAWINPUTDEVICE const *,unsigned int,unsigned int)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GHPBUtagRAWINPUTDEVICE@@II@Z@@YAPAPAXPAP6GHPBUtagRAWINPUTDEVICE@@II@Z@Z ENDP ; static_cast_p2p<void,int __stdcall(tagRAWINPUTDEVICE const *,unsigned int,unsigned int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GXEEKK@Z@@YAPAPAXPAP6GXEEKK@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GXEEKK@Z@@YAPAPAXPAP6GXEEKK@Z@Z PROC ; static_cast_p2p<void,void __stdcall(unsigned char,unsigned char,unsigned long,unsigned long)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GXEEKK@Z@@YAPAPAXPAP6GXEEKK@Z@Z ENDP ; static_cast_p2p<void,void __stdcall(unsigned char,unsigned char,unsigned long,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GXKKKKK@Z@@YAPAPAXPAP6GXKKKKK@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GXKKKKK@Z@@YAPAPAXPAP6GXKKKKK@Z@Z PROC ; static_cast_p2p<void,void __stdcall(unsigned long,unsigned long,unsigned long,unsigned long,unsigned long)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GXKKKKK@Z@@YAPAPAXPAP6GXKKKKK@Z@Z ENDP ; static_cast_p2p<void,void __stdcall(unsigned long,unsigned long,unsigned long,unsigned long,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GIIPAUtagINPUT@@H@Z@@YAPAPAXPAP6GIIPAUtagINPUT@@H@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GIIPAUtagINPUT@@H@Z@@YAPAPAXPAP6GIIPAUtagINPUT@@H@Z@Z PROC ; static_cast_p2p<void,unsigned int __stdcall(unsigned int,tagINPUT *,int)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GIIPAUtagINPUT@@H@Z@@YAPAPAXPAP6GIIPAUtagINPUT@@H@Z@Z ENDP ; static_cast_p2p<void,unsigned int __stdcall(unsigned int,tagINPUT *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GHHH@Z@@YAPAPAXPAP6GHHH@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GHHH@Z@@YAPAPAXPAP6GHHH@Z@Z PROC ; static_cast_p2p<void,int __stdcall(int,int)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GHHH@Z@@YAPAPAXPAP6GHHH@Z@Z ENDP ; static_cast_p2p<void,int __stdcall(int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GPAUHICON__@@PAU1@@Z@@YAPAPAXPAP6GPAUHICON__@@PAU0@@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GPAUHICON__@@PAU1@@Z@@YAPAPAXPAP6GPAUHICON__@@PAU0@@Z@Z PROC ; static_cast_p2p<void,HICON__ * __stdcall(HICON__ *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GPAUHICON__@@PAU1@@Z@@YAPAPAXPAP6GPAUHICON__@@PAU0@@Z@Z ENDP ; static_cast_p2p<void,HICON__ * __stdcall(HICON__ *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GHIPAUtagMOUSEMOVEPOINT@@0HK@Z@@YAPAPAXPAP6GHIPAUtagMOUSEMOVEPOINT@@0HK@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GHIPAUtagMOUSEMOVEPOINT@@0HK@Z@@YAPAPAXPAP6GHIPAUtagMOUSEMOVEPOINT@@0HK@Z@Z PROC ; static_cast_p2p<void,int __stdcall(unsigned int,tagMOUSEMOVEPOINT *,tagMOUSEMOVEPOINT *,int,unsigned long)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GHIPAUtagMOUSEMOVEPOINT@@0HK@Z@@YAPAPAXPAP6GHIPAUtagMOUSEMOVEPOINT@@0HK@Z@Z ENDP ; static_cast_p2p<void,int __stdcall(unsigned int,tagMOUSEMOVEPOINT *,tagMOUSEMOVEPOINT *,int,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GHPAUtagCURSORINFO@@@Z@@YAPAPAXPAP6GHPAUtagCURSORINFO@@@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GHPAUtagCURSORINFO@@@Z@@YAPAPAXPAP6GHPAUtagCURSORINFO@@@Z@Z PROC ; static_cast_p2p<void,int __stdcall(tagCURSORINFO *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GHPAUtagCURSORINFO@@@Z@@YAPAPAXPAP6GHPAUtagCURSORINFO@@@Z@Z ENDP ; static_cast_p2p<void,int __stdcall(tagCURSORINFO *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GHPAUtagPOINT@@@Z@@YAPAPAXPAP6GHPAUtagPOINT@@@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GHPAUtagPOINT@@@Z@@YAPAPAXPAP6GHPAUtagPOINT@@@Z@Z PROC ; static_cast_p2p<void,int __stdcall(tagPOINT *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GHPAUtagPOINT@@@Z@@YAPAPAXPAP6GHPAUtagPOINT@@@Z@Z ENDP ; static_cast_p2p<void,int __stdcall(tagPOINT *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GHPAE@Z@@YAPAPAXPAP6GHPAE@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GHPAE@Z@@YAPAPAXPAP6GHPAE@Z@Z PROC ; static_cast_p2p<void,int __stdcall(unsigned char *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GHPAE@Z@@YAPAPAXPAP6GHPAE@Z@Z ENDP ; static_cast_p2p<void,int __stdcall(unsigned char *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GFH@Z@@YAPAPAXPAP6GFH@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GFH@Z@@YAPAPAXPAP6GFH@Z@Z PROC	; static_cast_p2p<void,short __stdcall(int)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GFH@Z@@YAPAPAXPAP6GFH@Z@Z ENDP	; static_cast_p2p<void,short __stdcall(int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GIPAUHRAWINPUT__@@IPAXPAII@Z@@YAPAPAXPAP6GIPAUHRAWINPUT__@@IPAXPAII@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GIPAUHRAWINPUT__@@IPAXPAII@Z@@YAPAPAXPAP6GIPAUHRAWINPUT__@@IPAXPAII@Z@Z PROC ; static_cast_p2p<void,unsigned int __stdcall(HRAWINPUT__ *,unsigned int,void *,unsigned int *,unsigned int)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GIPAUHRAWINPUT__@@IPAXPAII@Z@@YAPAPAXPAP6GIPAUHRAWINPUT__@@IPAXPAII@Z@Z ENDP ; static_cast_p2p<void,unsigned int __stdcall(HRAWINPUT__ *,unsigned int,void *,unsigned int *,unsigned int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_Input_PreInit@@YAXXZ PROC				; SK_Input_PreInit

; 1742 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetRawInputData_Original@@3P6GIPAUHRAWINPUT__@@IPAXPAII@ZA ; GetRawInputData_Original
	push	OFFSET ?GetRawInputData_Detour@@YGIPAUHRAWINPUT__@@IPAXPAII@Z ; GetRawInputData_Detour
	push	OFFSET $SG163886
	push	OFFSET $SG163887
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1743 :                              "GetRawInputData",
; 1744 :                               GetRawInputData_Detour,
; 1745 :      static_cast_p2p <void> (&GetRawInputData_Original) );
; 1746 : 
; 1747 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	push	OFFSET ?GetAsyncKeyState_Detour@@YGFH@Z	; GetAsyncKeyState_Detour
	push	OFFSET $SG163888
	push	OFFSET $SG163889
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1748 :                              "GetAsyncKeyState",
; 1749 :                               GetAsyncKeyState_Detour,
; 1750 :      static_cast_p2p <void> (&GetAsyncKeyState_Original) );
; 1751 : 
; 1752 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetKeyState_Original@@3P6GFH@ZA	; GetKeyState_Original
	push	OFFSET ?GetKeyState_Detour@@YGFH@Z	; GetKeyState_Detour
	push	OFFSET $SG163890
	push	OFFSET $SG163891
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1753 :                              "GetKeyState",
; 1754 :                               GetKeyState_Detour,
; 1755 :      static_cast_p2p <void> (&GetKeyState_Original) );
; 1756 : 
; 1757 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetKeyboardState_Original@@3P6GHPAE@ZA ; GetKeyboardState_Original
	push	OFFSET ?GetKeyboardState_Detour@@YGHPAE@Z ; GetKeyboardState_Detour
	push	OFFSET $SG163892
	push	OFFSET $SG163893
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1758 :                              "GetKeyboardState",
; 1759 :                               GetKeyboardState_Detour,
; 1760 :      static_cast_p2p <void> (&GetKeyboardState_Original) );
; 1761 : 
; 1762 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetCursorPos_Original@@3P6GHPAUtagPOINT@@@ZA ; GetCursorPos_Original
	push	OFFSET ?GetCursorPos_Detour@@YGHPAUtagPOINT@@@Z ; GetCursorPos_Detour
	push	OFFSET $SG163894
	push	OFFSET $SG163895
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1763 :                              "GetCursorPos",
; 1764 :                               GetCursorPos_Detour,
; 1765 :      static_cast_p2p <void> (&GetCursorPos_Original) );
; 1766 : 
; 1767 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetCursorInfo_Original@@3P6GHPAUtagCURSORINFO@@@ZA ; GetCursorInfo_Original
	push	OFFSET ?GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z ; GetCursorInfo_Detour
	push	OFFSET $SG163896
	push	OFFSET $SG163897
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1768 :                              "GetCursorInfo",
; 1769 :                               GetCursorInfo_Detour,
; 1770 :      static_cast_p2p <void> (&GetCursorInfo_Original) );
; 1771 : 
; 1772 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetMouseMovePointsEx_Original@@3P6GHIPAUtagMOUSEMOVEPOINT@@0HK@ZA ; GetMouseMovePointsEx_Original
	push	OFFSET ?GetMouseMovePointsEx_Detour@@YGHIPAUtagMOUSEMOVEPOINT@@0HK@Z ; GetMouseMovePointsEx_Detour
	push	OFFSET $SG163898
	push	OFFSET $SG163899
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1773 :                              "GetMouseMovePointsEx",
; 1774 :                               GetMouseMovePointsEx_Detour,
; 1775 :      static_cast_p2p <void> (&GetMouseMovePointsEx_Original) );
; 1776 : 
; 1777 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?SetCursor_Original@@3P6GPAUHICON__@@PAU1@@ZA ; SetCursor_Original
	push	OFFSET ?SetCursor_Detour@@YGPAUHICON__@@PAU1@@Z ; SetCursor_Detour
	push	OFFSET $SG163900
	push	OFFSET $SG163901
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1778 :                              "SetCursor",
; 1779 :                               SetCursor_Detour,
; 1780 :      static_cast_p2p <void> (&SetCursor_Original) );
; 1781 : 
; 1782 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?SetCursorPos_Original@@3P6GHHH@ZA ; SetCursorPos_Original
	push	OFFSET ?SetCursorPos_Detour@@YGHHH@Z	; SetCursorPos_Detour
	push	OFFSET $SG163902
	push	OFFSET $SG163903
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1783 :                              "SetCursorPos",
; 1784 :                               SetCursorPos_Detour,
; 1785 :      static_cast_p2p <void> (&SetCursorPos_Original) );
; 1786 : 
; 1787 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?SendInput_Original@@3P6GIIPAUtagINPUT@@H@ZA ; SendInput_Original
	push	OFFSET ?SendInput_Detour@@YGIIPAUtagINPUT@@H@Z ; SendInput_Detour
	push	OFFSET $SG163904
	push	OFFSET $SG163905
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1788 :                              "SendInput",
; 1789 :                               SendInput_Detour,
; 1790 :      static_cast_p2p <void> (&SendInput_Original) );
; 1791 : 
; 1792 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?mouse_event_Original@@3P6GXKKKKK@ZA ; mouse_event_Original
	push	OFFSET ?mouse_event_Detour@@YGXKKKKK@Z	; mouse_event_Detour
	push	OFFSET $SG163906
	push	OFFSET $SG163907
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1793 :                              "mouse_event",
; 1794 :                               mouse_event_Detour,
; 1795 :      static_cast_p2p <void> (&mouse_event_Original) );
; 1796 : 
; 1797 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?keybd_event_Original@@3P6GXEEKK@ZA ; keybd_event_Original
	push	OFFSET ?keybd_event_Detour@@YGXEEKK@Z	; keybd_event_Detour
	push	OFFSET $SG163908
	push	OFFSET $SG163909
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1798 :                              "keybd_event",
; 1799 :                               keybd_event_Detour,
; 1800 :      static_cast_p2p <void> (&keybd_event_Original) );
; 1801 : 
; 1802 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
	push	OFFSET ?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z ; RegisterRawInputDevices_Detour
	push	OFFSET $SG163910
	push	OFFSET $SG163911
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1803 :                              "RegisterRawInputDevices",
; 1804 :                               RegisterRawInputDevices_Detour,
; 1805 :      static_cast_p2p <void> (&RegisterRawInputDevices_Original) );
; 1806 : 
; 1807 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetRegisteredRawInputDevices_Original@@3P6GIPAUtagRAWINPUTDEVICE@@PAII@ZA ; GetRegisteredRawInputDevices_Original
	push	OFFSET ?GetRegisteredRawInputDevices_Detour@@YGIPAUtagRAWINPUTDEVICE@@PAII@Z ; GetRegisteredRawInputDevices_Detour
	push	OFFSET $SG163912
	push	OFFSET $SG163913
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1808 :                              "GetRegisteredRawInputDevices",
; 1809 :                               GetRegisteredRawInputDevices_Detour,
; 1810 :      static_cast_p2p <void> (&GetRegisteredRawInputDevices_Original) );
; 1811 : 
; 1812 :   SK_CreateDLLHook2 (       L"user32.dll",

	push	0
	push	OFFSET ?GetRawInputBuffer_Original@@3P6GIPAUtagRAWINPUT@@PAII@ZA ; GetRawInputBuffer_Original
	push	OFFSET ?GetRawInputBuffer_Detour@@YGIPAUtagRAWINPUT@@PAII@Z ; GetRawInputBuffer_Detour
	push	OFFSET $SG163914
	push	OFFSET $SG163915
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 1813 :                              "GetRawInputBuffer",
; 1814 :                               GetRawInputBuffer_Detour,
; 1815 :      static_cast_p2p <void> (&GetRawInputBuffer_Original) );
; 1816 : 
; 1817 :   if (config.input.gamepad.hook_xinput)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+693, 0
	je	SHORT $LN2@SK_Input_P

; 1818 :     SK_XInput_InitHotPlugHooks ();

	call	?SK_XInput_InitHotPlugHooks@@YAXXZ	; SK_XInput_InitHotPlugHooks
$LN2@SK_Input_P:

; 1819 : 
; 1820 :   SK_ApplyQueuedHooks ();

	jmp	?SK_ApplyQueuedHooks@@YG?AW4MH_STATUS@@XZ ; SK_ApplyQueuedHooks
?SK_Input_PreInit@@YAXXZ ENDP				; SK_Input_PreInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_lpKeyState$ = 8					; size = 4
?GetKeyboardState_Detour@@YGHPAE@Z PROC			; GetKeyboardState_Detour

; 1627 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetKeyboardState_Detour@@YGHPAE@Z@4_NA, 0
	jne	SHORT $LN2@GetKeyboar
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@GetKeyboar
	push	OFFSET $SG163437
	push	OFFSET $SG163438
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@GetKeyboar:
	mov	BYTE PTR ?called@?2??GetKeyboardState_Detour@@YGHPAE@Z@4_NA, 1
$LN2@GetKeyboar:
	push	esi

; 1629 : 
; 1630 :   BOOL bRet =
; 1631 :     GetKeyboardState_Original (lpKeyState);

	mov	esi, DWORD PTR _lpKeyState$[ebp]
	push	edi
	push	esi
	call	DWORD PTR ?GetKeyboardState_Original@@3P6GHPAE@ZA ; GetKeyboardState_Original
	mov	edi, eax

; 1632 : 
; 1633 :   if (bRet)

	test	edi, edi
	je	SHORT $LN9@GetKeyboar

; 1634 :   {
; 1635 :     if (SK_ImGui_WantKeyboardCapture ())

	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture
	test	al, al
	je	SHORT $LN5@GetKeyboar

; 1636 :       memset (&lpKeyState [7], 0, 247);

	push	247					; 000000f7H
	lea	eax, DWORD PTR [esi+7]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN5@GetKeyboar:

; 1637 : 
; 1638 :     // Some games use this API for mouse buttons, for reasons that are beyond me...
; 1639 :     if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN9@GetKeyboar

; 1640 :       memset (  lpKeyState,    0, 7);

	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	WORD PTR [esi+4], ax
	mov	BYTE PTR [esi+6], al
$LN9@GetKeyboar:

; 1641 :   }
; 1642 : 
; 1643 :   return bRet;

	mov	eax, edi
	pop	edi
	pop	esi

; 1644 : }

	pop	ebp
	ret	4
?GetKeyboardState_Detour@@YGHPAE@Z ENDP			; GetKeyboardState_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_nVirtKey$ = 8						; size = 4
?GetKeyState_Detour@@YGFH@Z PROC			; GetKeyState_Detour

; 1592 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1593 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetKeyState_Detour@@YGFH@Z@4_NA, 0
	jne	SHORT $LN2@GetKeyStat
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@GetKeyStat
	push	OFFSET $SG163420
	push	OFFSET $SG163421
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@GetKeyStat:
	mov	BYTE PTR ?called@?2??GetKeyState_Detour@@YGFH@Z@4_NA, 1
$LN2@GetKeyStat:

; 1594 : 
; 1595 : #define SK_ConsumeVirtKey(nVirtKey) { GetKeyState_Original(nVirtKey); return 0; }
; 1596 : 
; 1597 :   // Block keyboard input to the game while the console is active
; 1598 :   if (SK_Console::getInstance ()->isVisible ())

	call	?getInstance@SK_Console@@SAPAV1@XZ	; SK_Console::getInstance
	cmp	BYTE PTR [eax+4356], 0
	je	SHORT $LN4@GetKeyStat
$LN16@GetKeyStat:

; 1599 :     SK_ConsumeVirtKey (nVirtKey);

	push	DWORD PTR _nVirtKey$[ebp]
	call	DWORD PTR ?GetKeyState_Original@@3P6GFH@ZA ; GetKeyState_Original
	xor	eax, eax

; 1620 : }

	pop	ebp
	ret	4
$LN4@GetKeyStat:

; 1600 : 
; 1601 :   // Block keyboard input to the game while it's in the background
; 1602 :   if ((! SK_GetCurrentRenderBackend ().fullscreen_exclusive) &&
; 1603 :       config.window.background_render && (! game_window.active))

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	cmp	BYTE PTR [eax+48], 0
	jne	SHORT $LN5@GetKeyStat
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+768, 0
	je	SHORT $LN5@GetKeyStat
	cmp	BYTE PTR ?game_window@@3Usk_window_s@@A+17, 0
	je	SHORT $LN16@GetKeyStat
$LN5@GetKeyStat:
	push	ebx

; 1604 :     SK_ConsumeVirtKey (nVirtKey);
; 1605 : 
; 1606 :   if (nVirtKey & 0xF8) // Valid Keys:  8 - 255

	mov	ebx, DWORD PTR _nVirtKey$[ebp]
	test	bl, 248					; 000000f8H
	je	SHORT $LN6@GetKeyStat

; 1607 :   {
; 1608 :     if (SK_ImGui_WantKeyboardCapture ())

	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture

; 1609 :       SK_ConsumeVirtKey (nVirtKey);

	jmp	SHORT $LN15@GetKeyStat
$LN6@GetKeyStat:

; 1610 :   }
; 1611 : 
; 1612 :   else if (nVirtKey < 8)

	cmp	ebx, 8
	jge	SHORT $LN10@GetKeyStat

; 1613 :   {
; 1614 :     // Some games use this API for mouse buttons, for reasons that are beyond me...
; 1615 :     if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
$LN15@GetKeyStat:
	test	al, al
	je	SHORT $LN10@GetKeyStat

; 1616 :       SK_ConsumeVirtKey (nVirtKey);

	push	ebx
	call	DWORD PTR ?GetKeyState_Original@@3P6GFH@ZA ; GetKeyState_Original
	xor	eax, eax
	pop	ebx

; 1620 : }

	pop	ebp
	ret	4
$LN10@GetKeyStat:

; 1617 :   }
; 1618 : 
; 1619 :   return GetKeyState_Original (nVirtKey);

	push	ebx
	call	DWORD PTR ?GetKeyState_Original@@3P6GFH@ZA ; GetKeyState_Original
	pop	ebx

; 1620 : }

	pop	ebp
	ret	4
?GetKeyState_Detour@@YGFH@Z ENDP			; GetKeyState_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_vKey$ = 8						; size = 4
?GetAsyncKeyState_Detour@@YGFH@Z PROC			; GetAsyncKeyState_Detour

; 1559 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1560 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetAsyncKeyState_Detour@@YGFH@Z@4_NA, 0
	jne	SHORT $LN2@GetAsyncKe
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@GetAsyncKe
	push	OFFSET $SG163404
	push	OFFSET $SG163405
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@GetAsyncKe:
	mov	BYTE PTR ?called@?2??GetAsyncKeyState_Detour@@YGFH@Z@4_NA, 1
$LN2@GetAsyncKe:

; 1561 : 
; 1562 : #define SK_ConsumeVKey(vKey) { GetAsyncKeyState_Original(vKey); return 0; }
; 1563 : 
; 1564 :   // Block keyboard input to the game while the console is active
; 1565 :   if (SK_Console::getInstance ()->isVisible ())

	call	?getInstance@SK_Console@@SAPAV1@XZ	; SK_Console::getInstance
	cmp	BYTE PTR [eax+4356], 0
	je	SHORT $LN4@GetAsyncKe
$LN16@GetAsyncKe:

; 1566 :     SK_ConsumeVKey (vKey);

	push	DWORD PTR _vKey$[ebp]
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	xor	eax, eax

; 1587 : }

	pop	ebp
	ret	4
$LN4@GetAsyncKe:

; 1567 : 
; 1568 :   // Block keyboard input to the game while it's in the background
; 1569 :   if ((! SK_GetCurrentRenderBackend ().fullscreen_exclusive) &&
; 1570 :       config.window.background_render && (! game_window.active))

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	cmp	BYTE PTR [eax+48], 0
	jne	SHORT $LN5@GetAsyncKe
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+768, 0
	je	SHORT $LN5@GetAsyncKe
	cmp	BYTE PTR ?game_window@@3Usk_window_s@@A+17, 0
	je	SHORT $LN16@GetAsyncKe
$LN5@GetAsyncKe:
	push	ebx

; 1571 :     SK_ConsumeVKey (vKey);
; 1572 : 
; 1573 :   if (vKey & 0xF8) // Valid Keys:  8 - 255

	mov	ebx, DWORD PTR _vKey$[ebp]
	test	bl, 248					; 000000f8H
	je	SHORT $LN6@GetAsyncKe

; 1574 :   {
; 1575 :     if (SK_ImGui_WantKeyboardCapture ())

	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture

; 1576 :       SK_ConsumeVKey (vKey);

	jmp	SHORT $LN15@GetAsyncKe
$LN6@GetAsyncKe:

; 1577 :   }
; 1578 : 
; 1579 :   else if (vKey < 8)

	cmp	ebx, 8
	jge	SHORT $LN10@GetAsyncKe

; 1580 :   {
; 1581 :     // Some games use this API for mouse buttons, for reasons that are beyond me...
; 1582 :     if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
$LN15@GetAsyncKe:
	test	al, al
	je	SHORT $LN10@GetAsyncKe

; 1583 :       SK_ConsumeVKey (vKey);

	push	ebx
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	xor	eax, eax
	pop	ebx

; 1587 : }

	pop	ebp
	ret	4
$LN10@GetAsyncKe:

; 1584 :   }
; 1585 : 
; 1586 :   return GetAsyncKeyState_Original (vKey);

	push	ebx
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	pop	ebx

; 1587 : }

	pop	ebp
	ret	4
?GetAsyncKeyState_Detour@@YGFH@Z ENDP			; GetAsyncKeyState_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_dwFlags$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
_dwData$ = 20						; size = 4
_dwExtraInfo$ = 24					; size = 4
?mouse_event_Detour@@YGXKKKKK@Z PROC			; mouse_event_Detour

; 1538 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1539 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??mouse_event_Detour@@YGXKKKKK@Z@4_NA, 0
	jne	SHORT $LN2@mouse_even
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@mouse_even
	push	OFFSET $SG163394
	push	OFFSET $SG163395
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@mouse_even:
	mov	BYTE PTR ?called@?2??mouse_event_Detour@@YGXKKKKK@Z@4_NA, 1
$LN2@mouse_even:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN12@mouse_even
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN12@mouse_even
	xor	eax, eax
	jmp	SHORT $LN13@mouse_even
$LN12@mouse_even:
	mov	eax, 1
$LN13@mouse_even:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN1@mouse_even
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN1@mouse_even

; 1549 : }

	pop	ebp

; 1540 : 
; 1541 : // TODO: Process this the right way...
; 1542 : 
; 1543 :   if (SK_ImGui_IsMouseRelevant ())
; 1544 :   {
; 1545 :     return;
; 1546 :   }
; 1547 : 
; 1548 :   mouse_event_Original (dwFlags, dx, dy, dwData, dwExtraInfo);

	jmp	DWORD PTR ?mouse_event_Original@@3P6GXKKKKK@ZA ; mouse_event_Original
$LN1@mouse_even:

; 1549 : }

	pop	ebp
	ret	20					; 00000014H
?mouse_event_Detour@@YGXKKKKK@Z ENDP			; mouse_event_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_bVk$ = 8						; size = 1
_bScan$ = 12						; size = 1
_dwFlags$ = 16						; size = 4
_dwExtraInfo$ = 20					; size = 4
?keybd_event_Detour@@YGXEEKK@Z PROC			; keybd_event_Detour

; 1516 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1517 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??keybd_event_Detour@@YGXEEKK@Z@4_NA, 0
	jne	SHORT $LN2@keybd_even
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@keybd_even
	push	OFFSET $SG163380
	push	OFFSET $SG163381
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@keybd_even:
	mov	BYTE PTR ?called@?2??keybd_event_Detour@@YGXEEKK@Z@4_NA, 1
$LN2@keybd_even:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN1@keybd_even
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN1@keybd_even
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 1527 : }

	pop	ebp

; 1518 : 
; 1519 : // TODO: Process this the right way...
; 1520 : 
; 1521 :   if (SK_ImGui_Active ())
; 1522 :   {
; 1523 :     return;
; 1524 :   }
; 1525 : 
; 1526 :   keybd_event_Original (bVk, bScan, dwFlags, dwExtraInfo);

	jmp	DWORD PTR ?keybd_event_Original@@3P6GXEEKK@ZA ; keybd_event_Original
$LN1@keybd_even:

; 1527 : }

	pop	ebp
	ret	16					; 00000010H
?keybd_event_Detour@@YGXEEKK@Z ENDP			; keybd_event_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_nInputs$ = 8						; size = 4
_pInputs$ = 12						; size = 4
_cbSize$ = 16						; size = 4
?SendInput_Detour@@YGIIPAUtagINPUT@@H@Z PROC		; SendInput_Detour

; 1493 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1494 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??SendInput_Detour@@YGIIPAUtagINPUT@@H@Z@4_NA, 0
	jne	SHORT $LN2@SendInput_
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@SendInput_
	push	OFFSET $SG163367
	push	OFFSET $SG163368
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@SendInput_:
	mov	BYTE PTR ?called@?2??SendInput_Detour@@YGIIPAUtagINPUT@@H@Z@4_NA, 1
$LN2@SendInput_:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN8@SendInput_
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN8@SendInput_
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 1504 : }

	pop	ebp

; 1501 :   }
; 1502 : 
; 1503 :   return SendInput_Original (nInputs, pInputs, cbSize);

	jmp	DWORD PTR ?SendInput_Original@@3P6GIIPAUtagINPUT@@H@ZA ; SendInput_Original
$LN8@SendInput_:

; 1495 : 
; 1496 :   // TODO: Process this the right way...
; 1497 : 
; 1498 :   if (SK_ImGui_Active ())
; 1499 :   {
; 1500 :     return 0;

	xor	eax, eax

; 1504 : }

	pop	ebp
	ret	12					; 0000000cH
?SendInput_Detour@@YGIIPAUtagINPUT@@H@Z ENDP		; SendInput_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetCursorPos_Detour@@YGHHH@Z PROC			; SetCursorPos_Detour

; 1453 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1454 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??SetCursorPos_Detour@@YGHHH@Z@4_NA, 0
	jne	SHORT $LN2@SetCursorP
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@SetCursorP
	push	OFFSET $SG163349
	push	OFFSET $SG163350
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@SetCursorP:
	mov	BYTE PTR ?called@?2??SetCursorPos_Detour@@YGHHH@Z@4_NA, 1
$LN2@SetCursorP:
	push	esi

; 1455 : 
; 1456 :   // Game WANTED to change its position, so remember that.
; 1457 :   SK_ImGui_Cursor.orig_pos.x = x;

	mov	esi, DWORD PTR _x$[ebp]
	push	edi

; 1458 :   SK_ImGui_Cursor.orig_pos.y = y;

	mov	edi, DWORD PTR _y$[ebp]

; 974  :   ScreenToClient (game_window.hWnd, lpPoint);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4

; 1455 : 
; 1456 :   // Game WANTED to change its position, so remember that.
; 1457 :   SK_ImGui_Cursor.orig_pos.x = x;

	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4, esi

; 1458 :   SK_ImGui_Cursor.orig_pos.y = y;

	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+8, edi

; 974  :   ScreenToClient (game_window.hWnd, lpPoint);

	call	DWORD PTR __imp__ScreenToClient@8

; 975  :   ClientToLocal  (lpPoint);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4
	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::ClientToLocal

; 1459 : 
; 1460 :   SK_ImGui_Cursor.ScreenToLocal (&SK_ImGui_Cursor.orig_pos);
; 1461 : 
; 1462 :   // Don't let the game continue moving the cursor while
; 1463 :   //   Alt+Tabbed out
; 1464 :   if ((! SK_GetCurrentRenderBackend ().fullscreen_exclusive) &&
; 1465 :       config.window.background_render && (! game_window.active))

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	cmp	BYTE PTR [eax+48], 0
	jne	SHORT $LN4@SetCursorP
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+768, 0
	je	SHORT $LN4@SetCursorP
	cmp	BYTE PTR ?game_window@@3Usk_window_s@@A+17, 0
	je	SHORT $LN10@SetCursorP
$LN4@SetCursorP:

; 1466 :     return TRUE;
; 1467 : 
; 1468 :   // Prevent Mouse Look while Drag Locked
; 1469 :   if (config.window.drag_lock)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+773, 0
	jne	SHORT $LN10@SetCursorP

; 1470 :     return TRUE;
; 1471 : 
; 1472 :   if ( ( SK_ImGui_Cursor.prefs.no_warp.ui_open && SK_ImGui_IsMouseRelevant       () ) ||

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+38, 0
	je	SHORT $LN9@SetCursorP
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN20@SetCursorP
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN20@SetCursorP
	xor	eax, eax
	jmp	SHORT $LN21@SetCursorP
$LN20@SetCursorP:
	mov	eax, 1
$LN21@SetCursorP:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN10@SetCursorP
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN10@SetCursorP
$LN9@SetCursorP:

; 1470 :     return TRUE;
; 1471 : 
; 1472 :   if ( ( SK_ImGui_Cursor.prefs.no_warp.ui_open && SK_ImGui_IsMouseRelevant       () ) ||

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+36, 0
	je	SHORT $LN6@SetCursorP
	call	?SK_InputUtil_IsHWCursorVisible@@YA_NXZ	; SK_InputUtil_IsHWCursorVisible
	test	al, al
	jne	SHORT $LN10@SetCursorP
$LN6@SetCursorP:

; 1473 :        ( SK_ImGui_Cursor.prefs.no_warp.visible && SK_InputUtil_IsHWCursorVisible () )    )
; 1474 :   {
; 1475 :     //game_mouselook = SK_GetFramesDrawn ();
; 1476 :   }
; 1477 : 
; 1478 :   else if (! SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	jne	SHORT $LN10@SetCursorP

; 1479 :   {
; 1480 :     return SetCursorPos_Original (x, y);

	push	edi
	push	esi
	call	DWORD PTR ?SetCursorPos_Original@@3P6GHHH@ZA ; SetCursorPos_Original
	pop	edi
	pop	esi

; 1484 : }

	pop	ebp
	ret	8
$LN10@SetCursorP:
	pop	edi

; 1481 :   }
; 1482 : 
; 1483 :   return TRUE;

	mov	eax, 1
	pop	esi

; 1484 : }

	pop	ebp
	ret	8
?SetCursorPos_Detour@@YGHHH@Z ENDP			; SetCursorPos_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_client$1 = -8						; size = 8
_client$2 = -8						; size = 8
_lpPoint$ = 8						; size = 4
?GetCursorPos_Detour@@YGHPAUtagPOINT@@@Z PROC		; GetCursorPos_Detour

; 1396 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1397 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetCursorPos_Detour@@YGHPAUtagPOINT@@@Z@4_NA, 0
	jne	SHORT $LN2@GetCursorP
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@GetCursorP
	push	OFFSET $SG163331
	push	OFFSET $SG163332
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@GetCursorP:
	mov	BYTE PTR ?called@?2??GetCursorPos_Detour@@YGHPAUtagPOINT@@@Z@4_NA, 1
$LN2@GetCursorP:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	mov	dl, BYTE PTR ?SK_ImGui_Visible@@3_NA	; SK_ImGui_Visible
	mov	cl, BYTE PTR ?SK_ReShade_Visible@@3_NA	; SK_ReShade_Visible
	test	dl, dl
	jne	SHORT $LN19@GetCursorP
	test	cl, cl
	jne	SHORT $LN19@GetCursorP
	xor	eax, eax
	jmp	SHORT $LN20@GetCursorP
$LN19@GetCursorP:
	mov	eax, 1
$LN20@GetCursorP:
	push	ebx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	mov	bl, BYTE PTR ?config@@3Usk_config_t@@A+740
	or	al, bl
	jne	$LN15@GetCursorP
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN38@GetCursorP

; 1433 :   }
; 1434 : 
; 1435 : 
; 1436 :   BOOL bRet = GetCursorPos_Original (lpPoint);

	push	esi
	mov	esi, DWORD PTR _lpPoint$[ebp]
	push	edi
	push	esi
	call	DWORD PTR ?GetCursorPos_Original@@3P6GHPAUtagPOINT@@@ZA ; GetCursorPos_Original
	mov	edi, eax

; 1437 : 
; 1438 :   if (bRet)

	test	edi, edi
	je	SHORT $LN11@GetCursorP

; 1439 :   {
; 1440 :     SK_ImGui_Cursor.orig_pos = *lpPoint;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4, ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+8, ecx

; 1441 :     SK_ImGui_Cursor.pos      = *lpPoint;

	mov	ecx, DWORD PTR [esi]

; 974  :   ScreenToClient (game_window.hWnd, lpPoint);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4

; 1441 :     SK_ImGui_Cursor.pos      = *lpPoint;

	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20, ecx
	mov	eax, DWORD PTR [esi+4]

; 974  :   ScreenToClient (game_window.hWnd, lpPoint);

	mov	esi, DWORD PTR __imp__ScreenToClient@8

; 1441 :     SK_ImGui_Cursor.pos      = *lpPoint;

	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24, eax

; 974  :   ScreenToClient (game_window.hWnd, lpPoint);

	call	esi

; 975  :   ClientToLocal  (lpPoint);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4
	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::ClientToLocal

; 974  :   ScreenToClient (game_window.hWnd, lpPoint);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	esi

; 975  :   ClientToLocal  (lpPoint);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::ClientToLocal
$LN11@GetCursorP:

; 1442 : 
; 1443 :     SK_ImGui_Cursor.ScreenToLocal (&SK_ImGui_Cursor.orig_pos);
; 1444 :     SK_ImGui_Cursor.ScreenToLocal (&SK_ImGui_Cursor.pos);
; 1445 :   }
; 1446 : 
; 1447 :   return bRet;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1448 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN38@GetCursorP:

; 1442 : 
; 1443 :     SK_ImGui_Cursor.ScreenToLocal (&SK_ImGui_Cursor.orig_pos);
; 1444 :     SK_ImGui_Cursor.ScreenToLocal (&SK_ImGui_Cursor.pos);
; 1445 :   }
; 1446 : 
; 1447 :   return bRet;

	mov	bl, BYTE PTR ?config@@3Usk_config_t@@A+740
	mov	dl, BYTE PTR ?SK_ImGui_Visible@@3_NA	; SK_ImGui_Visible
	mov	cl, BYTE PTR ?SK_ReShade_Visible@@3_NA	; SK_ReShade_Visible
$LN15@GetCursorP:

; 1398 : 
; 1399 : 
; 1400 :   if (SK_ImGui_IsMouseRelevant ())
; 1401 :   {
; 1402 :     bool implicit_capture = false;
; 1403 : 
; 1404 :     // Depending on warp prefs, we may not allow the game to know about mouse movement
; 1405 :     //   (even if ImGui doesn't want mouse capture)
; 1406 :     if ( ( SK_ImGui_Cursor.prefs.no_warp.ui_open && SK_ImGui_IsMouseRelevant       () ) ||

	xor	bh, bh
	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+38, bh
	je	SHORT $LN7@GetCursorP
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	test	dl, dl
	jne	SHORT $LN27@GetCursorP
	test	cl, cl
	jne	SHORT $LN27@GetCursorP
	xor	eax, eax
	jmp	SHORT $LN28@GetCursorP
$LN27@GetCursorP:
	mov	eax, 1
$LN28@GetCursorP:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, bl
	jne	SHORT $LN6@GetCursorP
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN6@GetCursorP
$LN7@GetCursorP:

; 1398 : 
; 1399 : 
; 1400 :   if (SK_ImGui_IsMouseRelevant ())
; 1401 :   {
; 1402 :     bool implicit_capture = false;
; 1403 : 
; 1404 :     // Depending on warp prefs, we may not allow the game to know about mouse movement
; 1405 :     //   (even if ImGui doesn't want mouse capture)
; 1406 :     if ( ( SK_ImGui_Cursor.prefs.no_warp.ui_open && SK_ImGui_IsMouseRelevant       () ) ||

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+36, 0
	je	SHORT $LN5@GetCursorP
	call	?SK_InputUtil_IsHWCursorVisible@@YA_NXZ	; SK_InputUtil_IsHWCursorVisible
	test	al, al
	je	SHORT $LN5@GetCursorP
$LN6@GetCursorP:

; 1407 :          ( SK_ImGui_Cursor.prefs.no_warp.visible && SK_InputUtil_IsHWCursorVisible () )    )
; 1408 :       implicit_capture = true;

	mov	bh, 1
$LN5@GetCursorP:

; 1409 : 
; 1410 :     if (SK_ImGui_WantMouseCapture () || implicit_capture)

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	jne	SHORT $LN10@GetCursorP
	test	bh, bh
	jne	SHORT $LN10@GetCursorP

; 1419 :     }
; 1420 : 
; 1421 :     else
; 1422 :     {
; 1423 :       POINT client =
; 1424 :         SK_ImGui_Cursor.pos;

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	mov	DWORD PTR _client$1[ebp], eax
	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24

; 1425 : 
; 1426 :       SK_ImGui_Cursor.LocalToScreen (&client);
; 1427 : 
; 1428 :       lpPoint->x = client.x;
; 1429 :       lpPoint->y = client.y;

	jmp	SHORT $LN39@GetCursorP
$LN10@GetCursorP:

; 1411 :     {
; 1412 :       POINT client =
; 1413 :         SK_ImGui_Cursor.orig_pos;

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4
	mov	DWORD PTR _client$2[ebp], eax
	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+8
$LN39@GetCursorP:
	mov	DWORD PTR _client$2[ebp+4], eax

; 910  :   LocalToClient  (lpPoint);

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	lea	eax, DWORD PTR _client$2[ebp]
	push	eax
	call	?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::LocalToClient

; 911  :   ClientToScreen (game_window.hWnd, lpPoint);

	lea	eax, DWORD PTR _client$2[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__ClientToScreen@8

; 1414 : 
; 1415 :       SK_ImGui_Cursor.LocalToScreen (&client);
; 1416 : 
; 1417 :       lpPoint->x = client.x;

	mov	ecx, DWORD PTR _lpPoint$[ebp]
	mov	eax, DWORD PTR _client$2[ebp]
	pop	ebx
	mov	DWORD PTR [ecx], eax

; 1418 :       lpPoint->y = client.y;

	mov	eax, DWORD PTR _client$2[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 1430 :     }
; 1431 : 
; 1432 :     return TRUE;

	mov	eax, 1

; 1448 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCursorPos_Detour@@YGHPAUtagPOINT@@@Z ENDP		; GetCursorPos_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ??0state_backup@?1??GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z@QAE@0@Z
_TEXT	SEGMENT
_pci$ = 8						; size = 4
??0state_backup@?1??GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z@QAE@0@Z PROC ; `GetCursorInfo_Detour'::`2'::state_backup::state_backup, COMDAT
; _this$ = ecx

; 1340 :       ptScreenPos (pci->ptScreenPos) { };

	npad	2
	push	ebp
	mov	ebp, esp

; 1339 :       hCursor     (pci->hCursor),

	mov	edx, DWORD PTR _pci$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 1340 :       ptScreenPos (pci->ptScreenPos) { };

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0state_backup@?1??GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z@QAE@0@Z ENDP ; `GetCursorInfo_Detour'::`2'::state_backup::state_backup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_client$1 = -16						; size = 8
_client$2 = -16						; size = 8
_actual$2$ = -12					; size = 4
_actual$1$ = -8						; size = 4
_actual$$sroa$75$1$ = -4				; size = 4
_ret$1$ = 8						; size = 4
_pci$ = 8						; size = 4
_implicit_capture$1$ = 11				; size = 1
?GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z PROC	; GetCursorInfo_Detour

; 1329 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1330 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z@4_NA, 0
	jne	SHORT $LN2@GetCursorI
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@GetCursorI
	push	OFFSET $SG163311
	push	OFFSET $SG163312
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@GetCursorI:
	mov	BYTE PTR ?called@?2??GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z@4_NA, 1
$LN2@GetCursorI:
	push	ebx

; 1331 : 
; 1332 :   POINT   pt        = pci->ptScreenPos;

	mov	ebx, DWORD PTR _pci$[ebp]
	push	esi
	push	edi

; 1333 :   BOOL    ret       = GetCursorInfo_Original (pci);

	push	ebx
	mov	esi, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR [ebx+16]
	call	DWORD PTR ?GetCursorInfo_Original@@3P6GHPAUtagCURSORINFO@@@ZA ; GetCursorInfo_Original
	mov	ecx, eax

; 1339 :       hCursor     (pci->hCursor),

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _actual$$sroa$75$1$[ebp], eax

; 1340 :       ptScreenPos (pci->ptScreenPos) { };

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _actual$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _actual$2$[ebp], eax

; 1341 : 
; 1342 :     HCURSOR hCursor;
; 1343 :     POINT   ptScreenPos;
; 1344 :   } actual (pci);
; 1345 : 
; 1346 :   pci->ptScreenPos = pt;

	mov	DWORD PTR [ebx+12], esi
	mov	DWORD PTR [ebx+16], edi

; 1347 :   pci->hCursor     =

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A
	mov	DWORD PTR _ret$1$[ebp], ecx
	mov	DWORD PTR [ebx+8], eax

; 1348 :     SK_ImGui_Cursor.orig_img;
; 1349 : 
; 1350 : 
; 1351 :   if (ret && SK_ImGui_IsMouseRelevant ())

	test	ecx, ecx
	je	$LN4@GetCursorI
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN20@GetCursorI
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN20@GetCursorI
	xor	eax, eax
	jmp	SHORT $LN21@GetCursorI
$LN20@GetCursorI:
	mov	eax, 1
$LN21@GetCursorI:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN16@GetCursorI
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	je	$LN27@GetCursorI
$LN16@GetCursorI:

; 1352 :   {
; 1353 :     bool implicit_capture = false;
; 1354 : 
; 1355 :     // Depending on warp prefs, we may not allow the game to know about mouse movement
; 1356 :     //   (even if ImGui doesn't want mouse capture)
; 1357 :     if ( ( SK_ImGui_Cursor.prefs.no_warp.ui_open && SK_ImGui_IsMouseRelevant       () ) ||

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+38, 0
	mov	BYTE PTR _implicit_capture$1$[ebp], 0
	je	SHORT $LN7@GetCursorI
	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	test	al, al
	jne	SHORT $LN6@GetCursorI
$LN7@GetCursorI:
	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+36, 0
	je	SHORT $LN5@GetCursorI
	call	?SK_InputUtil_IsHWCursorVisible@@YA_NXZ	; SK_InputUtil_IsHWCursorVisible
	test	al, al
	je	SHORT $LN5@GetCursorI
$LN6@GetCursorI:

; 1358 :          ( SK_ImGui_Cursor.prefs.no_warp.visible && SK_InputUtil_IsHWCursorVisible () )    )
; 1359 :       implicit_capture = true;

	mov	BYTE PTR _implicit_capture$1$[ebp], 1
$LN5@GetCursorI:

; 1360 : 
; 1361 :     if (SK_ImGui_WantMouseCapture () || implicit_capture)

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	jne	SHORT $LN10@GetCursorI
	cmp	BYTE PTR _implicit_capture$1$[ebp], al
	jne	SHORT $LN10@GetCursorI

; 1370 :     }
; 1371 : 
; 1372 :     else
; 1373 :     {
; 1374 :       POINT client =
; 1375 :         SK_ImGui_Cursor.pos;

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	mov	DWORD PTR _client$1[ebp], eax
	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24

; 1376 : 
; 1377 :       SK_ImGui_Cursor.LocalToScreen (&client);
; 1378 : 
; 1379 :       pci->ptScreenPos.x = client.x;
; 1380 :       pci->ptScreenPos.y = client.y;

	jmp	SHORT $LN28@GetCursorI
$LN10@GetCursorI:

; 1362 :     {
; 1363 :       POINT client =
; 1364 :         SK_ImGui_Cursor.orig_pos;

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4
	mov	DWORD PTR _client$2[ebp], eax
	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+8
$LN28@GetCursorI:
	mov	DWORD PTR _client$2[ebp+4], eax

; 910  :   LocalToClient  (lpPoint);

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	lea	eax, DWORD PTR _client$2[ebp]
	push	eax
	call	?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::LocalToClient

; 911  :   ClientToScreen (game_window.hWnd, lpPoint);

	lea	eax, DWORD PTR _client$2[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__ClientToScreen@8

; 1365 : 
; 1366 :       SK_ImGui_Cursor.LocalToScreen (&client);
; 1367 : 
; 1368 :       pci->ptScreenPos.x = client.x;

	mov	eax, DWORD PTR _client$2[ebp]
	mov	DWORD PTR [ebx+12], eax

; 1369 :       pci->ptScreenPos.y = client.y;

	mov	eax, DWORD PTR _client$2[ebp+4]
	pop	edi
	mov	DWORD PTR [ebx+16], eax

; 1381 :     }
; 1382 : 
; 1383 :     return TRUE;

	mov	eax, 1
	pop	esi
	pop	ebx

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN27@GetCursorI:
	mov	ecx, DWORD PTR _ret$1$[ebp]
$LN4@GetCursorI:

; 1384 :   }
; 1385 : 
; 1386 : 
; 1387 :   pci->hCursor     = actual.hCursor;

	mov	eax, DWORD PTR _actual$$sroa$75$1$[ebp]
	mov	DWORD PTR [ebx+8], eax

; 1388 :   pci->ptScreenPos = actual.ptScreenPos;

	mov	eax, DWORD PTR _actual$1$[ebp]
	mov	DWORD PTR [ebx+12], eax
	mov	eax, DWORD PTR _actual$2$[ebp]
	pop	edi
	mov	DWORD PTR [ebx+16], eax

; 1389 : 
; 1390 :   return ret;

	mov	eax, ecx
	pop	esi
	pop	ebx

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCursorInfo_Detour@@YGHPAUtagCURSORINFO@@@Z ENDP	; GetCursorInfo_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_hCursor$ = 8						; size = 4
?SetCursor_Detour@@YGPAUHICON__@@PAU1@@Z PROC		; SetCursor_Detour

; 1313 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1314 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??SetCursor_Detour@@YGPAUHICON__@@PAU2@@Z@4_NA, 0
	jne	SHORT $LN2@SetCursor_
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@SetCursor_
	push	OFFSET $SG163277
	push	OFFSET $SG163278
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@SetCursor_:
	mov	BYTE PTR ?called@?2??SetCursor_Detour@@YGPAUHICON__@@PAU2@@Z@4_NA, 1
$LN2@SetCursor_:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	push	esi
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 1316 :   SK_ImGui_Cursor.orig_img = hCursor;

	mov	esi, DWORD PTR _hCursor$[ebp]
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A, esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	jne	SHORT $LN14@SetCursor_
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN14@SetCursor_
	xor	eax, eax
	jmp	SHORT $LN15@SetCursor_
$LN14@SetCursor_:
	mov	eax, 1
$LN15@SetCursor_:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN4@SetCursor_
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN4@SetCursor_
$LN17@SetCursor_:

; 1317 : 
; 1318 :   if (! SK_ImGui_IsMouseRelevant ())
; 1319 :     return SetCursor_Original (hCursor);

	push	esi
	call	DWORD PTR ?SetCursor_Original@@3P6GPAUHICON__@@PAU1@@ZA ; SetCursor_Original
	pop	esi

; 1324 : }

	pop	ebp
	ret	4
$LN4@SetCursor_:

; 1320 :   else if (! (ImGui::GetIO ().WantCaptureMouse || hCursor == nullptr))

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	cmp	BYTE PTR [eax+840], 0
	jne	SHORT $LN6@SetCursor_
	test	esi, esi
	jne	SHORT $LN17@SetCursor_
$LN6@SetCursor_:

; 1321 :     return SetCursor_Original (hCursor);
; 1322 : 
; 1323 :   return GetGameCursor ();

	call	?GetGameCursor@@YAPAUHICON__@@XZ	; GetGameCursor
	pop	esi

; 1324 : }

	pop	ebp
	ret	4
?SetCursor_Detour@@YGPAUHICON__@@PAU1@@Z ENDP		; SetCursor_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_cbSize$ = 8						; size = 4
_lppt$ = 12						; size = 4
_lpptBuf$ = 16						; size = 4
_nBufPoints$ = 20					; size = 4
_resolution$ = 24					; size = 4
?GetMouseMovePointsEx_Detour@@YGHIPAUtagMOUSEMOVEPOINT@@0HK@Z PROC ; GetMouseMovePointsEx_Detour

; 1280 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1281 :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetMouseMovePointsEx_Detour@@YGHIPAUtagMOUSEMOVEPOINT@@0HK@Z@4_NA, 0
	jne	SHORT $LN2@GetMouseMo
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@GetMouseMo
	push	OFFSET $SG163262
	push	OFFSET $SG163263
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@GetMouseMo:
	mov	BYTE PTR ?called@?2??GetMouseMovePointsEx_Detour@@YGHIPAUtagMOUSEMOVEPOINT@@0HK@Z@4_NA, 1
$LN2@GetMouseMo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	mov	dl, BYTE PTR ?SK_ImGui_Visible@@3_NA	; SK_ImGui_Visible
	mov	cl, BYTE PTR ?SK_ReShade_Visible@@3_NA	; SK_ReShade_Visible
	test	dl, dl
	jne	SHORT $LN17@GetMouseMo
	test	cl, cl
	jne	SHORT $LN17@GetMouseMo
	xor	eax, eax
	jmp	SHORT $LN18@GetMouseMo
$LN17@GetMouseMo:
	mov	eax, 1
$LN18@GetMouseMo:
	push	ebx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	mov	bl, BYTE PTR ?config@@3Usk_config_t@@A+740
	or	al, bl
	jne	SHORT $LN13@GetMouseMo
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	je	SHORT $LN8@GetMouseMo
	mov	bl, BYTE PTR ?config@@3Usk_config_t@@A+740
	mov	dl, BYTE PTR ?SK_ImGui_Visible@@3_NA	; SK_ImGui_Visible
	mov	cl, BYTE PTR ?SK_ReShade_Visible@@3_NA	; SK_ReShade_Visible
$LN13@GetMouseMo:

; 1282 : 
; 1283 :   if (SK_ImGui_IsMouseRelevant ())
; 1284 :   {
; 1285 :     bool implicit_capture = false;

	xor	bh, bh

; 1286 : 
; 1287 :     // Depending on warp prefs, we may not allow the game to know about mouse movement
; 1288 :     //   (even if ImGui doesn't want mouse capture)
; 1289 :     if ( ( SK_ImGui_Cursor.prefs.no_warp.ui_open && SK_ImGui_IsMouseRelevant ()       ) ||

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+38, bh
	je	SHORT $LN7@GetMouseMo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	test	dl, dl
	jne	SHORT $LN25@GetMouseMo
	test	cl, cl
	jne	SHORT $LN25@GetMouseMo
	xor	eax, eax
	jmp	SHORT $LN26@GetMouseMo
$LN25@GetMouseMo:
	mov	eax, 1
$LN26@GetMouseMo:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, bl
	jne	SHORT $LN6@GetMouseMo
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN6@GetMouseMo
$LN7@GetMouseMo:

; 1286 : 
; 1287 :     // Depending on warp prefs, we may not allow the game to know about mouse movement
; 1288 :     //   (even if ImGui doesn't want mouse capture)
; 1289 :     if ( ( SK_ImGui_Cursor.prefs.no_warp.ui_open && SK_ImGui_IsMouseRelevant ()       ) ||

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+36, 0
	je	SHORT $LN5@GetMouseMo
	call	?SK_InputUtil_IsHWCursorVisible@@YA_NXZ	; SK_InputUtil_IsHWCursorVisible
	test	al, al
	je	SHORT $LN5@GetMouseMo
$LN6@GetMouseMo:

; 1290 :          ( SK_ImGui_Cursor.prefs.no_warp.visible && SK_InputUtil_IsHWCursorVisible () )    )
; 1291 :     {
; 1292 :       implicit_capture = true;

	mov	bh, 1
$LN5@GetMouseMo:

; 1293 :     }
; 1294 : 
; 1295 :     if (SK_ImGui_WantMouseCapture () || implicit_capture)

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	jne	SHORT $LN9@GetMouseMo
	test	bh, bh
	jne	SHORT $LN9@GetMouseMo
$LN8@GetMouseMo:
	pop	ebx

; 1304 :     GetMouseMovePointsEx_Original (cbSize, lppt, lpptBuf, nBufPoints, resolution);
; 1305 : }

	pop	ebp

; 1300 :     }
; 1301 :   }
; 1302 : 
; 1303 :   return

	jmp	DWORD PTR ?GetMouseMovePointsEx_Original@@3P6GHIPAUtagMOUSEMOVEPOINT@@0HK@ZA ; GetMouseMovePointsEx_Original
$LN9@GetMouseMo:

; 1296 :     {
; 1297 :       *lpptBuf = *lppt;

	mov	eax, DWORD PTR _lppt$[ebp]
	pop	ebx
	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, DWORD PTR _lpptBuf$[ebp]
	movups	XMMWORD PTR [eax], xmm0

; 1298 : 
; 1299 :       return 0;

	xor	eax, eax

; 1304 :     GetMouseMovePointsEx_Original (cbSize, lppt, lpptBuf, nBufPoints, resolution);
; 1305 : }

	pop	ebp
	ret	20					; 00000014H
?GetMouseMovePointsEx_Detour@@YGHIPAUtagMOUSEMOVEPOINT@@0HK@Z ENDP ; GetMouseMovePointsEx_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_screen$1 = -8						; size = 8
?ImGui_ToggleCursor@@YAXXZ PROC				; ImGui_ToggleCursor

; 1221 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1222 :   if (! SK_ImGui_Cursor.visible)

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+28, 0
	jne	SHORT $LN2@ImGui_Togg

; 1223 :   {
; 1224 :     if (SK_ImGui_Cursor.orig_img == nullptr)

	cmp	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A, 0
	jne	SHORT $LN4@ImGui_Togg

; 1225 :       SK_ImGui_Cursor.orig_img = GetGameCursor ();

	call	?GetGameCursor@@YAPAUHICON__@@XZ	; GetGameCursor
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A, eax
$LN4@ImGui_Togg:

; 1226 : 
; 1227 :     //GetClipCursor         (&SK_ImGui_Cursor.clip_rect);
; 1228 : 
; 1229 :     SK_ImGui_CenterCursorOnWindow ();

	call	?SK_ImGui_CenterCursorOnWindow@@YAXXZ	; SK_ImGui_CenterCursorOnWindow

; 1230 : 
; 1231 :     // Save original cursor position
; 1232 :     GetCursorPos_Original         (&SK_ImGui_Cursor.pos);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	call	DWORD PTR ?GetCursorPos_Original@@3P6GHPAUtagPOINT@@@ZA ; GetCursorPos_Original

; 974  :   ScreenToClient (game_window.hWnd, lpPoint);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__ScreenToClient@8

; 975  :   ClientToLocal  (lpPoint);

	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::ClientToLocal

; 1233 :     SK_ImGui_Cursor.ScreenToLocal (&SK_ImGui_Cursor.pos);
; 1234 : 
; 1235 :     ImGui::GetIO ().WantCaptureMouse = true;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+840], 1

; 1236 :   }
; 1237 : 
; 1238 :   else

	jmp	SHORT $LN3@ImGui_Togg
$LN2@ImGui_Togg:

; 1239 :   {
; 1240 :     if (SK_ImGui_Cursor.orig_img == nullptr)

	cmp	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A, 0
	jne	SHORT $LN5@ImGui_Togg

; 1241 :       SK_ImGui_Cursor.orig_img = GetGameCursor ();

	call	?GetGameCursor@@YAPAUHICON__@@XZ	; GetGameCursor
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A, eax
$LN5@ImGui_Togg:

; 1242 : 
; 1243 :     if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN6@ImGui_Togg

; 1244 :     {
; 1245 :       //ClipCursor_Original   (&SK_ImGui_Cursor.clip_rect);
; 1246 : 
; 1247 :       POINT screen = SK_ImGui_Cursor.orig_pos;

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4

; 910  :   LocalToClient  (lpPoint);

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor

; 1244 :     {
; 1245 :       //ClipCursor_Original   (&SK_ImGui_Cursor.clip_rect);
; 1246 : 
; 1247 :       POINT screen = SK_ImGui_Cursor.orig_pos;

	mov	DWORD PTR _screen$1[ebp], eax
	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+8
	mov	DWORD PTR _screen$1[ebp+4], eax

; 910  :   LocalToClient  (lpPoint);

	lea	eax, DWORD PTR _screen$1[ebp]
	push	eax
	call	?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::LocalToClient

; 911  :   ClientToScreen (game_window.hWnd, lpPoint);

	lea	eax, DWORD PTR _screen$1[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__ClientToScreen@8

; 1248 :       SK_ImGui_Cursor.LocalToScreen (&screen);
; 1249 :       SetCursorPos_Original ( screen.x,

	push	DWORD PTR _screen$1[ebp+4]
	push	DWORD PTR _screen$1[ebp]
	call	DWORD PTR ?SetCursorPos_Original@@3P6GHHH@ZA ; SetCursorPos_Original
$LN6@ImGui_Togg:

; 1250 :                               screen.y );
; 1251 :     }
; 1252 : 
; 1253 :     ImGui::GetIO ().WantCaptureMouse = false;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+840], 0
$LN3@ImGui_Togg:

; 1254 :   }
; 1255 : 
; 1256 :   SK_ImGui_Cursor.visible = (! SK_ImGui_Cursor.visible);

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+28, 0

; 1257 :   SK_ImGui_Cursor.update ();

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	sete	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+28
	call	?update@sk_imgui_cursor_s@@QAEXXZ	; sk_imgui_cursor_s::update

; 1258 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ToggleCursor@@YAXXZ ENDP				; ImGui_ToggleCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_ci$ = -20						; size = 20
?ImGuiCursor_Impl@@YAXXZ PROC				; ImGuiCursor_Impl

; 1015 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	xorps	xmm0, xmm0

; 1016 :   CURSORINFO ci = { };

	mov	DWORD PTR _ci$[ebp+16], 0

; 1017 :   ci.cbSize     = sizeof CURSORINFO;
; 1018 : 
; 1019 :   GetCursorInfo_Original (&ci);

	lea	eax, DWORD PTR _ci$[ebp]
	movups	XMMWORD PTR _ci$[ebp], xmm0
	push	eax
	mov	DWORD PTR _ci$[ebp], 20			; 00000014H
	call	DWORD PTR ?GetCursorInfo_Original@@3P6GHPAUtagCURSORINFO@@@ZA ; GetCursorInfo_Original

; 1020 : 
; 1021 :   //
; 1022 :   // Hardware Cursor
; 1023 :   //
; 1024 :   if (config.input.ui.use_hw_cursor)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+684, 0
	je	SHORT $LN3@ImGuiCurso

; 1025 :     SetCursor_Original (ImGui_DesiredCursor ());

	call	?ImGui_DesiredCursor@@YAPAUHICON__@@XZ	; ImGui_DesiredCursor
	push	eax
	call	DWORD PTR ?SetCursor_Original@@3P6GPAUHICON__@@PAU1@@ZA ; SetCursor_Original

; 1026 : 
; 1027 :   if ( config.input.ui.use_hw_cursor && (ci.flags & CURSOR_SHOWING) )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+684, 0
	je	SHORT $LN3@ImGuiCurso
	test	BYTE PTR _ci$[ebp+4], 1
	je	SHORT $LN3@ImGuiCurso

; 1028 :   {
; 1029 :     ImGui::GetIO ().MouseDrawCursor = false;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+224], 0

; 1041 :     }
; 1042 :   }
; 1043 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ImGuiCurso:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN13@ImGuiCurso
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN13@ImGuiCurso
	xor	eax, eax
	jmp	SHORT $LN14@ImGuiCurso
$LN13@ImGuiCurso:
	mov	eax, 1
$LN14@ImGuiCurso:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN9@ImGuiCurso
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	je	SHORT $LN5@ImGuiCurso
$LN9@ImGuiCurso:
	push	ebx

; 1030 :   }
; 1031 :   
; 1032 :   //
; 1033 :   // Software
; 1034 :   //
; 1035 :   else
; 1036 :   {
; 1037 :     if (SK_ImGui_IsMouseRelevant ())
; 1038 :     {
; 1039 :       SetCursor_Original (nullptr);

	push	0
	call	DWORD PTR ?SetCursor_Original@@3P6GPAUHICON__@@PAU1@@ZA ; SetCursor_Original

; 1040 :       ImGui::GetIO ().MouseDrawCursor = (! SK_ImGui_Cursor.idle);

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+29, 0
	sete	bl
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+224], bl
	pop	ebx
$LN5@ImGuiCurso:

; 1041 :     }
; 1042 :   }
; 1043 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGuiCursor_Impl@@YAXXZ ENDP				; ImGuiCursor_Impl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?ImGui_DesiredCursor@@YAPAUHICON__@@XZ PROC		; ImGui_DesiredCursor

; 984  :   static HCURSOR last_cursor = nullptr;
; 985  : 
; 986  :   if (ImGui::GetIO ().MouseDownDuration [0] <= 0.0f || last_cursor == nullptr)

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+968]
	jae	SHORT $LN6@ImGui_Desi
	mov	eax, DWORD PTR ?last_cursor@?1??ImGui_DesiredCursor@@YAPAUHICON__@@XZ@4PAU2@A
	test	eax, eax
	jne	SHORT $LN1@ImGui_Desi
$LN6@ImGui_Desi:

; 987  :   {
; 988  :     switch (ImGui::GetMouseCursor ())

	call	?GetMouseCursor@ImGui@@YAHXZ		; ImGui::GetMouseCursor
	cmp	eax, 6
	ja	SHORT $LN2@ImGui_Desi
	jmp	DWORD PTR $LN16@ImGui_Desi[eax*4]
$LN7@ImGui_Desi:

; 989  :     {
; 990  :       case ImGuiMouseCursor_Arrow:
; 991  :         //SetCursor_Original ((last_cursor = LoadCursor (nullptr, IDC_ARROW)));
; 992  :         return ((last_cursor = LoadCursor (SK_GetDLL (), (LPCWSTR)IDC_CURSOR_POINTER)));

	push	115					; 00000073H
	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax

; 993  :         break;                          
; 994  :       case ImGuiMouseCursor_TextInput:  
; 995  :         return ((last_cursor = LoadCursor (nullptr, IDC_IBEAM)));

	call	DWORD PTR __imp__LoadCursorW@8
	mov	DWORD PTR ?last_cursor@?1??ImGui_DesiredCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax

; 1011 : }

	ret	0
$LN8@ImGui_Desi:

; 993  :         break;                          
; 994  :       case ImGuiMouseCursor_TextInput:  
; 995  :         return ((last_cursor = LoadCursor (nullptr, IDC_IBEAM)));

	push	32513					; 00007f01H
	push	0
	call	DWORD PTR __imp__LoadCursorW@8
	mov	DWORD PTR ?last_cursor@?1??ImGui_DesiredCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax
$LN1@ImGui_Desi:

; 1011 : }

	ret	0
$LN9@ImGui_Desi:

; 996  :         break;                          
; 997  :       case ImGuiMouseCursor_ResizeEW:
; 998  :         //SetCursor_Original ((last_cursor = LoadCursor (nullptr, IDC_SIZEWE)));
; 999  :         return ((last_cursor = LoadCursor (SK_GetDLL (), (LPCWSTR)IDC_CURSOR_HORZ)));

	push	118					; 00000076H
	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	call	DWORD PTR __imp__LoadCursorW@8
	mov	DWORD PTR ?last_cursor@?1??ImGui_DesiredCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax

; 1011 : }

	ret	0
$LN10@ImGui_Desi:

; 1000 :         break;                          
; 1001 :       case ImGuiMouseCursor_ResizeNWSE: 
; 1002 :         return ((last_cursor = LoadCursor (nullptr, IDC_SIZENWSE)));

	push	32642					; 00007f82H
	push	0
	call	DWORD PTR __imp__LoadCursorW@8
	mov	DWORD PTR ?last_cursor@?1??ImGui_DesiredCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax

; 1011 : }

	ret	0
$LN2@ImGui_Desi:

; 1003 :         break;
; 1004 :     }
; 1005 :   }
; 1006 : 
; 1007 :   else
; 1008 :     return (last_cursor);
; 1009 : 
; 1010 :   return GetCursor ();

	jmp	DWORD PTR __imp__GetCursor@0
	npad	1
$LN16@ImGui_Desi:

; 1011 : }

	DD	$LN7@ImGui_Desi
	DD	$LN8@ImGui_Desi
	DD	$LN2@ImGui_Desi
	DD	$LN2@ImGui_Desi
	DD	$LN9@ImGui_Desi
	DD	$LN2@ImGui_Desi
	DD	$LN10@ImGui_Desi
?ImGui_DesiredCursor@@YAPAUHICON__@@XZ ENDP		; ImGui_DesiredCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-in>@?1??ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-in>@?1??ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z@QAE@XZ PROC ; `sk_imgui_cursor_s::ClientToLocal'::`2'::<unnamed-type-in>::<unnamed-type-in>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 1065353216		; 3f800000H
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 1065353216		; 3f800000H
	ret	0
??0<unnamed-type-in>@?1??ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z@QAE@XZ ENDP ; `sk_imgui_cursor_s::ClientToLocal'::`2'::<unnamed-type-in>::<unnamed-type-in>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$max@M@std@@YAABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@M@std@@YAABMABM0@Z PROC				; std::max<float>, COMDAT

; 3742 : 	{	// return larger of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, DWORD PTR [eax]
	cmova	eax, ecx

; 3744 : 	}

	pop	ebp
	ret	0
??$max@M@std@@YAABMABM0@Z ENDP				; std::max<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-in>@?1??LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-in>@?1??LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z@QAE@XZ PROC ; `sk_imgui_cursor_s::LocalToClient'::`2'::<unnamed-type-in>::<unnamed-type-in>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 1065353216		; 3f800000H
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 1065353216		; 3f800000H
	ret	0
??0<unnamed-type-in>@?1??LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z@QAE@XZ ENDP ; `sk_imgui_cursor_s::LocalToClient'::`2'::<unnamed-type-in>::<unnamed-type-in>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ?SK_ImGui_IsMouseRelevant@@YA_NXZ
_TEXT	SEGMENT
?SK_ImGui_IsMouseRelevant@@YA_NXZ PROC			; SK_ImGui_IsMouseRelevant, COMDAT
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN7@SK_ImGui_I
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN7@SK_ImGui_I
	xor	eax, eax
	jmp	SHORT $LN8@SK_ImGui_I
$LN7@SK_ImGui_I:
	mov	eax, 1
$LN8@SK_ImGui_I:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN3@SK_ImGui_I
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN3@SK_ImGui_I

; 878  : }

	ret	0
$LN3@SK_ImGui_I:

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	mov	al, 1

; 878  : }

	ret	0
?SK_ImGui_IsMouseRelevant@@YA_NXZ ENDP			; SK_ImGui_IsMouseRelevant
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?GetGameCursor@@YAPAUHICON__@@XZ PROC			; GetGameCursor

; 1202 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetGameCursor@@YAPAUHICON__@@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 1203 :   static HCURSOR sk_imgui_arrow = LoadCursor (SK_GetDLL (), (LPCWSTR)IDC_CURSOR_POINTER);

	mov	eax, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR __tls_index
	push	esi
	mov	esi, DWORD PTR __imp__LoadCursorW@8
	push	edi
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[edi]
	jle	SHORT $LN2@GetGameCur
	push	OFFSET ?$TSS0@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA, -1
	jne	SHORT $LN2@GetGameCur
	push	115					; 00000073H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	call	esi
	push	OFFSET ?$TSS0@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
	mov	DWORD PTR ?sk_imgui_arrow@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 4
$LN2@GetGameCur:

; 1204 :   static HCURSOR sk_imgui_horz  = LoadCursor (SK_GetDLL (), (LPCWSTR)IDC_CURSOR_HORZ);

	mov	eax, DWORD PTR ?$TSS1@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[edi]
	jle	SHORT $LN3@GetGameCur
	push	OFFSET ?$TSS1@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS1@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA, -1
	jne	SHORT $LN3@GetGameCur
	push	118					; 00000076H
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	call	esi

; 1205 :   static HCURSOR sk_imgui_ibeam = LoadCursor (nullptr, IDC_IBEAM);

	push	32513					; 00007f01H
	push	0
	mov	DWORD PTR ?sk_imgui_horz@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax
	call	esi

; 1206 :   static HCURSOR sys_arrow      = LoadCursor (nullptr, IDC_ARROW);

	push	32512					; 00007f00H
	push	0
	mov	DWORD PTR ?sk_imgui_ibeam@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax
	call	esi

; 1207 :   static HCURSOR sys_wait       = LoadCursor (nullptr, IDC_WAIT);

	push	32514					; 00007f02H
	push	0
	mov	DWORD PTR ?sys_arrow@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax
	call	esi
	push	OFFSET ?$TSS1@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
	mov	DWORD PTR ?sys_wait@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax
	call	__Init_thread_footer
	add	esp, 4
$LN3@GetGameCur:

; 1208 : 
; 1209 :   static HCURSOR hCurLast = nullptr;
; 1210 :          HCURSOR hCur     = GetCursor ();

	call	DWORD PTR __imp__GetCursor@0
	mov	ecx, eax

; 1211 : 
; 1212 :   if ( hCur != sk_imgui_horz && hCur != sk_imgui_arrow && hCur != sk_imgui_ibeam &&
; 1213 :        hCur != sys_arrow     && hCur != sys_wait )

	mov	eax, DWORD PTR ?hCurLast@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
	cmp	ecx, DWORD PTR ?sk_imgui_horz@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
	je	SHORT $LN7@GetGameCur
	cmp	ecx, DWORD PTR ?sk_imgui_arrow@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
	je	SHORT $LN7@GetGameCur
	cmp	ecx, DWORD PTR ?sk_imgui_ibeam@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
	je	SHORT $LN7@GetGameCur
	cmp	ecx, DWORD PTR ?sys_arrow@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
	je	SHORT $LN7@GetGameCur
	cmp	ecx, DWORD PTR ?sys_wait@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A
	cmovne	eax, ecx
	mov	DWORD PTR ?hCurLast@?1??GetGameCursor@@YAPAUHICON__@@XZ@4PAU2@A, eax
$LN7@GetGameCur:

; 1214 :     hCurLast = hCur;
; 1215 : 
; 1216 :   return hCurLast;
; 1217 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetGameCursor@@YAPAUHICON__@@XZ$0:
	push	OFFSET ?$TSS0@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__unwindfunclet$?GetGameCursor@@YAPAUHICON__@@XZ$1:
	push	OFFSET ?$TSS1@?1??GetGameCursor@@YAPAUHICON__@@XZ@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__ehhandler$?GetGameCursor@@YAPAUHICON__@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetGameCursor@@YAPAUHICON__@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGameCursor@@YAPAUHICON__@@XZ ENDP			; GetGameCursor
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_hRawInput$ = 8						; size = 4
_uiCommand$ = 12					; size = 4
_pData$ = 16						; size = 4
_pcbSize$ = 20						; size = 4
_cbSizeHeader$ = 24					; size = 4
?GetRawInputData_Detour@@YGIPAUHRAWINPUT__@@IPAXPAII@Z PROC ; GetRawInputData_Detour

; 853  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 854  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetRawInputData_Detour@@YGIPAUHRAWINPUT__@@IPAXPAII@Z@4_NA, 0
	jne	SHORT $LN2@GetRawInpu
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@GetRawInpu
	push	OFFSET $SG162980
	push	OFFSET $SG162981
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@GetRawInpu:
	mov	BYTE PTR ?called@?2??GetRawInputData_Detour@@YGIPAUHRAWINPUT__@@IPAXPAII@Z@4_NA, 1
$LN2@GetRawInpu:

; 855  : 
; 856  :   return SK_ImGui_ProcessRawInput (hRawInput, uiCommand, pData, pcbSize, cbSizeHeader, false);

	push	0
	push	DWORD PTR _cbSizeHeader$[ebp]
	push	DWORD PTR _pcbSize$[ebp]
	push	DWORD PTR _pData$[ebp]
	push	DWORD PTR _uiCommand$[ebp]
	push	DWORD PTR _hRawInput$[ebp]
	call	?SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z ; SK_ImGui_ProcessRawInput

; 857  : }

	pop	ebp
	ret	20					; 00000014H
?GetRawInputData_Detour@@YGIPAUHRAWINPUT__@@IPAXPAII@Z ENDP ; GetRawInputData_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_pTemp$1$ = -12						; size = 4
_cbSize$1 = -8						; size = 4
_count$1$ = -4						; size = 4
_pData$ = 8						; size = 4
_pcbSize$ = 12						; size = 4
_temp_ret$1$ = 16					; size = 4
_cbSizeHeader$ = 16					; size = 4
?GetRawInputBuffer_Detour@@YGIPAUtagRAWINPUT@@PAII@Z PROC ; GetRawInputBuffer_Detour

; 750  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 751  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetRawInputBuffer_Detour@@YGIPAUtagRAWINPUT@@PAII@Z@4_NA, 0
	jne	SHORT $LN7@GetRawInpu
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN8@GetRawInpu
	push	OFFSET $SG162946
	push	OFFSET $SG162947
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN8@GetRawInpu:
	mov	BYTE PTR ?called@?2??GetRawInputBuffer_Detour@@YGIPAUtagRAWINPUT@@PAII@Z@4_NA, 1
$LN7@GetRawInpu:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN26@GetRawInpu
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	je	$LN53@GetRawInpu
$LN26@GetRawInpu:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 755  :     ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 756  :       ImGui::GetIO ();
; 757  : 
; 758  :     bool filter = false;

	xor	cl, cl

; 759  : 
; 760  :     // Unconditional
; 761  :     if (config.input.ui.capture)

	mov	edx, 1
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+680, 0
	movzx	ecx, cl
	cmovne	ecx, edx

; 762  :       filter = true;
; 763  : 
; 764  :     // Only specific types
; 765  :     if (io.WantCaptureKeyboard || io.WantCaptureMouse)

	cmp	BYTE PTR [eax+841], 0
	jne	SHORT $LN51@GetRawInpu
	cmp	BYTE PTR [eax+840], 0
	jne	SHORT $LN51@GetRawInpu

; 766  :       filter = true;
; 767  : 
; 768  :     if (filter)

	test	cl, cl
	je	$LN53@GetRawInpu
$LN51@GetRawInpu:

; 769  :     {
; 770  :       if (pData != nullptr)

	mov	eax, DWORD PTR _pData$[ebp]
	test	eax, eax
	je	$LN14@GetRawInpu

; 771  :       {
; 772  :         ZeroMemory (pData, *pcbSize);

	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _pcbSize$[ebp]
	push	DWORD PTR [edi]
	push	0
	push	eax
	call	_memset

; 773  :         const int max_items = (sizeof RAWINPUT / *pcbSize);

	mov	esi, 40					; 00000028H
	xor	edx, edx
	mov	eax, esi

; 774  :               int count     =                            0;
; 775  :             auto *pTemp     = (uint8_t *)
; 776  :                                   new RAWINPUT [max_items];

	xor	ecx, ecx
	div	DWORD PTR [edi]
	xor	ebx, ebx
	mul	esi
	mov	DWORD PTR _count$1$[ebp], ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 777  :         uint8_t *pInput     =                        pTemp;
; 778  :            auto *pOutput    =             (uint8_t *)pData;
; 779  :         UINT     cbSize     =                     *pcbSize;

	mov	ecx, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbSize$1[ebp], ecx
	mov	esi, eax

; 780  :                   *pcbSize  =                            0;
; 781  : 
; 782  :         int       temp_ret  =
; 783  :           GetRawInputBuffer_Original ( (RAWINPUT *)pTemp, &cbSize, cbSizeHeader );

	lea	ecx, DWORD PTR _cbSize$1[ebp]
	mov	DWORD PTR _pTemp$1$[ebp], eax
	mov	DWORD PTR [edi], ebx
	push	DWORD PTR _cbSizeHeader$[ebp]
	push	ecx
	push	eax
	call	DWORD PTR ?GetRawInputBuffer_Original@@3P6GIPAUtagRAWINPUT@@PAII@ZA ; GetRawInputBuffer_Original
	mov	DWORD PTR _temp_ret$1$[ebp], eax

; 784  : 
; 785  :         for (int i = 0; i < temp_ret; i++)

	test	eax, eax
	jle	$LN3@GetRawInpu
$LL4@GetRawInpu:

; 786  :         {
; 787  :           auto* pItem = (RAWINPUT *)pInput;
; 788  : 
; 789  :           bool  remove = false;
; 790  :           int  advance = pItem->header.dwSize;
; 791  : 
; 792  :           switch (pItem->header.dwType)

	mov	eax, DWORD PTR [esi]
	xor	bl, bl
	mov	edi, DWORD PTR [esi+4]
	sub	eax, 0
	je	SHORT $LN17@GetRawInpu
	sub	eax, 1
	je	SHORT $LN15@GetRawInpu
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_RawInput_Backend@@3Usk_input_api_context_s@@A+40
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 808  :               if (SK_ImGui_WantGamepadCapture ())

	call	?SK_ImGui_WantGamepadCapture@@YA_NXZ	; SK_ImGui_WantGamepadCapture
	test	al, al
	je	SHORT $LN18@GetRawInpu

; 809  :                 remove = true;

	mov	bl, 1
	jmp	SHORT $LN18@GetRawInpu
$LN15@GetRawInpu:
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_RawInput_Backend@@3Usk_input_api_context_s@@A+36
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 796  :               if (SK_ImGui_WantKeyboardCapture ())

	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture
	test	al, al
	je	SHORT $LN18@GetRawInpu

; 797  :                 remove = true;

	mov	bl, 1

; 798  :               break;

	jmp	SHORT $LN18@GetRawInpu
$LN17@GetRawInpu:
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_RawInput_Backend@@3Usk_input_api_context_s@@A+32
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 802  :               if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	movzx	ebx, bl
	mov	eax, 1
	cmovne	ebx, eax
$LN18@GetRawInpu:

; 810  :               break;
; 811  :           }
; 812  : 
; 813  :           if (config.input.ui.capture)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+680, 0
	jne	SHORT $LN55@GetRawInpu

; 814  :             remove = true;
; 815  : 
; 816  :           if (! remove)

	test	bl, bl
	jne	SHORT $LN55@GetRawInpu

; 817  :           {
; 818  :             memcpy (pOutput, pItem, pItem->header.dwSize);

	push	DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _pData$[ebp]
	push	esi
	push	ebx
	call	_memcpy

; 819  :              pOutput += advance;
; 820  :                         ++count;
; 821  :             *pcbSize += advance;

	mov	eax, DWORD PTR _pcbSize$[ebp]
	add	ebx, edi
	mov	DWORD PTR _pData$[ebp], ebx
	add	esp, 12					; 0000000cH
	mov	ebx, DWORD PTR _count$1$[ebp]
	inc	ebx
	add	DWORD PTR [eax], edi
	mov	DWORD PTR _count$1$[ebp], ebx
	jmp	SHORT $LN22@GetRawInpu
$LN55@GetRawInpu:
	mov	ebx, DWORD PTR _count$1$[ebp]
$LN22@GetRawInpu:

; 822  :           }
; 823  :           
; 824  :           pInput += advance;

	add	esi, edi
	sub	DWORD PTR _temp_ret$1$[ebp], 1
	jne	$LL4@GetRawInpu
$LN3@GetRawInpu:

; 825  :         }
; 826  : 
; 827  :         delete [] pTemp;

	push	DWORD PTR _pTemp$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 828  : 
; 829  :         return count;

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 835  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN53@GetRawInpu:
	mov	eax, DWORD PTR _pData$[ebp]
$LN14@GetRawInpu:

; 830  :       }
; 831  :     }
; 832  :   }
; 833  : 
; 834  :   return GetRawInputBuffer_Original (pData, pcbSize, cbSizeHeader);

	push	DWORD PTR _cbSizeHeader$[ebp]
	push	DWORD PTR _pcbSize$[ebp]
	push	eax
	call	DWORD PTR ?GetRawInputBuffer_Original@@3P6GIPAUtagRAWINPUT@@PAII@ZA ; GetRawInputBuffer_Original

; 835  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetRawInputBuffer_Detour@@YGIPAUtagRAWINPUT@@PAII@Z ENDP ; GetRawInputBuffer_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_override_keyboards$ = -60				; size = 12
_override_mice$ = -48					; size = 12
_override_gamepads$ = -36				; size = 12
_actual_device_list$ = -24				; size = 12
__$EHRec$ = -12						; size = 12
_bRet$1$ = 8						; size = 4
_pRawInputDevices$ = 8					; size = 4
_uiNumDevices$ = 12					; size = 4
_pDevices$1$ = 16					; size = 4
_cbSize$ = 16						; size = 4
?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z PROC ; RegisterRawInputDevices_Detour

; 677  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H

; 678  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z@4_NA, 0
	jne	SHORT $LN14@RegisterRa
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN15@RegisterRa
	push	OFFSET $SG162904
	push	OFFSET $SG162905
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN15@RegisterRa:
	mov	BYTE PTR ?called@?2??RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z@4_NA, 1
$LN14@RegisterRa:
	push	esi

; 679  : 
; 680  :   if (cbSize != sizeof RAWINPUTDEVICE)

	mov	esi, DWORD PTR _cbSize$[ebp]
	cmp	esi, 12					; 0000000cH
	je	SHORT $LN16@RegisterRa

; 681  :   {
; 682  :     dll_log.Log ( L"[ RawInput ] RegisterRawInputDevices has wrong "

	push	12					; 0000000cH
	push	esi
	push	OFFSET $SG162907
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 683  :                   L"structure size (%lu bytes), expected: %zu",
; 684  :                     cbSize,
; 685  :                       sizeof RAWINPUTDEVICE );
; 686  : 
; 687  :     return

	push	esi
	push	DWORD PTR _uiNumDevices$[ebp]
	push	DWORD PTR _pRawInputDevices$[ebp]
	call	DWORD PTR ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
	pop	esi

; 734  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN16@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, eax
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 695  :   RAWINPUTDEVICE* pDevices = nullptr;

	xor	eax, eax
	push	ebx
	push	edi

; 696  : 
; 697  :   if (pRawInputDevices && uiNumDevices > 0)

	mov	edi, DWORD PTR _uiNumDevices$[ebp]
	mov	DWORD PTR _pDevices$1$[ebp], eax
	cmp	DWORD PTR _pRawInputDevices$[ebp], eax
	je	SHORT $LN17@RegisterRa
	test	edi, edi
	je	SHORT $LN17@RegisterRa

; 698  :     pDevices = new RAWINPUTDEVICE [uiNumDevices];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR _pDevices$1$[ebp], eax
$LN17@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	xor	ebx, ebx
	mov	DWORD PTR _actual_device_list$[ebp], ebx

; 477  : 		_Mylast(),

	mov	DWORD PTR _actual_device_list$[ebp+4], ebx

; 478  : 		_Myend()

	mov	DWORD PTR _actual_device_list$[ebp+8], ebx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 701  :   std::vector <RAWINPUTDEVICE> actual_device_list;

	mov	DWORD PTR __$EHRec$[ebp+8], ebx

; 702  : 
; 703  :   if (pDevices != nullptr)

	test	eax, eax
	je	SHORT $LN18@RegisterRa

; 706  :     for (unsigned int i = 0; i < uiNumDevices; i++)

	test	edi, edi
	je	SHORT $LN3@RegisterRa
	mov	ebx, DWORD PTR _pRawInputDevices$[ebp]
	mov	esi, eax
	sub	ebx, eax
$LL4@RegisterRa:

; 708  :       pDevices [i] = pRawInputDevices [i];

	movq	xmm0, QWORD PTR [ebx+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	mov	ecx, OFFSET ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_devices
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 708  :       pDevices [i] = pRawInputDevices [i];

	movq	QWORD PTR [esi], xmm0
	mov	eax, DWORD PTR [ebx+esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 708  :       pDevices [i] = pRawInputDevices [i];

	mov	DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 706  :     for (unsigned int i = 0; i < uiNumDevices; i++)

	add	esi, 12					; 0000000cH
	sub	edi, 1
	jne	SHORT $LL4@RegisterRa
	xor	ebx, ebx
$LN3@RegisterRa:

; 709  :       raw_devices.push_back (pDevices [i]);
; 710  :     }
; 711  : 
; 712  :     SK_RawInput_ClassifyDevices ();

	call	?SK_RawInput_ClassifyDevices@@YAXXZ	; SK_RawInput_ClassifyDevices
$LN18@RegisterRa:

; 713  :   }
; 714  : 
; 715  :   std::vector <RAWINPUTDEVICE> override_keyboards = SK_RawInput_GetKeyboards          ();

	lea	eax, DWORD PTR _override_keyboards$[ebp]
	push	0
	push	eax
	call	?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z ; SK_RawInput_GetKeyboards

; 716  :   std::vector <RAWINPUTDEVICE> override_mice      = SK_RawInput_GetMice               ();

	lea	eax, DWORD PTR _override_mice$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	push	eax
	call	?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z ; SK_RawInput_GetMice
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 717  :   std::vector <RAWINPUTDEVICE> override_gamepads  = SK_RawInput_GetRegisteredGamepads ();

	call	?SK_RawInput_GetRegisteredGamepads@@YAAAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@XZ ; SK_RawInput_GetRegisteredGamepads
	push	eax
	lea	ecx, DWORD PTR _override_gamepads$[ebp]
	call	??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@ABV01@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >

; 719  :   for (auto& it : override_keyboards) actual_device_list.push_back (it);

	mov	esi, DWORD PTR _override_keyboards$[ebp]
	mov	edi, DWORD PTR _override_keyboards$[ebp+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	esi, edi
	je	SHORT $LN6@RegisterRa
	npad	8
$LL7@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _actual_device_list$[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 719  :   for (auto& it : override_keyboards) actual_device_list.push_back (it);

	cmp	esi, edi
	jne	SHORT $LL7@RegisterRa
	mov	ebx, DWORD PTR _actual_device_list$[ebp]
$LN6@RegisterRa:

; 720  :   for (auto& it : override_mice)      actual_device_list.push_back (it);

	mov	esi, DWORD PTR _override_mice$[ebp]
	mov	edi, DWORD PTR _override_mice$[ebp+4]
	cmp	esi, edi
	je	SHORT $LN9@RegisterRa
	npad	3
$LL10@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _actual_device_list$[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 720  :   for (auto& it : override_mice)      actual_device_list.push_back (it);

	cmp	esi, edi
	jne	SHORT $LL10@RegisterRa
	mov	ebx, DWORD PTR _actual_device_list$[ebp]
$LN9@RegisterRa:

; 721  :   for (auto& it : override_gamepads)  actual_device_list.push_back (it);

	mov	edi, DWORD PTR _override_gamepads$[ebp]
	mov	esi, edi
	cmp	edi, DWORD PTR _override_gamepads$[ebp+4]
	je	SHORT $LN12@RegisterRa
	mov	ebx, DWORD PTR _override_gamepads$[ebp+4]
$LL13@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _actual_device_list$[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 721  :   for (auto& it : override_gamepads)  actual_device_list.push_back (it);

	cmp	esi, ebx
	jne	SHORT $LL13@RegisterRa
	mov	ebx, DWORD PTR _actual_device_list$[ebp]
$LN12@RegisterRa:

; 724  :     pDevices != nullptr ?

	mov	esi, DWORD PTR _pDevices$1$[ebp]
	test	esi, esi
	je	SHORT $LN21@RegisterRa
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR _actual_device_list$[ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, ebx
	imul	ecx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 724  :     pDevices != nullptr ?

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 724  :     pDevices != nullptr ?

	push	eax
	push	ebx
	call	DWORD PTR ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original

; 725  :       RegisterRawInputDevices_Original ( actual_device_list.data   (),
; 726  :                        static_cast <UINT> (actual_device_list.size () ),
; 727  :                                              cbSize ) :
; 728  :                 FALSE;
; 729  : 
; 730  :   if (pDevices)
; 731  :     delete [] pDevices;

	push	esi
	mov	DWORD PTR _bRet$1$[ebp], eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	jmp	SHORT $LN19@RegisterRa
$LN21@RegisterRa:

; 724  :     pDevices != nullptr ?

	mov	DWORD PTR _bRet$1$[ebp], 0
$LN19@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	edi, edi
	je	SHORT $LN326@RegisterRa

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _override_gamepads$[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, edi
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN393@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN777@RegisterRa:
$LN393@RegisterRa:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN398@RegisterRa

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR _override_gamepads$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN395@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN778@RegisterRa:
$LN395@RegisterRa:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	edi, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	edi, eax
	jb	SHORT $LN396@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN779@RegisterRa:
$LN396@RegisterRa:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, edi
	cmp	eax, 4
	jae	SHORT $LN397@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN780@RegisterRa:
$LN397@RegisterRa:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN398@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN781@RegisterRa:
$LN398@RegisterRa:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN326@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	esi, DWORD PTR _override_mice$[ebp]
	test	esi, esi
	je	SHORT $LN436@RegisterRa

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _override_mice$[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, esi
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN503@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN782@RegisterRa:
$LN503@RegisterRa:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN508@RegisterRa

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR _override_mice$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN505@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN783@RegisterRa:
$LN505@RegisterRa:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	esi, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	esi, eax
	jb	SHORT $LN506@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN784@RegisterRa:
$LN506@RegisterRa:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, esi
	cmp	eax, 4
	jae	SHORT $LN507@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN785@RegisterRa:
$LN507@RegisterRa:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN508@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN786@RegisterRa:
$LN508@RegisterRa:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN436@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	esi, DWORD PTR _override_keyboards$[ebp]
	test	esi, esi
	je	SHORT $LN545@RegisterRa

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _override_keyboards$[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, esi
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN612@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN787@RegisterRa:
$LN612@RegisterRa:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN617@RegisterRa

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR _override_keyboards$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN614@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN788@RegisterRa:
$LN614@RegisterRa:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	esi, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	esi, eax
	jb	SHORT $LN615@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN789@RegisterRa:
$LN615@RegisterRa:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, esi
	cmp	eax, 4
	jae	SHORT $LN616@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN790@RegisterRa:
$LN616@RegisterRa:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN617@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN791@RegisterRa:
$LN617@RegisterRa:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN545@RegisterRa:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	ebx, ebx
	je	SHORT $LN654@RegisterRa

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _actual_device_list$[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, ebx
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN721@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN792@RegisterRa:
$LN721@RegisterRa:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN722@RegisterRa

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bl, 31					; 0000001fH
	je	SHORT $LN723@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN793@RegisterRa:
$LN723@RegisterRa:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ebx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ebx
	jb	SHORT $LN724@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN794@RegisterRa:
$LN724@RegisterRa:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ebx, eax
	cmp	ebx, 4
	jae	SHORT $LN725@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN795@RegisterRa:
$LN725@RegisterRa:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ebx, 35					; 00000023H
	jbe	SHORT $LN726@RegisterRa
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN796@RegisterRa:
$LN726@RegisterRa:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ebx, eax
$LN722@RegisterRa:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN654@RegisterRa:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 734  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, DWORD PTR _bRet$1$[ebp]
	pop	edi
	pop	ebx
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN776@RegisterRa:
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z$0:
	lea	ecx, DWORD PTR _actual_device_list$[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__unwindfunclet$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z$1:
	lea	ecx, DWORD PTR _override_keyboards$[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__unwindfunclet$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z$2:
	lea	ecx, DWORD PTR _override_mice$[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__unwindfunclet$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z$3:
	lea	ecx, DWORD PTR _override_gamepads$[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__ehhandler$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z:
	mov	eax, OFFSET __ehfuncinfo$?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RegisterRawInputDevices_Detour@@YGHPBUtagRAWINPUTDEVICE@@II@Z ENDP ; RegisterRawInputDevices_Detour
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_pRawInputDevices$ = 8					; size = 4
_puiNumDevices$ = 12					; size = 4
_cbSize$ = 16						; size = 4
?GetRegisteredRawInputDevices_Detour@@YGIPAUtagRAWINPUTDEVICE@@PAII@Z PROC ; GetRegisteredRawInputDevices_Detour

; 628  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 629  :   UNREFERENCED_PARAMETER (cbSize);
; 630  : 
; 631  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??GetRegisteredRawInputDevices_Detour@@YGIPAUtagRAWINPUTDEVICE@@PAII@Z@4_NA, 0
	jne	SHORT $LN5@GetRegiste
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN6@GetRegiste
	push	OFFSET $SG162819
	push	OFFSET $SG162820
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN6@GetRegiste:
	mov	BYTE PTR ?called@?2??GetRegisteredRawInputDevices_Detour@@YGIPAUtagRAWINPUTDEVICE@@PAII@Z@4_NA, 1
$LN5@GetRegiste:
	push	esi

; 632  : 
; 633  :   assert (cbSize == sizeof RAWINPUTDEVICE);
; 634  : 
; 635  :   // On the first call to this function, we will need to query this stuff.
; 636  :   static bool init = false;
; 637  : 
; 638  :   //if (! init)
; 639  :   //{
; 640  :     SK_RawInput_PopulateDeviceList ();

	call	?SK_RawInput_PopulateDeviceList@@YAIXZ	; SK_RawInput_PopulateDeviceList
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	mov	edx, esi
	sub	edx, ecx
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 645  :   if (*puiNumDevices < static_cast <UINT> (raw_devices.size ()))

	mov	edx, DWORD PTR _puiNumDevices$[ebp]
	cmp	DWORD PTR [edx], eax
	jae	SHORT $LN7@GetRegiste

; 646  :   {
; 647  :       *puiNumDevices = static_cast <UINT> (raw_devices.size ());
; 648  : 
; 649  :     SetLastError (ERROR_INSUFFICIENT_BUFFER);

	push	122					; 0000007aH
	mov	DWORD PTR [edx], eax
	call	DWORD PTR __imp__SetLastError@4

; 650  : 
; 651  :     return std::numeric_limits <UINT>::max ();

	or	eax, -1
	pop	esi

; 671  : }

	pop	ebp
	ret	12					; 0000000cH
$LN7@GetRegiste:

; 652  :   }
; 653  : 
; 654  :   int idx = 0;
; 655  : 
; 656  :   if (pRawInputDevices)

	mov	edx, DWORD PTR _pRawInputDevices$[ebp]
	push	edi
	xor	edi, edi
	test	edx, edx
	je	SHORT $LN8@GetRegiste

; 657  :   {
; 658  :     for (auto it : raw_devices)

	cmp	ecx, esi
	je	SHORT $LN9@GetRegiste
$LL4@GetRegiste:
	movq	xmm0, QWORD PTR [ecx]

; 660  :       pRawInputDevices [idx++] = it;

	lea	edx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [ecx+8]
	inc	edi
	movq	QWORD PTR [edx-12], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 107  : 		++_Ptr;

	add	ecx, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 660  :       pRawInputDevices [idx++] = it;

	mov	DWORD PTR [edx-4], eax
	cmp	ecx, esi
	jne	SHORT $LL4@GetRegiste

; 667  :       static_cast <int> (raw_devices.size ());
; 668  :   }
; 669  : 
; 670  :   return idx;

	mov	eax, edi
	pop	edi
	pop	esi

; 671  : }

	pop	ebp
	ret	12					; 0000000cH
$LN8@GetRegiste:

; 661  :     }
; 662  :   }
; 663  : 
; 664  :   else
; 665  :   {
; 666  :     idx +=

	mov	edi, eax
$LN9@GetRegiste:

; 667  :       static_cast <int> (raw_devices.size ());
; 668  :   }
; 669  : 
; 670  :   return idx;

	mov	eax, edi
	pop	edi
	pop	esi

; 671  : }

	pop	ebp
	ret	12					; 0000000cH
?GetRegisteredRawInputDevices_Detour@@YGIPAUtagRAWINPUTDEVICE@@PAII@Z ENDP ; GetRegisteredRawInputDevices_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_uiNumDevices$ = -4					; size = 4
?SK_RawInput_PopulateDeviceList@@YAIXZ PROC		; SK_RawInput_PopulateDeviceList

; 581  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, eax
	mov	eax, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	mov	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, eax
	mov	eax, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	push	esi
	mov	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, eax
	mov	eax, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	push	edi
	mov	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, eax
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 587  :   DWORD            dwLastError = GetLastError ();

	call	DWORD PTR __imp__GetLastError@0
	mov	esi, eax

; 588  :   RAWINPUTDEVICE*  pDevices    = nullptr;
; 589  :   UINT            uiNumDevices = 0;

	mov	DWORD PTR _uiNumDevices$[ebp], 0

; 590  : 
; 591  :   UINT ret =
; 592  :     GetRegisteredRawInputDevices_Original ( pDevices,

	push	12					; 0000000cH
	lea	eax, DWORD PTR _uiNumDevices$[ebp]
	push	eax
	push	0
	call	DWORD PTR ?GetRegisteredRawInputDevices_Original@@3P6GIPAUtagRAWINPUTDEVICE@@PAII@ZA ; GetRegisteredRawInputDevices_Original

; 593  :                                               &uiNumDevices,
; 594  :                                                 sizeof RAWINPUTDEVICE );
; 595  : 
; 596  :   assert (ret == -1);
; 597  : 
; 598  :   SetLastError (dwLastError);

	push	esi
	mov	edi, eax
	call	DWORD PTR __imp__SetLastError@4

; 599  : 
; 600  :   if (uiNumDevices != 0 && ret == -1)

	mov	eax, DWORD PTR _uiNumDevices$[ebp]
	test	eax, eax
	je	SHORT $LN5@SK_RawInpu
	cmp	edi, -1
	jne	SHORT $LN5@SK_RawInpu

; 601  :   {
; 602  :     pDevices = new

	xor	ecx, ecx
	inc	eax
	mov	edx, 12					; 0000000cH
	mul	edx
	push	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	ebx, eax

; 603  :       RAWINPUTDEVICE [uiNumDevices + 1];
; 604  : 
; 605  :     GetRegisteredRawInputDevices_Original ( pDevices,

	lea	eax, DWORD PTR _uiNumDevices$[ebp]
	push	12					; 0000000cH
	push	eax
	push	ebx
	call	DWORD PTR ?GetRegisteredRawInputDevices_Original@@3P6GIPAUtagRAWINPUTDEVICE@@PAII@ZA ; GetRegisteredRawInputDevices_Original
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	ecx, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 611  :     for (UINT i = 0; i < uiNumDevices; i++)

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, ecx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 611  :     for (UINT i = 0; i < uiNumDevices; i++)

	cmp	DWORD PTR _uiNumDevices$[ebp], edi
	jbe	SHORT $LN3@SK_RawInpu

; 601  :   {
; 602  :     pDevices = new

	mov	esi, ebx
$LL4@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	mov	ecx, OFFSET ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_devices
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 611  :     for (UINT i = 0; i < uiNumDevices; i++)

	inc	edi
	add	esi, 12					; 0000000cH
	cmp	edi, DWORD PTR _uiNumDevices$[ebp]
	jb	SHORT $LL4@SK_RawInpu
$LN3@SK_RawInpu:

; 612  :       raw_devices.push_back (pDevices [i]);
; 613  : 
; 614  :     SK_RawInput_ClassifyDevices ();

	call	?SK_RawInput_ClassifyDevices@@YAXXZ	; SK_RawInput_ClassifyDevices

; 615  : 
; 616  :     delete [] pDevices;

	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]

; 617  :   }
; 618  : 
; 619  :   return uiNumDevices;

	mov	eax, DWORD PTR _uiNumDevices$[ebp]
	add	esp, 4
	pop	ebx
$LN5@SK_RawInpu:
	pop	edi
	pop	esi

; 620  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_RawInput_PopulateDeviceList@@YAIXZ ENDP		; SK_RawInput_PopulateDeviceList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_RawInput_ClassifyDevices@@YAXXZ PROC		; SK_RawInput_ClassifyDevices
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	push	esi

; 42   : 		: _Ptr(_Parg)

	mov	esi, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A

; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, eax
	mov	eax, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	push	edi

; 42   : 		: _Ptr(_Parg)

	mov	edi, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4

; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, eax
	mov	eax, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	mov	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, eax

; 206  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 552  :   for (auto& it : raw_devices)

	je	SHORT $LN3@SK_RawInpu
$LL4@SK_RawInpu:

; 553  :   {
; 554  :     if ((it).usUsagePage == HID_USAGE_PAGE_GENERIC)

	cmp	WORD PTR [esi], 1
	jne	SHORT $LN2@SK_RawInpu

; 555  :     {
; 556  :       switch ((it).usUsage)

	movzx	eax, WORD PTR [esi+2]
	add	eax, -2					; fffffffeH
	cmp	eax, 4
	ja	SHORT $LN2@SK_RawInpu
	jmp	DWORD PTR $LN210@SK_RawInpu[eax*4]
$LN8@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	mov	ecx, OFFSET ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_mice
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 560  :           break;

	jmp	SHORT $LN208@SK_RawInpu
$LN9@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	mov	ecx, OFFSET ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_keyboards
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 564  :           break;

	jmp	SHORT $LN208@SK_RawInpu
$LN10@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	mov	ecx, OFFSET ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_gamepads
$LN208@SK_RawInpu:
	push	esi
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>
$LN2@SK_RawInpu:

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH

; 206  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 552  :   for (auto& it : raw_devices)

	jne	SHORT $LL4@SK_RawInpu
$LN3@SK_RawInpu:
	pop	edi
	pop	esi

; 565  : 
; 566  :         case HID_USAGE_GENERIC_JOYSTICK: // Joystick
; 567  :         case HID_USAGE_GENERIC_GAMEPAD:  // Gamepad
; 568  :           raw_gamepads.push_back   (it);
; 569  :           break;
; 570  : 
; 571  :         default:
; 572  :           // UH OH, what the heck is this device?
; 573  :           break;
; 574  :       }
; 575  :     }
; 576  :   }
; 577  : }

	ret	0
$LN210@SK_RawInpu:
	DD	$LN8@SK_RawInpu
	DD	$LN2@SK_RawInpu
	DD	$LN10@SK_RawInpu
	DD	$LN10@SK_RawInpu
	DD	$LN9@SK_RawInpu
?SK_RawInput_ClassifyDevices@@YAXXZ ENDP		; SK_RawInput_ClassifyDevices
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_RawInput_GetRegisteredGamepads@@YAAAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@XZ PROC ; SK_RawInput_GetRegisteredGamepads

; 539  :   return raw_gamepads;

	mov	eax, OFFSET ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_gamepads

; 540  : }

	ret	0
?SK_RawInput_GetRegisteredGamepads@@YAAAV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@XZ ENDP ; SK_RawInput_GetRegisteredGamepads
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_overrides$2 = -28					; size = 12
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pDifferent$ = 12					; size = 4
?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z PROC ; SK_RawInput_GetKeyboards

; 387  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 388  :   if (raw_overrides.keyboard.active)

	cmp	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A+2, 0
	push	esi
	mov	DWORD PTR $T3[ebp], 0
	je	$LN5@SK_RawInpu
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	xor	ecx, ecx

; 477  : 		_Mylast(),

	xor	edx, edx
	push	edi
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 390  :     bool different = false;

	xor	bh, bh
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR _overrides$2[ebp], ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR _overrides$2[ebp+4], edx

; 478  : 		_Myend()

	mov	DWORD PTR _overrides$2[ebp+8], ecx

; 42   : 		: _Ptr(_Parg)

	mov	edi, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 402  :     for (auto& it : raw_keyboards)

	mov	esi, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	mov	DWORD PTR __$EHRec$[ebp+8], edx
	cmp	esi, edi
	je	SHORT $LN3@SK_RawInpu
	npad	10
$LL4@SK_RawInpu:

; 403  :     {
; 404  :       if (raw_overrides.keyboard.legacy_messages)

	cmp	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A+3, 0

; 405  :       {
; 406  :         different |= ((it).dwFlags & RIDEV_NOLEGACY) != 0;

	mov	ecx, DWORD PTR [esi+4]

; 407  :         (it).dwFlags &= ~(RIDEV_NOLEGACY | RIDEV_APPKEYS);

	mov	eax, ecx
	je	SHORT $LN8@SK_RawInpu
	and	eax, -1073				; fffffbcfH
	test	cl, 48					; 00000030H
	setne	bl

; 408  :       }
; 409  : 
; 410  :       else

	jmp	SHORT $LN339@SK_RawInpu
$LN8@SK_RawInpu:

; 411  :       {
; 412  :         different |= ((it).dwFlags & RIDEV_NOLEGACY) == 0;
; 413  :         (it).dwFlags |=   RIDEV_NOLEGACY | RIDEV_APPKEYS;

	or	eax, 1072				; 00000430H
	test	cl, 48					; 00000030H
	sete	bl
$LN339@SK_RawInpu:

; 414  :       }
; 415  : 
; 416  :       overrides.emplace_back (it);

	push	esi
	lea	ecx, DWORD PTR _overrides$2[ebp]
	mov	DWORD PTR [esi+4], eax
	call	??$emplace_back@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXAAUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE &>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
	or	bh, bl
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 402  :     for (auto& it : raw_keyboards)

	cmp	esi, edi
	jne	SHORT $LL4@SK_RawInpu
	mov	edx, DWORD PTR _overrides$2[ebp+4]
	mov	ecx, DWORD PTR _overrides$2[ebp]
$LN3@SK_RawInpu:

; 417  :     }
; 418  : 
; 419  :     if (pDifferent != nullptr)

	mov	eax, DWORD PTR _pDifferent$[ebp]
	test	eax, eax
	je	SHORT $LN10@SK_RawInpu

; 420  :       *pDifferent = different;

	mov	BYTE PTR [eax], bh
$LN10@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 836  : 		this->_Myfirst() = _Right._Myfirst();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	ebx
	pop	esi
	mov	DWORD PTR [eax], ecx

; 837  : 		this->_Mylast() = _Right._Mylast();
; 838  : 		this->_Myend() = _Right._Myend();

	mov	ecx, DWORD PTR _overrides$2[ebp+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 434  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SK_RawInpu:

; 421  : 
; 422  :     return overrides;
; 423  :   }
; 424  : 
; 425  :   else
; 426  :   {
; 427  :     if (pDifferent != nullptr)

	mov	eax, DWORD PTR _pDifferent$[ebp]
	test	eax, eax
	je	SHORT $LN11@SK_RawInpu

; 428  :       *pDifferent = false;

	mov	BYTE PTR [eax], 0
$LN11@SK_RawInpu:

; 429  : 
; 430  :     //(it).dwFlags &= ~(RIDEV_NOLEGACY | RIDEV_APPKEYS);
; 431  : 
; 432  :     return raw_keyboards;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_keyboards
	call	??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@ABV01@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >

; 434  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z$0:
	lea	ecx, DWORD PTR _overrides$2[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__ehhandler$?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z ENDP ; SK_RawInput_GetKeyboards
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$emplace_back@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXAAUtagRAWINPUTDEVICE@@@Z
_TEXT	SEGMENT
__Newvec$1$ = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXAAUtagRAWINPUTDEVICE@@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE &>, COMDAT
; _this$ = ecx

; 908  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi

; 1731 : 		return (this->_Myend() != this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx

; 909  : 		if (_Has_unused_capacity())

	je	SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN70@emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN70@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 902  : 		++this->_Mylast();

	add	DWORD PTR [esi+4], 12			; 0000000cH
	pop	edi
	pop	esi

; 942  : 			}
; 943  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@emplace_ba:

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	ecx, DWORD PTR [esi]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	push	ebx
	sar	edx, 1
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 910  : 			{
; 911  : 			_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 912  : 			}
; 913  : 		else
; 914  : 			{	// reallocate
; 915  : 			const size_type _Oldsize = size();
; 916  : 
; 917  : 			if (_Oldsize == max_size())

	cmp	ebx, 357913941				; 15555555H
	je	$LN271@emplace_ba

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, DWORD PTR [esi]

; 920  : 				}
; 921  : 
; 922  : 			const size_type _Newsize = _Oldsize + 1;

	lea	ecx, DWORD PTR [ebx+1]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	imul	edi

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 357913941				; 15555555H

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, edi
	shr	edx, 1
	sub	eax, edx
	cmp	edi, eax
	jbe	SHORT $LN146@emplace_ba

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	edi, ecx
	jmp	SHORT $LN147@emplace_ba
$LN146@emplace_ba:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	edi, edx

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	edi, ecx
	cmovb	edi, ecx
$LN147@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	mov	ecx, esi
	call	?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ; std::allocator<tagRAWINPUTDEVICE>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 925  : 			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	edx, eax

; 926  : 
; 927  : 			_TRY_BEGIN
; 928  : 			this->_Getal().construct(_Unfancy(_Newvec + _Oldsize), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	DWORD PTR __Newvec$1$[ebp], edx
	lea	ecx, DWORD PTR [edx+ecx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN219@emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN219@emplace_ba:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ecx, DWORD PTR [esi]

; 2297 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2298 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR [esi+4]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 941  : 			_Change_array(_Newvec, _Newsize, _Newcapacity);

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, esi
	push	edi
	push	eax
	push	DWORD PTR __Newvec$1$[ebp]
	call	?_Change_array@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXQAUtagRAWINPUTDEVICE@@II@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Change_array
	pop	ebx
	pop	edi
	pop	esi

; 942  : 			}
; 943  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN271@emplace_ba:

; 918  : 				{
; 919  : 				_Xlength();

	call	?_Xlength@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@CAXXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Xlength
$LN273@emplace_ba:
$LN270@emplace_ba:
	int	3
??$emplace_back@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXAAUtagRAWINPUTDEVICE@@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator++, COMDAT
; _this$ = ecx

; 107  : 		++_Ptr;

	add	DWORD PTR [ecx], 12			; 0000000cH

; 332  : 		++*(_Mybase *)this;
; 333  : 		return (*this);

	mov	eax, ecx

; 334  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEAAUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEAAUtagRAWINPUTDEVICE@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 323  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEAAUtagRAWINPUTDEVICE@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@PAUtagRAWINPUTDEVICE@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@PAUtagRAWINPUTDEVICE@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 305  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@PAUtagRAWINPUTDEVICE@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator!=, COMDAT
; _this$ = ecx

; 210  : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 211  : 		return (!(*this == _Right));
; 212  : 		}

	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator==, COMDAT
; _this$ = ecx

; 204  : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 205  : 		_Compat(_Right);
; 206  : 		return (_Ptr == _Right._Ptr);
; 207  : 		}

	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator++, COMDAT
; _this$ = ecx

; 91   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 92   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 93   : 		if (_Mycont == 0
; 94   : 			|| _Ptr == nullptr_t{}
; 95   : 			|| _Mycont->_Mylast <= _Ptr)
; 96   : 			{	// report error
; 97   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 98   : 			}
; 99   : 
; 100  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 101  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 102  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 103  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 104  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 105  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 106  : 
; 107  : 		++_Ptr;

	add	DWORD PTR [ecx], 12			; 0000000cH

; 108  : 		return (*this);

	mov	eax, ecx

; 109  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABUtagRAWINPUTDEVICE@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator*, COMDAT
; _this$ = ecx

; 62   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 63   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 64   : 		if (_Mycont == 0
; 65   : 			|| _Ptr == _Tptr()
; 66   : 			|| _Ptr < _Mycont->_Myfirst
; 67   : 			|| _Mycont->_Mylast <= _Ptr)
; 68   : 			{	// report error
; 69   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 70   : 			}
; 71   : 
; 72   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 73   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 74   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 75   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 77   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 78   : 
; 79   : 		_Analysis_assume_(_Ptr != _Tptr());
; 80   : 
; 81   : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 82   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABUtagRAWINPUTDEVICE@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@PAUtagRAWINPUTDEVICE@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@PAUtagRAWINPUTDEVICE@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with pointer _Parg

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 44   : 		this->_Adopt(_Pvector);
; 45   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@PAUtagRAWINPUTDEVICE@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_overrides$2 = -32					; size = 12
$T3 = -20						; size = 4
_different$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pDifferent$ = 12					; size = 4
?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z PROC ; SK_RawInput_GetMice

; 331  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H

; 332  :   if (raw_overrides.mouse.active)

	mov	eax, DWORD PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A ; raw_overrides
	mov	DWORD PTR $T3[ebp], 0
	push	esi
	test	al, al
	je	$LN5@SK_RawInpu
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	xor	edx, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 334  :     bool different = false;

	xor	cl, cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	xor	ebx, ebx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 334  :     bool different = false;

	mov	BYTE PTR _different$1$[ebp], cl
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR _overrides$2[ebp], edx

; 477  : 		_Mylast(),

	mov	DWORD PTR _overrides$2[ebp+4], ebx

; 478  : 		_Myend()

	mov	DWORD PTR _overrides$2[ebp+8], edx

; 42   : 		: _Ptr(_Parg)

	mov	edi, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 346  :     for (auto& it : raw_mice)

	mov	esi, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	cmp	esi, edi
	je	SHORT $LN3@SK_RawInpu
	npad	7
$LL4@SK_RawInpu:

; 347  :     {
; 348  :       HWND hWnd = it.hwndTarget;
; 349  : 
; 350  :       if (raw_overrides.mouse.legacy_messages)
; 351  :       {
; 352  :         different    |= (it.dwFlags & RIDEV_NOLEGACY) != 0;

	mov	ebx, DWORD PTR [esi+4]
	test	ah, ah

; 355  :         it.hwndTarget = hWnd;
; 356  :         RegisterRawInputDevices_Original ( &it, 1, sizeof RAWINPUTDEVICE );

	push	12					; 0000000cH
	push	1
	push	esi
	mov	eax, ebx
	je	SHORT $LN8@SK_RawInpu

; 353  :         it.dwFlags   &= ~(RIDEV_NOLEGACY | RIDEV_APPKEYS | RIDEV_REMOVE);
; 354  :         it.dwFlags   &= ~RIDEV_CAPTUREMOUSE;

	and	eax, -1586				; fffff9ceH
	mov	DWORD PTR [esi+4], eax

; 355  :         it.hwndTarget = hWnd;
; 356  :         RegisterRawInputDevices_Original ( &it, 1, sizeof RAWINPUTDEVICE );

	call	DWORD PTR ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
	test	bl, 48					; 00000030H
	setne	bl

; 357  :       }
; 358  : 
; 359  :       else

	jmp	SHORT $LN9@SK_RawInpu
$LN8@SK_RawInpu:

; 360  :       {
; 361  :         different  |= (it.dwFlags & RIDEV_NOLEGACY) == 0;
; 362  :         it.dwFlags |= RIDEV_NOLEGACY;

	or	eax, 48					; 00000030H
	mov	DWORD PTR [esi+4], eax

; 363  :         RegisterRawInputDevices_Original ( &it, 1, sizeof RAWINPUTDEVICE );

	call	DWORD PTR ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
	test	bl, 48					; 00000030H
	sete	bl
$LN9@SK_RawInpu:

; 364  :       }
; 365  :     
; 366  :       overrides.emplace_back (it);

	push	esi
	lea	ecx, DWORD PTR _overrides$2[ebp]
	call	??$emplace_back@AAUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXAAUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE &>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 107  : 		++_Ptr;

	mov	cl, BYTE PTR _different$1$[ebp]
	add	esi, 12					; 0000000cH
	or	cl, bl
	mov	BYTE PTR _different$1$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 346  :     for (auto& it : raw_mice)

	cmp	esi, edi
	je	SHORT $LN341@SK_RawInpu
	mov	eax, DWORD PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A ; raw_overrides
	jmp	SHORT $LL4@SK_RawInpu
$LN341@SK_RawInpu:
	mov	ebx, DWORD PTR _overrides$2[ebp+4]
	mov	edx, DWORD PTR _overrides$2[ebp]
$LN3@SK_RawInpu:

; 367  :     }
; 368  : 
; 369  :     if (pDifferent != nullptr)

	mov	eax, DWORD PTR _pDifferent$[ebp]
	test	eax, eax
	je	SHORT $LN10@SK_RawInpu

; 370  :       *pDifferent = different;

	mov	BYTE PTR [eax], cl
$LN10@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 836  : 		this->_Myfirst() = _Right._Myfirst();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 838  : 		this->_Myend() = _Right._Myend();

	mov	ecx, DWORD PTR _overrides$2[ebp+8]
	pop	edi

; 837  : 		this->_Mylast() = _Right._Mylast();

	mov	DWORD PTR [eax+4], ebx
	pop	ebx

; 836  : 		this->_Myfirst() = _Right._Myfirst();

	mov	DWORD PTR [eax], edx

; 838  : 		this->_Myend() = _Right._Myend();

	mov	DWORD PTR [eax+8], ecx
	pop	esi
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 382  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SK_RawInpu:

; 371  : 
; 372  :     return overrides;
; 373  :   }
; 374  : 
; 375  :   else
; 376  :   {
; 377  :     if (pDifferent != nullptr)

	mov	eax, DWORD PTR _pDifferent$[ebp]
	test	eax, eax
	je	SHORT $LN11@SK_RawInpu

; 378  :        *pDifferent = false;

	mov	BYTE PTR [eax], 0
$LN11@SK_RawInpu:

; 379  : 
; 380  :     return raw_mice;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_mice
	call	??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@ABV01@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >

; 382  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z$0:
	lea	ecx, DWORD PTR _overrides$2[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__ehhandler$?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z ENDP ; SK_RawInput_GetMice
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-raw_overrides>@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-raw_overrides>@@QAE@XZ PROC		; <unnamed-type-raw_overrides>::<unnamed-type-raw_overrides>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0<unnamed-type-raw_overrides>@@QAE@XZ ENDP		; <unnamed-type-raw_overrides>::<unnamed-type-raw_overrides>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-mouse>@<unnamed-type-raw_overrides>@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-mouse>@<unnamed-type-raw_overrides>@@QAE@XZ PROC ; <unnamed-type-raw_overrides>::<unnamed-type-mouse>::<unnamed-type-mouse>, COMDAT
; _this$ = ecx
	mov	WORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0<unnamed-type-mouse>@<unnamed-type-raw_overrides>@@QAE@XZ ENDP ; <unnamed-type-raw_overrides>::<unnamed-type-mouse>::<unnamed-type-mouse>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??__Fraw_gamepads@@YAXXZ
text$yd	SEGMENT
??__Fraw_gamepads@@YAXXZ PROC				; `dynamic atexit destructor for 'raw_gamepads'', COMDAT

; 1947 : 		this->_Orphan_all();

	mov	ecx, OFFSET ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_gamepads
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Orphan_all

; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	test	eax, eax
	je	SHORT $LN7@dynamic

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	push	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
	mov	ecx, OFFSET ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_gamepads
	push	eax
	call	?_Destroy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@0@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Destroy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	imul	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A, 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8, 0
$LN7@dynamic:
	ret	0
??__Fraw_gamepads@@YAXXZ ENDP				; `dynamic atexit destructor for 'raw_gamepads''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ??__Eraw_gamepads@@YAXXZ
text$di	SEGMENT
??__Eraw_gamepads@@YAXXZ PROC				; `dynamic initializer for 'raw_gamepads'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_gamepads
	call	??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 312  : std::vector <RAWINPUTDEVICE> raw_gamepads;  // View of only game pads

	push	OFFSET ??__Fraw_gamepads@@YAXXZ		; `dynamic atexit destructor for 'raw_gamepads''
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A, 0

; 477  : 		_Mylast(),

	mov	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, 0

; 478  : 		_Myend()

	mov	DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8, 0
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 312  : std::vector <RAWINPUTDEVICE> raw_gamepads;  // View of only game pads

	call	_atexit
	pop	ecx
	ret	0
??__Eraw_gamepads@@YAXXZ ENDP				; `dynamic initializer for 'raw_gamepads''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??__Fraw_keyboards@@YAXXZ
text$yd	SEGMENT
??__Fraw_keyboards@@YAXXZ PROC				; `dynamic atexit destructor for 'raw_keyboards'', COMDAT

; 1947 : 		this->_Orphan_all();

	mov	ecx, OFFSET ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_keyboards
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Orphan_all

; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	test	eax, eax
	je	SHORT $LN7@dynamic

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	push	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
	mov	ecx, OFFSET ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_keyboards
	push	eax
	call	?_Destroy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@0@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Destroy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	imul	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A, 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8, 0
$LN7@dynamic:
	ret	0
??__Fraw_keyboards@@YAXXZ ENDP				; `dynamic atexit destructor for 'raw_keyboards''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ??__Eraw_keyboards@@YAXXZ
text$di	SEGMENT
??__Eraw_keyboards@@YAXXZ PROC				; `dynamic initializer for 'raw_keyboards'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_keyboards
	call	??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 311  : std::vector <RAWINPUTDEVICE> raw_keyboards; // View of only keyboards

	push	OFFSET ??__Fraw_keyboards@@YAXXZ	; `dynamic atexit destructor for 'raw_keyboards''
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A, 0

; 477  : 		_Mylast(),

	mov	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, 0

; 478  : 		_Myend()

	mov	DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8, 0
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 311  : std::vector <RAWINPUTDEVICE> raw_keyboards; // View of only keyboards

	call	_atexit
	pop	ecx
	ret	0
??__Eraw_keyboards@@YAXXZ ENDP				; `dynamic initializer for 'raw_keyboards''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??__Fraw_mice@@YAXXZ
text$yd	SEGMENT
??__Fraw_mice@@YAXXZ PROC				; `dynamic atexit destructor for 'raw_mice'', COMDAT

; 1947 : 		this->_Orphan_all();

	mov	ecx, OFFSET ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_mice
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Orphan_all

; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	test	eax, eax
	je	SHORT $LN7@dynamic

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	push	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
	mov	ecx, OFFSET ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_mice
	push	eax
	call	?_Destroy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@0@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Destroy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	imul	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A, 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8, 0
$LN7@dynamic:
	ret	0
??__Fraw_mice@@YAXXZ ENDP				; `dynamic atexit destructor for 'raw_mice''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ??__Eraw_mice@@YAXXZ
text$di	SEGMENT
??__Eraw_mice@@YAXXZ PROC				; `dynamic initializer for 'raw_mice'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_mice
	call	??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 310  : std::vector <RAWINPUTDEVICE> raw_mice;      // View of only mice

	push	OFFSET ??__Fraw_mice@@YAXXZ		; `dynamic atexit destructor for 'raw_mice''
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A, 0

; 477  : 		_Mylast(),

	mov	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, 0

; 478  : 		_Myend()

	mov	DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8, 0
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 310  : std::vector <RAWINPUTDEVICE> raw_mice;      // View of only mice

	call	_atexit
	pop	ecx
	ret	0
??__Eraw_mice@@YAXXZ ENDP				; `dynamic initializer for 'raw_mice''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??__Fraw_devices@@YAXXZ
text$yd	SEGMENT
??__Fraw_devices@@YAXXZ PROC				; `dynamic atexit destructor for 'raw_devices'', COMDAT

; 1947 : 		this->_Orphan_all();

	mov	ecx, OFFSET ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_devices
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Orphan_all

; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	test	eax, eax
	je	SHORT $LN7@dynamic

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	push	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
	mov	ecx, OFFSET ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_devices
	push	eax
	call	?_Destroy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@0@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Destroy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	imul	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A, 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8, 0
$LN7@dynamic:
	ret	0
??__Fraw_devices@@YAXXZ ENDP				; `dynamic atexit destructor for 'raw_devices''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ??__Eraw_devices@@YAXXZ
text$di	SEGMENT
??__Eraw_devices@@YAXXZ PROC				; `dynamic initializer for 'raw_devices'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A ; raw_devices
	call	??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 308  : std::vector <RAWINPUTDEVICE> raw_devices;   // ALL devices, this is the list as Windows would give it to the game

	push	OFFSET ??__Fraw_devices@@YAXXZ		; `dynamic atexit destructor for 'raw_devices''
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A, 0

; 477  : 		_Mylast(),

	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4, 0

; 478  : 		_Myend()

	mov	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+8, 0
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 308  : std::vector <RAWINPUTDEVICE> raw_devices;   // ALL devices, this is the list as Windows would give it to the game

	call	_atexit
	pop	ecx
	ret	0
??__Eraw_devices@@YAXXZ ENDP				; `dynamic initializer for 'raw_devices''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_range@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABEXPAUtagRAWINPUTDEVICE@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABEXPAUtagRAWINPUTDEVICE@@0@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1996 : 		}

	ret	8
?_Orphan_range@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABEXPAUtagRAWINPUTDEVICE@@0@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@CAXXZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@CAXXZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXXZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXXZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXQAUtagRAWINPUTDEVICE@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXQAUtagRAWINPUTDEVICE@@II@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXQAUtagRAWINPUTDEVICE@@II@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Buy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAE_NI@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Buy, COMDAT
; _this$ = ecx

; 1908 : 		{	// allocate array with _Newcapacity elements

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1909 : 		this->_Myfirst() = pointer();
; 1910 : 		this->_Mylast() = pointer();
; 1911 : 		this->_Myend() = pointer();
; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	mov	edi, DWORD PTR __Newcapacity$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1914 : 			{
; 1915 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN2@Buy:

; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	edi, 357913941				; 15555555H
	ja	SHORT $LN104@Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ; std::allocator<tagRAWINPUTDEVICE>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();
; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [esi]
	pop	edi
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], eax

; 1926 : 
; 1927 : 		return (true);

	mov	al, 1
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN104@Buy:

; 1919 : 			{
; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@CAXXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Xlength
$LN106@Buy:
$LN103@Buy:
	int	3
?_Buy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAE_NI@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABEII@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 357913941				; 15555555H

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, ecx
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABEII@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@0@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@0@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@00@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@00@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEXPAUtagRAWINPUTDEVICE@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_Has_unused_capacity@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABE_NXZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Has_unused_capacity, COMDAT
; _this$ = ecx

; 1730 : 		{	// micro-optimization for capacity() != size()

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [ecx+4]
	setne	al

; 1731 : 		return (this->_Myend() != this->_Mylast());
; 1732 : 		}

	ret	0
?_Has_unused_capacity@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@ABE_NXZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1721 : 		}

	ret	0
?capacity@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 357913941				; 15555555H

; 1716 : 		}

	ret	0
?max_size@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1711 : 		}

	ret	0
?size@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?empty@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBE_NXZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::empty, COMDAT
; _this$ = ecx

; 1704 : 		{	// test if sequence is empty

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1705 : 		return (this->_Myfirst() == this->_Mylast());
; 1706 : 		}

	ret	0
?empty@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBE_NXZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?end@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@2@XZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::end, COMDAT
; _this$ = ecx

; 1654 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1655 : 		return (iterator(this->_Mylast(), _STD addressof(this->_Get_data())));
; 1656 : 		}

	pop	ebp
	ret	4
?end@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@2@XZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?begin@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@2@XZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::begin, COMDAT
; _this$ = ecx

; 1644 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 42   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1645 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
; 1646 : 		}

	pop	ebp
	ret	4
?begin@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@@2@XZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?data@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEPAUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
?data@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEPAUtagRAWINPUTDEVICE@@XZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::data, COMDAT
; _this$ = ecx

; 1635 : 		return (_Unfancy_maybe_null(this->_Myfirst()));

	mov	eax, DWORD PTR [ecx]

; 1636 : 		}

	ret	0
?data@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEPAUtagRAWINPUTDEVICE@@XZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?clear@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXXZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::clear, COMDAT
; _this$ = ecx

; 1615 : 		this->_Orphan_all();
; 1616 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1617 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1618 : 		}

	ret	0
?clear@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXXZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?push_back@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::push_back, COMDAT
; _this$ = ecx

; 946  : 		{	// insert element at end, provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 948  : 		}

	pop	ebp

; 947  : 		emplace_back(_Val);

	jmp	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>
?push_back@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >, COMDAT
; _this$ = ecx

; 860  : 		{	// construct by moving _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 836  : 		this->_Myfirst() = _Right._Myfirst();

	mov	edx, DWORD PTR __Right$[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 836  : 		this->_Myfirst() = _Right._Myfirst();

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 837  : 		this->_Mylast() = _Right._Mylast();

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 838  : 		this->_Myend() = _Right._Myend();

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 861  : 		_Move_from(_STD move(_Right), true_type{});
; 862  : 		}

	mov	eax, ecx

; 840  : 		_Right._Myfirst() = pointer();

	mov	DWORD PTR [edx], 0

; 841  : 		_Right._Mylast() = pointer();

	mov	DWORD PTR [edx+4], 0

; 842  : 		_Right._Myend() = pointer();

	mov	DWORD PTR [edx+8], 0

; 861  : 		_Move_from(_STD move(_Right), true_type{});
; 862  : 		}

	pop	ebp
	ret	4
??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Move_from@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_from@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Move_from, COMDAT
; _this$ = ecx

; 833  : 		{	// move from _Right, stealing its contents

	npad	2
	push	ebp
	mov	ebp, esp

; 834  : 		this->_Swap_all(_Right);
; 835  : 
; 836  : 		this->_Myfirst() = _Right._Myfirst();

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 837  : 		this->_Mylast() = _Right._Mylast();

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 838  : 		this->_Myend() = _Right._Myend();

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 839  : 
; 840  : 		_Right._Myfirst() = pointer();

	mov	DWORD PTR [edx], 0

; 841  : 		_Right._Mylast() = pointer();

	mov	DWORD PTR [edx+4], 0

; 842  : 		_Right._Myend() = pointer();

	mov	DWORD PTR [edx+8], 0

; 843  : 		}

	pop	ebp
	ret	8
?_Move_from@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@AAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Move_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >, COMDAT
; _this$ = ecx

; 805  : 		{	// construct by copying _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ebx, ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	push	edi
	mov	edi, DWORD PTR __Right$[ebp]

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ebx], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [ebx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ebx+8], 0

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [edi+4]
	sub	edx, DWORD PTR [edi]
	imul	edx

; 1909 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [ebx], 0

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	esi, edx

; 1910 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [ebx+4], 0

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	shr	esi, 31					; 0000001fH

; 1911 : 		this->_Myend() = pointer();

	mov	DWORD PTR [ebx+8], 0

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	add	esi, edx

; 1913 : 		if (_Newcapacity == 0)

	je	SHORT $LN5@vector

; 1914 : 			{
; 1915 : 			return (false);
; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	esi, 357913941				; 15555555H
	ja	SHORT $LN220@vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	esi
	call	?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ; std::allocator<tagRAWINPUTDEVICE>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [ebx], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	lea	ecx, DWORD PTR [esi+esi*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [ebx+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [ebx]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2296 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	eax, DWORD PTR [edi]

; 2299 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [ebx]
	sub	esi, eax

; 2300 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove

; 2301 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [esi+edi]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 809  : 			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());

	mov	DWORD PTR [ebx+4], eax
$LN5@vector:

; 810  : 			_CATCH_ALL
; 811  : 			_Tidy();
; 812  : 			_RERAISE;
; 813  : 			_CATCH_END
; 814  : 			}
; 815  : 		}

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
$LN220@vector:

; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@CAXXZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::_Xlength
$LN222@vector:
$LN219@vector:
	int	3
??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ PROC ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 723  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 723  : 		}

	ret	0
??0?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >,std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >::_Vector_val<std::_Simple_types<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABQAUtagRAWINPUTDEVICE@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAPAUtagRAWINPUTDEVICE@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UtagRAWINPUTDEVICE@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Swap_all, COMDAT
; _this$ = ecx

; 626  : 		_Get_data()._Swap_all(_Right._Get_data());
; 627  : 		}

	ret	4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 509  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 509  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >::_Vector_alloc<std::_Vec_base_types<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 357913941				; 15555555H

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@I@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXPAUtagRAWINPUTDEVICE@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ; std::allocator<tagRAWINPUTDEVICE>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 1013 : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 1014 : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1015 : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<tagRAWINPUTDEVICE> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SA?AV?$allocator@UtagRAWINPUTDEVICE@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SA?AV?$allocator@UtagRAWINPUTDEVICE@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::select_on_container_copy_construction, COMDAT

; 975  : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 976  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 977  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SA?AV?$allocator@UtagRAWINPUTDEVICE@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAIABV?$allocator@UtagRAWINPUTDEVICE@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAIABV?$allocator@UtagRAWINPUTDEVICE@@@2@@Z PROC ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 357913941				; 15555555H

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@SAIABV?$allocator@UtagRAWINPUTDEVICE@@@2@@Z ENDP ; std::allocator_traits<std::allocator<tagRAWINPUTDEVICE> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@UtagRAWINPUTDEVICE@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UtagRAWINPUTDEVICE@@@std@@QBEIXZ PROC ; std::allocator<tagRAWINPUTDEVICE>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 357913941				; 15555555H

; 852  : 		}

	ret	0
?max_size@?$allocator@UtagRAWINPUTDEVICE@@@std@@QBEIXZ ENDP ; std::allocator<tagRAWINPUTDEVICE>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z PROC ; std::allocator<tagRAWINPUTDEVICE>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEPAUtagRAWINPUTDEVICE@@I@Z ENDP ; std::allocator<tagRAWINPUTDEVICE>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@I@Z PROC ; std::allocator<tagRAWINPUTDEVICE>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@UtagRAWINPUTDEVICE@@@std@@QAEXPAUtagRAWINPUTDEVICE@@I@Z ENDP ; std::allocator<tagRAWINPUTDEVICE>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@UtagRAWINPUTDEVICE@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UtagRAWINPUTDEVICE@@@std@@QAE@ABV01@@Z PROC ; std::allocator<tagRAWINPUTDEVICE>::allocator<tagRAWINPUTDEVICE>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@UtagRAWINPUTDEVICE@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<tagRAWINPUTDEVICE>::allocator<tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@UtagRAWINPUTDEVICE@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UtagRAWINPUTDEVICE@@@std@@QAE@XZ PROC	; std::allocator<tagRAWINPUTDEVICE>::allocator<tagRAWINPUTDEVICE>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@UtagRAWINPUTDEVICE@@@std@@QAE@XZ ENDP	; std::allocator<tagRAWINPUTDEVICE>::allocator<tagRAWINPUTDEVICE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_Input_PreHookHID@@YAXXZ PROC			; SK_Input_PreHookHID

; 289  :   if (! config.input.gamepad.hook_hid)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+692, 0
	je	SHORT $LN3@SK_Input_P

; 290  :     return;
; 291  : 
; 292  :   static sk_import_test_s tests [] = { { "hid.dll", false } };
; 293  : 
; 294  :   SK_TestImports (GetModuleHandle (nullptr), tests, 1);

	push	1
	push	OFFSET ?tests@?1??SK_Input_PreHookHID@@YAXXZ@4PAUsk_import_test_s@@A
	push	0
	call	DWORD PTR __imp__GetModuleHandleW@4
	push	eax
	call	?SK_TestImports@@YGXPAUHINSTANCE__@@PAUsk_import_test_s@@H@Z ; SK_TestImports

; 295  : 
; 296  :   if (tests [0].used)// || GetModuleHandle (L"hid.dll"))

	cmp	BYTE PTR ?tests@?1??SK_Input_PreHookHID@@YAXXZ@4PAUsk_import_test_s@@A+4, 0
	jne	?SK_Input_HookHID@@YAXXZ		; SK_Input_HookHID
$LN3@SK_Input_P:

; 297  :   {
; 298  :     SK_Input_HookHID ();
; 299  :   }
; 300  : }

	ret	0
?SK_Input_PreHookHID@@YAXXZ ENDP			; SK_Input_PreHookHID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GEPAX0K@Z@@YAPAPAXPAP6GEPAX0K@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GEPAX0K@Z@@YAPAPAXPAP6GEPAX0K@Z@Z PROC ; static_cast_p2p<void,unsigned char __stdcall(void *,void *,unsigned long)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GEPAX0K@Z@@YAPAPAXPAP6GEPAX0K@Z@Z ENDP ; static_cast_p2p<void,unsigned char __stdcall(void *,void *,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GEPAU_HIDP_PREPARSED_DATA@@@Z@@YAPAPAXPAP6GEPAU_HIDP_PREPARSED_DATA@@@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GEPAU_HIDP_PREPARSED_DATA@@@Z@@YAPAPAXPAP6GEPAU_HIDP_PREPARSED_DATA@@@Z@Z PROC ; static_cast_p2p<void,unsigned char __stdcall(_HIDP_PREPARSED_DATA *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GEPAU_HIDP_PREPARSED_DATA@@@Z@@YAPAPAXPAP6GEPAU_HIDP_PREPARSED_DATA@@@Z@Z ENDP ; static_cast_p2p<void,unsigned char __stdcall(_HIDP_PREPARSED_DATA *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@@YAPAPAXPAP6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@@YAPAPAXPAP6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@Z PROC ; static_cast_p2p<void,unsigned char __stdcall(void *,_HIDP_PREPARSED_DATA * *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@@YAPAPAXPAP6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@Z ENDP ; static_cast_p2p<void,unsigned char __stdcall(void *,_HIDP_PREPARSED_DATA * *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@@YAPAPAXPAP6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@@YAPAPAXPAP6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@Z PROC ; static_cast_p2p<void,long __stdcall(enum _HIDP_REPORT_TYPE,_HIDP_DATA *,unsigned long *,_HIDP_PREPARSED_DATA *,char *,unsigned long)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@@YAPAPAXPAP6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@Z ENDP ; static_cast_p2p<void,long __stdcall(enum _HIDP_REPORT_TYPE,_HIDP_DATA *,unsigned long *,_HIDP_PREPARSED_DATA *,char *,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_ReportType$ = 8					; size = 4
_DataList$ = 12						; size = 4
_DataLength$ = 16					; size = 4
_PreparsedData$ = 20					; size = 4
_Report$ = 24						; size = 4
_ReportLength$ = 28					; size = 4
?HidP_GetData_Detour@@YGJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z PROC ; HidP_GetData_Detour

; 212  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 213  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??HidP_GetData_Detour@@YGJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@4_NA, 0
	jne	SHORT $LN2@HidP_GetDa
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@HidP_GetDa
	push	OFFSET $SG161490
	push	OFFSET $SG161491
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@HidP_GetDa:
	mov	BYTE PTR ?called@?2??HidP_GetData_Detour@@YGJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z@4_NA, 1
$LN2@HidP_GetDa:
	push	ebx
	push	esi

; 214  : 
; 215  :   NTSTATUS ret =
; 216  :     HidP_GetData_Original ( ReportType, DataList,

	mov	esi, DWORD PTR _DataLength$[ebp]
	push	edi
	push	DWORD PTR _ReportLength$[ebp]
	mov	edi, DWORD PTR _ReportType$[ebp]
	push	DWORD PTR _Report$[ebp]
	push	DWORD PTR _PreparsedData$[ebp]
	push	esi
	push	DWORD PTR _DataList$[ebp]
	push	edi
	call	DWORD PTR ?HidP_GetData_Original@@3P6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@ZA ; HidP_GetData_Original
	mov	ebx, eax

; 217  :                               DataLength, PreparsedData,
; 218  :                                 Report, ReportLength );
; 219  : 
; 220  : 
; 221  :   // De we want block this I/O?
; 222  :   bool filter = false;
; 223  : 
; 224  :   if ( ret == HIDP_STATUS_SUCCESS && ( ReportType == HidP_Input || ReportType == HidP_Output ))

	cmp	ebx, 1114112				; 00110000H
	jne	SHORT $LN9@HidP_GetDa
	test	edi, edi
	je	SHORT $LN5@HidP_GetDa
	cmp	edi, 1
	jne	SHORT $LN9@HidP_GetDa
$LN5@HidP_GetDa:

; 225  :   {
; 226  :     // This will classify the data for us, so don't record this event yet.
; 227  :     filter = SK_HID_FilterPreparsedData (PreparsedData);

	push	DWORD PTR _PreparsedData$[ebp]
	call	?SK_HID_FilterPreparsedData@@YA_NPAU_HIDP_PREPARSED_DATA@@@Z ; SK_HID_FilterPreparsedData
	add	esp, 4

; 228  :   }
; 229  : 
; 230  : 
; 231  :   if (! filter)

	test	al, al
	je	SHORT $LN9@HidP_GetDa

; 233  : 
; 234  :   else {
; 235  :     memset (DataList, 0, *DataLength);

	push	DWORD PTR [esi]
	push	0
	push	DWORD PTR _DataList$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 236  :            *DataLength = 0;

	mov	DWORD PTR [esi], 0

; 237  :   }
; 238  : 
; 239  :   return ret;

	mov	eax, 1114112				; 00110000H
	pop	edi
	pop	esi
	pop	ebx

; 240  : }

	pop	ebp
	ret	24					; 00000018H
$LN9@HidP_GetDa:
	pop	edi
	pop	esi

; 232  :     return ret;

	mov	eax, ebx
	pop	ebx

; 240  : }

	pop	ebp
	ret	24					; 00000018H
?HidP_GetData_Detour@@YGJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z ENDP ; HidP_GetData_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_pData$ = -4						; size = 4
_HidDeviceObject$ = 8					; size = 4
_ReportBuffer$ = 12					; size = 4
_ReportBufferLength$ = 16				; size = 4
?HidD_GetFeature_Detour@@YGEPAX0K@Z PROC		; HidD_GetFeature_Detour

; 183  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 184  :   ////SK_HID_READ (sk_input_dev_type::Gamepad)
; 185  : 
; 186  :   bool                 filter = false;
; 187  :   PHIDP_PREPARSED_DATA pData  = nullptr;
; 188  : 
; 189  :   if (HidD_GetPreparsedData_Original (HidDeviceObject, &pData))

	lea	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pData$[ebp], 0
	push	eax
	push	DWORD PTR _HidDeviceObject$[ebp]
	xor	bl, bl
	call	DWORD PTR ?HidD_GetPreparsedData_Original@@3P6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@ZA ; HidD_GetPreparsedData_Original
	test	al, al
	je	SHORT $LN6@HidD_GetFe

; 190  :   {
; 191  :     if (SK_HID_FilterPreparsedData (pData))

	push	DWORD PTR _pData$[ebp]
	call	?SK_HID_FilterPreparsedData@@YA_NPAU_HIDP_PREPARSED_DATA@@@Z ; SK_HID_FilterPreparsedData
	add	esp, 4
	movzx	ebx, bl
	test	al, al
	mov	ecx, 1
	cmovne	ebx, ecx

; 192  :       filter = true;
; 193  : 
; 194  :     HidD_FreePreparsedData_Original (pData);

	push	DWORD PTR _pData$[ebp]
	call	DWORD PTR ?HidD_FreePreparsedData_Original@@3P6GEPAU_HIDP_PREPARSED_DATA@@@ZA ; HidD_FreePreparsedData_Original

; 195  :   }
; 196  : 
; 197  :   if (! filter)

	test	bl, bl
	je	SHORT $LN6@HidD_GetFe

; 199  : 
; 200  :   return FALSE;

	xor	al, al
	pop	ebx

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN6@HidD_GetFe:

; 198  :     return HidD_GetFeature_Original ( HidDeviceObject, ReportBuffer, ReportBufferLength );

	push	DWORD PTR _ReportBufferLength$[ebp]
	push	DWORD PTR _ReportBuffer$[ebp]
	push	DWORD PTR _HidDeviceObject$[ebp]
	call	DWORD PTR ?HidD_GetFeature_Original@@3P6GEPAX0K@ZA ; HidD_GetFeature_Original
	pop	ebx

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?HidD_GetFeature_Detour@@YGEPAX0K@Z ENDP		; HidD_GetFeature_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_PreparsedData$ = 8					; size = 4
?HidD_FreePreparsedData_Detour@@YGEPAU_HIDP_PREPARSED_DATA@@@Z PROC ; HidD_FreePreparsedData_Detour

; 167  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 168  :   BOOLEAN bRet =
; 169  :     HidD_FreePreparsedData_Original (PreparsedData);

	push	DWORD PTR _PreparsedData$[ebp]
	call	DWORD PTR ?HidD_FreePreparsedData_Original@@3P6GEPAU_HIDP_PREPARSED_DATA@@@ZA ; HidD_FreePreparsedData_Original

; 170  : 
; 171  :   if (PreparsedData == SK_HID_PreparsedData)

	mov	ecx, DWORD PTR ?SK_HID_PreparsedData@@3PAU_HIDP_PREPARSED_DATA@@A ; SK_HID_PreparsedData
	xor	edx, edx
	cmp	DWORD PTR _PreparsedData$[ebp], ecx
	cmove	ecx, edx
	mov	DWORD PTR ?SK_HID_PreparsedData@@3PAU_HIDP_PREPARSED_DATA@@A, ecx ; SK_HID_PreparsedData

; 172  :     SK_HID_PreparsedData = nullptr;
; 173  : 
; 174  :   return bRet;
; 175  : }

	pop	ebp
	ret	4
?HidD_FreePreparsedData_Detour@@YGEPAU_HIDP_PREPARSED_DATA@@@Z ENDP ; HidD_FreePreparsedData_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_pData$ = -4						; size = 4
_HidDeviceObject$ = 8					; size = 4
_PreparsedData$ = 12					; size = 4
?HidD_GetPreparsedData_Detour@@YGEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z PROC ; HidD_GetPreparsedData_Detour

; 131  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 132  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??HidD_GetPreparsedData_Detour@@YGEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@4_NA, 0
	jne	SHORT $LN2@HidD_GetPr
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, 0
	jl	SHORT $LN3@HidD_GetPr
	push	OFFSET $SG161455
	push	OFFSET $SG161456
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@HidD_GetPr:
	mov	BYTE PTR ?called@?2??HidD_GetPreparsedData_Detour@@YGEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z@4_NA, 1
$LN2@HidD_GetPr:
	push	ebx
	push	esi

; 133  : 
; 134  :   PHIDP_PREPARSED_DATA pData = nullptr;
; 135  :   BOOLEAN              bRet  =
; 136  :     HidD_GetPreparsedData_Original ( HidDeviceObject,

	lea	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pData$[ebp], 0
	push	eax
	push	DWORD PTR _HidDeviceObject$[ebp]
	call	DWORD PTR ?HidD_GetPreparsedData_Original@@3P6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@ZA ; HidD_GetPreparsedData_Original
	mov	bl, al

; 137  :                                        &pData );
; 138  : 
; 139  :   if (bRet)

	test	bl, bl
	je	SHORT $LN4@HidD_GetPr

; 140  :   {
; 141  :     SK_HID_PreparsedDataP = PreparsedData;
; 142  :     SK_HID_PreparsedData  = pData;

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	esi, DWORD PTR _PreparsedData$[ebp]

; 143  : 
; 144  :     if (SK_HID_FilterPreparsedData (pData) || config.input.gamepad.disable_ps4_hid)

	push	ecx
	mov	DWORD PTR ?SK_HID_PreparsedDataP@@3PAPAU_HIDP_PREPARSED_DATA@@A, esi ; SK_HID_PreparsedDataP
	mov	DWORD PTR ?SK_HID_PreparsedData@@3PAU_HIDP_PREPARSED_DATA@@A, ecx ; SK_HID_PreparsedData
	call	?SK_HID_FilterPreparsedData@@YA_NPAU_HIDP_PREPARSED_DATA@@@Z ; SK_HID_FilterPreparsedData
	add	esp, 4
	test	al, al
	jne	SHORT $LN6@HidD_GetPr
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+688, al
	jne	SHORT $LN6@HidD_GetPr

; 146  : 
; 147  :     *PreparsedData   =  pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR [esi], eax
$LN4@HidD_GetPr:

; 148  :   }
; 149  : 
; 150  :   // Can't figure out how The Witness works yet, but it will bypass input blocking
; 151  :   //   on HID using a PS4 controller unless we return FALSE here.
; 152  :   //return FALSE;
; 153  :   return bRet;

	pop	esi
	mov	al, bl
	pop	ebx

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN6@HidD_GetPr:
	pop	esi

; 145  :       return FALSE;

	xor	al, al
	pop	ebx

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HidD_GetPreparsedData_Detour@@YGEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z ENDP ; HidD_GetPreparsedData_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_caps$ = -64						; size = 64
_pData$ = 8						; size = 4
?SK_HID_FilterPreparsedData@@YA_NPAU_HIDP_PREPARSED_DATA@@@Z PROC ; SK_HID_FilterPreparsedData

; 74   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 75   :   bool filter = false;
; 76   : 
; 77   :         HIDP_CAPS caps;
; 78   :   const NTSTATUS  stat =
; 79   :           HidP_GetCaps_Original (pData, &caps);

	lea	eax, DWORD PTR _caps$[ebp]
	push	ebx
	push	eax
	push	DWORD PTR _pData$[ebp]
	xor	bl, bl
	call	DWORD PTR ?HidP_GetCaps_Original@@3P6GJPAU_HIDP_PREPARSED_DATA@@PAU_HIDP_CAPS@@@ZA ; HidP_GetCaps_Original

; 80   : 
; 81   :   if ( stat           == HIDP_STATUS_SUCCESS && 

	cmp	eax, 1114112				; 00110000H
	jne	SHORT $LN10@SK_HID_Fil
	cmp	WORD PTR _caps$[ebp+2], 1
	jne	SHORT $LN10@SK_HID_Fil

; 82   :        caps.UsagePage == HID_USAGE_PAGE_GENERIC )
; 83   :   {
; 84   :     switch (caps.Usage)

	movzx	eax, WORD PTR _caps$[ebp]
	dec	eax
	cmp	eax, 6
	ja	SHORT $LN10@SK_HID_Fil
	jmp	DWORD PTR $LN31@SK_HID_Fil[eax*4]
$LN5@SK_HID_Fil:
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_HID_Backend@@3Usk_input_api_context_s@@A+40
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 91   :         if (SK_ImGui_WantGamepadCapture () && (! config.input.gamepad.native_ps4))

	call	?SK_ImGui_WantGamepadCapture@@YA_NXZ	; SK_ImGui_WantGamepadCapture
	test	al, al
	je	SHORT $LN10@SK_HID_Fil
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+694, 0
	jne	SHORT $LN10@SK_HID_Fil

; 92   :           filter = true;

	mov	bl, 1

; 110  :           filter = true;
; 111  :       } break;
; 112  :     }
; 113  :   }
; 114  : 
; 115  :   //SK_LOG0 ( ( L"HID Preparsed Data - Stat: %04x, UsagePage: %02x, Usage: %02x",
; 116  :                 //stat, caps.UsagePage, caps.Usage ),
; 117  :               //L" HIDInput ");
; 118  : 
; 119  :   return filter;

	mov	al, bl
	pop	ebx

; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@SK_HID_Fil:
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_HID_Backend@@3Usk_input_api_context_s@@A+32
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 100  :         if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN10@SK_HID_Fil

; 101  :           filter = true;

	mov	bl, 1

; 110  :           filter = true;
; 111  :       } break;
; 112  :     }
; 113  :   }
; 114  : 
; 115  :   //SK_LOG0 ( ( L"HID Preparsed Data - Stat: %04x, UsagePage: %02x, Usage: %02x",
; 116  :                 //stat, caps.UsagePage, caps.Usage ),
; 117  :               //L" HIDInput ");
; 118  : 
; 119  :   return filter;

	mov	al, bl
	pop	ebx

; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@SK_HID_Fil:
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_HID_Backend@@3Usk_input_api_context_s@@A+36
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 109  :         if (SK_ImGui_WantKeyboardCapture ())

	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture
	test	al, al
	movzx	ebx, bl
	mov	ecx, 1
	cmovne	ebx, ecx
$LN10@SK_HID_Fil:

; 110  :           filter = true;
; 111  :       } break;
; 112  :     }
; 113  :   }
; 114  : 
; 115  :   //SK_LOG0 ( ( L"HID Preparsed Data - Stat: %04x, UsagePage: %02x, Usage: %02x",
; 116  :                 //stat, caps.UsagePage, caps.Usage ),
; 117  :               //L" HIDInput ");
; 118  : 
; 119  :   return filter;

	mov	al, bl
	pop	ebx

; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN31@SK_HID_Fil:
	DD	$LN7@SK_HID_Fil
	DD	$LN7@SK_HID_Fil
	DD	$LN10@SK_HID_Fil
	DD	$LN5@SK_HID_Fil
	DD	$LN5@SK_HID_Fil
	DD	$LN9@SK_HID_Fil
	DD	$LN9@SK_HID_Fil
?SK_HID_FilterPreparsedData@@YA_NPAU_HIDP_PREPARSED_DATA@@@Z ENDP ; SK_HID_FilterPreparsedData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_cursor_info$ = -20					; size = 20
?SK_InputUtil_IsHWCursorVisible@@YA_NXZ PROC		; SK_InputUtil_IsHWCursorVisible

; 46   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	xorps	xmm0, xmm0

; 47   :   CURSORINFO cursor_info        = { };

	mov	DWORD PTR _cursor_info$[ebp+16], 0

; 48   :              cursor_info.cbSize = sizeof (CURSORINFO);
; 49   :   
; 50   :   GetCursorInfo_Original (&cursor_info);

	lea	eax, DWORD PTR _cursor_info$[ebp]
	movups	XMMWORD PTR _cursor_info$[ebp], xmm0
	push	eax
	mov	DWORD PTR _cursor_info$[ebp], 20	; 00000014H
	call	DWORD PTR ?GetCursorInfo_Original@@3P6GHPAUtagCURSORINFO@@@ZA ; GetCursorInfo_Original

; 51   : 
; 52   :   return (cursor_info.flags & CURSOR_SHOWING);

	mov	eax, DWORD PTR _cursor_info$[ebp+4]
	and	eax, 1

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_InputUtil_IsHWCursorVisible@@YA_NXZ ENDP		; SK_InputUtil_IsHWCursorVisible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
_TEXT	SEGMENT
?SK_ImGui_Active@@YA_NXZ PROC				; SK_ImGui_Active

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN3@SK_ImGui_A
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN3@SK_ImGui_A
	xor	al, al
	ret	0
$LN3@SK_ImGui_A:
	mov	al, 1
	ret	0
?SK_ImGui_Active@@YA_NXZ ENDP				; SK_ImGui_Active
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\console.h
;	COMDAT ?isVisible@SK_Console@@QAE_NXZ
_TEXT	SEGMENT
?isVisible@SK_Console@@QAE_NXZ PROC			; SK_Console::isVisible, COMDAT
; _this$ = ecx

; 69   :   bool isVisible (void) { return visible; }

	mov	al, BYTE PTR [ecx+4356]
	ret	0
?isVisible@SK_Console@@QAE_NXZ ENDP			; SK_Console::isVisible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 68   : 		}

	ret	4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?max@?$numeric_limits@I@std@@SAIXZ
_TEXT	SEGMENT
?max@?$numeric_limits@I@std@@SAIXZ PROC			; std::numeric_limits<unsigned int>::max, COMDAT

; 741  : 		return (UINT_MAX);

	or	eax, -1

; 742  : 		}

	ret	0
?max@?$numeric_limits@I@std@@SAIXZ ENDP			; std::numeric_limits<unsigned int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_RawInput_RestoreLegacyKeyboard@@YAXXZ PROC		; SK_RawInput_RestoreLegacyKeyboard

; 524  :   if (raw_overrides.keyboard.active)

	cmp	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A+2, 0
	je	SHORT $LN2@SK_RawInpu
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	imul	ecx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 528  :     RegisterRawInputDevices_Original (

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 526  :     raw_overrides.keyboard.active = false;

	mov	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A+2, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 528  :     RegisterRawInputDevices_Original (

	push	eax
	push	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	call	DWORD PTR ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
$LN2@SK_RawInpu:

; 529  :       raw_devices.data (),
; 530  :         static_cast <UINT> (raw_devices.size ()),
; 531  :           sizeof RAWINPUTDEVICE
; 532  :     );
; 533  :   }
; 534  : }

	ret	0
?SK_RawInput_RestoreLegacyKeyboard@@YAXXZ ENDP		; SK_RawInput_RestoreLegacyKeyboard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_keyboards$2 = -40					; size = 12
_device_override$3 = -28				; size = 12
_different$4 = -13					; size = 1
__$EHRec$ = -12						; size = 12
_enable$ = 8						; size = 1
?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z PROC	; SK_RawInput_EnableLegacyKeyboard

; 492  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 493  :   if (! raw_overrides.keyboard.active)

	cmp	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A+2, 0
	jne	$LN11@SK_RawInpu

; 496  :     raw_overrides.keyboard.legacy_messages = enable;

	mov	al, BYTE PTR _enable$[ebp]
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	xor	ebx, ebx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 495  :     raw_overrides.keyboard.active          = true;

	mov	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A+2, 1
	push	esi
	push	edi

; 496  :     raw_overrides.keyboard.legacy_messages = enable;

	mov	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A+3, al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR _device_override$3[ebp], ebx

; 477  : 		_Mylast(),

	mov	DWORD PTR _device_override$3[ebp+4], ebx

; 478  : 		_Myend()

	mov	DWORD PTR _device_override$3[ebp+8], ebx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 502  :     std::vector <RAWINPUTDEVICE> keyboards = SK_RawInput_GetKeyboards (&different);

	lea	eax, DWORD PTR _different$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	push	eax
	lea	eax, DWORD PTR _keyboards$2[ebp]
	mov	BYTE PTR _different$4[ebp], bl
	push	eax
	call	?SK_RawInput_GetKeyboards@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z ; SK_RawInput_GetKeyboards
	add	esp, 8

; 504  :     for (auto& it : keyboards)    device_override.push_back (it);

	mov	esi, DWORD PTR _keyboards$2[ebp]
	mov	edi, DWORD PTR _keyboards$2[ebp+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	esi, edi
	je	SHORT $LN3@SK_RawInpu
	npad	5
$LL4@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _device_override$3[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 504  :     for (auto& it : keyboards)    device_override.push_back (it);

	cmp	esi, edi
	jne	SHORT $LL4@SK_RawInpu
	mov	ebx, DWORD PTR _device_override$3[ebp]
$LN3@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 42   : 		: _Ptr(_Parg)

	mov	edi, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 505  :     for (auto& it : raw_gamepads) device_override.push_back (it);

	mov	esi, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	cmp	esi, edi
	je	SHORT $LN6@SK_RawInpu
$LL7@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _device_override$3[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 505  :     for (auto& it : raw_gamepads) device_override.push_back (it);

	cmp	esi, edi
	jne	SHORT $LL7@SK_RawInpu
	mov	ebx, DWORD PTR _device_override$3[ebp]
$LN6@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 42   : 		: _Ptr(_Parg)

	mov	edi, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 506  :     for (auto& it : raw_mice)     device_override.push_back (it);

	mov	esi, DWORD PTR ?raw_mice@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	cmp	esi, edi
	je	SHORT $LN9@SK_RawInpu
$LL10@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _device_override$3[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 506  :     for (auto& it : raw_mice)     device_override.push_back (it);

	cmp	esi, edi
	jne	SHORT $LL10@SK_RawInpu
	mov	ebx, DWORD PTR _device_override$3[ebp]
$LN9@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR _device_override$3[ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, ebx
	imul	ecx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 508  :     RegisterRawInputDevices_Original (

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 508  :     RegisterRawInputDevices_Original (

	push	eax
	push	ebx
	call	DWORD PTR ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	esi, DWORD PTR _keyboards$2[ebp]
	test	esi, esi
	je	SHORT $LN273@SK_RawInpu

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _keyboards$2[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, esi
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN340@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN502@SK_RawInpu:
$LN340@SK_RawInpu:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN345@SK_RawInpu

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR _keyboards$2[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN342@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN503@SK_RawInpu:
$LN342@SK_RawInpu:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	esi, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	esi, eax
	jb	SHORT $LN343@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN504@SK_RawInpu:
$LN343@SK_RawInpu:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, esi
	cmp	eax, 4
	jae	SHORT $LN344@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN505@SK_RawInpu:
$LN344@SK_RawInpu:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN345@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN506@SK_RawInpu:
$LN345@SK_RawInpu:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN273@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	ebx, ebx
	je	SHORT $LN383@SK_RawInpu

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _device_override$3[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, ebx
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN450@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN507@SK_RawInpu:
$LN450@SK_RawInpu:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN451@SK_RawInpu

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bl, 31					; 0000001fH
	je	SHORT $LN452@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN508@SK_RawInpu:
$LN452@SK_RawInpu:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ebx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ebx
	jb	SHORT $LN453@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN509@SK_RawInpu:
$LN453@SK_RawInpu:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ebx, eax
	cmp	ebx, 4
	jae	SHORT $LN454@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN510@SK_RawInpu:
$LN454@SK_RawInpu:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ebx, 35					; 00000023H
	jbe	SHORT $LN455@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN511@SK_RawInpu:
$LN455@SK_RawInpu:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ebx, eax
$LN451@SK_RawInpu:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN383@SK_RawInpu:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 514  :     return different;

	mov	al, BYTE PTR _different$4[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 515  :   }
; 516  : 
; 517  :   return false;
; 518  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@SK_RawInpu:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN501@SK_RawInpu:
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z$0:
	lea	ecx, DWORD PTR _device_override$3[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__unwindfunclet$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z$1:
	lea	ecx, DWORD PTR _keyboards$2[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__ehhandler$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z ENDP	; SK_RawInput_EnableLegacyKeyboard
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_RawInput_RestoreLegacyMouse@@YAXXZ PROC		; SK_RawInput_RestoreLegacyMouse

; 477  :   if (raw_overrides.mouse.active)

	cmp	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A, 0
	je	SHORT $LN2@SK_RawInpu
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	imul	ecx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 481  :     RegisterRawInputDevices_Original (

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 479  :     raw_overrides.mouse.active = false;

	mov	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 481  :     RegisterRawInputDevices_Original (

	push	eax
	push	DWORD PTR ?raw_devices@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	call	DWORD PTR ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
$LN2@SK_RawInpu:

; 482  :       raw_devices.data (),
; 483  :         static_cast <UINT> (raw_devices.size ()),
; 484  :           sizeof RAWINPUTDEVICE
; 485  :     );
; 486  :   }
; 487  : }

	ret	0
?SK_RawInput_RestoreLegacyMouse@@YAXXZ ENDP		; SK_RawInput_RestoreLegacyMouse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_mice$2 = -40						; size = 12
_device_override$3 = -28				; size = 12
_different$4 = -13					; size = 1
__$EHRec$ = -12						; size = 12
_enable$ = 8						; size = 1
?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z PROC		; SK_RawInput_EnableLegacyMouse

; 439  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 440  :   if (! raw_overrides.mouse.active)

	cmp	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A, 0
	jne	$LN11@SK_RawInpu

; 443  :     raw_overrides.mouse.legacy_messages = enable;

	mov	al, BYTE PTR _enable$[ebp]
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	xor	ebx, ebx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 442  :     raw_overrides.mouse.active          = true;

	mov	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A, 1
	push	esi
	push	edi

; 443  :     raw_overrides.mouse.legacy_messages = enable;

	mov	BYTE PTR ?raw_overrides@@3U<unnamed-type-raw_overrides>@@A+1, al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR _device_override$3[ebp], ebx

; 477  : 		_Mylast(),

	mov	DWORD PTR _device_override$3[ebp+4], ebx

; 478  : 		_Myend()

	mov	DWORD PTR _device_override$3[ebp+8], ebx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 453  :     std::vector <RAWINPUTDEVICE> mice = SK_RawInput_GetMice (&different);

	lea	eax, DWORD PTR _different$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	push	eax
	lea	eax, DWORD PTR _mice$2[ebp]
	mov	BYTE PTR _different$4[ebp], bl
	push	eax
	call	?SK_RawInput_GetMice@@YA?AV?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@PA_N@Z ; SK_RawInput_GetMice
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 42   : 		: _Ptr(_Parg)

	mov	edi, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 455  :     for (auto& it : raw_keyboards) device_override.push_back (it);

	mov	esi, DWORD PTR ?raw_keyboards@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	esi, edi
	je	SHORT $LN3@SK_RawInpu
$LL4@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _device_override$3[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 455  :     for (auto& it : raw_keyboards) device_override.push_back (it);

	cmp	esi, edi
	jne	SHORT $LL4@SK_RawInpu
	mov	ebx, DWORD PTR _device_override$3[ebp]
$LN3@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 42   : 		: _Ptr(_Parg)

	mov	edi, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A+4
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 456  :     for (auto& it : raw_gamepads)  device_override.push_back (it);

	mov	esi, DWORD PTR ?raw_gamepads@@3V?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@A
	cmp	esi, edi
	je	SHORT $LN6@SK_RawInpu
$LL7@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _device_override$3[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 456  :     for (auto& it : raw_gamepads)  device_override.push_back (it);

	cmp	esi, edi
	jne	SHORT $LL7@SK_RawInpu
	mov	ebx, DWORD PTR _device_override$3[ebp]
$LN6@SK_RawInpu:

; 457  :     for (auto& it : mice)          device_override.push_back (it);

	mov	edi, DWORD PTR _mice$2[ebp]
	mov	esi, edi
	cmp	edi, DWORD PTR _mice$2[ebp+4]
	je	SHORT $LN9@SK_RawInpu
	mov	ebx, DWORD PTR _mice$2[ebp+4]
$LL10@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 947  : 		emplace_back(_Val);

	push	esi
	lea	ecx, DWORD PTR _device_override$3[ebp]
	call	??$emplace_back@ABUtagRAWINPUTDEVICE@@@?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAEXABUtagRAWINPUTDEVICE@@@Z ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::emplace_back<tagRAWINPUTDEVICE const &>

; 107  : 		++_Ptr;

	add	esi, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 457  :     for (auto& it : mice)          device_override.push_back (it);

	cmp	esi, ebx
	jne	SHORT $LL10@SK_RawInpu
	mov	ebx, DWORD PTR _device_override$3[ebp]
$LN9@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR _device_override$3[ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, ebx
	imul	ecx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 461  :     RegisterRawInputDevices_Original (

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 461  :     RegisterRawInputDevices_Original (

	push	eax
	push	ebx
	call	DWORD PTR ?RegisterRawInputDevices_Original@@3P6GHPBUtagRAWINPUTDEVICE@@II@ZA ; RegisterRawInputDevices_Original
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	edi, edi
	je	SHORT $LN273@SK_RawInpu

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _mice$2[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, edi
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN340@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN502@SK_RawInpu:
$LN340@SK_RawInpu:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN345@SK_RawInpu

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR _mice$2[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN342@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN503@SK_RawInpu:
$LN342@SK_RawInpu:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	edi, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	edi, eax
	jb	SHORT $LN343@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN504@SK_RawInpu:
$LN343@SK_RawInpu:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, edi
	cmp	eax, 4
	jae	SHORT $LN344@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN505@SK_RawInpu:
$LN344@SK_RawInpu:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN345@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN506@SK_RawInpu:
$LN345@SK_RawInpu:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN273@SK_RawInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	test	ebx, ebx
	je	SHORT $LN383@SK_RawInpu

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _device_override$3[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, ebx
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN450@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN507@SK_RawInpu:
$LN450@SK_RawInpu:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN451@SK_RawInpu

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bl, 31					; 0000001fH
	je	SHORT $LN452@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN508@SK_RawInpu:
$LN452@SK_RawInpu:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ebx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ebx
	jb	SHORT $LN453@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN509@SK_RawInpu:
$LN453@SK_RawInpu:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ebx, eax
	cmp	ebx, 4
	jae	SHORT $LN454@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN510@SK_RawInpu:
$LN454@SK_RawInpu:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ebx, 35					; 00000023H
	jbe	SHORT $LN455@SK_RawInpu
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN511@SK_RawInpu:
$LN455@SK_RawInpu:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ebx, eax
$LN451@SK_RawInpu:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN383@SK_RawInpu:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 467  :     return different;

	mov	al, BYTE PTR _different$4[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 468  :   }
; 469  : 
; 470  :   return false;
; 471  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@SK_RawInpu:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN501@SK_RawInpu:
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z$0:
	lea	ecx, DWORD PTR _device_override$3[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__unwindfunclet$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z$1:
	lea	ecx, DWORD PTR _mice$2[ebp]
	jmp	??1?$vector@UtagRAWINPUTDEVICE@@V?$allocator@UtagRAWINPUTDEVICE@@@std@@@std@@QAE@XZ ; std::vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >::~vector<tagRAWINPUTDEVICE,std::allocator<tagRAWINPUTDEVICE> >
__ehhandler$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z ENDP		; SK_RawInput_EnableLegacyMouse
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
?SK_ImGui_HandlesMessage@@YA_NPAUtagMSG@@_N1@Z PROC	; SK_ImGui_HandlesMessage

; 1655 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1656 :   assert (lpMsg->hwnd == game_window.hWnd);
; 1657 : 
; 1658 :   bool handled = false;
; 1659 : 
; 1660 :   switch (lpMsg->message)

	mov	ecx, DWORD PTR _lpMsg$[ebp]
	push	ebx
	xor	bl, bl
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, edx
	cmp	eax, 274				; 00000112H
	ja	SHORT $LN18@SK_ImGui_H
	je	SHORT $LN4@SK_ImGui_H
	sub	eax, 32					; 00000020H
	cmp	eax, 229				; 000000e5H
	ja	$LN14@SK_ImGui_H
	movzx	eax, BYTE PTR $LN19@SK_ImGui_H[eax]
	jmp	DWORD PTR $LN23@SK_ImGui_H[eax*4]
$LN7@SK_ImGui_H:

; 1670 :       break;
; 1671 : 
; 1672 :     // Fix for Melody's Escape, which attempts to remove these messages!
; 1673 :     case WM_KEYDOWN:
; 1674 :     case WM_KEYUP:
; 1675 :     case WM_SYSKEYDOWN:
; 1676 :     case WM_SYSKEYUP:
; 1677 :     {
; 1678 :       if (ImGui_WndProcHandler (lpMsg->hwnd, lpMsg->message, lpMsg->wParam, lpMsg->lParam))

	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	push	edx
	push	DWORD PTR [ecx]
	call	?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z ; ImGui_WndProcHandler
	test	eax, eax
	je	$LN2@SK_ImGui_H

; 1679 :         handled = true;

	mov	bl, 1

; 1727 :     } break;
; 1728 :   }
; 1729 : 
; 1730 :   return handled;

	mov	al, bl
	pop	ebx

; 1731 : }

	pop	ebp
	ret	0
$LN9@SK_ImGui_H:

; 1680 :     } break;
; 1681 : 
; 1682 :     case WM_SETCURSOR:
; 1683 :     {
; 1684 :       if (lpMsg->hwnd == game_window.hWnd && game_window.hWnd != nullptr)

	mov	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	cmp	DWORD PTR [ecx], eax
	jne	$LN2@SK_ImGui_H
	test	eax, eax
	je	$LN2@SK_ImGui_H

; 1685 :         SK_ImGui_Cursor.update ();

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?update@sk_imgui_cursor_s@@QAEXXZ	; sk_imgui_cursor_s::update

; 1727 :     } break;
; 1728 :   }
; 1729 : 
; 1730 :   return handled;

	mov	al, bl
	pop	ebx

; 1731 : }

	pop	ebp
	ret	0
$LN4@SK_ImGui_H:

; 1661 :   {
; 1662 :     case WM_SYSCOMMAND:
; 1663 :       if ((lpMsg->wParam & 0xfff0) == SC_KEYMENU && lpMsg->lParam == 0) // Disable ALT application menu

	mov	eax, DWORD PTR [ecx+8]
	and	eax, 65520				; 0000fff0H
	cmp	eax, 61696				; 0000f100H
	jne	SHORT $LN2@SK_ImGui_H
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN2@SK_ImGui_H
$LN21@SK_ImGui_H:

; 1664 :         handled = true;

	mov	bl, 1

; 1727 :     } break;
; 1728 :   }
; 1729 : 
; 1730 :   return handled;

	mov	al, bl
	pop	ebx

; 1731 : }

	pop	ebp
	ret	0
$LN18@SK_ImGui_H:

; 1656 :   assert (lpMsg->hwnd == game_window.hWnd);
; 1657 : 
; 1658 :   bool handled = false;
; 1659 : 
; 1660 :   switch (lpMsg->message)

	sub	eax, 288				; 00000120H
	cmp	eax, 249				; 000000f9H
	ja	SHORT $LN14@SK_ImGui_H
	movzx	eax, BYTE PTR $LN20@SK_ImGui_H[eax]
	jmp	DWORD PTR $LN24@SK_ImGui_H[eax*4]
$LN6@SK_ImGui_H:

; 1665 :       break;
; 1666 : 
; 1667 :     case WM_CHAR:
; 1668 :     case WM_MENUCHAR:
; 1669 :       handled = SK_ImGui_WantTextCapture ();

	call	?SK_ImGui_WantTextCapture@@YA_NXZ	; SK_ImGui_WantTextCapture
	mov	bl, al
	pop	ebx

; 1731 : }

	pop	ebp
	ret	0
$LN11@SK_ImGui_H:

; 1686 :     } break;
; 1687 : 
; 1688 :     // TODO: Does this message have an HWND always?
; 1689 :     case WM_DEVICECHANGE:
; 1690 :     {
; 1691 :       handled =

	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	push	edx
	push	DWORD PTR [ecx]
	call	?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z ; ImGui_WndProcHandler
	test	eax, eax
	setne	bl

; 1727 :     } break;
; 1728 :   }
; 1729 : 
; 1730 :   return handled;

	mov	al, bl
	pop	ebx

; 1731 : }

	pop	ebp
	ret	0
$LN12@SK_ImGui_H:

; 1692 :         ImGui_WndProcHandler (lpMsg->hwnd, lpMsg->message, lpMsg->wParam, lpMsg->lParam);
; 1693 :     } break;
; 1694 : 
; 1695 :     // Pre-Dispose These Mesages (fixes The Witness)
; 1696 :     case WM_LBUTTONDBLCLK:
; 1697 :     case WM_LBUTTONDOWN:
; 1698 :     case WM_LBUTTONUP:
; 1699 :     case WM_MBUTTONDBLCLK:
; 1700 :     case WM_MBUTTONDOWN:
; 1701 :     case WM_MBUTTONUP:
; 1702 :     case WM_RBUTTONDBLCLK:
; 1703 :     case WM_RBUTTONDOWN:
; 1704 :     case WM_RBUTTONUP:
; 1705 :     case WM_XBUTTONDBLCLK:
; 1706 :     case WM_XBUTTONDOWN:
; 1707 :     case WM_XBUTTONUP:
; 1708 : 
; 1709 :     case WM_CAPTURECHANGED:
; 1710 :     case WM_MOUSEMOVE:
; 1711 :     case WM_MOUSEWHEEL:
; 1712 :     case WM_MOUSEHWHEEL:
; 1713 :     {
; 1714 :       handled =

	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	push	edx
	push	DWORD PTR [ecx]
	call	?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z ; ImGui_WndProcHandler
	test	eax, eax
	je	SHORT $LN16@SK_ImGui_H
	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	jne	SHORT $LN21@SK_ImGui_H
$LN16@SK_ImGui_H:
	xor	bl, bl

; 1727 :     } break;
; 1728 :   }
; 1729 : 
; 1730 :   return handled;

	mov	al, bl
	pop	ebx

; 1731 : }

	pop	ebp
	ret	0
$LN14@SK_ImGui_H:

; 1715 :         ( ImGui_WndProcHandler (lpMsg->hwnd, lpMsg->message, lpMsg->wParam, lpMsg->lParam) != 0 ) &&
; 1716 :        SK_ImGui_WantMouseCapture ();
; 1717 :     } break;
; 1718 : 
; 1719 :     case WM_INPUT:
; 1720 :     {
; 1721 :       ////handled = (ImGui_WndProcHandler (lpMsg->hwnd, lpMsg->message, lpMsg->wParam, lpMsg->lParam) != 0);
; 1722 :     } break;
; 1723 : 
; 1724 :     default:
; 1725 :     {
; 1726 :       ImGui_WndProcHandler (lpMsg->hwnd, lpMsg->message, lpMsg->wParam, lpMsg->lParam);

	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	push	edx
	push	DWORD PTR [ecx]
	call	?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z ; ImGui_WndProcHandler
$LN2@SK_ImGui_H:

; 1727 :     } break;
; 1728 :   }
; 1729 : 
; 1730 :   return handled;

	mov	al, bl
	pop	ebx

; 1731 : }

	pop	ebp
	ret	0
	npad	1
$LN23@SK_ImGui_H:
	DD	$LN9@SK_ImGui_H
	DD	$LN2@SK_ImGui_H
	DD	$LN7@SK_ImGui_H
	DD	$LN6@SK_ImGui_H
	DD	$LN14@SK_ImGui_H
$LN19@SK_ImGui_H:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	2
	DB	3
	DB	4
	DB	2
	DB	2
	npad	2
$LN24@SK_ImGui_H:
	DD	$LN6@SK_ImGui_H
	DD	$LN12@SK_ImGui_H
	DD	$LN11@SK_ImGui_H
	DD	$LN14@SK_ImGui_H
$LN20@SK_ImGui_H:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	2
?SK_ImGui_HandlesMessage@@YA_NPAUtagMSG@@_N1@Z ENDP	; SK_ImGui_HandlesMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
;	COMDAT ?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z PROC ; sk_input_api_context_s::markRead, COMDAT
; _this$ = ecx

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _type$[ebp]
	cmp	edx, 1
	jne	SHORT $LN5@markRead
	xor	eax, eax
	lock	 inc	 DWORD PTR [ecx+eax*4+32]

; 105  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 106  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
$LN5@markRead:

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	cmp	edx, 2
	jne	SHORT $LN3@markRead
	mov	eax, 1
	lock	 inc	 DWORD PTR [ecx+eax*4+32]

; 105  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 106  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
$LN3@markRead:

; 104  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	xor	eax, eax
	cmp	edx, 4
	setne	al
	lock	 inc	 DWORD PTR [ecx+eax*4+40]

; 105  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 106  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z ENDP ; sk_input_api_context_s::markRead
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0sk_imgui_cursor_s@@QAE@XZ
_TEXT	SEGMENT
??0sk_imgui_cursor_s@@QAE@XZ PROC			; sk_imgui_cursor_s::sk_imgui_cursor_s, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	BYTE PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	WORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], -1
	mov	WORD PTR [ecx+36], 1
	mov	BYTE PTR [ecx+38], 1
	ret	0
??0sk_imgui_cursor_s@@QAE@XZ ENDP			; sk_imgui_cursor_s::sk_imgui_cursor_s
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-prefs>@sk_imgui_cursor_s@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-prefs>@sk_imgui_cursor_s@@QAE@XZ PROC	; sk_imgui_cursor_s::<unnamed-type-prefs>::<unnamed-type-prefs>, COMDAT
; _this$ = ecx
	mov	WORD PTR [ecx], 1
	mov	eax, ecx
	mov	BYTE PTR [ecx+2], 1
	ret	0
??0<unnamed-type-prefs>@sk_imgui_cursor_s@@QAE@XZ ENDP	; sk_imgui_cursor_s::<unnamed-type-prefs>::<unnamed-type-prefs>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-no_warp>@<unnamed-type-prefs>@sk_imgui_cursor_s@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-no_warp>@<unnamed-type-prefs>@sk_imgui_cursor_s@@QAE@XZ PROC ; sk_imgui_cursor_s::<unnamed-type-prefs>::<unnamed-type-no_warp>::<unnamed-type-no_warp>, COMDAT
; _this$ = ecx
	mov	WORD PTR [ecx], 1
	mov	eax, ecx
	mov	BYTE PTR [ecx+2], 1
	ret	0
??0<unnamed-type-no_warp>@<unnamed-type-prefs>@sk_imgui_cursor_s@@QAE@XZ ENDP ; sk_imgui_cursor_s::<unnamed-type-prefs>::<unnamed-type-no_warp>::<unnamed-type-no_warp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_ci$ = -20						; size = 20
_active$ = 8						; size = 1
?activateWindow@sk_imgui_cursor_s@@QAEX_N@Z PROC	; sk_imgui_cursor_s::activateWindow
; _this$ = ecx

; 1076 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	xorps	xmm0, xmm0

; 1077 :   CURSORINFO ci = { };

	mov	DWORD PTR _ci$[ebp+16], 0

; 1078 :   ci.cbSize     = sizeof ci;
; 1079 : 
; 1080 :   GetCursorInfo_Original (&ci);

	lea	eax, DWORD PTR _ci$[ebp]
	movups	XMMWORD PTR _ci$[ebp], xmm0
	push	eax
	mov	DWORD PTR _ci$[ebp], 20			; 00000014H
	call	DWORD PTR ?GetCursorInfo_Original@@3P6GHPAUtagCURSORINFO@@@ZA ; GetCursorInfo_Original

; 1081 : 
; 1082 :   if (active)

	cmp	BYTE PTR _active$[ebp], 0
	je	SHORT $LN6@activateWi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN14@activateWi
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN14@activateWi
	xor	eax, eax
	jmp	SHORT $LN15@activateWi
$LN14@activateWi:
	mov	eax, 1
$LN15@activateWi:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN10@activateWi
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	je	SHORT $LN6@activateWi
$LN10@activateWi:

; 1083 :   {
; 1084 :     if (SK_ImGui_IsMouseRelevant ())
; 1085 :     {
; 1086 :       if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	jne	SHORT $LN6@activateWi

; 1087 :       {
; 1088 : 
; 1089 :       }
; 1090 : 
; 1091 :       else if (SK_ImGui_Cursor.orig_img)

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A
	test	eax, eax
	je	SHORT $LN6@activateWi

; 1092 :         SetCursor_Original (SK_ImGui_Cursor.orig_img);

	push	eax
	call	DWORD PTR ?SetCursor_Original@@3P6GPAUHICON__@@PAU1@@ZA ; SetCursor_Original
$LN6@activateWi:

; 1093 :     }
; 1094 :   }
; 1095 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?activateWindow@sk_imgui_cursor_s@@QAEX_N@Z ENDP	; sk_imgui_cursor_s::activateWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ?ScreenToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
_lpPoint$ = 8						; size = 4
?ScreenToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z PROC ; sk_imgui_cursor_s::ScreenToLocal, COMDAT
; _this$ = ecx

; 973  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 974  :   ScreenToClient (game_window.hWnd, lpPoint);

	push	DWORD PTR _lpPoint$[ebp]
	mov	edi, ecx
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__ScreenToClient@8

; 975  :   ClientToLocal  (lpPoint);

	push	DWORD PTR _lpPoint$[ebp]
	mov	ecx, edi
	call	?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::ClientToLocal
	pop	edi

; 976  : }

	pop	ebp
	ret	4
?ScreenToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ENDP ; sk_imgui_cursor_s::ScreenToLocal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_real_client$ = -24					; size = 16
_local_dims$ = -8					; size = 8
_lpPoint$ = 8						; size = 4
?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z PROC ; sk_imgui_cursor_s::ClientToLocal
; _this$ = ecx

; 943  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 944  :   RECT real_client;
; 945  :   GetClientRect (game_window.hWnd, &real_client);

	lea	eax, DWORD PTR _real_client$[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 946  : 
; 947  :   const ImVec2 local_dims =
; 948  :     ImGui::GetIO ().DisplayFramebufferScale;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm3, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR [eax+148]
	mov	DWORD PTR _local_dims$[ebp+4], eax

; 949  : 
; 950  :   struct {
; 951  :     float width  = 1.0f,
; 952  :           height = 1.0f;
; 953  :   } in, out;
; 954  : 
; 955  :   out.width  = local_dims.x;
; 956  :   out.height = local_dims.y;
; 957  : 
; 958  :   in.width   = (float)(real_client.right  - real_client.left);

	mov	eax, DWORD PTR _real_client$[ebp+8]
	sub	eax, DWORD PTR _real_client$[ebp]
	mov	DWORD PTR _local_dims$[ebp], ecx

; 959  :   in.height  = (float)(real_client.bottom - real_client.top);
; 960  : 
; 961  :   float x = 2.0f * ((float)lpPoint->x / std::max (1.0f, in.width )) - 1.0f;

	mov	ecx, DWORD PTR _lpPoint$[ebp]
	movd	xmm0, eax
	mov	eax, DWORD PTR _real_client$[ebp+12]
	sub	eax, DWORD PTR _real_client$[ebp+4]
	movd	xmm1, DWORD PTR [ecx]
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm1, xmm1
	maxss	xmm0, xmm3
	movd	xmm4, eax
	cvtdq2ps xmm4, xmm4
	divss	xmm1, xmm0
	movd	xmm0, DWORD PTR [ecx+4]
	maxss	xmm4, xmm3

; 962  :   float y = 2.0f * ((float)lpPoint->y / std::max (1.0f, in.height)) - 1.0f;

	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm1
	divss	xmm0, xmm4
	subss	xmm1, xmm3
	addss	xmm0, xmm0

; 963  :                                         // Avoid division-by-zero, this should be a signaling NAN but
; 964  :                                         //   some games alter FPU behavior and will turn this into a non-continuable exception.
; 965  : 
; 966  :   lpPoint->x = (LONG)( ( x * out.width  + out.width  ) / 2.0f );

	addss	xmm1, xmm3
	subss	xmm0, xmm3
	mulss	xmm1, DWORD PTR _local_dims$[ebp]

; 967  :   lpPoint->y = (LONG)( ( y * out.height + out.height ) / 2.0f );

	addss	xmm0, xmm3
	mulss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR _local_dims$[ebp+4]
	cvttss2si eax, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	DWORD PTR [ecx], eax
	cvttss2si eax, xmm0
	mov	DWORD PTR [ecx+4], eax

; 968  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ENDP ; sk_imgui_cursor_s::ClientToLocal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_real_client$ = -24					; size = 16
_local_dims$ = -8					; size = 8
_lpPoint$ = 8						; size = 4
?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z PROC ; sk_imgui_cursor_s::LocalToClient
; _this$ = ecx

; 916  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 917  :   RECT real_client;
; 918  :   GetClientRect (game_window.hWnd, &real_client);

	lea	eax, DWORD PTR _real_client$[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 919  : 
; 920  :   ImVec2 local_dims =
; 921  :     ImGui::GetIO ().DisplayFramebufferScale;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm3, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _local_dims$[ebp], ecx

; 922  : 
; 923  :   struct {
; 924  :     float width  = 1.0f,
; 925  :           height = 1.0f;
; 926  :   } in, out;
; 927  : 
; 928  :   in.width   = local_dims.x;
; 929  :   in.height  = local_dims.y;
; 930  : 
; 931  :   out.width  = (float)(real_client.right  - real_client.left);
; 932  :   out.height = (float)(real_client.bottom - real_client.top);
; 933  : 
; 934  :   float x = 2.0f * ((float)lpPoint->x / std::max (1.0f, in.width )) - 1.0f;

	mov	ecx, DWORD PTR _lpPoint$[ebp]
	movss	xmm0, DWORD PTR _local_dims$[ebp]
	maxss	xmm0, xmm3
	mov	eax, DWORD PTR [eax+148]
	mov	DWORD PTR _local_dims$[ebp+4], eax
	movd	xmm1, DWORD PTR [ecx]
	cvtdq2ps xmm1, xmm1
	mov	eax, DWORD PTR _real_client$[ebp+8]
	sub	eax, DWORD PTR _real_client$[ebp]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR _local_dims$[ebp+4]
	addss	xmm1, xmm1
	movd	xmm2, eax
	mov	eax, DWORD PTR _real_client$[ebp+12]
	maxss	xmm0, xmm3
	sub	eax, DWORD PTR _real_client$[ebp+4]
	cvtdq2ps xmm2, xmm2
	subss	xmm1, xmm3
	movd	xmm4, eax
	cvtdq2ps xmm4, xmm4

; 935  :   float y = 2.0f * ((float)lpPoint->y / std::max (1.0f, in.height)) - 1.0f;
; 936  : 
; 937  :   lpPoint->x = (LONG)( ( x * out.width  + out.width  ) / 2.0f );

	addss	xmm1, xmm3
	mulss	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@3f000000
	cvttss2si eax, xmm1
	movd	xmm1, DWORD PTR [ecx+4]
	cvtdq2ps xmm1, xmm1
	mov	DWORD PTR [ecx], eax
	divss	xmm1, xmm0
	addss	xmm1, xmm1
	subss	xmm1, xmm3

; 938  :   lpPoint->y = (LONG)( ( y * out.height + out.height ) / 2.0f );

	addss	xmm1, xmm3
	mulss	xmm1, xmm4
	mulss	xmm1, DWORD PTR __real@3f000000
	cvttss2si eax, xmm1
	mov	DWORD PTR [ecx+4], eax

; 939  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ENDP ; sk_imgui_cursor_s::LocalToClient
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ?LocalToScreen@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
_lpPoint$ = 8						; size = 4
?LocalToScreen@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z PROC ; sk_imgui_cursor_s::LocalToScreen, COMDAT
; _this$ = ecx

; 909  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 910  :   LocalToClient  (lpPoint);

	push	DWORD PTR _lpPoint$[ebp]
	call	?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::LocalToClient

; 911  :   ClientToScreen (game_window.hWnd, lpPoint);

	push	DWORD PTR _lpPoint$[ebp]
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__ClientToScreen@8

; 912  : }

	pop	ebp
	ret	4
?LocalToScreen@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ENDP ; sk_imgui_cursor_s::LocalToScreen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
;	COMDAT ?update@sk_imgui_cursor_s@@QAEXXZ
_TEXT	SEGMENT
?update@sk_imgui_cursor_s@@QAEXXZ PROC			; sk_imgui_cursor_s::update, COMDAT
; _this$ = ecx

; 884  :   if (GetGameCursor () != nullptr)

	call	?GetGameCursor@@YAPAUHICON__@@XZ	; GetGameCursor
	test	eax, eax
	je	SHORT $LN2@update

; 885  :     SK_ImGui_Cursor.orig_img = GetGameCursor ();

	call	?GetGameCursor@@YAPAUHICON__@@XZ	; GetGameCursor
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A, eax
$LN2@update:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN15@update
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN15@update
	xor	eax, eax
	jmp	SHORT $LN16@update
$LN15@update:
	mov	eax, 1
$LN16@update:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN11@update
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN11@update
$LN19@update:

; 891  :     else
; 892  :       SK_ImGui_Cursor.showSystemCursor (true);
; 893  :   }
; 894  : 
; 895  :   else
; 896  :     SK_ImGui_Cursor.showSystemCursor ();

	push	1
	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z ; sk_imgui_cursor_s::showSystemCursor

; 897  : }

	ret	0
$LN11@update:

; 886  : 
; 887  :   if (SK_ImGui_IsMouseRelevant ())
; 888  :   {
; 889  :     if (ImGui::GetIO ().WantCaptureMouse || SK_ImGui_Cursor.orig_img == nullptr)

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	cmp	BYTE PTR [eax+840], 0
	jne	SHORT $LN7@update
	cmp	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A, 0
	jne	SHORT $LN19@update
$LN7@update:

; 890  :       SK_ImGui_Cursor.showSystemCursor (false);

	push	0
	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z ; sk_imgui_cursor_s::showSystemCursor

; 897  : }

	ret	0
?update@sk_imgui_cursor_s@@QAEXXZ ENDP			; sk_imgui_cursor_s::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_cursor_info$ = -20					; size = 20
_system$ = 8						; size = 1
?showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z PROC	; sk_imgui_cursor_s::showSystemCursor
; _this$ = ecx

; 1047 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1048 :   CURSORINFO cursor_info = { };
; 1049 :   cursor_info.cbSize     = sizeof (CURSORINFO);
; 1050 : 
; 1051 :   static HCURSOR wait_cursor =

	mov	eax, DWORD PTR fs:__tls_array
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR __tls_index
	movups	XMMWORD PTR _cursor_info$[ebp], xmm0
	mov	DWORD PTR _cursor_info$[ebp+16], 0
	mov	DWORD PTR _cursor_info$[ebp], 20	; 00000014H
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jg	$LN19@showSystem
$LN2@showSystem:

; 1053 : 
; 1054 :   if (SK_ImGui_Cursor.orig_img == wait_cursor)

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A
	cmp	eax, DWORD PTR ?wait_cursor@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4PAUHICON__@@A
	jne	SHORT $LN3@showSystem

; 1055 :     SK_ImGui_Cursor.orig_img = LoadCursor (nullptr, IDC_ARROW);

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorW@8
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A, eax
$LN3@showSystem:

; 1056 : 
; 1057 :   if (system)

	cmp	BYTE PTR _system$[ebp], 0
	je	SHORT $LN4@showSystem

; 1058 :   {
; 1059 :     SetCursor_Original     (SK_ImGui_Cursor.orig_img);

	push	eax
	call	DWORD PTR ?SetCursor_Original@@3P6GPAUHICON__@@PAU1@@ZA ; SetCursor_Original

; 1060 :     GetCursorInfo_Original (&cursor_info);

	lea	eax, DWORD PTR _cursor_info$[ebp]
	push	eax
	call	DWORD PTR ?GetCursorInfo_Original@@3P6GHPAUtagCURSORINFO@@@ZA ; GetCursorInfo_Original
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN16@showSystem
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN16@showSystem
	xor	eax, eax
	jmp	SHORT $LN17@showSystem
$LN16@showSystem:
	mov	eax, 1
$LN17@showSystem:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN12@showSystem
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	je	SHORT $LN8@showSystem
$LN12@showSystem:

; 1061 : 
; 1062 :     if ((! SK_ImGui_IsMouseRelevant ()) || (cursor_info.flags & CURSOR_SHOWING))

	test	BYTE PTR _cursor_info$[ebp+4], 1
	je	SHORT $LN4@showSystem
$LN8@showSystem:

; 1063 :       ImGui::GetIO ().MouseDrawCursor = false;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+224], 0

; 1071 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@showSystem:

; 1064 : 
; 1065 :     else
; 1066 :       ImGuiCursor_Impl ();
; 1067 :   }
; 1068 : 
; 1069 :   else
; 1070 :     ImGuiCursor_Impl ();

	call	?ImGuiCursor_Impl@@YAXXZ		; ImGuiCursor_Impl

; 1071 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN19@showSystem:

; 1048 :   CURSORINFO cursor_info = { };
; 1049 :   cursor_info.cbSize     = sizeof (CURSORINFO);
; 1050 : 
; 1051 :   static HCURSOR wait_cursor =

	push	OFFSET ?$TSS0@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4HA, -1
	jne	$LN2@showSystem

; 1052 :     LoadCursor (nullptr, IDC_WAIT);

	push	32514					; 00007f02H
	push	0
	call	DWORD PTR __imp__LoadCursorW@8
	push	OFFSET ?$TSS0@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4HA
	mov	DWORD PTR ?wait_cursor@?1??showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z@4PAUHICON__@@A, eax
	call	__Init_thread_footer
	add	esp, 4
	jmp	$LN2@showSystem
?showSystemCursor@sk_imgui_cursor_s@@QAEX_N@Z ENDP	; sk_imgui_cursor_s::showSystemCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_Input_Init@@YAXXZ PROC				; SK_Input_Init

; 1827 :   SK_Input_PreHookHID    ();

	call	?SK_Input_PreHookHID@@YAXXZ		; SK_Input_PreHookHID

; 1828 :   SK_Input_PreHookDI8    ();

	call	?SK_Input_PreHookDI8@@YAXXZ		; SK_Input_PreHookDI8

; 1829 :   SK_Input_PreHookXInput ();

	jmp	?SK_Input_PreHookXInput@@YAXXZ		; SK_Input_PreHookXInput
?SK_Input_Init@@YAXXZ ENDP				; SK_Input_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_Input_HookHID@@YAXXZ PROC				; SK_Input_HookHID

; 245  :   if (! config.input.gamepad.hook_hid)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+692, 0
	je	$LN5@SK_Input_H

; 246  :     return;
; 247  : 
; 248  :   static volatile LONG hooked = FALSE;
; 249  : 
; 250  :   if (! InterlockedCompareExchange (&hooked, 1, 0))

	mov	ecx, 1
	mov	edx, OFFSET ?hooked@?1??SK_Input_HookHID@@YAXXZ@4JC
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
	test	eax, eax
	jne	$LN5@SK_Input_H

; 251  :   {
; 252  :     SK_LOG0 ( ( L"Game uses HID, installing input hooks..." ),

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+836, eax
	jl	SHORT $LN4@SK_Input_H
	push	OFFSET $SG161525
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN4@SK_Input_H:

; 253  :                 L"   Input  " );
; 254  : 
; 255  :     SK_CreateDLLHook2 (     L"HID.DLL",

	push	0
	push	OFFSET ?HidP_GetData_Original@@3P6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@ZA ; HidP_GetData_Original
	push	OFFSET ?HidP_GetData_Detour@@YGJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@Z ; HidP_GetData_Detour
	push	OFFSET $SG161526
	push	OFFSET $SG161527
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 256  :                              "HidP_GetData",
; 257  :                               HidP_GetData_Detour,
; 258  :      static_cast_p2p <void> (&HidP_GetData_Original) );
; 259  : 
; 260  :     SK_CreateDLLHook2 (     L"HID.DLL",

	push	0
	push	OFFSET ?HidD_GetPreparsedData_Original@@3P6GEPAXPAPAU_HIDP_PREPARSED_DATA@@@ZA ; HidD_GetPreparsedData_Original
	push	OFFSET ?HidD_GetPreparsedData_Detour@@YGEPAXPAPAU_HIDP_PREPARSED_DATA@@@Z ; HidD_GetPreparsedData_Detour
	push	OFFSET $SG161528
	push	OFFSET $SG161529
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 261  :                              "HidD_GetPreparsedData",
; 262  :                               HidD_GetPreparsedData_Detour,
; 263  :      static_cast_p2p <void> (&HidD_GetPreparsedData_Original) );
; 264  : 
; 265  :     SK_CreateDLLHook2 (     L"HID.DLL",

	push	0
	push	OFFSET ?HidD_FreePreparsedData_Original@@3P6GEPAU_HIDP_PREPARSED_DATA@@@ZA ; HidD_FreePreparsedData_Original
	push	OFFSET ?HidD_FreePreparsedData_Detour@@YGEPAU_HIDP_PREPARSED_DATA@@@Z ; HidD_FreePreparsedData_Detour
	push	OFFSET $SG161530
	push	OFFSET $SG161531
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 266  :                              "HidD_FreePreparsedData",
; 267  :                               HidD_FreePreparsedData_Detour,
; 268  :      static_cast_p2p <void> (&HidD_FreePreparsedData_Original) );
; 269  : 
; 270  :     SK_CreateDLLHook2 (     L"HID.DLL",

	push	0
	push	OFFSET ?HidD_GetFeature_Original@@3P6GEPAX0K@ZA ; HidD_GetFeature_Original
	push	OFFSET ?HidD_GetFeature_Detour@@YGEPAX0K@Z ; HidD_GetFeature_Detour
	push	OFFSET $SG161532
	push	OFFSET $SG161533
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2

; 271  :                              "HidD_GetFeature",
; 272  :                               HidD_GetFeature_Detour,
; 273  :      static_cast_p2p <void> (&HidD_GetFeature_Original) );
; 274  : 
; 275  :     HidP_GetCaps_Original =

	push	OFFSET $SG161534
	push	OFFSET $SG161535
	call	DWORD PTR __imp__GetModuleHandleW@4
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?HidP_GetCaps_Original@@3P6GJPAU_HIDP_PREPARSED_DATA@@PAU_HIDP_CAPS@@@ZA, eax ; HidP_GetCaps_Original

; 276  :       (HidP_GetCaps_pfn)GetProcAddress ( GetModuleHandle (L"HID.DLL"),
; 277  :                                            "HidP_GetCaps" );
; 278  : 
; 279  :     SK_ApplyQueuedHooks ();

	call	?SK_ApplyQueuedHooks@@YG?AW4MH_STATUS@@XZ ; SK_ApplyQueuedHooks

; 280  : 
; 281  :     if (HidP_GetData_Original == nullptr)

	cmp	DWORD PTR ?HidP_GetData_Original@@3P6GJW4_HIDP_REPORT_TYPE@@PAU_HIDP_DATA@@PAKPAU_HIDP_PREPARSED_DATA@@PADK@ZA, 0 ; HidP_GetData_Original
	jne	SHORT $LN5@SK_Input_H

; 282  :       InterlockedDecrement (&hooked);

	lock	 dec	 DWORD PTR ?hooked@?1??SK_Input_HookHID@@YAXXZ@4JC
$LN5@SK_Input_H:

; 283  :   }
; 284  : }

	ret	0
?SK_Input_HookHID@@YAXXZ ENDP				; SK_Input_HookHID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_ImGui_WantTextCapture@@YA_NXZ PROC			; SK_ImGui_WantTextCapture

; 1125 :   bool imgui_capture = false;
; 1126 : 
; 1127 :   //if (SK_ImGui_Visible)
; 1128 :   //{
; 1129 :     ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	cmp	BYTE PTR [eax+842], 0
	setne	al

; 1130 :       ImGui::GetIO ();
; 1131 : 
; 1132 :     if (io.WantTextInput)
; 1133 :       imgui_capture = true;
; 1134 :   //}
; 1135 : 
; 1136 :   return imgui_capture;
; 1137 : }

	ret	0
?SK_ImGui_WantTextCapture@@YA_NXZ ENDP			; SK_ImGui_WantTextCapture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_ImGui_WantKeyboardCapture@@YA_NXZ PROC		; SK_ImGui_WantKeyboardCapture

; 1104 : {

	npad	2
	push	ebx

; 1105 :   bool imgui_capture = false;

	xor	bl, bl

; 1106 : 
; 1107 :   //if (SK_ImGui_Visible)
; 1108 :   //{
; 1109 :     ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 1110 :       ImGui::GetIO ();
; 1111 : 
; 1112 :     if (nav_usable || io.WantCaptureKeyboard || io.WantTextInput)

	cmp	BYTE PTR ?nav_usable@@3_NA, bl		; nav_usable
	jne	SHORT $LN3@SK_ImGui_W
	cmp	BYTE PTR [eax+841], bl
	jne	SHORT $LN3@SK_ImGui_W
	cmp	BYTE PTR [eax+842], bl
	je	SHORT $LN2@SK_ImGui_W
$LN3@SK_ImGui_W:

; 1113 :       imgui_capture = true;

	mov	bl, 1
$LN2@SK_ImGui_W:

; 1114 :   //}
; 1115 : 
; 1116 :   if (config.input.keyboard.disabled_to_game)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+730, 0
	mov	ecx, 1
	movzx	eax, bl
	cmovne	eax, ecx
	pop	ebx

; 1117 :     imgui_capture = true;
; 1118 : 
; 1119 :   return imgui_capture;
; 1120 : }

	ret	0
?SK_ImGui_WantKeyboardCapture@@YA_NXZ ENDP		; SK_ImGui_WantKeyboardCapture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
_dwReasonMask$ = 8					; size = 4
?SK_ImGui_WantMouseCaptureEx@@YA_NK@Z PROC		; SK_ImGui_WantMouseCaptureEx

; 1170 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 1171 :   bool imgui_capture = false;

	xor	bl, bl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, bl	; SK_ImGui_Visible
	jne	SHORT $LN14@SK_ImGui_W
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, bl	; SK_ReShade_Visible
	jne	SHORT $LN14@SK_ImGui_W
	xor	eax, eax
	jmp	SHORT $LN15@SK_ImGui_W
$LN14@SK_ImGui_W:
	mov	eax, 1
$LN15@SK_ImGui_W:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 877  :   return config.input.mouse.disabled_to_game | SK_ImGui_Active () || ImGui::IsAnyWindowHovered ();

	or	al, BYTE PTR ?config@@3Usk_config_t@@A+740
	jne	SHORT $LN10@SK_ImGui_W
	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN10@SK_ImGui_W

; 1185 :       imgui_capture = true;
; 1186 :   }
; 1187 : 
; 1188 :   return imgui_capture;

	mov	al, bl
	pop	ebx

; 1189 : }

	pop	ebp
	ret	0
$LN10@SK_ImGui_W:

; 1172 : 
; 1173 :   if (SK_ImGui_IsMouseRelevant ())
; 1174 :   {
; 1175 :     ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 1176 :       ImGui::GetIO ();
; 1177 : 
; 1178 :     if (config.input.ui.capture_mouse || io.WantCaptureMouse/* || io.WantTextInput*/)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+680, 0
	jne	SHORT $LN4@SK_ImGui_W
	cmp	BYTE PTR [eax+840], 0
	je	SHORT $LN3@SK_ImGui_W
$LN4@SK_ImGui_W:

; 1179 :       imgui_capture = true;

	mov	bl, 1
$LN3@SK_ImGui_W:

; 1180 : 
; 1181 :     if (config.input.ui.capture_hidden && (! SK_InputUtil_IsHWCursorVisible ()))

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+681, 0
	push	esi
	mov	esi, 1
	je	SHORT $LN5@SK_ImGui_W
	call	?SK_InputUtil_IsHWCursorVisible@@YA_NXZ	; SK_InputUtil_IsHWCursorVisible
	test	al, al
	movzx	ebx, bl
	cmove	ebx, esi
$LN5@SK_ImGui_W:

; 1182 :       imgui_capture = true;
; 1183 : 
; 1184 :     if ((dwReasonMask & REASON_DISABLED) && config.input.mouse.disabled_to_game)

	test	BYTE PTR _dwReasonMask$[ebp], 4
	je	SHORT $LN17@SK_ImGui_W
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+740, 0
	movzx	eax, bl
	cmovne	eax, esi
	pop	esi
	pop	ebx

; 1189 : }

	pop	ebp
	ret	0
$LN17@SK_ImGui_W:
	pop	esi

; 1185 :       imgui_capture = true;
; 1186 :   }
; 1187 : 
; 1188 :   return imgui_capture;

	mov	al, bl
	pop	ebx

; 1189 : }

	pop	ebp
	ret	0
?SK_ImGui_WantMouseCaptureEx@@YA_NK@Z ENDP		; SK_ImGui_WantMouseCaptureEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_ImGui_WantMouseCapture@@YA_NXZ PROC			; SK_ImGui_WantMouseCapture

; 1196 :   return SK_ImGui_WantMouseCaptureEx (0xFFFF);

	push	65535					; 0000ffffH
	call	?SK_ImGui_WantMouseCaptureEx@@YA_NK@Z	; SK_ImGui_WantMouseCaptureEx
	add	esp, 4

; 1197 : }

	ret	0
?SK_ImGui_WantMouseCapture@@YA_NXZ ENDP			; SK_ImGui_WantMouseCapture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\input\input.cpp
_TEXT	SEGMENT
?SK_ImGui_WantGamepadCapture@@YA_NXZ PROC		; SK_ImGui_WantGamepadCapture

; 1142 :   bool imgui_capture = false;

	xor	al, al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	mov	ecx, 1
	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, al	; SK_ImGui_Visible
	jne	SHORT $LN8@SK_ImGui_W
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, al	; SK_ReShade_Visible
	je	SHORT $LN3@SK_ImGui_W
$LN8@SK_ImGui_W:
; File c:\users\andon\source\repos\specialk\src\input\input.cpp

; 1146 :     if (nav_usable)

	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable
	movzx	eax, al
	cmovne	eax, ecx
$LN3@SK_ImGui_W:

; 1147 :       imgui_capture = true;
; 1148 :   }
; 1149 : 
; 1150 : #ifdef _WIN64
; 1151 :   // Stupid hack, breaking whatever abstraction this horrible mess passes for
; 1152 :   extern bool __FAR_Freelook;
; 1153 :   if (__FAR_Freelook)
; 1154 :     imgui_capture = true;
; 1155 : #endif
; 1156 : 
; 1157 :   extern bool SK_ImGui_GamepadComboDialogActive;
; 1158 : 
; 1159 :   if (SK_ImGui_GamepadComboDialogActive)

	cmp	BYTE PTR ?SK_ImGui_GamepadComboDialogActive@@3_NA, 0 ; SK_ImGui_GamepadComboDialogActive
	movzx	eax, al
	cmovne	eax, ecx

; 1160 :     imgui_capture = true;
; 1161 : 
; 1162 :   return imgui_capture;
; 1163 : }

	ret	0
?SK_ImGui_WantGamepadCapture@@YA_NXZ ENDP		; SK_ImGui_WantGamepadCapture
_TEXT	ENDS
END
