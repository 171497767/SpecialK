; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\imgui\backends\imgui_vk.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?g_Time@@3_JA DQ 01H DUP (?)				; g_Time
?g_TicksPerSecond@@3_JA DQ 01H DUP (?)			; g_TicksPerSecond
?g_Allocator@@3PAUVkAllocationCallbacks@@A DD 01H DUP (?) ; g_Allocator
?g_Gpu@@3PAUVkPhysicalDevice_T@@A DD 01H DUP (?)	; g_Gpu
?g_Device@@3PAUVkDevice_T@@A DD 01H DUP (?)		; g_Device
	ALIGN	8

?g_RenderPass@@3_KA DQ 01H DUP (?)			; g_RenderPass
?g_PipelineCache@@3_KA DQ 01H DUP (?)			; g_PipelineCache
?g_DescriptorPool@@3_KA DQ 01H DUP (?)			; g_DescriptorPool
?g_CheckVkResult@@3P6AXW4VkResult@@@ZA DD 01H DUP (?)	; g_CheckVkResult
?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A DD 01H DUP (?) ; g_CommandBuffer
?g_PipelineCreateFlags@@3IA DD 01H DUP (?)		; g_PipelineCreateFlags
?g_FrameIndex@@3HA DD 01H DUP (?)			; g_FrameIndex
?g_DescriptorSetLayout@@3_KA DQ 01H DUP (?)		; g_DescriptorSetLayout
?g_PipelineLayout@@3_KA DQ 01H DUP (?)			; g_PipelineLayout
?g_DescriptorSet@@3_KA DQ 01H DUP (?)			; g_DescriptorSet
?g_Pipeline@@3_KA DQ 01H DUP (?)			; g_Pipeline
?g_FontSampler@@3_KA DQ 01H DUP (?)			; g_FontSampler
?g_FontMemory@@3_KA DQ 01H DUP (?)			; g_FontMemory
?g_FontImage@@3_KA DQ 01H DUP (?)			; g_FontImage
?g_FontView@@3_KA DQ 01H DUP (?)			; g_FontView
?g_VertexBufferMemory@@3PA_KA DQ 02H DUP (?)		; g_VertexBufferMemory
?g_IndexBufferMemory@@3PA_KA DQ 02H DUP (?)		; g_IndexBufferMemory
?g_VertexBufferSize@@3PA_KA DQ 02H DUP (?)		; g_VertexBufferSize
?g_IndexBufferSize@@3PA_KA DQ 02H DUP (?)		; g_IndexBufferSize
?g_VertexBuffer@@3PA_KA DQ 02H DUP (?)			; g_VertexBuffer
?g_IndexBuffer@@3PA_KA DQ 02H DUP (?)			; g_IndexBuffer
?g_UploadBufferMemory@@3_KA DQ 01H DUP (?)		; g_UploadBufferMemory
?g_UploadBuffer@@3_KA DQ 01H DUP (?)			; g_UploadBuffer
_BSS	ENDS
CONST	SEGMENT
$SG90982 DB	'main', 00H
	ORG $+3
$SG90983 DB	'main', 00H
	ORG $+3
$SG91058 DB	'vkGetPhysicalDeviceMemoryProperties', 00H
$SG91059 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91060 DB	'vkAllocateMemory', 00H
	ORG $+3
$SG91061 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91062 DB	'vkFreeMemory', 00H
	ORG $+3
$SG91063 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91064 DB	'vkMapMemory', 00H
$SG91065 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91066 DB	'vkUnmapMemory', 00H
	ORG $+2
$SG91067 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91068 DB	'vkFlushMappedMemoryRanges', 00H
	ORG $+2
$SG91069 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91070 DB	'vkBindBufferMemory', 00H
	ORG $+1
$SG91071 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91072 DB	'vkBindImageMemory', 00H
	ORG $+2
$SG91073 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91074 DB	'vkGetBufferMemoryRequirements', 00H
	ORG $+2
$SG91075 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91076 DB	'vkGetImageMemoryRequirements', 00H
	ORG $+3
$SG91077 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91078 DB	'vkCreateBuffer', 00H
	ORG $+1
$SG91079 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91080 DB	'vkDestroyBuffer', 00H
$SG91081 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91082 DB	'vkCreateImage', 00H
	ORG $+2
$SG91083 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91084 DB	'vkDestroyImage', 00H
	ORG $+1
$SG91085 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91086 DB	'vkCreateImageView', 00H
	ORG $+2
$SG91087 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91088 DB	'vkDestroyImageView', 00H
	ORG $+1
$SG91089 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91090 DB	'vkCreateShaderModule', 00H
	ORG $+3
$SG91091 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91092 DB	'vkDestroyShaderModule', 00H
	ORG $+2
$SG91093 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91094 DB	'vkCreateGraphicsPipelines', 00H
	ORG $+2
$SG91095 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91096 DB	'vkDestroyPipeline', 00H
	ORG $+2
$SG91097 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91098 DB	'vkCreatePipelineLayout', 00H
	ORG $+1
$SG91099 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91100 DB	'vkDestroyPipelineLayout', 00H
$SG91101 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91102 DB	'vkCreateSampler', 00H
$SG91103 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91104 DB	'vkDestroySampler', 00H
	ORG $+3
$SG91105 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91106 DB	'vkCreateDescriptorSetLayout', 00H
$SG91107 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91108 DB	'vkDestroyDescriptorSetLayout', 00H
	ORG $+3
$SG91109 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91110 DB	'vkAllocateDescriptorSets', 00H
	ORG $+3
$SG91111 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91112 DB	'vkUpdateDescriptorSets', 00H
	ORG $+1
$SG91113 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91114 DB	'vkCmdBindPipeline', 00H
	ORG $+2
$SG91115 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91116 DB	'vkCmdSetViewport', 00H
	ORG $+3
$SG91117 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91118 DB	'vkCmdSetScissor', 00H
$SG91119 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91120 DB	'vkCmdBindDescriptorSets', 00H
$SG91121 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91122 DB	'vkCmdBindIndexBuffer', 00H
	ORG $+3
$SG91123 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91124 DB	'vkCmdBindVertexBuffers', 00H
	ORG $+1
$SG91125 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91126 DB	'vkCmdDrawIndexed', 00H
	ORG $+3
$SG91127 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91128 DB	'vkCmdCopyBufferToImage', 00H
	ORG $+1
$SG91129 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91130 DB	'vkCmdPipelineBarrier', 00H
	ORG $+3
$SG91131 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG91132 DB	'vkCmdPushConstants', 00H
	ORG $+1
$SG91133 DB	'v', 00H, 'u', 00H, 'l', 00H, 'k', 00H, 'a', 00H, 'n', 00H
	DB	'-', 00H, '1', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H
	DB	00H
CONST	ENDS
_DATA	SEGMENT
?g_BufferMemoryAlignment@@3_KA DQ 0000000000000100H	; g_BufferMemoryAlignment
?__glsl_shader_vert_spv@@3PAIA DD 07230203H		; __glsl_shader_vert_spv
	DD	010000H
	DD	080001H
	DD	02eH
	DD	00H
	DD	020011H
	DD	01H
	DD	06000bH
	DD	01H
	DD	04c534c47H
	DD	06474732eH
	DD	03035342eH
	DD	00H
	DD	03000eH
	DD	00H
	DD	01H
	DD	0a000fH
	DD	00H
	DD	04H
	DD	06e69616dH
	DD	00H
	DD	0bH
	DD	0fH
	DD	015H
	DD	01bH
	DD	01cH
	DD	030003H
	DD	02H
	DD	01c2H
	DD	040005H
	DD	04H
	DD	06e69616dH
	DD	00H
	DD	030005H
	DD	09H
	DD	00H
	DD	050006H
	DD	09H
	DD	00H
	DD	06f6c6f43H
	DD	072H
	DD	040006H
	DD	09H
	DD	01H
	DD	05655H
	DD	030005H
	DD	0bH
	DD	074754fH
	DD	040005H
	DD	0fH
	DD	06c6f4361H
	DD	0726fH
	DD	030005H
	DD	015H
	DD	0565561H
	DD	060005H
	DD	019H
	DD	0505f6c67H
	DD	065567265H
	DD	078657472H
	DD	00H
	DD	060006H
	DD	019H
	DD	00H
	DD	0505f6c67H
	DD	07469736fH
	DD	06e6f69H
	DD	030005H
	DD	01bH
	DD	00H
	DD	040005H
	DD	01cH
	DD	0736f5061H
	DD	00H
	DD	060005H
	DD	01eH
	DD	073755075H
	DD	06e6f4368H
	DD	06e617473H
	DD	074H
	DD	050006H
	DD	01eH
	DD	00H
	DD	061635375H
	DD	0656cH
	DD	060006H
	DD	01eH
	DD	01H
	DD	061725475H
	DD	0616c736eH
	DD	06574H
	DD	030005H
	DD	020H
	DD	06370H
	DD	040047H
	DD	0bH
	DD	01eH
	DD	00H
	DD	040047H
	DD	0fH
	DD	01eH
	DD	02H
	DD	040047H
	DD	015H
	DD	01eH
	DD	01H
	DD	050048H
	DD	019H
	DD	00H
	DD	0bH
	DD	00H
	DD	030047H
	DD	019H
	DD	02H
	DD	040047H
	DD	01cH
	DD	01eH
	DD	00H
	DD	050048H
	DD	01eH
	DD	00H
	DD	023H
	DD	00H
	DD	050048H
	DD	01eH
	DD	01H
	DD	023H
	DD	08H
	DD	030047H
	DD	01eH
	DD	02H
	DD	020013H
	DD	02H
	DD	030021H
	DD	03H
	DD	02H
	DD	030016H
	DD	06H
	DD	020H
	DD	040017H
	DD	07H
	DD	06H
	DD	04H
	DD	040017H
	DD	08H
	DD	06H
	DD	02H
	DD	04001eH
	DD	09H
	DD	07H
	DD	08H
	DD	040020H
	DD	0aH
	DD	03H
	DD	09H
	DD	04003bH
	DD	0aH
	DD	0bH
	DD	03H
	DD	040015H
	DD	0cH
	DD	020H
	DD	01H
	DD	04002bH
	DD	0cH
	DD	0dH
	DD	00H
	DD	040020H
	DD	0eH
	DD	01H
	DD	07H
	DD	04003bH
	DD	0eH
	DD	0fH
	DD	01H
	DD	040020H
	DD	011H
	DD	03H
	DD	07H
	DD	04002bH
	DD	0cH
	DD	013H
	DD	01H
	DD	040020H
	DD	014H
	DD	01H
	DD	08H
	DD	04003bH
	DD	014H
	DD	015H
	DD	01H
	DD	040020H
	DD	017H
	DD	03H
	DD	08H
	DD	03001eH
	DD	019H
	DD	07H
	DD	040020H
	DD	01aH
	DD	03H
	DD	019H
	DD	04003bH
	DD	01aH
	DD	01bH
	DD	03H
	DD	04003bH
	DD	014H
	DD	01cH
	DD	01H
	DD	04001eH
	DD	01eH
	DD	08H
	DD	08H
	DD	040020H
	DD	01fH
	DD	09H
	DD	01eH
	DD	04003bH
	DD	01fH
	DD	020H
	DD	09H
	DD	040020H
	DD	021H
	DD	09H
	DD	08H
	DD	04002bH
	DD	06H
	DD	028H
	DD	00H
	DD	04002bH
	DD	06H
	DD	029H
	DD	03f800000H
	DD	050036H
	DD	02H
	DD	04H
	DD	00H
	DD	03H
	DD	0200f8H
	DD	05H
	DD	04003dH
	DD	07H
	DD	010H
	DD	0fH
	DD	050041H
	DD	011H
	DD	012H
	DD	0bH
	DD	0dH
	DD	03003eH
	DD	012H
	DD	010H
	DD	04003dH
	DD	08H
	DD	016H
	DD	015H
	DD	050041H
	DD	017H
	DD	018H
	DD	0bH
	DD	013H
	DD	03003eH
	DD	018H
	DD	016H
	DD	04003dH
	DD	08H
	DD	01dH
	DD	01cH
	DD	050041H
	DD	021H
	DD	022H
	DD	020H
	DD	0dH
	DD	04003dH
	DD	08H
	DD	023H
	DD	022H
	DD	050085H
	DD	08H
	DD	024H
	DD	01dH
	DD	023H
	DD	050041H
	DD	021H
	DD	025H
	DD	020H
	DD	013H
	DD	04003dH
	DD	08H
	DD	026H
	DD	025H
	DD	050081H
	DD	08H
	DD	027H
	DD	024H
	DD	026H
	DD	050051H
	DD	06H
	DD	02aH
	DD	027H
	DD	00H
	DD	050051H
	DD	06H
	DD	02bH
	DD	027H
	DD	01H
	DD	070050H
	DD	07H
	DD	02cH
	DD	02aH
	DD	02bH
	DD	028H
	DD	029H
	DD	050041H
	DD	011H
	DD	02dH
	DD	01bH
	DD	0dH
	DD	03003eH
	DD	02dH
	DD	02cH
	DD	0100fdH
	DD	010038H
?__glsl_shader_frag_spv@@3PAIA DD 07230203H		; __glsl_shader_frag_spv
	DD	010000H
	DD	080001H
	DD	01eH
	DD	00H
	DD	020011H
	DD	01H
	DD	06000bH
	DD	01H
	DD	04c534c47H
	DD	06474732eH
	DD	03035342eH
	DD	00H
	DD	03000eH
	DD	00H
	DD	01H
	DD	07000fH
	DD	04H
	DD	04H
	DD	06e69616dH
	DD	00H
	DD	09H
	DD	0dH
	DD	030010H
	DD	04H
	DD	07H
	DD	030003H
	DD	02H
	DD	01c2H
	DD	040005H
	DD	04H
	DD	06e69616dH
	DD	00H
	DD	040005H
	DD	09H
	DD	06c6f4366H
	DD	0726fH
	DD	030005H
	DD	0bH
	DD	00H
	DD	050006H
	DD	0bH
	DD	00H
	DD	06f6c6f43H
	DD	072H
	DD	040006H
	DD	0bH
	DD	01H
	DD	05655H
	DD	030005H
	DD	0dH
	DD	06e49H
	DD	050005H
	DD	016H
	DD	078655473H
	DD	065727574H
	DD	00H
	DD	040047H
	DD	09H
	DD	01eH
	DD	00H
	DD	040047H
	DD	0dH
	DD	01eH
	DD	00H
	DD	040047H
	DD	016H
	DD	022H
	DD	00H
	DD	040047H
	DD	016H
	DD	021H
	DD	00H
	DD	020013H
	DD	02H
	DD	030021H
	DD	03H
	DD	02H
	DD	030016H
	DD	06H
	DD	020H
	DD	040017H
	DD	07H
	DD	06H
	DD	04H
	DD	040020H
	DD	08H
	DD	03H
	DD	07H
	DD	04003bH
	DD	08H
	DD	09H
	DD	03H
	DD	040017H
	DD	0aH
	DD	06H
	DD	02H
	DD	04001eH
	DD	0bH
	DD	07H
	DD	0aH
	DD	040020H
	DD	0cH
	DD	01H
	DD	0bH
	DD	04003bH
	DD	0cH
	DD	0dH
	DD	01H
	DD	040015H
	DD	0eH
	DD	020H
	DD	01H
	DD	04002bH
	DD	0eH
	DD	0fH
	DD	00H
	DD	040020H
	DD	010H
	DD	01H
	DD	07H
	DD	090019H
	DD	013H
	DD	06H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	03001bH
	DD	014H
	DD	013H
	DD	040020H
	DD	015H
	DD	00H
	DD	014H
	DD	04003bH
	DD	015H
	DD	016H
	DD	00H
	DD	04002bH
	DD	0eH
	DD	018H
	DD	01H
	DD	040020H
	DD	019H
	DD	01H
	DD	0aH
	DD	050036H
	DD	02H
	DD	04H
	DD	00H
	DD	03H
	DD	0200f8H
	DD	05H
	DD	050041H
	DD	010H
	DD	011H
	DD	0dH
	DD	0fH
	DD	04003dH
	DD	07H
	DD	012H
	DD	011H
	DD	04003dH
	DD	014H
	DD	017H
	DD	016H
	DD	050041H
	DD	019H
	DD	01aH
	DD	0dH
	DD	018H
	DD	04003dH
	DD	0aH
	DD	01bH
	DD	01aH
	DD	050057H
	DD	07H
	DD	01cH
	DD	017H
	DD	01bH
	DD	050085H
	DD	07H
	DD	01dH
	DD	012H
	DD	01cH
	DD	03003eH
	DD	09H
	DD	01dH
	DD	0100fdH
	DD	010038H
_DATA	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?ImGui_ImplVulkan_Init@@YA_NPAUImGui_ImplVulkan_Init_Data@@@Z ; ImGui_ImplVulkan_Init
PUBLIC	?ImGui_ImplVulkan_Shutdown@@YAXXZ		; ImGui_ImplVulkan_Shutdown
PUBLIC	?ImGui_ImplVulkan_NewFrame@@YAXXZ		; ImGui_ImplVulkan_NewFrame
PUBLIC	?ImGui_ImplVulkan_Render@@YAXPAUVkCommandBuffer_T@@@Z ; ImGui_ImplVulkan_Render
PUBLIC	?ImGui_ImplVulkan_InvalidateFontUploadObjects@@YAXXZ ; ImGui_ImplVulkan_InvalidateFontUploadObjects
PUBLIC	?ImGui_ImplVulkan_InvalidateDeviceObjects@@YAXXZ ; ImGui_ImplVulkan_InvalidateDeviceObjects
PUBLIC	?ImGui_ImplVulkan_CreateFontsTexture@@YA_NPAUVkCommandBuffer_T@@@Z ; ImGui_ImplVulkan_CreateFontsTexture
PUBLIC	?ImGui_ImplVulkan_CreateDeviceObjects@@YA_NXZ	; ImGui_ImplVulkan_CreateDeviceObjects
PUBLIC	?ImGui_ImplVulkan_RenderDrawLists@@YAXPAUImDrawData@@@Z ; ImGui_ImplVulkan_RenderDrawLists
PUBLIC	__real@3f800000
PUBLIC	__xmm@00000000000000010000000100000001
PUBLIC	__xmm@00000007000000000000000700000006
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?Render@ImGui@@YAXXZ:PROC			; ImGui::Render
EXTRN	?Shutdown@ImGui@@YAXXZ:PROC			; ImGui::Shutdown
EXTRN	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z:PROC ; ImFontAtlas::GetTexDataAsRGBA32
EXTRN	?SK_ImGui_LoadFonts@@YAXXZ:PROC			; SK_ImGui_LoadFonts
EXTRN	?SK_ImGui_ResetExternal@@YAXXZ:PROC		; SK_ImGui_ResetExternal
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
EXTRN	__ftoui3:PROC
EXTRN	__ltod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	?game_window@@3Usk_window_s@@A:BYTE		; game_window
EXTRN	?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA:DWORD ; QueryPerformanceCounter_Original
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?vkGetPhysicalDeviceMemoryProperties@@3P6GXPAUVkPhysicalDevice_T@@PAUVkPhysicalDeviceMemoryProperties@@@ZA DD 01H DUP (?) ; vkGetPhysicalDeviceMemoryProperties
?vkAllocateMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkMemoryAllocateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkAllocateMemory
?vkFreeMemory@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkFreeMemory
?vkMapMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11IPAPAX@ZA DD 01H DUP (?) ; vkMapMemory
?vkUnmapMemory@@3P6GXPAUVkDevice_T@@_K@ZA DD 01H DUP (?) ; vkUnmapMemory
?vkFlushMappedMemoryRanges@@3P6G?AW4VkResult@@PAUVkDevice_T@@IPBUVkMappedMemoryRange@@@ZA DD 01H DUP (?) ; vkFlushMappedMemoryRanges
?vkBindBufferMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11@ZA DD 01H DUP (?) ; vkBindBufferMemory
?vkBindImageMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11@ZA DD 01H DUP (?) ; vkBindImageMemory
?vkGetBufferMemoryRequirements@@3P6GXPAUVkDevice_T@@_KPAUVkMemoryRequirements@@@ZA DD 01H DUP (?) ; vkGetBufferMemoryRequirements
?vkGetImageMemoryRequirements@@3P6GXPAUVkDevice_T@@_KPAUVkMemoryRequirements@@@ZA DD 01H DUP (?) ; vkGetImageMemoryRequirements
?vkCreateBuffer@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkBufferCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkCreateBuffer
?vkDestroyBuffer@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkDestroyBuffer
?vkCreateImage@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkImageCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkCreateImage
?vkDestroyImage@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkDestroyImage
?vkCreateImageView@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkImageViewCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkCreateImageView
?vkDestroyImageView@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkDestroyImageView
?vkCreateShaderModule@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkShaderModuleCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkCreateShaderModule
?vkDestroyShaderModule@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkDestroyShaderModule
?vkCreateGraphicsPipelines@@3P6G?AW4VkResult@@PAUVkDevice_T@@_KIPBUVkGraphicsPipelineCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkCreateGraphicsPipelines
?vkDestroyPipeline@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkDestroyPipeline
?vkCreatePipelineLayout@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkPipelineLayoutCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkCreatePipelineLayout
?vkDestroyPipelineLayout@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkDestroyPipelineLayout
?vkCreateSampler@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkSamplerCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkCreateSampler
?vkDestroySampler@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkDestroySampler
?vkCreateDescriptorSetLayout@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkDescriptorSetLayoutCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA DD 01H DUP (?) ; vkCreateDescriptorSetLayout
?vkDestroyDescriptorSetLayout@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA DD 01H DUP (?) ; vkDestroyDescriptorSetLayout
?vkAllocateDescriptorSets@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkDescriptorSetAllocateInfo@@PA_K@ZA DD 01H DUP (?) ; vkAllocateDescriptorSets
?vkUpdateDescriptorSets@@3P6GXPAUVkDevice_T@@IPBUVkWriteDescriptorSet@@IPBUVkCopyDescriptorSet@@@ZA DD 01H DUP (?) ; vkUpdateDescriptorSets
?vkCmdBindPipeline@@3P6GXPAUVkCommandBuffer_T@@W4VkPipelineBindPoint@@_K@ZA DD 01H DUP (?) ; vkCmdBindPipeline
?vkCmdSetViewport@@3P6GXPAUVkCommandBuffer_T@@IIPBUVkViewport@@@ZA DD 01H DUP (?) ; vkCmdSetViewport
?vkCmdSetScissor@@3P6GXPAUVkCommandBuffer_T@@IIPBUVkRect2D@@@ZA DD 01H DUP (?) ; vkCmdSetScissor
?vkCmdBindDescriptorSets@@3P6GXPAUVkCommandBuffer_T@@W4VkPipelineBindPoint@@_KIIPB_KIPBI@ZA DD 01H DUP (?) ; vkCmdBindDescriptorSets
?vkCmdBindIndexBuffer@@3P6GXPAUVkCommandBuffer_T@@_K1W4VkIndexType@@@ZA DD 01H DUP (?) ; vkCmdBindIndexBuffer
?vkCmdBindVertexBuffers@@3P6GXPAUVkCommandBuffer_T@@IIPB_K1@ZA DD 01H DUP (?) ; vkCmdBindVertexBuffers
?vkCmdDrawIndexed@@3P6GXPAUVkCommandBuffer_T@@IIIHI@ZA DD 01H DUP (?) ; vkCmdDrawIndexed
?vkCmdCopyBufferToImage@@3P6GXPAUVkCommandBuffer_T@@_K1W4VkImageLayout@@IPBUVkBufferImageCopy@@@ZA DD 01H DUP (?) ; vkCmdCopyBufferToImage
?vkCmdPipelineBarrier@@3P6GXPAUVkCommandBuffer_T@@IIIIPBUVkMemoryBarrier@@IPBUVkBufferMemoryBarrier@@IPBUVkImageMemoryBarrier@@@ZA DD 01H DUP (?) ; vkCmdPipelineBarrier
?vkCmdPushConstants@@3P6GXPAUVkCommandBuffer_T@@_KIIIPBX@ZA DD 01H DUP (?) ; vkCmdPushConstants
_BSS	ENDS
;	COMDAT __xmm@00000007000000000000000700000006
CONST	SEGMENT
__xmm@00000007000000000000000700000006 DB 06H, 00H, 00H, 00H, 07H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 07H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000010000000100000001
CONST	SEGMENT
__xmm@00000000000000010000000100000001 DB 01H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ?first@?1??ImGui_ImplVulkan_Init@@YA_NPAUImGui_ImplVulkan_Init_Data@@@Z@4_NA
_DATA	SEGMENT
?first@?1??ImGui_ImplVulkan_Init@@YA_NPAUImGui_ImplVulkan_Init_Data@@@Z@4_NA DB 01H ; `ImGui_ImplVulkan_Init'::`2'::first
_DATA	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
_range$1 = -280						; size = 64
_buffer_info$2 = -216					; size = 40
_buffer_info$3 = -176					; size = 40
_req$4 = -136						; size = 24
_req$5 = -112						; size = 24
_alloc_info$6 = -88					; size = 24
_scissor$7 = -80					; size = 16
_viewport$8 = -64					; size = 24
_alloc_info$9 = -64					; size = 24
_translate$10 = -40					; size = 8
_vertex_offset$11 = -40					; size = 8
_scale$12 = -32						; size = 8
_io$1$ = -28						; size = 4
_desc_set$13 = -24					; size = 8
_vertex_size$2$ = -20					; size = 4
tv665 = -20						; size = 4
_vertex_buffers$14 = -16				; size = 8
_index_size$2$ = -12					; size = 4
_n$1$ = -12						; size = 4
_idx_offset$1$ = -8					; size = 4
_idx_dst$15 = -8					; size = 4
_vtx_offset$1$ = -4					; size = 4
_vtx_dst$16 = -4					; size = 4
_draw_data$ = 8						; size = 4
?ImGui_ImplVulkan_RenderDrawLists@@YAXPAUImDrawData@@@Z PROC ; ImGui_ImplVulkan_RenderDrawLists

; 188  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi

; 189  :   VkResult err { };
; 190  : 
; 191  :   ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 192  :     ImGui::GetIO ();
; 193  : 
; 194  :   // Create the Vertex Buffer:
; 195  :   VkDeviceSize vertex_size =
; 196  :     draw_data->TotalVtxCount * sizeof (ImDrawVert);

	mov	ebx, DWORD PTR _draw_data$[ebp]
	mov	DWORD PTR _io$1$[ebp], eax
	mov	ecx, DWORD PTR [ebx+12]
	lea	esi, DWORD PTR [ecx+ecx*4]

; 197  : 
; 198  :   if (! g_VertexBuffer [g_FrameIndex] || g_VertexBufferSize[g_FrameIndex] < vertex_size)

	mov	ecx, DWORD PTR ?g_FrameIndex@@3HA
	shl	ecx, 3
	shl	esi, 2
	mov	DWORD PTR _vertex_size$2$[ebp], esi
	mov	edi, DWORD PTR ?g_VertexBuffer@@3PA_KA[ecx]
	mov	eax, edi
	mov	edx, DWORD PTR ?g_VertexBuffer@@3PA_KA[ecx+4]
	or	eax, edx
	je	SHORT $LN40@ImGui_Impl
	cmp	DWORD PTR ?g_VertexBufferSize@@3PA_KA[ecx+4], 0
	ja	$LN11@ImGui_Impl
	jb	SHORT $LN40@ImGui_Impl
	cmp	DWORD PTR ?g_VertexBufferSize@@3PA_KA[ecx], esi
	jae	$LN11@ImGui_Impl
$LN40@ImGui_Impl:

; 199  :   {
; 200  :     if (g_VertexBuffer [g_FrameIndex])

	mov	eax, edi
	or	eax, edx
	je	SHORT $LN13@ImGui_Impl

; 201  :       vkDestroyBuffer (g_Device, g_VertexBuffer [g_FrameIndex], g_Allocator);

	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	edi
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyBuffer@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
$LN13@ImGui_Impl:

; 202  : 
; 203  :     if (g_VertexBufferMemory [g_FrameIndex])

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	mov	edx, DWORD PTR ?g_VertexBufferMemory@@3PA_KA[eax*8]
	mov	ecx, DWORD PTR ?g_VertexBufferMemory@@3PA_KA[eax*8+4]
	mov	eax, edx
	or	eax, ecx
	je	SHORT $LN14@ImGui_Impl

; 204  :       vkFreeMemory (g_Device, g_VertexBufferMemory [g_FrameIndex], g_Allocator);

	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	ecx
	push	edx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkFreeMemory@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
$LN14@ImGui_Impl:

; 205  : 
; 206  :     VkDeviceSize vertex_buffer_size =
; 207  :       ((vertex_size - 1) / g_BufferMemoryAlignment + 1) * g_BufferMemoryAlignment;

	mov	edi, DWORD PTR ?g_BufferMemoryAlignment@@3_KA+4
	mov	ecx, esi
	mov	esi, DWORD PTR ?g_BufferMemoryAlignment@@3_KA
	add	ecx, -1
	push	edi
	mov	eax, 0
	push	esi
	adc	eax, -1
	push	eax
	push	ecx
	call	__aulldiv
	add	eax, 1
	push	edi
	push	esi
	adc	edx, 0
	push	edx
	push	eax
	call	__allmul

; 208  : 
; 209  :     VkBufferCreateInfo buffer_info = { };
; 210  : 
; 211  :     buffer_info.sType       = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
; 212  :     buffer_info.size        = vertex_buffer_size;
; 213  :     buffer_info.usage       = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
; 214  :     buffer_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
; 215  : 
; 216  :     err =

	mov	ecx, DWORD PTR ?g_FrameIndex@@3HA
	mov	esi, eax
	xorps	xmm0, xmm0
	mov	edi, edx
	movups	XMMWORD PTR _buffer_info$3[ebp+16], xmm0
	mov	DWORD PTR _buffer_info$3[ebp+16], esi
	lea	eax, DWORD PTR ?g_VertexBuffer@@3PA_KA[ecx*8]
	movq	QWORD PTR _buffer_info$3[ebp+32], xmm0
	push	eax
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	lea	eax, DWORD PTR _buffer_info$3[ebp]
	mov	DWORD PTR _buffer_info$3[ebp+20], edi
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	movups	XMMWORD PTR _buffer_info$3[ebp], xmm0
	mov	DWORD PTR _buffer_info$3[ebp], 12	; 0000000cH
	mov	DWORD PTR _buffer_info$3[ebp+24], 128	; 00000080H
	mov	DWORD PTR _buffer_info$3[ebp+28], 0
	call	DWORD PTR ?vkCreateBuffer@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkBufferCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 217  :       vkCreateBuffer (g_Device, &buffer_info, g_Allocator, &g_VertexBuffer [g_FrameIndex]);
; 218  : 
; 219  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 220  : 
; 221  :     VkMemoryRequirements req;
; 222  :     vkGetBufferMemoryRequirements (g_Device, g_VertexBuffer [g_FrameIndex], &req);

	lea	eax, DWORD PTR _req$5[ebp]
	push	eax
	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	push	DWORD PTR ?g_VertexBuffer@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_VertexBuffer@@3PA_KA[eax*8]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkGetBufferMemoryRequirements@@3P6GXPAUVkDevice_T@@_KPAUVkMemoryRequirements@@@ZA

; 223  : 
; 224  :     g_BufferMemoryAlignment =

	mov	ecx, DWORD PTR _req$5[ebp+12]
	cmp	DWORD PTR ?g_BufferMemoryAlignment@@3_KA+4, ecx
	ja	SHORT $LN23@ImGui_Impl
	mov	eax, DWORD PTR _req$5[ebp+8]
	jb	SHORT $LN41@ImGui_Impl
	cmp	DWORD PTR ?g_BufferMemoryAlignment@@3_KA, eax
	ja	SHORT $LN23@ImGui_Impl
$LN41@ImGui_Impl:
	mov	DWORD PTR ?g_BufferMemoryAlignment@@3_KA, eax
	mov	DWORD PTR ?g_BufferMemoryAlignment@@3_KA+4, ecx
$LN23@ImGui_Impl:

; 225  :       (g_BufferMemoryAlignment > req.alignment) ? g_BufferMemoryAlignment :
; 226  :                                                   req.alignment;
; 227  : 
; 228  :     VkMemoryAllocateInfo alloc_info = { };
; 229  : 
; 230  :     alloc_info.sType           = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
; 231  :     alloc_info.allocationSize  = req.size;

	mov	eax, DWORD PTR _req$5[ebp]
	xorps	xmm0, xmm0

; 232  :     alloc_info.memoryTypeIndex = ImGui_ImplVulkan_MemoryType (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, req.memoryTypeBits);

	push	DWORD PTR _req$5[ebp+16]
	movups	XMMWORD PTR _alloc_info$6[ebp], xmm0
	mov	DWORD PTR _alloc_info$6[ebp+8], eax
	mov	eax, DWORD PTR _req$5[ebp+4]
	push	2
	movq	QWORD PTR _alloc_info$6[ebp+16], xmm0
	mov	DWORD PTR _alloc_info$6[ebp], 5
	mov	DWORD PTR _alloc_info$6[ebp+12], eax
	call	?ImGui_ImplVulkan_MemoryType@@YAIII@Z	; ImGui_ImplVulkan_MemoryType
	mov	DWORD PTR _alloc_info$6[ebp+16], eax
	add	esp, 8

; 233  : 
; 234  :     err =

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	lea	eax, DWORD PTR ?g_VertexBufferMemory@@3PA_KA[eax*8]
	push	eax
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	lea	eax, DWORD PTR _alloc_info$6[ebp]
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkAllocateMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkMemoryAllocateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 235  :       vkAllocateMemory (g_Device, &alloc_info, g_Allocator, &g_VertexBufferMemory [g_FrameIndex]);
; 236  : 
; 237  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 238  : 
; 239  :     err =

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	add	esp, 4
	push	0
	push	0
	push	DWORD PTR ?g_VertexBufferMemory@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_VertexBufferMemory@@3PA_KA[eax*8]
	push	DWORD PTR ?g_VertexBuffer@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_VertexBuffer@@3PA_KA[eax*8]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkBindBufferMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11@ZA

; 240  :       vkBindBufferMemory (g_Device, g_VertexBuffer [g_FrameIndex], g_VertexBufferMemory [g_FrameIndex], 0);
; 241  : 
; 242  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 243  : 
; 244  :     g_VertexBufferSize [g_FrameIndex] = vertex_buffer_size;

	mov	ecx, DWORD PTR ?g_FrameIndex@@3HA
	add	esp, 4
	shl	ecx, 3
	mov	DWORD PTR ?g_VertexBufferSize@@3PA_KA[ecx], esi
	mov	DWORD PTR ?g_VertexBufferSize@@3PA_KA[ecx+4], edi
$LN11@ImGui_Impl:

; 245  :   }
; 246  : 
; 247  :   // Create the Index Buffer:
; 248  :   VkDeviceSize index_size = draw_data->TotalIdxCount * sizeof (ImDrawIdx);

	mov	esi, DWORD PTR [ebx+16]

; 249  : 
; 250  :   if (! g_IndexBuffer [g_FrameIndex] || g_IndexBufferSize [g_FrameIndex] < index_size)

	mov	edi, DWORD PTR ?g_IndexBuffer@@3PA_KA[ecx]
	add	esi, esi
	mov	edx, DWORD PTR ?g_IndexBuffer@@3PA_KA[ecx+4]
	mov	eax, edi
	or	eax, edx
	mov	DWORD PTR _index_size$2$[ebp], esi
	je	SHORT $LN42@ImGui_Impl
	cmp	DWORD PTR ?g_IndexBufferSize@@3PA_KA[ecx+4], 0
	ja	$LN15@ImGui_Impl
	jb	SHORT $LN42@ImGui_Impl
	cmp	DWORD PTR ?g_IndexBufferSize@@3PA_KA[ecx], esi
	jae	$LN15@ImGui_Impl
$LN42@ImGui_Impl:

; 251  :   {
; 252  :     if (g_IndexBuffer [g_FrameIndex])

	mov	eax, edi
	or	eax, edx
	je	SHORT $LN17@ImGui_Impl

; 253  :       vkDestroyBuffer (g_Device, g_IndexBuffer [g_FrameIndex], g_Allocator);

	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	edi
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyBuffer@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
$LN17@ImGui_Impl:

; 254  : 
; 255  :     if (g_IndexBufferMemory [g_FrameIndex])

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	mov	edx, DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8]
	mov	ecx, DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8+4]
	mov	eax, edx
	or	eax, ecx
	je	SHORT $LN18@ImGui_Impl

; 256  :       vkFreeMemory (g_Device, g_IndexBufferMemory [g_FrameIndex], g_Allocator);

	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	ecx
	push	edx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkFreeMemory@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
$LN18@ImGui_Impl:

; 257  : 
; 258  :     VkDeviceSize index_buffer_size =
; 259  :       ((index_size - 1) / g_BufferMemoryAlignment + 1) * g_BufferMemoryAlignment;

	mov	edi, DWORD PTR ?g_BufferMemoryAlignment@@3_KA+4
	mov	ecx, esi
	mov	esi, DWORD PTR ?g_BufferMemoryAlignment@@3_KA
	add	ecx, -1
	push	edi
	mov	eax, 0
	push	esi
	adc	eax, -1
	push	eax
	push	ecx
	call	__aulldiv
	add	eax, 1
	push	edi
	push	esi
	adc	edx, 0
	push	edx
	push	eax
	call	__allmul

; 260  : 
; 261  :     VkBufferCreateInfo buffer_info = { };
; 262  : 
; 263  :     buffer_info.sType       = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
; 264  :     buffer_info.size        = index_buffer_size;
; 265  :     buffer_info.usage       = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
; 266  :     buffer_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
; 267  : 
; 268  :     err =

	mov	ecx, DWORD PTR ?g_FrameIndex@@3HA
	mov	esi, eax
	xorps	xmm0, xmm0
	mov	edi, edx
	movups	XMMWORD PTR _buffer_info$2[ebp+16], xmm0
	mov	DWORD PTR _buffer_info$2[ebp+16], esi
	lea	eax, DWORD PTR ?g_IndexBuffer@@3PA_KA[ecx*8]
	movq	QWORD PTR _buffer_info$2[ebp+32], xmm0
	push	eax
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	lea	eax, DWORD PTR _buffer_info$2[ebp]
	mov	DWORD PTR _buffer_info$2[ebp+20], edi
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	movups	XMMWORD PTR _buffer_info$2[ebp], xmm0
	mov	DWORD PTR _buffer_info$2[ebp], 12	; 0000000cH
	mov	DWORD PTR _buffer_info$2[ebp+24], 64	; 00000040H
	mov	DWORD PTR _buffer_info$2[ebp+28], 0
	call	DWORD PTR ?vkCreateBuffer@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkBufferCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 269  :       vkCreateBuffer (g_Device, &buffer_info, g_Allocator, &g_IndexBuffer [g_FrameIndex]);
; 270  : 
; 271  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 272  : 
; 273  :     VkMemoryRequirements req;
; 274  : 
; 275  :     vkGetBufferMemoryRequirements (g_Device, g_IndexBuffer [g_FrameIndex], &req);

	lea	eax, DWORD PTR _req$4[ebp]
	push	eax
	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	push	DWORD PTR ?g_IndexBuffer@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_IndexBuffer@@3PA_KA[eax*8]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkGetBufferMemoryRequirements@@3P6GXPAUVkDevice_T@@_KPAUVkMemoryRequirements@@@ZA

; 276  : 
; 277  :     g_BufferMemoryAlignment = (g_BufferMemoryAlignment > req.alignment) ? g_BufferMemoryAlignment :

	mov	ecx, DWORD PTR _req$4[ebp+12]
	cmp	DWORD PTR ?g_BufferMemoryAlignment@@3_KA+4, ecx
	ja	SHORT $LN25@ImGui_Impl
	mov	eax, DWORD PTR _req$4[ebp+8]
	jb	SHORT $LN43@ImGui_Impl
	cmp	DWORD PTR ?g_BufferMemoryAlignment@@3_KA, eax
	ja	SHORT $LN25@ImGui_Impl
$LN43@ImGui_Impl:
	mov	DWORD PTR ?g_BufferMemoryAlignment@@3_KA, eax
	mov	DWORD PTR ?g_BufferMemoryAlignment@@3_KA+4, ecx
$LN25@ImGui_Impl:

; 278  :                                                                           req.alignment;
; 279  :     VkMemoryAllocateInfo alloc_info = { };
; 280  : 
; 281  :     alloc_info.sType           = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
; 282  :     alloc_info.allocationSize  = req.size;

	mov	eax, DWORD PTR _req$4[ebp]
	xorps	xmm0, xmm0

; 283  :     alloc_info.memoryTypeIndex = ImGui_ImplVulkan_MemoryType (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, req.memoryTypeBits);

	push	DWORD PTR _req$4[ebp+16]
	movups	XMMWORD PTR _alloc_info$9[ebp], xmm0
	mov	DWORD PTR _alloc_info$9[ebp+8], eax
	mov	eax, DWORD PTR _req$4[ebp+4]
	push	2
	movq	QWORD PTR _alloc_info$9[ebp+16], xmm0
	mov	DWORD PTR _alloc_info$9[ebp], 5
	mov	DWORD PTR _alloc_info$9[ebp+12], eax
	call	?ImGui_ImplVulkan_MemoryType@@YAIII@Z	; ImGui_ImplVulkan_MemoryType
	mov	DWORD PTR _alloc_info$9[ebp+16], eax
	add	esp, 8

; 284  : 
; 285  :     err =

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	lea	eax, DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8]
	push	eax
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	lea	eax, DWORD PTR _alloc_info$9[ebp]
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkAllocateMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkMemoryAllocateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 286  :       vkAllocateMemory (g_Device, &alloc_info, g_Allocator, &g_IndexBufferMemory [g_FrameIndex]);
; 287  : 
; 288  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 289  : 
; 290  :     err =

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	add	esp, 4
	push	0
	push	0
	push	DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8]
	push	DWORD PTR ?g_IndexBuffer@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_IndexBuffer@@3PA_KA[eax*8]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkBindBufferMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11@ZA

; 291  :       vkBindBufferMemory (g_Device, g_IndexBuffer [g_FrameIndex], g_IndexBufferMemory [g_FrameIndex], 0);
; 292  : 
; 293  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 294  : 
; 295  :     g_IndexBufferSize [g_FrameIndex] = index_buffer_size;

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	add	esp, 4
	lea	ecx, DWORD PTR [eax*8]
	mov	DWORD PTR ?g_IndexBufferSize@@3PA_KA[ecx], esi
	mov	esi, DWORD PTR _index_size$2$[ebp]
	mov	DWORD PTR ?g_IndexBufferSize@@3PA_KA[ecx+4], edi
$LN15@ImGui_Impl:

; 296  :   }
; 297  : 
; 298  :   // Upload Vertex and index Data:
; 299  :   {
; 300  :     ImDrawVert* vtx_dst = 0;
; 301  :     ImDrawIdx*  idx_dst = 0;
; 302  : 
; 303  :     err =

	lea	eax, DWORD PTR _vtx_dst$16[ebp]
	mov	DWORD PTR _vtx_dst$16[ebp], 0
	push	eax
	push	0
	push	0
	push	DWORD PTR _vertex_size$2$[ebp]
	mov	DWORD PTR _idx_dst$15[ebp], 0
	push	0
	push	0
	push	DWORD PTR ?g_VertexBufferMemory@@3PA_KA[ecx+4]
	push	DWORD PTR ?g_VertexBufferMemory@@3PA_KA[ecx]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkMapMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11IPAPAX@ZA

; 304  :       vkMapMemory (g_Device, g_VertexBufferMemory [g_FrameIndex], 0, vertex_size, 0, (void**)(&vtx_dst));
; 305  : 
; 306  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 307  : 
; 308  :     err =

	lea	eax, DWORD PTR _idx_dst$15[ebp]
	push	eax
	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	push	0
	push	0
	push	esi
	push	0
	push	0
	push	DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkMapMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11IPAPAX@ZA

; 309  :       vkMapMemory (g_Device, g_IndexBufferMemory [g_FrameIndex], 0, index_size, 0, (void**)(&idx_dst));
; 310  : 
; 311  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 312  : 
; 313  :     for (int n = 0; n < draw_data->CmdListsCount; n++)

	xor	edi, edi
	add	esp, 4
	cmp	DWORD PTR [ebx+8], edi
	jle	SHORT $LN3@ImGui_Impl
	mov	edx, DWORD PTR _vtx_dst$16[ebp]
	npad	6
$LL4@ImGui_Impl:

; 314  :     {
; 315  :       const ImDrawList* cmd_list =
; 316  :         draw_data->CmdLists [n];

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [eax+edi*4]

; 317  : 
; 318  :       memcpy (vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof (ImDrawVert));

	mov	eax, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+32]
	push	edx
	call	_memcpy

; 319  :       memcpy (idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof (ImDrawIdx));

	mov	eax, DWORD PTR [esi+12]
	add	eax, eax
	push	eax
	push	DWORD PTR [esi+20]
	push	DWORD PTR _idx_dst$15[ebp]
	call	_memcpy

; 320  : 
; 321  :       vtx_dst += cmd_list->VtxBuffer.Size;

	mov	eax, DWORD PTR [esi+24]
	inc	edi
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _vtx_dst$16[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 322  :       idx_dst += cmd_list->IdxBuffer.Size;

	mov	eax, DWORD PTR _idx_dst$15[ebp]
	mov	DWORD PTR _vtx_dst$16[ebp], edx
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _idx_dst$15[ebp], eax
	cmp	edi, DWORD PTR [ebx+8]
	jl	SHORT $LL4@ImGui_Impl
	mov	esi, DWORD PTR _index_size$2$[ebp]
$LN3@ImGui_Impl:

; 323  :     }
; 324  : 
; 325  :     VkMappedMemoryRange range [2] = { };

	push	64					; 00000040H
	lea	eax, DWORD PTR _range$1[ebp]
	push	0
	push	eax
	call	_memset

; 326  : 
; 327  :     range [0].sType  = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
; 328  :     range [0].memory = g_VertexBufferMemory [g_FrameIndex];

	mov	ecx, DWORD PTR ?g_FrameIndex@@3HA
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _range$1[ebp], 6

; 329  :     range [0].size   = vertex_size;

	mov	DWORD PTR _range$1[ebp+28], 0

; 330  :     range [1].sType  = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;

	mov	DWORD PTR _range$1[ebp+32], 6
	mov	eax, DWORD PTR ?g_VertexBufferMemory@@3PA_KA[ecx*8]
	mov	DWORD PTR _range$1[ebp+8], eax
	mov	eax, DWORD PTR ?g_VertexBufferMemory@@3PA_KA[ecx*8+4]
	mov	DWORD PTR _range$1[ebp+12], eax
	mov	eax, DWORD PTR _vertex_size$2$[ebp]
	mov	DWORD PTR _range$1[ebp+24], eax

; 331  :     range [1].memory = g_IndexBufferMemory [g_FrameIndex];

	mov	eax, DWORD PTR ?g_IndexBufferMemory@@3PA_KA[ecx*8]
	mov	DWORD PTR _range$1[ebp+40], eax
	mov	eax, DWORD PTR ?g_IndexBufferMemory@@3PA_KA[ecx*8+4]
	mov	DWORD PTR _range$1[ebp+44], eax

; 332  :     range [1].size   = index_size;
; 333  : 
; 334  :     err =

	lea	eax, DWORD PTR _range$1[ebp]
	push	eax
	push	2
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	mov	DWORD PTR _range$1[ebp+56], esi
	mov	DWORD PTR _range$1[ebp+60], 0
	call	DWORD PTR ?vkFlushMappedMemoryRanges@@3P6G?AW4VkResult@@PAUVkDevice_T@@IPBUVkMappedMemoryRange@@@ZA

; 335  :       vkFlushMappedMemoryRanges (g_Device, 2, range);
; 336  : 
; 337  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 338  : 
; 339  :     vkUnmapMemory (g_Device, g_VertexBufferMemory [g_FrameIndex]);

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	add	esp, 4
	push	DWORD PTR ?g_VertexBufferMemory@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_VertexBufferMemory@@3PA_KA[eax*8]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkUnmapMemory@@3P6GXPAUVkDevice_T@@_K@ZA

; 340  :     vkUnmapMemory (g_Device, g_IndexBufferMemory  [g_FrameIndex]);

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	push	DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_IndexBufferMemory@@3PA_KA[eax*8]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkUnmapMemory@@3P6GXPAUVkDevice_T@@_K@ZA

; 341  :   }
; 342  : 
; 343  :   // Bind pipeline and descriptor sets:
; 344  :   {
; 345  :     vkCmdBindPipeline (g_CommandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, g_Pipeline);

	push	DWORD PTR ?g_Pipeline@@3_KA+4
	push	DWORD PTR ?g_Pipeline@@3_KA
	push	0
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	call	DWORD PTR ?vkCmdBindPipeline@@3P6GXPAUVkCommandBuffer_T@@W4VkPipelineBindPoint@@_K@ZA

; 346  : 
; 347  :     VkDescriptorSet desc_set [1] = { g_DescriptorSet };

	mov	eax, DWORD PTR ?g_DescriptorSet@@3_KA

; 348  : 
; 349  :     vkCmdBindDescriptorSets (g_CommandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, g_PipelineLayout, 0, 1, desc_set, 0, NULL);

	push	0
	push	0
	mov	DWORD PTR _desc_set$13[ebp], eax
	mov	eax, DWORD PTR ?g_DescriptorSet@@3_KA+4
	mov	DWORD PTR _desc_set$13[ebp+4], eax
	lea	eax, DWORD PTR _desc_set$13[ebp]
	push	eax
	push	1
	push	0
	push	DWORD PTR ?g_PipelineLayout@@3_KA+4
	push	DWORD PTR ?g_PipelineLayout@@3_KA
	push	0
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	call	DWORD PTR ?vkCmdBindDescriptorSets@@3P6GXPAUVkCommandBuffer_T@@W4VkPipelineBindPoint@@_KIIPB_KIPBI@ZA

; 350  :   }
; 351  : 
; 352  :   // Bind Vertex And Index Buffer:
; 353  :   {
; 354  :     VkBuffer     vertex_buffers [1] = { g_VertexBuffer [g_FrameIndex] };

	mov	ecx, DWORD PTR ?g_FrameIndex@@3HA
	xorps	xmm0, xmm0

; 355  :     VkDeviceSize vertex_offset  [1] = { 0 };

	movlpd	QWORD PTR _vertex_offset$11[ebp], xmm0
	mov	eax, DWORD PTR ?g_VertexBuffer@@3PA_KA[ecx*8]
	mov	DWORD PTR _vertex_buffers$14[ebp], eax
	mov	eax, DWORD PTR ?g_VertexBuffer@@3PA_KA[ecx*8+4]
	mov	DWORD PTR _vertex_buffers$14[ebp+4], eax

; 356  : 
; 357  :     vkCmdBindVertexBuffers (g_CommandBuffer, 0, 1, vertex_buffers, vertex_offset);

	lea	eax, DWORD PTR _vertex_offset$11[ebp]
	push	eax
	lea	eax, DWORD PTR _vertex_buffers$14[ebp]
	push	eax
	push	1
	push	0
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	call	DWORD PTR ?vkCmdBindVertexBuffers@@3P6GXPAUVkCommandBuffer_T@@IIPB_K1@ZA

; 358  :     vkCmdBindIndexBuffer   (g_CommandBuffer, g_IndexBuffer [g_FrameIndex], 0, VK_INDEX_TYPE_UINT16);

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	push	0
	push	0
	push	0
	push	DWORD PTR ?g_IndexBuffer@@3PA_KA[eax*8+4]
	push	DWORD PTR ?g_IndexBuffer@@3PA_KA[eax*8]
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	call	DWORD PTR ?vkCmdBindIndexBuffer@@3P6GXPAUVkCommandBuffer_T@@_K1W4VkIndexType@@@ZA

; 359  :   }
; 360  : 
; 361  :   // Setup viewport:
; 362  :   {
; 363  :     VkViewport viewport;
; 364  : 
; 365  :     viewport.x        = 0;

	mov	DWORD PTR _viewport$8[ebp], 0

; 366  :     viewport.y        = 0;

	mov	DWORD PTR _viewport$8[ebp+4], 0

; 367  :     viewport.width    = ImGui::GetIO ().DisplaySize.x;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _viewport$8[ebp+8], xmm0

; 368  :     viewport.height   = ImGui::GetIO ().DisplaySize.y;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR [eax+4]

; 369  :     viewport.minDepth = 0.0f;
; 370  :     viewport.maxDepth = 1.0f;
; 371  : 
; 372  :     vkCmdSetViewport (g_CommandBuffer, 0, 1, &viewport);

	lea	eax, DWORD PTR _viewport$8[ebp]
	push	eax
	push	1
	push	0
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	movss	DWORD PTR _viewport$8[ebp+12], xmm0
	mov	DWORD PTR _viewport$8[ebp+16], 0
	mov	DWORD PTR _viewport$8[ebp+20], 1065353216 ; 3f800000H
	call	DWORD PTR ?vkCmdSetViewport@@3P6GXPAUVkCommandBuffer_T@@IIPBUVkViewport@@@ZA

; 373  :   }
; 374  : 
; 375  :   // Setup scale and translation:
; 376  :   {
; 377  :     float scale [2];
; 378  :     scale       [0] = 2.0f / io.DisplaySize.x;

	mov	eax, DWORD PTR _io$1$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000

; 379  :     scale       [1] = 2.0f / io.DisplaySize.y;
; 380  : 
; 381  :     float translate [2];
; 382  : 
; 383  :     translate [0] = -1.0f;

	mov	DWORD PTR _translate$10[ebp], -1082130432 ; bf800000H

; 384  :     translate [1] = -1.0f;

	mov	DWORD PTR _translate$10[ebp+4], -1082130432 ; bf800000H
	divss	xmm0, DWORD PTR [eax]
	addss	xmm0, xmm0
	movss	DWORD PTR _scale$12[ebp], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [eax+4]

; 385  : 
; 386  :     vkCmdPushConstants (g_CommandBuffer, g_PipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, sizeof(float) * 0, sizeof(float) * 2, scale);

	lea	eax, DWORD PTR _scale$12[ebp]
	push	eax
	push	8
	push	0
	push	1
	push	DWORD PTR ?g_PipelineLayout@@3_KA+4
	addss	xmm0, xmm0
	push	DWORD PTR ?g_PipelineLayout@@3_KA
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	movss	DWORD PTR _scale$12[ebp+4], xmm0
	call	DWORD PTR ?vkCmdPushConstants@@3P6GXPAUVkCommandBuffer_T@@_KIIIPBX@ZA

; 387  :     vkCmdPushConstants (g_CommandBuffer, g_PipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, sizeof(float) * 2, sizeof(float) * 2, translate);

	lea	eax, DWORD PTR _translate$10[ebp]
	push	eax
	push	8
	push	8
	push	1
	push	DWORD PTR ?g_PipelineLayout@@3_KA+4
	push	DWORD PTR ?g_PipelineLayout@@3_KA
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	call	DWORD PTR ?vkCmdPushConstants@@3P6GXPAUVkCommandBuffer_T@@_KIIIPBX@ZA

; 388  :   }
; 389  : 
; 390  :   // Render the command lists:
; 391  :   int vtx_offset = 0;

	xor	ecx, ecx

; 392  :   int idx_offset = 0;
; 393  : 
; 394  :   for (int n = 0; n < draw_data->CmdListsCount; n++)

	xor	edx, edx
	mov	DWORD PTR _vtx_offset$1$[ebp], ecx
	mov	DWORD PTR _idx_offset$1$[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	DWORD PTR [ebx+8], ecx
	jle	$LN6@ImGui_Impl
$LL7@ImGui_Impl:

; 395  :   {
; 396  :     const ImDrawList* cmd_list = draw_data->CmdLists [n];

	mov	eax, DWORD PTR [ebx+4]

; 397  : 
; 398  :     for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	xor	ebx, ebx
	mov	edi, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [edi], ebx
	jle	$LN9@ImGui_Impl

; 395  :   {
; 396  :     const ImDrawList* cmd_list = draw_data->CmdLists [n];

	xor	eax, eax
	mov	DWORD PTR tv665[ebp], eax
$LL10@ImGui_Impl:

; 397  : 
; 398  :     for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	mov	esi, DWORD PTR [edi+8]
	add	esi, eax

; 399  :     {
; 400  :       const ImDrawCmd* pcmd =
; 401  :         &cmd_list->CmdBuffer [cmd_i];
; 402  : 
; 403  :       if (pcmd->UserCallback)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN19@ImGui_Impl

; 404  :       {
; 405  :         pcmd->UserCallback (cmd_list, pcmd);

	push	esi
	push	edi
	call	eax
	add	esp, 8

; 406  :       }
; 407  : 
; 408  :       else

	jmp	SHORT $LN20@ImGui_Impl
$LN19@ImGui_Impl:

; 409  :       {
; 410  :         VkRect2D scissor;
; 411  : 
; 412  :         scissor.offset.x      = (int32_t)(pcmd->ClipRect.x);

	cvttss2si eax, DWORD PTR [esi+4]

; 413  :         scissor.offset.y      = (int32_t)(pcmd->ClipRect.y);
; 414  :         scissor.extent.width  = (uint32_t)(pcmd->ClipRect.z - pcmd->ClipRect.x);

	movss	xmm0, DWORD PTR [esi+12]
	subss	xmm0, DWORD PTR [esi+4]
	mov	DWORD PTR _scissor$7[ebp], eax
	cvttss2si eax, DWORD PTR [esi+8]
	mov	DWORD PTR _scissor$7[ebp+4], eax
	call	__ftoui3

; 415  :         scissor.extent.height = (uint32_t)(pcmd->ClipRect.w - pcmd->ClipRect.y + 1); // TODO: + 1??????

	movss	xmm0, DWORD PTR [esi+16]
	subss	xmm0, DWORD PTR [esi+8]
	mov	DWORD PTR _scissor$7[ebp+8], eax
	addss	xmm0, DWORD PTR __real@3f800000
	call	__ftoui3
	mov	DWORD PTR _scissor$7[ebp+12], eax

; 416  : 
; 417  :         vkCmdSetScissor  (g_CommandBuffer, 0, 1, &scissor);

	lea	eax, DWORD PTR _scissor$7[ebp]
	push	eax
	push	1
	push	0
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	call	DWORD PTR ?vkCmdSetScissor@@3P6GXPAUVkCommandBuffer_T@@IIPBUVkRect2D@@@ZA

; 418  :         vkCmdDrawIndexed (g_CommandBuffer, pcmd->ElemCount, 1, idx_offset, vtx_offset, 0);

	push	0
	push	DWORD PTR _vtx_offset$1$[ebp]
	push	DWORD PTR _idx_offset$1$[ebp]
	push	1
	push	DWORD PTR [esi]
	push	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A
	call	DWORD PTR ?vkCmdDrawIndexed@@3P6GXPAUVkCommandBuffer_T@@IIIHI@ZA
$LN20@ImGui_Impl:

; 419  :       }
; 420  : 
; 421  :       idx_offset += pcmd->ElemCount;

	mov	ecx, DWORD PTR _idx_offset$1$[ebp]
	inc	ebx
	mov	eax, DWORD PTR tv665[ebp]
	add	ecx, DWORD PTR [esi]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _idx_offset$1$[ebp], ecx
	mov	DWORD PTR tv665[ebp], eax
	cmp	ebx, DWORD PTR [edi]
	jl	$LL10@ImGui_Impl
	mov	ecx, DWORD PTR _vtx_offset$1$[ebp]
	mov	edx, DWORD PTR _n$1$[ebp]
$LN9@ImGui_Impl:

; 392  :   int idx_offset = 0;
; 393  : 
; 394  :   for (int n = 0; n < draw_data->CmdListsCount; n++)

	mov	ebx, DWORD PTR _draw_data$[ebp]
	inc	edx

; 422  :     }
; 423  : 
; 424  :     vtx_offset += cmd_list->VtxBuffer.Size;

	add	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR _vtx_offset$1$[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	edx, DWORD PTR [ebx+8]
	jl	$LL7@ImGui_Impl
$LN6@ImGui_Impl:
	pop	edi
	pop	esi
	pop	ebx

; 425  :   }
; 426  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplVulkan_RenderDrawLists@@YAXPAUImDrawData@@@Z ENDP ; ImGui_ImplVulkan_RenderDrawLists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
_err$ = 8						; size = 4
?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z PROC	; ImGui_ImplVulkan_VkResult

; 180  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 181  :   if (g_CheckVkResult)

	mov	eax, DWORD PTR ?g_CheckVkResult@@3P6AXW4VkResult@@@ZA
	test	eax, eax
	je	SHORT $LN2@ImGui_Impl

; 183  : }

	pop	ebp

; 182  :     g_CheckVkResult (err);

	jmp	eax
$LN2@ImGui_Impl:

; 183  : }

	pop	ebp
	ret	0
?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ENDP	; ImGui_ImplVulkan_VkResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
_prop$ = -520						; size = 520
_properties$ = 8					; size = 4
_type_bits$ = 12					; size = 4
?ImGui_ImplVulkan_MemoryType@@YAIII@Z PROC		; ImGui_ImplVulkan_MemoryType

; 166  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 520				; 00000208H
	push	esi
	push	edi

; 167  :   VkPhysicalDeviceMemoryProperties prop;
; 168  :   vkGetPhysicalDeviceMemoryProperties (g_Gpu, &prop);

	lea	eax, DWORD PTR _prop$[ebp]
	push	eax
	push	DWORD PTR ?g_Gpu@@3PAUVkPhysicalDevice_T@@A
	call	DWORD PTR ?vkGetPhysicalDeviceMemoryProperties@@3P6GXPAUVkPhysicalDevice_T@@PAUVkPhysicalDeviceMemoryProperties@@@ZA

; 169  : 
; 170  :   for (uint32_t i = 0; i < prop.memoryTypeCount; i++)

	mov	esi, DWORD PTR _prop$[ebp]
	xor	ecx, ecx
	test	esi, esi
	je	SHORT $LN12@ImGui_Impl
	mov	edi, DWORD PTR _type_bits$[ebp]
	mov	edx, DWORD PTR _properties$[ebp]
$LL4@ImGui_Impl:

; 171  :     if ((prop.memoryTypes [i].propertyFlags & properties) == properties && type_bits & (1 << i))

	mov	eax, DWORD PTR _prop$[ebp+ecx*8+4]
	and	eax, edx
	cmp	eax, edx
	jne	SHORT $LN2@ImGui_Impl
	mov	eax, 1
	shl	eax, cl
	test	eax, edi
	jne	SHORT $LN8@ImGui_Impl
$LN2@ImGui_Impl:

; 169  : 
; 170  :   for (uint32_t i = 0; i < prop.memoryTypeCount; i++)

	inc	ecx
	cmp	ecx, esi
	jb	SHORT $LL4@ImGui_Impl
$LN12@ImGui_Impl:
	pop	edi

; 173  : 
; 174  :   return 0xffffffff; // Unable to find memoryType

	or	eax, -1
	pop	esi

; 175  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@ImGui_Impl:
	pop	edi

; 172  :       return i;

	mov	eax, ecx
	pop	esi

; 175  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplVulkan_MemoryType@@YAIII@Z ENDP		; ImGui_ImplVulkan_MemoryType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
_depth_info$ = -904					; size = 96
_info$1 = -808						; size = 72
_blend_info$ = -736					; size = 44
_raster_info$ = -692					; size = 52
_ms_info$ = -640					; size = 36
_info$ = -592						; size = 96
_stage$ = -496						; size = 64
_color_attachment$ = -432				; size = 32
_viewport_info$ = -400					; size = 28
_ia_info$ = -368					; size = 20
_attribute_desc$ = -336					; size = 48
_dynamic_state$ = -288					; size = 20
_frag_info$2 = -256					; size = 20
_vert_info$3 = -224					; size = 20
_vertex_info$ = -192					; size = 28
_alloc_info$4 = -160					; size = 24
_dynamic_states$ = -116					; size = 8
_binding_desc$ = -108					; size = 12
_layout_info$5 = -96					; size = 28
_info$6 = -96						; size = 20
_frag_module$ = -64					; size = 8
_vert_module$ = -56					; size = 8
_binding$7 = -48					; size = 20
_push_constants$8 = -40					; size = 12
_set_layout$9 = -8					; size = 8
_sampler$10 = -8					; size = 8
?ImGui_ImplVulkan_CreateDeviceObjects@@YA_NXZ PROC	; ImGui_ImplVulkan_CreateDeviceObjects

; 644  : {

	npad	2
	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 904				; 00000388H
	push	esi
	push	edi

; 645  :   VkResult       err;
; 646  :   VkShaderModule vert_module;
; 647  :   VkShaderModule frag_module;
; 648  : 
; 649  :   // Create The Shader Modules:
; 650  :   {
; 651  :     VkShaderModuleCreateInfo vert_info = { };
; 652  : 
; 653  :     vert_info.sType    = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
; 654  :     vert_info.codeSize = sizeof(__glsl_shader_vert_spv);
; 655  :     vert_info.pCode    = (uint32_t*)__glsl_shader_vert_spv;
; 656  : 
; 657  :     err =

	lea	eax, DWORD PTR _vert_module$[ebp]
	mov	DWORD PTR _vert_info$3[ebp+16], 0
	push	eax
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	lea	eax, DWORD PTR _vert_info$3[ebp]
	mov	DWORD PTR _vert_info$3[ebp+16], OFFSET ?__glsl_shader_vert_spv@@3PAIA
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR _vert_info$3[ebp], xmm0
	mov	DWORD PTR _vert_info$3[ebp], 16		; 00000010H
	mov	DWORD PTR _vert_info$3[ebp+12], 1296	; 00000510H
	call	DWORD PTR ?vkCreateShaderModule@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkShaderModuleCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 658  :       vkCreateShaderModule (g_Device, &vert_info, g_Allocator, &vert_module);
; 659  : 
; 660  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 661  : 
; 662  :     VkShaderModuleCreateInfo frag_info = { };

	mov	DWORD PTR _frag_info$2[ebp+16], 0

; 663  : 
; 664  :     frag_info.sType    = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
; 665  :     frag_info.codeSize = sizeof(__glsl_shader_frag_spv);
; 666  :     frag_info.pCode    = (uint32_t*)__glsl_shader_frag_spv;
; 667  : 
; 668  :     err =

	lea	eax, DWORD PTR _frag_module$[ebp]
	mov	DWORD PTR _frag_info$2[ebp+16], OFFSET ?__glsl_shader_frag_spv@@3PAIA
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR _frag_info$2[ebp], xmm0
	push	eax
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	lea	eax, DWORD PTR _frag_info$2[ebp]
	mov	DWORD PTR _frag_info$2[ebp], 16		; 00000010H
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	mov	DWORD PTR _frag_info$2[ebp+12], 772	; 00000304H
	call	DWORD PTR ?vkCreateShaderModule@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkShaderModuleCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 669  :       vkCreateShaderModule (g_Device, &frag_info, g_Allocator, &frag_module);
; 670  : 
; 671  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 672  :   }
; 673  : 
; 674  :   if (! g_FontSampler)

	mov	ecx, DWORD PTR ?g_FontSampler@@3_KA
	add	esp, 4
	mov	edx, DWORD PTR ?g_FontSampler@@3_KA+4
	mov	eax, ecx
	or	eax, edx
	jne	$LN2@ImGui_Impl

; 675  :   {
; 676  :     VkSamplerCreateInfo info = { };

	push	72					; 00000048H
	push	eax
	lea	eax, DWORD PTR _info$1[ebp]
	push	eax
	call	_memset
	movaps	xmm0, XMMWORD PTR __xmm@00000000000000010000000100000001

; 677  : 
; 678  :     info.sType        = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
; 679  :     info.magFilter    = VK_FILTER_LINEAR;
; 680  :     info.minFilter    = VK_FILTER_LINEAR;
; 681  :     info.mipmapMode   = VK_SAMPLER_MIPMAP_MODE_LINEAR;
; 682  :     info.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
; 683  :     info.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
; 684  :     info.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
; 685  :     info.minLod       = -1000;
; 686  :     info.maxLod       =  1000;
; 687  : 
; 688  :     err =

	lea	eax, DWORD PTR _info$1[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _info$1[ebp], 31		; 0000001fH
	movups	XMMWORD PTR _info$1[ebp+12], xmm0
	mov	DWORD PTR _info$1[ebp+28], 0
	mov	DWORD PTR _info$1[ebp+32], 0
	push	OFFSET ?g_FontSampler@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	mov	DWORD PTR _info$1[ebp+56], -998637568	; c47a0000H
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	mov	DWORD PTR _info$1[ebp+60], 1148846080	; 447a0000H
	call	DWORD PTR ?vkCreateSampler@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkSamplerCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 689  :       vkCreateSampler (g_Device, &info, g_Allocator, &g_FontSampler);
; 690  : 
; 691  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	mov	edx, DWORD PTR ?g_FontSampler@@3_KA+4
	add	esp, 4
	mov	ecx, DWORD PTR ?g_FontSampler@@3_KA
$LN2@ImGui_Impl:

; 692  :   }
; 693  : 
; 694  :   if (! g_DescriptorSetLayout)

	mov	eax, DWORD PTR ?g_DescriptorSetLayout@@3_KA
	or	eax, DWORD PTR ?g_DescriptorSetLayout@@3_KA+4
	jne	SHORT $LN3@ImGui_Impl

; 695  :   {
; 696  :     VkSampler                    sampler [1] = { g_FontSampler };
; 697  :     VkDescriptorSetLayoutBinding binding [1] = {               };

	mov	DWORD PTR _binding$7[ebp+16], eax
	xorps	xmm0, xmm0

; 698  : 
; 699  :     binding [0].descriptorType     = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
; 700  :     binding [0].descriptorCount    = 1;
; 701  :     binding [0].stageFlags         = VK_SHADER_STAGE_FRAGMENT_BIT;
; 702  : 
; 703  :     binding [0].pImmutableSamplers = sampler;

	lea	eax, DWORD PTR _sampler$10[ebp]

; 704  :     VkDescriptorSetLayoutCreateInfo info = {};

	mov	DWORD PTR _info$6[ebp+16], 0
	mov	DWORD PTR _binding$7[ebp+16], eax

; 705  : 
; 706  :     info.sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
; 707  :     info.bindingCount = 1;
; 708  :     info.pBindings    = binding;

	lea	eax, DWORD PTR _binding$7[ebp]

; 709  : 
; 710  :     err =

	push	OFFSET ?g_DescriptorSetLayout@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	mov	DWORD PTR _info$6[ebp+16], eax
	lea	eax, DWORD PTR _info$6[ebp]
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	movaps	XMMWORD PTR _binding$7[ebp], xmm0
	movaps	XMMWORD PTR _info$6[ebp], xmm0
	mov	DWORD PTR _sampler$10[ebp], ecx
	mov	DWORD PTR _sampler$10[ebp+4], edx
	mov	DWORD PTR _binding$7[ebp+4], 1
	mov	DWORD PTR _binding$7[ebp+8], 1
	mov	DWORD PTR _binding$7[ebp+12], 16	; 00000010H
	mov	DWORD PTR _info$6[ebp], 32		; 00000020H
	mov	DWORD PTR _info$6[ebp+12], 1
	call	DWORD PTR ?vkCreateDescriptorSetLayout@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkDescriptorSetLayoutCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 711  :       vkCreateDescriptorSetLayout (g_Device, &info, g_Allocator, &g_DescriptorSetLayout);
; 712  : 
; 713  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4
$LN3@ImGui_Impl:

; 714  :   }
; 715  : 
; 716  :   // Create Descriptor Set:
; 717  :   {
; 718  :     VkDescriptorSetAllocateInfo alloc_info = { };
; 719  : 
; 720  :     alloc_info.sType              = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
; 721  :     alloc_info.descriptorPool     = g_DescriptorPool;

	mov	eax, DWORD PTR ?g_DescriptorPool@@3_KA
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR _alloc_info$4[ebp], xmm0
	mov	DWORD PTR _alloc_info$4[ebp+8], eax
	mov	eax, DWORD PTR ?g_DescriptorPool@@3_KA+4
	mov	DWORD PTR _alloc_info$4[ebp+12], eax

; 722  :     alloc_info.descriptorSetCount = 1;
; 723  :     alloc_info.pSetLayouts        = &g_DescriptorSetLayout;
; 724  : 
; 725  :     err =

	lea	eax, DWORD PTR _alloc_info$4[ebp]
	push	OFFSET ?g_DescriptorSet@@3_KA
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	movq	QWORD PTR _alloc_info$4[ebp+16], xmm0
	mov	DWORD PTR _alloc_info$4[ebp], 34	; 00000022H
	mov	DWORD PTR _alloc_info$4[ebp+16], 1
	mov	DWORD PTR _alloc_info$4[ebp+20], OFFSET ?g_DescriptorSetLayout@@3_KA
	call	DWORD PTR ?vkAllocateDescriptorSets@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkDescriptorSetAllocateInfo@@PA_K@ZA

; 726  :       vkAllocateDescriptorSets (g_Device, &alloc_info, &g_DescriptorSet);
; 727  : 
; 728  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 729  :   }
; 730  : 
; 731  :   if (! g_PipelineLayout)

	mov	esi, DWORD PTR ?g_PipelineLayout@@3_KA
	add	esp, 4
	mov	edi, DWORD PTR ?g_PipelineLayout@@3_KA+4
	mov	eax, esi
	or	eax, edi
	jne	$LN4@ImGui_Impl

; 732  :   {
; 733  :     VkPushConstantRange push_constants [1] = { };

	xorps	xmm0, xmm0
	mov	DWORD PTR _push_constants$8[ebp+8], eax
	movq	QWORD PTR _push_constants$8[ebp], xmm0

; 734  : 
; 735  :     push_constants [0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
; 736  :     push_constants [0].offset     = sizeof (float) * 0;

	mov	DWORD PTR _push_constants$8[ebp+4], eax

; 737  :     push_constants [0].size       = sizeof (float) * 4;
; 738  : 
; 739  :     VkDescriptorSetLayout      set_layout [1] = { g_DescriptorSetLayout };

	mov	eax, DWORD PTR ?g_DescriptorSetLayout@@3_KA
	mov	DWORD PTR _set_layout$9[ebp], eax
	mov	eax, DWORD PTR ?g_DescriptorSetLayout@@3_KA+4
	mov	DWORD PTR _set_layout$9[ebp+4], eax

; 740  :     VkPipelineLayoutCreateInfo layout_info    = {                       };
; 741  : 
; 742  :     layout_info.sType                  = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
; 743  :     layout_info.setLayoutCount         = 1;
; 744  :     layout_info.pSetLayouts            = set_layout;

	lea	eax, DWORD PTR _set_layout$9[ebp]
	movq	QWORD PTR _layout_info$5[ebp+16], xmm0
	mov	DWORD PTR _layout_info$5[ebp+16], eax

; 745  :     layout_info.pushConstantRangeCount = 1;
; 746  :     layout_info.pPushConstantRanges     = push_constants;

	lea	eax, DWORD PTR _push_constants$8[ebp]

; 747  : 
; 748  :     err =

	push	OFFSET ?g_PipelineLayout@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	mov	DWORD PTR _layout_info$5[ebp+24], 0
	mov	DWORD PTR _layout_info$5[ebp+24], eax
	lea	eax, DWORD PTR _layout_info$5[ebp]
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	movaps	XMMWORD PTR _layout_info$5[ebp], xmm0
	mov	DWORD PTR _push_constants$8[ebp], 1
	mov	DWORD PTR _push_constants$8[ebp+8], 16	; 00000010H
	mov	DWORD PTR _layout_info$5[ebp], 30	; 0000001eH
	mov	DWORD PTR _layout_info$5[ebp+12], 1
	mov	DWORD PTR _layout_info$5[ebp+20], 1
	call	DWORD PTR ?vkCreatePipelineLayout@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkPipelineLayoutCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 749  :       vkCreatePipelineLayout (g_Device, &layout_info, g_Allocator, &g_PipelineLayout);
; 750  : 
; 751  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	mov	edi, DWORD PTR ?g_PipelineLayout@@3_KA+4
	add	esp, 4
	mov	esi, DWORD PTR ?g_PipelineLayout@@3_KA
$LN4@ImGui_Impl:

; 752  :   }
; 753  : 
; 754  :   VkPipelineShaderStageCreateInfo stage [2] = { };

	push	64					; 00000040H
	lea	eax, DWORD PTR _stage$[ebp]
	push	0
	push	eax
	call	_memset

; 755  : 
; 756  :   stage [0].sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
; 757  :   stage [0].stage  = VK_SHADER_STAGE_VERTEX_BIT;
; 758  :   stage [0].module = vert_module;

	mov	eax, DWORD PTR _vert_module$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR _stage$[ebp+16], eax
	mov	eax, DWORD PTR _vert_module$[ebp+4]
	mov	DWORD PTR _stage$[ebp+20], eax

; 759  :   stage [0].pName  = "main";
; 760  :   stage [1].sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
; 761  :   stage [1].stage  = VK_SHADER_STAGE_FRAGMENT_BIT;
; 762  :   stage [1].module = frag_module;

	mov	eax, DWORD PTR _frag_module$[ebp]
	mov	DWORD PTR _stage$[ebp+48], eax
	mov	eax, DWORD PTR _frag_module$[ebp+4]

; 763  :   stage [1].pName  = "main";
; 764  : 
; 765  :   VkVertexInputBindingDescription binding_desc [1] = { };
; 766  : 
; 767  :   binding_desc [0].stride    = sizeof(ImDrawVert);
; 768  :   binding_desc [0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
; 769  : 
; 770  :   VkVertexInputAttributeDescription attribute_desc [3] = { };

	push	48					; 00000030H
	mov	DWORD PTR _stage$[ebp+52], eax
	lea	eax, DWORD PTR _attribute_desc$[ebp]
	push	0
	movq	QWORD PTR _binding_desc$[ebp], xmm0
	mov	DWORD PTR _binding_desc$[ebp+8], 0
	push	eax
	mov	DWORD PTR _stage$[ebp], 18		; 00000012H
	mov	DWORD PTR _stage$[ebp+12], 1
	mov	DWORD PTR _stage$[ebp+24], OFFSET $SG90982
	mov	DWORD PTR _stage$[ebp+32], 18		; 00000012H
	mov	DWORD PTR _stage$[ebp+44], 16		; 00000010H
	mov	DWORD PTR _stage$[ebp+56], OFFSET $SG90983
	mov	DWORD PTR _binding_desc$[ebp+4], 20	; 00000014H
	mov	DWORD PTR _binding_desc$[ebp+8], 0
	call	_memset

; 771  : 
; 772  :   attribute_desc [0].location = 0;
; 773  :   attribute_desc [0].binding  = binding_desc[0].binding;

	mov	eax, DWORD PTR _binding_desc$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR _attribute_desc$[ebp+4], eax

; 774  :   attribute_desc [0].format   = VK_FORMAT_R32G32_SFLOAT;
; 775  :   attribute_desc [0].offset   = (size_t)(&((ImDrawVert*)0)->pos);
; 776  :   attribute_desc [1].location = 1;
; 777  :   attribute_desc [1].binding  = binding_desc[0].binding;

	mov	DWORD PTR _attribute_desc$[ebp+20], eax

; 778  :   attribute_desc [1].format   = VK_FORMAT_R32G32_SFLOAT;
; 779  :   attribute_desc [1].offset   = (size_t)(&((ImDrawVert*)0)->uv);
; 780  :   attribute_desc [2].location = 2;
; 781  :   attribute_desc [2].binding  = binding_desc[0].binding;

	mov	DWORD PTR _attribute_desc$[ebp+36], eax

; 782  :   attribute_desc [2].format   = VK_FORMAT_R8G8B8A8_UNORM;
; 783  :   attribute_desc [2].offset   = (size_t)(&((ImDrawVert*)0)->col);
; 784  : 
; 785  :   VkPipelineVertexInputStateCreateInfo vertex_info = { };
; 786  : 
; 787  :   vertex_info.sType                           = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
; 788  :   vertex_info.vertexBindingDescriptionCount   = 1;
; 789  :   vertex_info.pVertexBindingDescriptions      = binding_desc;

	lea	eax, DWORD PTR _binding_desc$[ebp]
	movq	QWORD PTR _vertex_info$[ebp+16], xmm0
	mov	DWORD PTR _vertex_info$[ebp+16], eax

; 790  :   vertex_info.vertexAttributeDescriptionCount = 3;
; 791  :   vertex_info.pVertexAttributeDescriptions    = attribute_desc;

	lea	eax, DWORD PTR _attribute_desc$[ebp]

; 792  : 
; 793  :   VkPipelineInputAssemblyStateCreateInfo ia_info = { };
; 794  : 
; 795  :   ia_info.sType    = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
; 796  :   ia_info.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
; 797  : 
; 798  :   VkPipelineViewportStateCreateInfo viewport_info = { };
; 799  : 
; 800  :   viewport_info.sType         = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
; 801  :   viewport_info.viewportCount = 1;
; 802  :   viewport_info.scissorCount  = 1;
; 803  : 
; 804  :   VkPipelineRasterizationStateCreateInfo raster_info = { };

	push	52					; 00000034H
	mov	DWORD PTR _vertex_info$[ebp+24], 0
	mov	DWORD PTR _vertex_info$[ebp+24], eax
	lea	eax, DWORD PTR _raster_info$[ebp]
	movaps	XMMWORD PTR _vertex_info$[ebp], xmm0
	movaps	XMMWORD PTR _ia_info$[ebp], xmm0
	movaps	XMMWORD PTR _viewport_info$[ebp], xmm0
	push	0
	movq	QWORD PTR _viewport_info$[ebp+16], xmm0
	push	eax
	mov	DWORD PTR _attribute_desc$[ebp], 0
	mov	DWORD PTR _attribute_desc$[ebp+8], 103	; 00000067H
	mov	DWORD PTR _attribute_desc$[ebp+12], 0
	mov	DWORD PTR _attribute_desc$[ebp+16], 1
	mov	DWORD PTR _attribute_desc$[ebp+24], 103	; 00000067H
	mov	DWORD PTR _attribute_desc$[ebp+28], 8
	mov	DWORD PTR _attribute_desc$[ebp+32], 2
	mov	DWORD PTR _attribute_desc$[ebp+40], 37	; 00000025H
	mov	DWORD PTR _attribute_desc$[ebp+44], 16	; 00000010H
	mov	DWORD PTR _vertex_info$[ebp], 19	; 00000013H
	mov	DWORD PTR _vertex_info$[ebp+12], 1
	mov	DWORD PTR _vertex_info$[ebp+20], 3
	mov	DWORD PTR _ia_info$[ebp+16], 0
	mov	DWORD PTR _ia_info$[ebp], 20		; 00000014H
	mov	DWORD PTR _ia_info$[ebp+12], 3
	mov	DWORD PTR _viewport_info$[ebp+24], 0
	mov	DWORD PTR _viewport_info$[ebp], 22	; 00000016H
	mov	DWORD PTR _viewport_info$[ebp+12], 1
	mov	DWORD PTR _viewport_info$[ebp+20], 1
	call	_memset
	xorps	xmm0, xmm0

; 805  : 
; 806  :   raster_info.sType       = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;

	mov	DWORD PTR _raster_info$[ebp], 23	; 00000017H

; 807  :   raster_info.polygonMode = VK_POLYGON_MODE_FILL;
; 808  :   raster_info.cullMode    = VK_CULL_MODE_NONE;
; 809  :   raster_info.frontFace   = VK_FRONT_FACE_COUNTER_CLOCKWISE;
; 810  :   raster_info.lineWidth   = 1.0f;
; 811  : 
; 812  :   VkPipelineMultisampleStateCreateInfo ms_info = { };

	movaps	XMMWORD PTR _ms_info$[ebp], xmm0
	mov	DWORD PTR _raster_info$[ebp+20], 0
	mov	DWORD PTR _raster_info$[ebp+24], 0
	mov	DWORD PTR _raster_info$[ebp+28], 0
	mov	DWORD PTR _raster_info$[ebp+48], 1065353216 ; 3f800000H
	movaps	XMMWORD PTR _ms_info$[ebp+16], xmm0
	mov	DWORD PTR _ms_info$[ebp+32], 0

; 813  : 
; 814  :   ms_info.sType                = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;

	mov	DWORD PTR _ms_info$[ebp], 24		; 00000018H

; 815  :   ms_info.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

	mov	DWORD PTR _ms_info$[ebp+12], 1

; 816  : 
; 817  :   VkPipelineColorBlendAttachmentState color_attachment [1] = { };

	movaps	XMMWORD PTR _color_attachment$[ebp], xmm0
	movaps	XMMWORD PTR _color_attachment$[ebp+16], xmm0

; 818  : 
; 819  :   color_attachment [0].blendEnable         = VK_TRUE;
; 820  :   color_attachment [0].srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
; 821  :   color_attachment [0].dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
; 822  :   color_attachment [0].colorBlendOp        = VK_BLEND_OP_ADD;
; 823  :   color_attachment [0].srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
; 824  :   color_attachment [0].dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
; 825  :   color_attachment [0].alphaBlendOp        = VK_BLEND_OP_ADD;
; 826  :   color_attachment [0].colorWriteMask      = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
; 827  : 
; 828  :   VkPipelineDepthStencilStateCreateInfo depth_info = { };

	movaps	xmm0, XMMWORD PTR __xmm@00000007000000000000000700000006
	lea	eax, DWORD PTR _depth_info$[ebp]
	push	96					; 00000060H
	push	0
	push	eax
	mov	DWORD PTR _color_attachment$[ebp], 1
	movups	XMMWORD PTR _color_attachment$[ebp+4], xmm0
	mov	DWORD PTR _color_attachment$[ebp+20], 0
	mov	DWORD PTR _color_attachment$[ebp+24], 0
	mov	DWORD PTR _color_attachment$[ebp+28], 15 ; 0000000fH
	call	_memset

; 829  : 
; 830  :   depth_info.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
; 831  : 
; 832  :   VkPipelineColorBlendStateCreateInfo blend_info = { };

	push	44					; 0000002cH
	lea	eax, DWORD PTR _blend_info$[ebp]
	mov	DWORD PTR _depth_info$[ebp], 25		; 00000019H
	push	0
	push	eax
	call	_memset

; 833  : 
; 834  :   blend_info.sType           = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
; 835  :   blend_info.attachmentCount = 1;
; 836  :   blend_info.pAttachments    = color_attachment;

	lea	eax, DWORD PTR _color_attachment$[ebp]

; 837  : 
; 838  :   const VkDynamicState dynamic_states [2] =
; 839  :     { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };
; 840  : 
; 841  :   VkPipelineDynamicStateCreateInfo dynamic_state = { };

	mov	DWORD PTR _dynamic_state$[ebp+16], 0
	mov	DWORD PTR _blend_info$[ebp+24], eax
	xorps	xmm0, xmm0

; 842  : 
; 843  :   dynamic_state.sType             = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
; 844  :   dynamic_state.dynamicStateCount = 2;
; 845  :   dynamic_state.pDynamicStates    = dynamic_states;

	lea	eax, DWORD PTR _dynamic_states$[ebp]
	movaps	XMMWORD PTR _dynamic_state$[ebp], xmm0

; 846  : 
; 847  :   VkGraphicsPipelineCreateInfo info = { };

	push	96					; 00000060H
	mov	DWORD PTR _dynamic_state$[ebp+16], eax
	lea	eax, DWORD PTR _info$[ebp]
	push	0
	push	eax
	mov	DWORD PTR _blend_info$[ebp], 26		; 0000001aH
	mov	DWORD PTR _blend_info$[ebp+20], 1
	mov	DWORD PTR _dynamic_states$[ebp], 0
	mov	DWORD PTR _dynamic_states$[ebp+4], 1
	mov	DWORD PTR _dynamic_state$[ebp], 27	; 0000001bH
	mov	DWORD PTR _dynamic_state$[ebp+12], 2
	call	_memset

; 848  : 
; 849  :   info.sType               = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
; 850  :   info.flags               = g_PipelineCreateFlags;

	mov	eax, DWORD PTR ?g_PipelineCreateFlags@@3IA
	add	esp, 72					; 00000048H
	mov	DWORD PTR _info$[ebp+8], eax

; 851  :   info.stageCount          = 2;
; 852  :   info.pStages             = stage;

	lea	eax, DWORD PTR _stage$[ebp]
	mov	DWORD PTR _info$[ebp+16], eax

; 853  :   info.pVertexInputState   = &vertex_info;

	lea	eax, DWORD PTR _vertex_info$[ebp]
	mov	DWORD PTR _info$[ebp+20], eax

; 854  :   info.pInputAssemblyState = &ia_info;

	lea	eax, DWORD PTR _ia_info$[ebp]
	mov	DWORD PTR _info$[ebp+24], eax

; 855  :   info.pViewportState      = &viewport_info;

	lea	eax, DWORD PTR _viewport_info$[ebp]
	mov	DWORD PTR _info$[ebp+32], eax

; 856  :   info.pRasterizationState = &raster_info;

	lea	eax, DWORD PTR _raster_info$[ebp]
	mov	DWORD PTR _info$[ebp+36], eax

; 857  :   info.pMultisampleState   = &ms_info;

	lea	eax, DWORD PTR _ms_info$[ebp]
	mov	DWORD PTR _info$[ebp+40], eax

; 858  :   info.pDepthStencilState  = &depth_info;

	lea	eax, DWORD PTR _depth_info$[ebp]
	mov	DWORD PTR _info$[ebp+44], eax

; 859  :   info.pColorBlendState    = &blend_info;

	lea	eax, DWORD PTR _blend_info$[ebp]
	mov	DWORD PTR _info$[ebp+48], eax

; 860  :   info.pDynamicState       = &dynamic_state;

	lea	eax, DWORD PTR _dynamic_state$[ebp]

; 861  :   info.layout              = g_PipelineLayout;
; 862  :   info.renderPass          = g_RenderPass;
; 863  : 
; 864  :   err =

	push	OFFSET ?g_Pipeline@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	mov	DWORD PTR _info$[ebp+52], eax
	mov	eax, DWORD PTR ?g_RenderPass@@3_KA
	mov	DWORD PTR _info$[ebp+64], eax
	mov	eax, DWORD PTR ?g_RenderPass@@3_KA+4
	mov	DWORD PTR _info$[ebp+68], eax
	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	push	1
	push	DWORD PTR ?g_PipelineCache@@3_KA+4
	mov	DWORD PTR _info$[ebp], 28		; 0000001cH
	push	DWORD PTR ?g_PipelineCache@@3_KA
	mov	DWORD PTR _info$[ebp+12], 2
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	mov	DWORD PTR _info$[ebp+56], esi
	mov	DWORD PTR _info$[ebp+60], edi
	call	DWORD PTR ?vkCreateGraphicsPipelines@@3P6G?AW4VkResult@@PAUVkDevice_T@@_KIPBUVkGraphicsPipelineCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 865  :     vkCreateGraphicsPipelines (g_Device, g_PipelineCache, 1, &info, g_Allocator, &g_Pipeline);
; 866  : 
; 867  :   ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 868  : 
; 869  :   vkDestroyShaderModule (g_Device, vert_module, g_Allocator);

	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	DWORD PTR _vert_module$[ebp+4]
	push	DWORD PTR _vert_module$[ebp]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyShaderModule@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA

; 870  :   vkDestroyShaderModule (g_Device, frag_module, g_Allocator);

	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	DWORD PTR _frag_module$[ebp+4]
	push	DWORD PTR _frag_module$[ebp]
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyShaderModule@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA

; 871  : 
; 872  :   return true;
; 873  : }

	pop	edi
	mov	al, 1
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?ImGui_ImplVulkan_CreateDeviceObjects@@YA_NXZ ENDP	; ImGui_ImplVulkan_CreateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
_region$1 = -296					; size = 56
_write_desc$2 = -288					; size = 48
_alloc_info$3 = -240					; size = 24
_info$4 = -216						; size = 68
_copy_barrier$5 = -212					; size = 64
_req$6 = -148						; size = 24
_req$7 = -148						; size = 24
_info$8 = -124						; size = 72
_use_barrier$9 = -116					; size = 64
_buffer_info$10 = -92					; size = 40
_io$1$ = -52						; size = 4
_range$11 = -48						; size = 32
_desc_image$12 = -40					; size = 24
_alloc_info$13 = -40					; size = 24
_map$14 = -16						; size = 4
_pixels$ = -12						; size = 4
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_command_buffer$ = 8					; size = 4
?ImGui_ImplVulkan_CreateFontsTexture@@YA_NPAUVkCommandBuffer_T@@@Z PROC ; ImGui_ImplVulkan_CreateFontsTexture

; 430  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	push	ebx
	push	esi
	push	edi

; 431  :   ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	ebx, eax
	mov	DWORD PTR _io$1$[ebp], ebx

; 432  :     ImGui::GetIO ();
; 433  : 
; 434  :   extern void
; 435  :   SK_ImGui_LoadFonts (void);
; 436  : 
; 437  :   SK_ImGui_LoadFonts ();

	call	?SK_ImGui_LoadFonts@@YAXXZ		; SK_ImGui_LoadFonts

; 438  : 
; 439  :   unsigned char* pixels = nullptr;
; 440  :   int            width  = 0,
; 441  :                  height = 0;
; 442  : 
; 443  :   io.Fonts->GetTexDataAsRGBA32 (&pixels, &width, &height);

	push	0
	lea	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _pixels$[ebp], 0
	push	eax
	lea	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _width$[ebp], 0
	push	eax
	lea	eax, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR _height$[ebp], 0
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	call	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32

; 444  : 
; 445  :   size_t upload_size =
; 446  :     width * height * 4 * sizeof (uint8_t);

	mov	edi, DWORD PTR _height$[ebp]

; 447  : 
; 448  :   VkResult err = VK_NOT_READY;
; 449  : 
; 450  :   // Create the Image:
; 451  :   {
; 452  :     VkImageCreateInfo info = { };

	lea	eax, DWORD PTR _info$4[ebp]
	mov	esi, DWORD PTR _width$[ebp]
	mov	ebx, edi
	imul	ebx, esi
	push	68					; 00000044H
	push	0
	push	eax
	shl	ebx, 2
	call	_memset
	add	esp, 12					; 0000000cH

; 453  : 
; 454  :     info.sType         = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;

	mov	DWORD PTR _info$4[ebp], 14		; 0000000eH

; 455  :     info.imageType     = VK_IMAGE_TYPE_2D;
; 456  :     info.format        = VK_FORMAT_R8G8B8A8_UNORM;
; 457  :     info.extent.width  = width;
; 458  :     info.extent.height = height;
; 459  :     info.extent.depth  = 1;
; 460  :     info.mipLevels     = 1;
; 461  :     info.arrayLayers   = 1;
; 462  :     info.samples       = VK_SAMPLE_COUNT_1_BIT;
; 463  :     info.tiling        = VK_IMAGE_TILING_OPTIMAL;
; 464  :     info.usage         = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;
; 465  :     info.sharingMode   = VK_SHARING_MODE_EXCLUSIVE;
; 466  :     info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
; 467  : 
; 468  :     err =

	lea	eax, DWORD PTR _info$4[ebp]
	mov	DWORD PTR _info$4[ebp+12], 1
	mov	DWORD PTR _info$4[ebp+16], 37		; 00000025H
	mov	DWORD PTR _info$4[ebp+20], esi
	push	OFFSET ?g_FontImage@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	mov	DWORD PTR _info$4[ebp+24], edi
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	mov	DWORD PTR _info$4[ebp+28], 1
	mov	DWORD PTR _info$4[ebp+32], 1
	mov	DWORD PTR _info$4[ebp+36], 1
	mov	DWORD PTR _info$4[ebp+40], 1
	mov	DWORD PTR _info$4[ebp+44], 0
	mov	DWORD PTR _info$4[ebp+48], 6
	mov	DWORD PTR _info$4[ebp+52], 0
	mov	DWORD PTR _info$4[ebp+64], 0
	call	DWORD PTR ?vkCreateImage@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkImageCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 469  :       vkCreateImage (g_Device, &info, g_Allocator, &g_FontImage);
; 470  : 
; 471  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 472  : 
; 473  :     VkMemoryRequirements req;
; 474  :     vkGetImageMemoryRequirements (g_Device, g_FontImage, &req);

	lea	eax, DWORD PTR _req$7[ebp]
	push	eax
	push	DWORD PTR ?g_FontImage@@3_KA+4
	push	DWORD PTR ?g_FontImage@@3_KA
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkGetImageMemoryRequirements@@3P6GXPAUVkDevice_T@@_KPAUVkMemoryRequirements@@@ZA

; 475  : 
; 476  :     VkMemoryAllocateInfo alloc_info = { };
; 477  : 
; 478  :     alloc_info.sType           = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
; 479  :     alloc_info.allocationSize  = req.size;

	mov	eax, DWORD PTR _req$7[ebp]
	xorps	xmm0, xmm0

; 480  :     alloc_info.memoryTypeIndex = ImGui_ImplVulkan_MemoryType (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, req.memoryTypeBits);

	push	DWORD PTR _req$7[ebp+16]
	movups	XMMWORD PTR _alloc_info$13[ebp], xmm0
	mov	DWORD PTR _alloc_info$13[ebp+8], eax
	mov	eax, DWORD PTR _req$7[ebp+4]
	push	1
	movq	QWORD PTR _alloc_info$13[ebp+16], xmm0
	mov	DWORD PTR _alloc_info$13[ebp], 5
	mov	DWORD PTR _alloc_info$13[ebp+12], eax
	call	?ImGui_ImplVulkan_MemoryType@@YAIII@Z	; ImGui_ImplVulkan_MemoryType
	add	esp, 8
	mov	DWORD PTR _alloc_info$13[ebp+16], eax

; 481  : 
; 482  :     err =

	lea	eax, DWORD PTR _alloc_info$13[ebp]
	push	OFFSET ?g_FontMemory@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkAllocateMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkMemoryAllocateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 483  :       vkAllocateMemory (g_Device, &alloc_info, g_Allocator, &g_FontMemory);
; 484  : 
; 485  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 486  : 
; 487  :     err =

	push	0
	push	0
	push	DWORD PTR ?g_FontMemory@@3_KA+4
	push	DWORD PTR ?g_FontMemory@@3_KA
	push	DWORD PTR ?g_FontImage@@3_KA+4
	push	DWORD PTR ?g_FontImage@@3_KA
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkBindImageMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11@ZA

; 488  :       vkBindImageMemory (g_Device, g_FontImage, g_FontMemory, 0);
; 489  : 
; 490  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 491  :   }
; 492  : 
; 493  :   // Create the Image View:
; 494  :   {
; 495  :     VkImageViewCreateInfo info = { };

	push	72					; 00000048H
	lea	eax, DWORD PTR _info$8[ebp]
	push	0
	push	eax
	call	_memset

; 496  : 
; 497  :     info.sType                       = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
; 498  :     info.image                       = g_FontImage;

	mov	eax, DWORD PTR ?g_FontImage@@3_KA
	add	esp, 16					; 00000010H
	mov	DWORD PTR _info$8[ebp+16], eax
	mov	eax, DWORD PTR ?g_FontImage@@3_KA+4
	mov	DWORD PTR _info$8[ebp+20], eax

; 499  :     info.viewType                    = VK_IMAGE_VIEW_TYPE_2D;
; 500  :     info.format                      = VK_FORMAT_R8G8B8A8_UNORM;
; 501  :     info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
; 502  :     info.subresourceRange.levelCount = 1;
; 503  :     info.subresourceRange.layerCount = 1;
; 504  : 
; 505  :     err =

	lea	eax, DWORD PTR _info$8[ebp]
	push	OFFSET ?g_FontView@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	mov	DWORD PTR _info$8[ebp], 15		; 0000000fH
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	mov	DWORD PTR _info$8[ebp+24], 1
	mov	DWORD PTR _info$8[ebp+28], 37		; 00000025H
	mov	DWORD PTR _info$8[ebp+48], 1
	mov	DWORD PTR _info$8[ebp+56], 1
	mov	DWORD PTR _info$8[ebp+64], 1
	call	DWORD PTR ?vkCreateImageView@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkImageViewCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 506  :       vkCreateImageView (g_Device, &info, g_Allocator, &g_FontView);
; 507  : 
; 508  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 509  :   }
; 510  : 
; 511  :   // Update the Descriptor Set:
; 512  :   {
; 513  :     VkDescriptorImageInfo desc_image [1] = { };
; 514  : 
; 515  :     desc_image [0].sampler     = g_FontSampler;

	mov	eax, DWORD PTR ?g_FontSampler@@3_KA
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _desc_image$12[ebp], xmm0
	mov	DWORD PTR _desc_image$12[ebp], eax
	mov	eax, DWORD PTR ?g_FontSampler@@3_KA+4
	mov	DWORD PTR _desc_image$12[ebp+4], eax

; 516  :     desc_image [0].imageView   = g_FontView;

	mov	eax, DWORD PTR ?g_FontView@@3_KA
	mov	DWORD PTR _desc_image$12[ebp+8], eax
	mov	eax, DWORD PTR ?g_FontView@@3_KA+4

; 517  :     desc_image [0].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
; 518  : 
; 519  :     VkWriteDescriptorSet write_desc [1] = { };

	push	48					; 00000030H
	mov	DWORD PTR _desc_image$12[ebp+12], eax
	lea	eax, DWORD PTR _write_desc$2[ebp]
	push	0
	movq	QWORD PTR _desc_image$12[ebp+16], xmm0
	push	eax
	mov	DWORD PTR _desc_image$12[ebp+16], 5
	call	_memset

; 520  : 
; 521  :     write_desc [0].sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
; 522  :     write_desc [0].dstSet          = g_DescriptorSet;

	mov	eax, DWORD PTR ?g_DescriptorSet@@3_KA
	add	esp, 16					; 00000010H
	mov	DWORD PTR _write_desc$2[ebp+8], eax
	mov	eax, DWORD PTR ?g_DescriptorSet@@3_KA+4
	mov	DWORD PTR _write_desc$2[ebp+12], eax

; 523  :     write_desc [0].descriptorCount = 1;
; 524  :     write_desc [0].descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
; 525  :     write_desc [0].pImageInfo      = desc_image;

	lea	eax, DWORD PTR _desc_image$12[ebp]

; 526  : 
; 527  :     vkUpdateDescriptorSets (g_Device, 1, write_desc, 0, NULL);

	push	0
	push	0
	mov	DWORD PTR _write_desc$2[ebp+32], eax
	lea	eax, DWORD PTR _write_desc$2[ebp]
	push	eax
	push	1
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	mov	DWORD PTR _write_desc$2[ebp], 35	; 00000023H
	mov	DWORD PTR _write_desc$2[ebp+24], 1
	mov	DWORD PTR _write_desc$2[ebp+28], 1
	call	DWORD PTR ?vkUpdateDescriptorSets@@3P6GXPAUVkDevice_T@@IPBUVkWriteDescriptorSet@@IPBUVkCopyDescriptorSet@@@ZA

; 528  :   }
; 529  : 
; 530  :   // Create the Upload Buffer:
; 531  :   {
; 532  :     VkBufferCreateInfo buffer_info = { };
; 533  : 
; 534  :     buffer_info.sType       = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
; 535  :     buffer_info.size        = upload_size;
; 536  :     buffer_info.usage       = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
; 537  :     buffer_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
; 538  : 
; 539  :     err =

	push	OFFSET ?g_UploadBuffer@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR _buffer_info$10[ebp]
	movups	XMMWORD PTR _buffer_info$10[ebp+16], xmm0
	xor	esi, esi
	mov	DWORD PTR _buffer_info$10[ebp+16], ebx
	movq	QWORD PTR _buffer_info$10[ebp+32], xmm0
	movups	XMMWORD PTR _buffer_info$10[ebp], xmm0
	mov	DWORD PTR _buffer_info$10[ebp], 12	; 0000000cH
	mov	DWORD PTR _buffer_info$10[ebp+20], esi
	mov	DWORD PTR _buffer_info$10[ebp+24], 1
	mov	DWORD PTR _buffer_info$10[ebp+28], esi
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkCreateBuffer@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkBufferCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 540  :       vkCreateBuffer (g_Device, &buffer_info, g_Allocator, &g_UploadBuffer);
; 541  : 
; 542  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 543  : 
; 544  :     VkMemoryRequirements req;
; 545  : 
; 546  :     vkGetBufferMemoryRequirements (g_Device, g_UploadBuffer, &req);

	lea	eax, DWORD PTR _req$6[ebp]
	push	eax
	push	DWORD PTR ?g_UploadBuffer@@3_KA+4
	push	DWORD PTR ?g_UploadBuffer@@3_KA
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkGetBufferMemoryRequirements@@3P6GXPAUVkDevice_T@@_KPAUVkMemoryRequirements@@@ZA

; 547  : 
; 548  :     g_BufferMemoryAlignment = (g_BufferMemoryAlignment > req.alignment) ? g_BufferMemoryAlignment :

	mov	ecx, DWORD PTR _req$6[ebp+12]
	cmp	DWORD PTR ?g_BufferMemoryAlignment@@3_KA+4, ecx
	ja	SHORT $LN4@ImGui_Impl
	mov	eax, DWORD PTR _req$6[ebp+8]
	jb	SHORT $LN5@ImGui_Impl
	cmp	DWORD PTR ?g_BufferMemoryAlignment@@3_KA, eax
	ja	SHORT $LN4@ImGui_Impl
$LN5@ImGui_Impl:
	mov	DWORD PTR ?g_BufferMemoryAlignment@@3_KA, eax
	mov	DWORD PTR ?g_BufferMemoryAlignment@@3_KA+4, ecx
$LN4@ImGui_Impl:

; 549  :                                                                           req.alignment;
; 550  : 
; 551  :     VkMemoryAllocateInfo alloc_info = { };
; 552  : 
; 553  :     alloc_info.sType           = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
; 554  :     alloc_info.allocationSize  = req.size;

	mov	eax, DWORD PTR _req$6[ebp]
	xorps	xmm0, xmm0

; 555  :     alloc_info.memoryTypeIndex = ImGui_ImplVulkan_MemoryType (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, req.memoryTypeBits);

	push	DWORD PTR _req$6[ebp+16]
	movups	XMMWORD PTR _alloc_info$3[ebp], xmm0
	mov	DWORD PTR _alloc_info$3[ebp+8], eax
	mov	eax, DWORD PTR _req$6[ebp+4]
	push	2
	movq	QWORD PTR _alloc_info$3[ebp+16], xmm0
	mov	DWORD PTR _alloc_info$3[ebp], 5
	mov	DWORD PTR _alloc_info$3[ebp+12], eax
	call	?ImGui_ImplVulkan_MemoryType@@YAIII@Z	; ImGui_ImplVulkan_MemoryType
	add	esp, 8
	mov	DWORD PTR _alloc_info$3[ebp+16], eax

; 556  : 
; 557  :     err =

	lea	eax, DWORD PTR _alloc_info$3[ebp]
	push	OFFSET ?g_UploadBufferMemory@@3_KA
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	eax
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkAllocateMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkMemoryAllocateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA

; 558  :       vkAllocateMemory (g_Device, &alloc_info, g_Allocator, &g_UploadBufferMemory);
; 559  : 
; 560  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 561  : 
; 562  :     err =

	push	0
	push	0
	push	DWORD PTR ?g_UploadBufferMemory@@3_KA+4
	push	DWORD PTR ?g_UploadBufferMemory@@3_KA
	push	DWORD PTR ?g_UploadBuffer@@3_KA+4
	push	DWORD PTR ?g_UploadBuffer@@3_KA
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkBindBufferMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11@ZA

; 563  :       vkBindBufferMemory (g_Device, g_UploadBuffer, g_UploadBufferMemory, 0);
; 564  : 
; 565  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 566  :   }
; 567  : 
; 568  :   // Upload to Buffer:
; 569  :   {
; 570  :     char* map = nullptr;

	mov	DWORD PTR _map$14[ebp], esi

; 571  : 
; 572  :     err =

	lea	eax, DWORD PTR _map$14[ebp]
	push	eax
	push	0
	push	esi
	push	ebx
	push	0
	push	0
	push	DWORD PTR ?g_UploadBufferMemory@@3_KA+4
	push	DWORD PTR ?g_UploadBufferMemory@@3_KA
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkMapMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11IPAPAX@ZA

; 573  :       vkMapMemory (g_Device, g_UploadBufferMemory, 0, upload_size, 0, (void**)(&map));
; 574  : 
; 575  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult

; 576  : 
; 577  :     memcpy (map, pixels, upload_size);

	push	ebx
	push	DWORD PTR _pixels$[ebp]
	push	DWORD PTR _map$14[ebp]
	call	_memcpy

; 578  : 
; 579  :     VkMappedMemoryRange range [1] = { };
; 580  : 
; 581  :     range [0].sType  = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
; 582  :     range [0].memory = g_UploadBufferMemory;

	mov	eax, DWORD PTR ?g_UploadBufferMemory@@3_KA
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _range$11[ebp], xmm0
	add	esp, 16					; 00000010H
	mov	DWORD PTR _range$11[ebp+8], eax
	mov	eax, DWORD PTR ?g_UploadBufferMemory@@3_KA+4
	mov	DWORD PTR _range$11[ebp+12], eax

; 583  :     range [0].size   = upload_size;
; 584  : 
; 585  :     err =

	lea	eax, DWORD PTR _range$11[ebp]
	movups	XMMWORD PTR _range$11[ebp+16], xmm0
	push	eax
	push	1
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	mov	DWORD PTR _range$11[ebp], 6
	mov	DWORD PTR _range$11[ebp+24], ebx
	mov	DWORD PTR _range$11[ebp+28], esi
	call	DWORD PTR ?vkFlushMappedMemoryRanges@@3P6G?AW4VkResult@@PAUVkDevice_T@@IPBUVkMappedMemoryRange@@@ZA

; 586  :       vkFlushMappedMemoryRanges (g_Device, 1, range);
; 587  : 
; 588  :     ImGui_ImplVulkan_VkResult (err);

	push	eax
	call	?ImGui_ImplVulkan_VkResult@@YAXW4VkResult@@@Z ; ImGui_ImplVulkan_VkResult
	add	esp, 4

; 589  : 
; 590  :     vkUnmapMemory (g_Device, g_UploadBufferMemory);

	push	DWORD PTR ?g_UploadBufferMemory@@3_KA+4
	push	DWORD PTR ?g_UploadBufferMemory@@3_KA
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkUnmapMemory@@3P6GXPAUVkDevice_T@@_K@ZA

; 591  :   }
; 592  :   // Copy to Image:
; 593  :   {
; 594  :     VkImageMemoryBarrier copy_barrier [1] = { };

	push	64					; 00000040H
	lea	eax, DWORD PTR _copy_barrier$5[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 595  : 
; 596  :     copy_barrier [0].sType                       = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;

	mov	DWORD PTR _copy_barrier$5[ebp], 45	; 0000002dH

; 597  :     copy_barrier [0].dstAccessMask               = VK_ACCESS_TRANSFER_WRITE_BIT;
; 598  :     copy_barrier [0].oldLayout                   = VK_IMAGE_LAYOUT_UNDEFINED;
; 599  :     copy_barrier [0].newLayout                   = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
; 600  :     copy_barrier [0].srcQueueFamilyIndex         = VK_QUEUE_FAMILY_IGNORED;
; 601  :     copy_barrier [0].dstQueueFamilyIndex         = VK_QUEUE_FAMILY_IGNORED;
; 602  :     copy_barrier [0].image                       = g_FontImage;

	mov	eax, DWORD PTR ?g_FontImage@@3_KA
	mov	DWORD PTR _copy_barrier$5[ebp+32], eax
	mov	eax, DWORD PTR ?g_FontImage@@3_KA+4
	mov	DWORD PTR _copy_barrier$5[ebp+36], eax

; 603  :     copy_barrier [0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
; 604  :     copy_barrier [0].subresourceRange.levelCount = 1;
; 605  :     copy_barrier [0].subresourceRange.layerCount = 1;
; 606  : 
; 607  :     vkCmdPipelineBarrier (command_buffer, VK_PIPELINE_STAGE_HOST_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, NULL, 0, NULL, 1, copy_barrier);

	lea	eax, DWORD PTR _copy_barrier$5[ebp]
	push	eax
	push	1
	push	0
	push	0
	push	0
	push	0
	push	0
	push	4096					; 00001000H
	mov	DWORD PTR _copy_barrier$5[ebp+16], esi
	mov	esi, DWORD PTR _command_buffer$[ebp]
	push	16384					; 00004000H
	push	esi
	mov	DWORD PTR _copy_barrier$5[ebp+12], 4096	; 00001000H
	mov	DWORD PTR _copy_barrier$5[ebp+20], 7
	mov	DWORD PTR _copy_barrier$5[ebp+24], -1
	mov	DWORD PTR _copy_barrier$5[ebp+28], -1
	mov	DWORD PTR _copy_barrier$5[ebp+40], 1
	mov	DWORD PTR _copy_barrier$5[ebp+48], 1
	mov	DWORD PTR _copy_barrier$5[ebp+56], 1
	call	DWORD PTR ?vkCmdPipelineBarrier@@3P6GXPAUVkCommandBuffer_T@@IIIIPBUVkMemoryBarrier@@IPBUVkBufferMemoryBarrier@@IPBUVkImageMemoryBarrier@@@ZA

; 608  : 
; 609  :     VkBufferImageCopy region = { };

	push	56					; 00000038H
	lea	eax, DWORD PTR _region$1[ebp]
	push	0
	push	eax
	call	_memset

; 610  : 
; 611  :     region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
; 612  :     region.imageSubresource.layerCount = 1;
; 613  :     region.imageExtent.width           = width;

	mov	eax, DWORD PTR _width$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _region$1[ebp+44], eax

; 614  :     region.imageExtent.height          = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _region$1[ebp+48], eax

; 615  : 
; 616  :     vkCmdCopyBufferToImage (command_buffer, g_UploadBuffer, g_FontImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);

	lea	eax, DWORD PTR _region$1[ebp]
	push	eax
	push	1
	push	7
	push	DWORD PTR ?g_FontImage@@3_KA+4
	mov	DWORD PTR _region$1[ebp+16], 1
	push	DWORD PTR ?g_FontImage@@3_KA
	mov	DWORD PTR _region$1[ebp+28], 1
	push	DWORD PTR ?g_UploadBuffer@@3_KA+4
	push	DWORD PTR ?g_UploadBuffer@@3_KA
	push	esi
	call	DWORD PTR ?vkCmdCopyBufferToImage@@3P6GXPAUVkCommandBuffer_T@@_K1W4VkImageLayout@@IPBUVkBufferImageCopy@@@ZA

; 617  : 
; 618  :     VkImageMemoryBarrier use_barrier [1] = { };

	push	64					; 00000040H
	lea	eax, DWORD PTR _use_barrier$9[ebp]
	push	0
	push	eax
	call	_memset

; 619  : 
; 620  :     use_barrier [0].sType                       = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
; 621  :     use_barrier [0].srcAccessMask               = VK_ACCESS_TRANSFER_WRITE_BIT;
; 622  :     use_barrier [0].dstAccessMask               = VK_ACCESS_SHADER_READ_BIT;
; 623  :     use_barrier [0].oldLayout                   = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
; 624  :     use_barrier [0].newLayout                   = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
; 625  :     use_barrier [0].srcQueueFamilyIndex         = VK_QUEUE_FAMILY_IGNORED;
; 626  :     use_barrier [0].dstQueueFamilyIndex         = VK_QUEUE_FAMILY_IGNORED;
; 627  :     use_barrier [0].image                       = g_FontImage;

	mov	eax, DWORD PTR ?g_FontImage@@3_KA
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _use_barrier$9[ebp+32], eax
	mov	eax, DWORD PTR ?g_FontImage@@3_KA+4
	mov	DWORD PTR _use_barrier$9[ebp+36], eax

; 628  :     use_barrier [0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
; 629  :     use_barrier [0].subresourceRange.levelCount = 1;
; 630  :     use_barrier [0].subresourceRange.layerCount = 1;
; 631  : 
; 632  :     vkCmdPipelineBarrier (command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, NULL, 0, NULL, 1, use_barrier);

	lea	eax, DWORD PTR _use_barrier$9[ebp]
	push	eax
	push	1
	push	0
	push	0
	push	0
	push	0
	push	0
	push	128					; 00000080H
	push	4096					; 00001000H
	push	esi
	mov	DWORD PTR _use_barrier$9[ebp], 45	; 0000002dH
	mov	DWORD PTR _use_barrier$9[ebp+8], 4096	; 00001000H
	mov	DWORD PTR _use_barrier$9[ebp+12], 32	; 00000020H
	mov	DWORD PTR _use_barrier$9[ebp+16], 7
	mov	DWORD PTR _use_barrier$9[ebp+20], 5
	mov	DWORD PTR _use_barrier$9[ebp+24], -1
	mov	DWORD PTR _use_barrier$9[ebp+28], -1
	mov	DWORD PTR _use_barrier$9[ebp+40], 1
	mov	DWORD PTR _use_barrier$9[ebp+48], 1
	mov	DWORD PTR _use_barrier$9[ebp+56], 1
	call	DWORD PTR ?vkCmdPipelineBarrier@@3P6GXPAUVkCommandBuffer_T@@IIIIPBUVkMemoryBarrier@@IPBUVkBufferMemoryBarrier@@IPBUVkImageMemoryBarrier@@@ZA

; 633  :   }
; 634  : 
; 635  :   // Store our identifier
; 636  :   io.Fonts->TexID =

	mov	eax, DWORD PTR _io$1$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	eax, DWORD PTR ?g_FontImage@@3_KA
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax

; 637  :     (void *)(intptr_t)g_FontImage;
; 638  : 
; 639  :   return true;

	mov	al, 1
	pop	ebx

; 640  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplVulkan_CreateFontsTexture@@YA_NPAUVkCommandBuffer_T@@@Z ENDP ; ImGui_ImplVulkan_CreateFontsTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
?ImGui_ImplVulkan_InvalidateDeviceObjects@@YAXXZ PROC	; ImGui_ImplVulkan_InvalidateDeviceObjects

; 893  : {

	npad	2
	push	esi

; 894  :   ImGui_ImplVulkan_InvalidateFontUploadObjects ();

	call	?ImGui_ImplVulkan_InvalidateFontUploadObjects@@YAXXZ ; ImGui_ImplVulkan_InvalidateFontUploadObjects

; 897  :   {
; 898  :     if (g_VertexBuffer       [i])   { vkDestroyBuffer (g_Device, g_VertexBuffer       [i], g_Allocator); g_VertexBuffer       [i] = VK_NULL_HANDLE; }

	xor	esi, esi
	npad	6
$LL4@ImGui_Impl:
	mov	edx, DWORD PTR ?g_VertexBuffer@@3PA_KA[esi]
	mov	eax, edx
	mov	ecx, DWORD PTR ?g_VertexBuffer@@3PA_KA[esi+4]
	or	eax, ecx
	je	SHORT $LN5@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	ecx
	push	edx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyBuffer@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	mov	DWORD PTR ?g_VertexBuffer@@3PA_KA[esi], 0
	mov	DWORD PTR ?g_VertexBuffer@@3PA_KA[esi+4], 0
$LN5@ImGui_Impl:

; 899  :     if (g_VertexBufferMemory [i])   { vkFreeMemory    (g_Device, g_VertexBufferMemory [i], g_Allocator); g_VertexBufferMemory [i] = VK_NULL_HANDLE; }

	mov	edx, DWORD PTR ?g_VertexBufferMemory@@3PA_KA[esi]
	mov	eax, edx
	mov	ecx, DWORD PTR ?g_VertexBufferMemory@@3PA_KA[esi+4]
	or	eax, ecx
	je	SHORT $LN6@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	ecx
	push	edx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkFreeMemory@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	mov	DWORD PTR ?g_VertexBufferMemory@@3PA_KA[esi], 0
	mov	DWORD PTR ?g_VertexBufferMemory@@3PA_KA[esi+4], 0
$LN6@ImGui_Impl:

; 900  :     if (g_IndexBuffer        [i])   { vkDestroyBuffer (g_Device, g_IndexBuffer        [i], g_Allocator); g_IndexBuffer        [i] = VK_NULL_HANDLE; }

	mov	edx, DWORD PTR ?g_IndexBuffer@@3PA_KA[esi]
	mov	eax, edx
	mov	ecx, DWORD PTR ?g_IndexBuffer@@3PA_KA[esi+4]
	or	eax, ecx
	je	SHORT $LN7@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	ecx
	push	edx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyBuffer@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	mov	DWORD PTR ?g_IndexBuffer@@3PA_KA[esi], 0
	mov	DWORD PTR ?g_IndexBuffer@@3PA_KA[esi+4], 0
$LN7@ImGui_Impl:

; 901  :     if (g_IndexBufferMemory  [i])   { vkFreeMemory    (g_Device, g_IndexBufferMemory  [i], g_Allocator); g_IndexBufferMemory  [i] = VK_NULL_HANDLE; }

	mov	edx, DWORD PTR ?g_IndexBufferMemory@@3PA_KA[esi]
	mov	eax, edx
	mov	ecx, DWORD PTR ?g_IndexBufferMemory@@3PA_KA[esi+4]
	or	eax, ecx
	je	SHORT $LN2@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	ecx
	push	edx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkFreeMemory@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	mov	DWORD PTR ?g_IndexBufferMemory@@3PA_KA[esi], 0
	mov	DWORD PTR ?g_IndexBufferMemory@@3PA_KA[esi+4], 0
$LN2@ImGui_Impl:

; 895  : 
; 896  :   for (int i = 0; i < IMGUI_VK_QUEUED_FRAMES; i++)

	add	esi, 8
	cmp	esi, 16					; 00000010H
	jl	$LL4@ImGui_Impl

; 902  :   }
; 903  : 
; 904  :   if (g_FontView)             { vkDestroyImageView           (g_Device, g_FontView,            g_Allocator); g_FontView            = VK_NULL_HANDLE; }

	mov	ecx, DWORD PTR ?g_FontView@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_FontView@@3_KA+4
	or	eax, edx
	pop	esi
	je	SHORT $LN9@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyImageView@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0
	movlpd	QWORD PTR ?g_FontView@@3_KA, xmm0
$LN9@ImGui_Impl:

; 905  :   if (g_FontImage)            { vkDestroyImage               (g_Device, g_FontImage,           g_Allocator); g_FontImage           = VK_NULL_HANDLE; }

	mov	ecx, DWORD PTR ?g_FontImage@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_FontImage@@3_KA+4
	or	eax, edx
	je	SHORT $LN10@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyImage@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0
	movlpd	QWORD PTR ?g_FontImage@@3_KA, xmm0
$LN10@ImGui_Impl:

; 906  :   if (g_FontMemory)           { vkFreeMemory                 (g_Device, g_FontMemory,          g_Allocator); g_FontMemory          = VK_NULL_HANDLE; }

	mov	ecx, DWORD PTR ?g_FontMemory@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_FontMemory@@3_KA+4
	or	eax, edx
	je	SHORT $LN11@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkFreeMemory@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0
	movlpd	QWORD PTR ?g_FontMemory@@3_KA, xmm0
$LN11@ImGui_Impl:

; 907  :   if (g_FontSampler)          { vkDestroySampler             (g_Device, g_FontSampler,         g_Allocator); g_FontSampler         = VK_NULL_HANDLE; }

	mov	ecx, DWORD PTR ?g_FontSampler@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_FontSampler@@3_KA+4
	or	eax, edx
	je	SHORT $LN12@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroySampler@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0
	movlpd	QWORD PTR ?g_FontSampler@@3_KA, xmm0
$LN12@ImGui_Impl:

; 908  :   if (g_DescriptorSetLayout)  { vkDestroyDescriptorSetLayout (g_Device, g_DescriptorSetLayout, g_Allocator); g_DescriptorSetLayout = VK_NULL_HANDLE; }

	mov	ecx, DWORD PTR ?g_DescriptorSetLayout@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_DescriptorSetLayout@@3_KA+4
	or	eax, edx
	je	SHORT $LN13@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyDescriptorSetLayout@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0
	movlpd	QWORD PTR ?g_DescriptorSetLayout@@3_KA, xmm0
$LN13@ImGui_Impl:

; 909  :   if (g_PipelineLayout)       { vkDestroyPipelineLayout      (g_Device, g_PipelineLayout,      g_Allocator); g_PipelineLayout      = VK_NULL_HANDLE; }

	mov	ecx, DWORD PTR ?g_PipelineLayout@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_PipelineLayout@@3_KA+4
	or	eax, edx
	je	SHORT $LN14@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyPipelineLayout@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0
	movlpd	QWORD PTR ?g_PipelineLayout@@3_KA, xmm0
$LN14@ImGui_Impl:

; 910  :   if (g_Pipeline)             { vkDestroyPipeline            (g_Device, g_Pipeline,            g_Allocator); g_Pipeline            = VK_NULL_HANDLE; }

	mov	ecx, DWORD PTR ?g_Pipeline@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_Pipeline@@3_KA+4
	or	eax, edx
	je	SHORT $LN15@ImGui_Impl
	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyPipeline@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0
	movlpd	QWORD PTR ?g_Pipeline@@3_KA, xmm0
$LN15@ImGui_Impl:

; 911  : 
; 912  :   extern void
; 913  :   SK_ImGui_ResetExternal (void);
; 914  :   SK_ImGui_ResetExternal ();

	jmp	?SK_ImGui_ResetExternal@@YAXXZ		; SK_ImGui_ResetExternal
?ImGui_ImplVulkan_InvalidateDeviceObjects@@YAXXZ ENDP	; ImGui_ImplVulkan_InvalidateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
?ImGui_ImplVulkan_InvalidateFontUploadObjects@@YAXXZ PROC ; ImGui_ImplVulkan_InvalidateFontUploadObjects

; 878  :   if (g_UploadBuffer)

	mov	ecx, DWORD PTR ?g_UploadBuffer@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_UploadBuffer@@3_KA+4
	or	eax, edx
	je	SHORT $LN2@ImGui_Impl

; 879  :   {
; 880  :     vkDestroyBuffer (g_Device, g_UploadBuffer, g_Allocator);

	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkDestroyBuffer@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0

; 881  :     g_UploadBuffer = VK_NULL_HANDLE;

	movlpd	QWORD PTR ?g_UploadBuffer@@3_KA, xmm0
$LN2@ImGui_Impl:

; 882  :   }
; 883  : 
; 884  :   if (g_UploadBufferMemory)

	mov	ecx, DWORD PTR ?g_UploadBufferMemory@@3_KA
	mov	eax, ecx
	mov	edx, DWORD PTR ?g_UploadBufferMemory@@3_KA+4
	or	eax, edx
	je	SHORT $LN3@ImGui_Impl

; 885  :   {
; 886  :     vkFreeMemory (g_Device, g_UploadBufferMemory, g_Allocator);

	push	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A
	push	edx
	push	ecx
	push	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A
	call	DWORD PTR ?vkFreeMemory@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA
	xorps	xmm0, xmm0

; 887  :     g_UploadBufferMemory = VK_NULL_HANDLE;

	movlpd	QWORD PTR ?g_UploadBufferMemory@@3_KA, xmm0
$LN3@ImGui_Impl:

; 888  :   }
; 889  : }

	ret	0
?ImGui_ImplVulkan_InvalidateFontUploadObjects@@YAXXZ ENDP ; ImGui_ImplVulkan_InvalidateFontUploadObjects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
_command_buffer$ = 8					; size = 4
?ImGui_ImplVulkan_Render@@YAXPAUVkCommandBuffer_T@@@Z PROC ; ImGui_ImplVulkan_Render

; 1062 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1063 :   g_CommandBuffer = command_buffer;

	mov	eax, DWORD PTR _command_buffer$[ebp]
	mov	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A, eax

; 1064 : 
; 1065 :   ImGui::Render ();

	call	?Render@ImGui@@YAXXZ			; ImGui::Render

; 1066 : 
; 1067 :   g_CommandBuffer = VK_NULL_HANDLE;
; 1068 :   g_FrameIndex    = (g_FrameIndex + 1) % IMGUI_VK_QUEUED_FRAMES;

	mov	eax, DWORD PTR ?g_FrameIndex@@3HA
	inc	eax
	mov	DWORD PTR ?g_CommandBuffer@@3PAUVkCommandBuffer_T@@A, 0
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN3@ImGui_Impl
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN3@ImGui_Impl:
	mov	DWORD PTR ?g_FrameIndex@@3HA, eax

; 1069 : }

	pop	ebp
	ret	0
?ImGui_ImplVulkan_Render@@YAXPAUVkCommandBuffer_T@@@Z ENDP ; ImGui_ImplVulkan_Render
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
_client$ = -32						; size = 16
_current_time$ = -16					; size = 8
$T1 = -8						; size = 8
$T2 = -8						; size = 8
tv202 = -4						; size = 4
?ImGui_ImplVulkan_NewFrame@@YAXXZ PROC			; ImGui_ImplVulkan_NewFrame

; 1025 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 1026 :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	esi, eax

; 1027 : 
; 1028 :   // Setup display size (every frame to accommodate for window resizing)
; 1029 :   int         w,         h;
; 1030 :   int display_w, display_h;
; 1031 : 
; 1032 :   RECT client;
; 1033 :   GetClientRect (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 1034 : 
; 1035 :   w = client.right  - client.left;

	mov	ecx, DWORD PTR _client$[ebp+8]
	sub	ecx, DWORD PTR _client$[ebp]

; 1036 :   h = client.bottom - client.top;

	mov	eax, DWORD PTR _client$[ebp+12]
	sub	eax, DWORD PTR _client$[ebp+4]
	movd	xmm1, ecx

; 1041 :   io.DisplaySize             = ImVec2 ((float)w, (float)h);

	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp

; 1041 :   io.DisplaySize             = ImVec2 ((float)w, (float)h);

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [esi], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp

; 1041 :   io.DisplaySize             = ImVec2 ((float)w, (float)h);

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [esi+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp

; 1042 :   io.DisplayFramebufferScale = ImVec2 ((float)w, (float)h);//ImVec2 (w > 0 ? ((float)display_w / w) : 0, h > 0 ? ((float)display_h / h) : 0);

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esi+144], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp

; 1042 :   io.DisplayFramebufferScale = ImVec2 ((float)w, (float)h);//ImVec2 (w > 0 ? ((float)display_w / w) : 0, h > 0 ? ((float)display_h / h) : 0);

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [esi+148], eax

; 1043 : 
; 1044 :   // Setup time step
; 1045 :   INT64 current_time;
; 1046 : 
; 1047 :   QueryPerformanceCounter_Original ((LARGE_INTEGER *)&current_time);

	lea	eax, DWORD PTR _current_time$[ebp]
	push	eax
	call	DWORD PTR ?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA ; QueryPerformanceCounter_Original

; 1048 : 
; 1049 :   io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;

	mov	ecx, DWORD PTR _current_time$[ebp]
	sub	ecx, DWORD PTR ?g_Time@@3_JA
	mov	edx, DWORD PTR _current_time$[ebp+4]
	sbb	edx, DWORD PTR ?g_Time@@3_JA+4
	call	__ltod3
	mov	edx, DWORD PTR ?g_TicksPerSecond@@3_JA+4
	mov	ecx, DWORD PTR ?g_TicksPerSecond@@3_JA
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv202[ebp], xmm0
	call	__ltod3
	movss	xmm1, DWORD PTR tv202[ebp]
	cvtsd2ss xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [esi+8], xmm1

; 1050 :   g_Time       =         current_time;

	mov	eax, DWORD PTR _current_time$[ebp]
	mov	DWORD PTR ?g_Time@@3_JA, eax
	mov	eax, DWORD PTR _current_time$[ebp+4]
	mov	DWORD PTR ?g_Time@@3_JA+4, eax

; 1051 : 
; 1052 :   // Read keyboard modifiers inputs
; 1053 :   io.KeyCtrl   = (io.KeysDown [VK_CONTROL]) != 0;

	cmp	BYTE PTR [esi+246], 0
	setne	al
	mov	BYTE PTR [esi+225], al

; 1054 :   io.KeyShift  = (io.KeysDown [VK_SHIFT])   != 0;

	cmp	BYTE PTR [esi+245], 0
	setne	al
	mov	BYTE PTR [esi+226], al

; 1055 :   io.KeyAlt    = (io.KeysDown [VK_MENU])    != 0;

	cmp	BYTE PTR [esi+247], 0

; 1056 : 
; 1057 :   io.KeySuper  = false;

	mov	BYTE PTR [esi+228], 0
	setne	al
	mov	BYTE PTR [esi+227], al
	pop	esi

; 1058 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplVulkan_NewFrame@@YAXXZ ENDP			; ImGui_ImplVulkan_NewFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
?ImGui_ImplVulkan_Shutdown@@YAXXZ PROC			; ImGui_ImplVulkan_Shutdown

; 1019 :   ImGui_ImplVulkan_InvalidateDeviceObjects ();

	call	?ImGui_ImplVulkan_InvalidateDeviceObjects@@YAXXZ ; ImGui_ImplVulkan_InvalidateDeviceObjects

; 1020 :   ImGui::Shutdown ();

	jmp	?Shutdown@ImGui@@YAXXZ			; ImGui::Shutdown
?ImGui_ImplVulkan_Shutdown@@YAXXZ ENDP			; ImGui_ImplVulkan_Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_vk.cpp
_TEXT	SEGMENT
_init_data$ = 8						; size = 4
?ImGui_ImplVulkan_Init@@YA_NPAUImGui_ImplVulkan_Init_Data@@@Z PROC ; ImGui_ImplVulkan_Init

; 923  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 924  :   g_Allocator      = init_data->allocator;
; 925  :   g_Gpu            = init_data->gpu;
; 926  :   g_Device         = init_data->device;
; 927  :   g_RenderPass     = init_data->render_pass;
; 928  :   g_PipelineCache  = init_data->pipeline_cache;
; 929  :   g_DescriptorPool = init_data->descriptor_pool;
; 930  :   g_CheckVkResult  = init_data->check_vk_result;
; 931  : 
; 932  :   static bool first = true;
; 933  : 
; 934  :   if (first) {

	cmp	BYTE PTR ?first@?1??ImGui_ImplVulkan_Init@@YA_NPAUImGui_ImplVulkan_Init_Data@@@Z@4_NA, 0
	mov	ecx, DWORD PTR _init_data$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?g_Allocator@@3PAUVkAllocationCallbacks@@A, eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR ?g_Gpu@@3PAUVkPhysicalDevice_T@@A, eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR ?g_Device@@3PAUVkDevice_T@@A, eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR ?g_RenderPass@@3_KA, eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR ?g_RenderPass@@3_KA+4, eax
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR ?g_PipelineCache@@3_KA, eax
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR ?g_PipelineCache@@3_KA+4, eax
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR ?g_DescriptorPool@@3_KA, eax
	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR ?g_DescriptorPool@@3_KA+4, eax
	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR ?g_CheckVkResult@@3P6AXW4VkResult@@@ZA, eax
	je	SHORT $LN2@ImGui_Impl

; 935  :     if (! QueryPerformanceFrequency ((LARGE_INTEGER *)&g_TicksPerSecond))

	push	OFFSET ?g_TicksPerSecond@@3_JA
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	test	eax, eax
	jne	SHORT $LN3@ImGui_Impl
$LN6@ImGui_Impl:

; 936  :       return false;

	xor	al, al

; 1014 : }

	pop	ebp
	ret	0
$LN3@ImGui_Impl:

; 937  : 
; 938  :     if (! QueryPerformanceCounter_Original ((LARGE_INTEGER *)&g_Time))

	push	OFFSET ?g_Time@@3_JA
	call	DWORD PTR ?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA ; QueryPerformanceCounter_Original
	test	eax, eax
	je	SHORT $LN6@ImGui_Impl

; 939  :       return false;
; 940  : 
; 941  :     first = false;

	mov	BYTE PTR ?first@?1??ImGui_ImplVulkan_Init@@YA_NPAUImGui_ImplVulkan_Init_Data@@@Z@4_NA, 0
$LN2@ImGui_Impl:
	push	esi
	push	edi

; 942  :   }
; 943  : 
; 944  :   SK_IMPORT_VK_FUNC (vkGetPhysicalDeviceMemoryProperties)

	mov	edi, DWORD PTR __imp__GetModuleHandleW@4
	push	OFFSET $SG91058
	push	OFFSET $SG91059
	call	edi
	mov	esi, DWORD PTR __imp__GetProcAddress@8
	push	eax
	call	esi

; 945  :   SK_IMPORT_VK_FUNC (vkAllocateMemory)

	push	OFFSET $SG91060
	push	OFFSET $SG91061
	mov	DWORD PTR ?vkGetPhysicalDeviceMemoryProperties@@3P6GXPAUVkPhysicalDevice_T@@PAUVkPhysicalDeviceMemoryProperties@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 946  :   SK_IMPORT_VK_FUNC (vkFreeMemory)

	push	OFFSET $SG91062
	push	OFFSET $SG91063
	mov	DWORD PTR ?vkAllocateMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkMemoryAllocateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 947  :   SK_IMPORT_VK_FUNC (vkMapMemory)

	push	OFFSET $SG91064
	push	OFFSET $SG91065
	mov	DWORD PTR ?vkFreeMemory@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 948  :   SK_IMPORT_VK_FUNC (vkUnmapMemory)

	push	OFFSET $SG91066
	push	OFFSET $SG91067
	mov	DWORD PTR ?vkMapMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11IPAPAX@ZA, eax
	call	edi
	push	eax
	call	esi

; 949  :   SK_IMPORT_VK_FUNC (vkFlushMappedMemoryRanges)

	push	OFFSET $SG91068
	push	OFFSET $SG91069
	mov	DWORD PTR ?vkUnmapMemory@@3P6GXPAUVkDevice_T@@_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 950  :   SK_IMPORT_VK_FUNC (vkBindBufferMemory)

	push	OFFSET $SG91070
	push	OFFSET $SG91071
	mov	DWORD PTR ?vkFlushMappedMemoryRanges@@3P6G?AW4VkResult@@PAUVkDevice_T@@IPBUVkMappedMemoryRange@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 951  :   SK_IMPORT_VK_FUNC (vkBindImageMemory)

	push	OFFSET $SG91072
	push	OFFSET $SG91073
	mov	DWORD PTR ?vkBindBufferMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11@ZA, eax
	call	edi
	push	eax
	call	esi

; 952  :   SK_IMPORT_VK_FUNC (vkGetBufferMemoryRequirements)

	push	OFFSET $SG91074
	push	OFFSET $SG91075
	mov	DWORD PTR ?vkBindImageMemory@@3P6G?AW4VkResult@@PAUVkDevice_T@@_K11@ZA, eax
	call	edi
	push	eax
	call	esi

; 953  :   SK_IMPORT_VK_FUNC (vkGetImageMemoryRequirements)

	push	OFFSET $SG91076
	push	OFFSET $SG91077
	mov	DWORD PTR ?vkGetBufferMemoryRequirements@@3P6GXPAUVkDevice_T@@_KPAUVkMemoryRequirements@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 954  :   SK_IMPORT_VK_FUNC (vkCreateBuffer)

	push	OFFSET $SG91078
	push	OFFSET $SG91079
	mov	DWORD PTR ?vkGetImageMemoryRequirements@@3P6GXPAUVkDevice_T@@_KPAUVkMemoryRequirements@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 955  :   SK_IMPORT_VK_FUNC (vkDestroyBuffer)

	push	OFFSET $SG91080
	push	OFFSET $SG91081
	mov	DWORD PTR ?vkCreateBuffer@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkBufferCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 956  :   SK_IMPORT_VK_FUNC (vkCreateImage)

	push	OFFSET $SG91082
	push	OFFSET $SG91083
	mov	DWORD PTR ?vkDestroyBuffer@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 957  :   SK_IMPORT_VK_FUNC (vkDestroyImage)

	push	OFFSET $SG91084
	push	OFFSET $SG91085
	mov	DWORD PTR ?vkCreateImage@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkImageCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 958  :   SK_IMPORT_VK_FUNC (vkCreateImageView)  

	push	OFFSET $SG91086
	push	OFFSET $SG91087
	mov	DWORD PTR ?vkDestroyImage@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 959  :   SK_IMPORT_VK_FUNC (vkDestroyImageView) 

	push	OFFSET $SG91088
	push	OFFSET $SG91089
	mov	DWORD PTR ?vkCreateImageView@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkImageViewCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 960  :   SK_IMPORT_VK_FUNC (vkCreateShaderModule)

	push	OFFSET $SG91090
	push	OFFSET $SG91091
	mov	DWORD PTR ?vkDestroyImageView@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 961  :   SK_IMPORT_VK_FUNC (vkDestroyShaderModule)

	push	OFFSET $SG91092
	push	OFFSET $SG91093
	mov	DWORD PTR ?vkCreateShaderModule@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkShaderModuleCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 962  :   SK_IMPORT_VK_FUNC (vkCreateGraphicsPipelines)

	push	OFFSET $SG91094
	push	OFFSET $SG91095
	mov	DWORD PTR ?vkDestroyShaderModule@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 963  :   SK_IMPORT_VK_FUNC (vkDestroyPipeline)

	push	OFFSET $SG91096
	push	OFFSET $SG91097
	mov	DWORD PTR ?vkCreateGraphicsPipelines@@3P6G?AW4VkResult@@PAUVkDevice_T@@_KIPBUVkGraphicsPipelineCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 964  :   SK_IMPORT_VK_FUNC (vkCreatePipelineLayout)

	push	OFFSET $SG91098
	push	OFFSET $SG91099
	mov	DWORD PTR ?vkDestroyPipeline@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 965  :   SK_IMPORT_VK_FUNC (vkDestroyPipelineLayout)

	push	OFFSET $SG91100
	push	OFFSET $SG91101
	mov	DWORD PTR ?vkCreatePipelineLayout@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkPipelineLayoutCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 966  :   SK_IMPORT_VK_FUNC (vkCreateSampler)

	push	OFFSET $SG91102
	push	OFFSET $SG91103
	mov	DWORD PTR ?vkDestroyPipelineLayout@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 967  :   SK_IMPORT_VK_FUNC (vkDestroySampler)

	push	OFFSET $SG91104
	push	OFFSET $SG91105
	mov	DWORD PTR ?vkCreateSampler@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkSamplerCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 968  :   SK_IMPORT_VK_FUNC (vkCreateDescriptorSetLayout)

	push	OFFSET $SG91106
	push	OFFSET $SG91107
	mov	DWORD PTR ?vkDestroySampler@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 969  :   SK_IMPORT_VK_FUNC (vkDestroyDescriptorSetLayout)

	push	OFFSET $SG91108
	push	OFFSET $SG91109
	mov	DWORD PTR ?vkCreateDescriptorSetLayout@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkDescriptorSetLayoutCreateInfo@@PBUVkAllocationCallbacks@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 970  :   SK_IMPORT_VK_FUNC (vkAllocateDescriptorSets)

	push	OFFSET $SG91110
	mov	DWORD PTR ?vkDestroyDescriptorSetLayout@@3P6GXPAUVkDevice_T@@_KPBUVkAllocationCallbacks@@@ZA, eax
	push	OFFSET $SG91111
	call	edi
	push	eax
	call	esi

; 971  :   SK_IMPORT_VK_FUNC (vkUpdateDescriptorSets)

	push	OFFSET $SG91112
	push	OFFSET $SG91113
	mov	DWORD PTR ?vkAllocateDescriptorSets@@3P6G?AW4VkResult@@PAUVkDevice_T@@PBUVkDescriptorSetAllocateInfo@@PA_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 972  :   SK_IMPORT_VK_FUNC (vkCmdBindPipeline)

	push	OFFSET $SG91114
	push	OFFSET $SG91115
	mov	DWORD PTR ?vkUpdateDescriptorSets@@3P6GXPAUVkDevice_T@@IPBUVkWriteDescriptorSet@@IPBUVkCopyDescriptorSet@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 973  :   SK_IMPORT_VK_FUNC (vkCmdSetViewport)

	push	OFFSET $SG91116
	push	OFFSET $SG91117
	mov	DWORD PTR ?vkCmdBindPipeline@@3P6GXPAUVkCommandBuffer_T@@W4VkPipelineBindPoint@@_K@ZA, eax
	call	edi
	push	eax
	call	esi

; 974  :   SK_IMPORT_VK_FUNC (vkCmdSetScissor)

	push	OFFSET $SG91118
	push	OFFSET $SG91119
	mov	DWORD PTR ?vkCmdSetViewport@@3P6GXPAUVkCommandBuffer_T@@IIPBUVkViewport@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 975  :   SK_IMPORT_VK_FUNC (vkCmdBindDescriptorSets)

	push	OFFSET $SG91120
	push	OFFSET $SG91121
	mov	DWORD PTR ?vkCmdSetScissor@@3P6GXPAUVkCommandBuffer_T@@IIPBUVkRect2D@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 976  :   SK_IMPORT_VK_FUNC (vkCmdBindIndexBuffer)

	push	OFFSET $SG91122
	push	OFFSET $SG91123
	mov	DWORD PTR ?vkCmdBindDescriptorSets@@3P6GXPAUVkCommandBuffer_T@@W4VkPipelineBindPoint@@_KIIPB_KIPBI@ZA, eax
	call	edi
	push	eax
	call	esi

; 977  :   SK_IMPORT_VK_FUNC (vkCmdBindVertexBuffers)

	push	OFFSET $SG91124
	push	OFFSET $SG91125
	mov	DWORD PTR ?vkCmdBindIndexBuffer@@3P6GXPAUVkCommandBuffer_T@@_K1W4VkIndexType@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 978  :   SK_IMPORT_VK_FUNC (vkCmdDrawIndexed)

	push	OFFSET $SG91126
	push	OFFSET $SG91127
	mov	DWORD PTR ?vkCmdBindVertexBuffers@@3P6GXPAUVkCommandBuffer_T@@IIPB_K1@ZA, eax
	call	edi
	push	eax
	call	esi

; 979  :   SK_IMPORT_VK_FUNC (vkCmdCopyBufferToImage)

	push	OFFSET $SG91128
	push	OFFSET $SG91129
	mov	DWORD PTR ?vkCmdDrawIndexed@@3P6GXPAUVkCommandBuffer_T@@IIIHI@ZA, eax
	call	edi
	push	eax
	call	esi

; 980  :   SK_IMPORT_VK_FUNC (vkCmdPipelineBarrier)

	push	OFFSET $SG91130
	push	OFFSET $SG91131
	mov	DWORD PTR ?vkCmdCopyBufferToImage@@3P6GXPAUVkCommandBuffer_T@@_K1W4VkImageLayout@@IPBUVkBufferImageCopy@@@ZA, eax
	call	edi
	push	eax
	call	esi

; 981  :   SK_IMPORT_VK_FUNC (vkCmdPushConstants)

	push	OFFSET $SG91132
	push	OFFSET $SG91133
	mov	DWORD PTR ?vkCmdPipelineBarrier@@3P6GXPAUVkCommandBuffer_T@@IIIIPBUVkMemoryBarrier@@IPBUVkBufferMemoryBarrier@@IPBUVkImageMemoryBarrier@@@ZA, eax
	call	edi
	push	eax
	call	esi
	mov	DWORD PTR ?vkCmdPushConstants@@3P6GXPAUVkCommandBuffer_T@@_KIIIPBX@ZA, eax

; 982  : 
; 983  :   ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	ecx, eax

; 984  :     ImGui::GetIO ();
; 985  : 
; 986  :   // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array that we will update during the application lifetime.
; 987  :   io.KeyMap [ImGuiKey_Tab]        = VK_TAB;

	mov	DWORD PTR [ecx+36], 9

; 988  :   io.KeyMap [ImGuiKey_LeftArrow]  = VK_LEFT;

	mov	DWORD PTR [ecx+48], 37			; 00000025H

; 989  :   io.KeyMap [ImGuiKey_RightArrow] = VK_RIGHT;

	mov	DWORD PTR [ecx+52], 39			; 00000027H

; 990  :   io.KeyMap [ImGuiKey_UpArrow]    = VK_UP;

	mov	DWORD PTR [ecx+40], 38			; 00000026H

; 991  :   io.KeyMap [ImGuiKey_DownArrow]  = VK_DOWN;

	mov	DWORD PTR [ecx+44], 40			; 00000028H

; 992  :   io.KeyMap [ImGuiKey_PageUp]     = VK_PRIOR;

	mov	DWORD PTR [ecx+56], 33			; 00000021H

; 993  :   io.KeyMap [ImGuiKey_PageDown]   = VK_NEXT;

	mov	DWORD PTR [ecx+60], 34			; 00000022H

; 994  :   io.KeyMap [ImGuiKey_Home]       = VK_HOME;

	mov	DWORD PTR [ecx+64], 36			; 00000024H

; 995  :   io.KeyMap [ImGuiKey_End]        = VK_END;

	mov	DWORD PTR [ecx+68], 35			; 00000023H

; 996  :   io.KeyMap [ImGuiKey_Delete]     = VK_DELETE;

	mov	DWORD PTR [ecx+72], 46			; 0000002eH

; 997  :   io.KeyMap [ImGuiKey_Backspace]  = VK_BACK;

	mov	DWORD PTR [ecx+76], 8

; 998  :   io.KeyMap [ImGuiKey_Enter]      = VK_RETURN;

	mov	DWORD PTR [ecx+80], 13			; 0000000dH

; 999  :   io.KeyMap [ImGuiKey_Escape]     = VK_ESCAPE;

	mov	DWORD PTR [ecx+84], 27			; 0000001bH

; 1000 :   io.KeyMap [ImGuiKey_A]          = 'A';

	mov	DWORD PTR [ecx+88], 65			; 00000041H

; 1001 :   io.KeyMap [ImGuiKey_C]          = 'C';

	mov	DWORD PTR [ecx+92], 67			; 00000043H

; 1002 :   io.KeyMap [ImGuiKey_V]          = 'V';

	mov	DWORD PTR [ecx+96], 86			; 00000056H

; 1003 :   io.KeyMap [ImGuiKey_X]          = 'X';

	mov	DWORD PTR [ecx+100], 88			; 00000058H

; 1004 :   io.KeyMap [ImGuiKey_Y]          = 'Y';

	mov	DWORD PTR [ecx+104], 89			; 00000059H

; 1005 :   io.KeyMap [ImGuiKey_Z]          = 'Z';

	mov	DWORD PTR [ecx+108], 90			; 0000005aH

; 1006 : 
; 1007 :   io.RenderDrawListsFn = ImGui_ImplVulkan_RenderDrawLists;

	mov	DWORD PTR [ecx+172], OFFSET ?ImGui_ImplVulkan_RenderDrawLists@@YAXPAUImDrawData@@@Z ; ImGui_ImplVulkan_RenderDrawLists

; 1008 :   io.ClipboardUserData = game_window.hWnd;

	mov	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	mov	DWORD PTR [ecx+184], eax

; 1009 :   io.ImeWindowHandle   = game_window.hWnd;

	mov	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	mov	DWORD PTR [ecx+200], eax

; 1010 : 
; 1011 :   ImGui_ImplVulkan_CreateDeviceObjects ();

	call	?ImGui_ImplVulkan_CreateDeviceObjects@@YA_NXZ ; ImGui_ImplVulkan_CreateDeviceObjects
	pop	edi

; 1012 : 
; 1013 :   return true;

	mov	al, 1
	pop	esi

; 1014 : }

	pop	ebp
	ret	0
?ImGui_ImplVulkan_Init@@YA_NPAUImGui_ImplVulkan_Init_Data@@@Z ENDP ; ImGui_ImplVulkan_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
